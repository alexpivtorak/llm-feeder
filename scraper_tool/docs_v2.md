# Quick Start – React

URL: https://react.dev/learn

[Learn React](https://react.dev/learn)

# Quick Start

Welcome to the React documentation! This page will give you an introduction to 80% of the React concepts that you will use on a daily basis.

### You will learn

* How to create and nest components
* How to add markup and styles
* How to display data
* How to render conditions and lists
* How to respond to events and update the screen
* How to share data between components

## Creating and nesting components

React apps are made out of *components*. A component is a piece of the UI (user interface) that has its own logic and appearance. A component can be as small as a button, or as large as an entire page.

React components are JavaScript functions that return markup:

```
function MyButton() {

return (

<button>I'm a button</button>

);

}
```

Now that you’ve declared `MyButton`, you can nest it into another component:

```
export default function MyApp() {

return (

<div>

<h1>Welcome to my app</h1>

<MyButton />

</div>

);

}
```

Notice that `<MyButton />` starts with a capital letter. That’s how you know it’s a React component. React component names must always start with a capital letter, while HTML tags must be lowercase.

Have a look at the result:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function MyButton() {
  return (
    <button>
      I'm a button
    </button>
  );
}

export default function MyApp() {
  return (
    <div>
      <h1>Welcome to my app</h1>
      <MyButton />
    </div>
  );
}
```

Show more

The `export default` keywords specify the main component in the file. If you’re not familiar with some piece of JavaScript syntax, [MDN](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export) and [javascript.info](https://javascript.info/import-export) have great references.

## Writing markup with JSX

The markup syntax you’ve seen above is called *JSX*. It is optional, but most React projects use JSX for its convenience. All of the [tools we recommend for local development](https://react.dev/learn/installation) support JSX out of the box.

JSX is stricter than HTML. You have to close tags like `<br />`. Your component also can’t return multiple JSX tags. You have to wrap them into a shared parent, like a `<div>...</div>` or an empty `<>...</>` wrapper:

```
function AboutPage() {

return (

<>

<h1>About</h1>

<p>Hello there.<br />How do you do?</p>

</>

);

}
```

If you have a lot of HTML to port to JSX, you can use an [online converter.](https://transform.tools/html-to-jsx)

## Adding styles

In React, you specify a CSS class with `className`. It works the same way as the HTML [`class`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class) attribute:

```
<img className="avatar" />
```

Then you write the CSS rules for it in a separate CSS file:

```
/* In your CSS */

.avatar {

border-radius: 50%;

}
```

React does not prescribe how you add CSS files. In the simplest case, you’ll add a [`<link>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link) tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.

## Displaying data

JSX lets you put markup into JavaScript. Curly braces let you “escape back” into JavaScript so that you can embed some variable from your code and display it to the user. For example, this will display `user.name`:

```
return (

<h1>

{user.name}

</h1>

);
```

You can also “escape into JavaScript” from JSX attributes, but you have to use curly braces *instead of* quotes. For example, `className="avatar"` passes the `"avatar"` string as the CSS class, but `src={user.imageUrl}` reads the JavaScript `user.imageUrl` variable value, and then passes that value as the `src` attribute:

```
return (

<img

className="avatar"

src={user.imageUrl}

/>

);
```

You can put more complex expressions inside the JSX curly braces too, for example, [string concatenation](https://javascript.info/operators#string-concatenation-with-binary):

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
const user = {
  name: 'Hedy Lamarr',
  imageUrl: 'https://i.imgur.com/yXOvdOSs.jpg',
  imageSize: 90,
};

export default function Profile() {
  return (
    <>
      <h1>{user.name}</h1>
      <img
        className="avatar"
        src={user.imageUrl}
        alt={'Photo of ' + user.name}
        style={{
          width: user.imageSize,
          height: user.imageSize
        }}
      />
    </>
  );
}
```

Show more

In the above example, `style={{}}` is not a special syntax, but a regular `{}` object inside the `style={ }` JSX curly braces. You can use the `style` attribute when your styles depend on JavaScript variables.

## Conditional rendering

In React, there is no special syntax for writing conditions. Instead, you’ll use the same techniques as you use when writing regular JavaScript code. For example, you can use an [`if`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else) statement to conditionally include JSX:

```
let content;

if (isLoggedIn) {

content = <AdminPanel />;

} else {

content = <LoginForm />;

}

return (

<div>

{content}

</div>

);
```

If you prefer more compact code, you can use the [conditional `?` operator.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator) Unlike `if`, it works inside JSX:

```
<div>

{isLoggedIn ? (

<AdminPanel />

) : (

<LoginForm />

)}

</div>
```

When you don’t need the `else` branch, you can also use a shorter [logical `&&` syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND#short-circuit_evaluation):

```
<div>

{isLoggedIn && <AdminPanel />}

</div>
```

All of these approaches also work for conditionally specifying attributes. If you’re unfamiliar with some of this JavaScript syntax, you can start by always using `if...else`.

## Rendering lists

You will rely on JavaScript features like [`for` loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for) and the [array `map()` function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) to render lists of components.

For example, let’s say you have an array of products:

```
const products = [

{ title: 'Cabbage', id: 1 },

{ title: 'Garlic', id: 2 },

{ title: 'Apple', id: 3 },

];
```

Inside your component, use the `map()` function to transform an array of products into an array of `<li>` items:

```
const listItems = products.map(product =>

<li key={product.id}>

{product.title}

</li>

);

return (

<ul>{listItems}</ul>

);
```

Notice how `<li>` has a `key` attribute. For each item in a list, you should pass a string or a number that uniquely identifies that item among its siblings. Usually, a key should be coming from your data, such as a database ID. React uses your keys to know what happened if you later insert, delete, or reorder the items.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
const products = [
  { title: 'Cabbage', isFruit: false, id: 1 },
  { title: 'Garlic', isFruit: false, id: 2 },
  { title: 'Apple', isFruit: true, id: 3 },
];

export default function ShoppingList() {
  const listItems = products.map(product =>
    <li
      key={product.id}
      style={{
        color: product.isFruit ? 'magenta' : 'darkgreen'
      }}
    >
      {product.title}
    </li>
  );

  return (
    <ul>{listItems}</ul>
  );
}
```

Show more

## Responding to events

You can respond to events by declaring *event handler* functions inside your components:

```
function MyButton() {

function handleClick() {

alert('You clicked me!');

}

return (

<button onClick={handleClick}>

Click me

</button>

);

}
```

Notice how `onClick={handleClick}` has no parentheses at the end! Do not *call* the event handler function: you only need to *pass it down*. React will call your event handler when the user clicks the button.

## Updating the screen

Often, you’ll want your component to “remember” some information and display it. For example, maybe you want to count the number of times a button is clicked. To do this, add *state* to your component.

First, import [`useState`](https://react.dev/reference/react/useState) from React:

```
import { useState } from 'react';
```

Now you can declare a *state variable* inside your component:

```
function MyButton() {

const [count, setCount] = useState(0);

// ...
```

You’ll get two things from `useState`: the current state (`count`), and the function that lets you update it (`setCount`). You can give them any names, but the convention is to write `[something, setSomething]`.

The first time the button is displayed, `count` will be `0` because you passed `0` to `useState()`. When you want to change state, call `setCount()` and pass the new value to it. Clicking this button will increment the counter:

```
function MyButton() {

const [count, setCount] = useState(0);

function handleClick() {

setCount(count + 1);

}

return (

<button onClick={handleClick}>

Clicked {count} times

</button>

);

}
```

React will call your component function again. This time, `count` will be `1`. Then it will be `2`. And so on.

If you render the same component multiple times, each will get its own state. Click each button separately:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function MyApp() {
  return (
    <div>
      <h1>Counters that update separately</h1>
      <MyButton />
      <MyButton />
    </div>
  );
}

function MyButton() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      Clicked {count} times
    </button>
  );
}
```

Show more

Notice how each button “remembers” its own `count` state and doesn’t affect other buttons.

## Using Hooks

Functions starting with `use` are called *Hooks*. `useState` is a built-in Hook provided by React. You can find other built-in Hooks in the [API reference.](https://react.dev/reference/react) You can also write your own Hooks by combining the existing ones.

Hooks are more restrictive than other functions. You can only call Hooks *at the top* of your components (or other Hooks). If you want to use `useState` in a condition or a loop, extract a new component and put it there.

## Sharing data between components

In the previous example, each `MyButton` had its own independent `count`, and when each button was clicked, only the `count` for the button clicked changed:

![Diagram showing a tree of three components, one parent labeled MyApp and two children labeled MyButton. Both MyButton components contain a count with value zero.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_child.dark.png&w=828&q=75)

![Diagram showing a tree of three components, one parent labeled MyApp and two children labeled MyButton. Both MyButton components contain a count with value zero.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_child.png&w=828&q=75)

Initially, each `MyButton`’s `count` state is `0`

![The same diagram as the previous, with the count of the first child MyButton component highlighted indicating a click with the count value incremented to one. The second MyButton component still contains value zero.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_child_clicked.dark.png&w=828&q=75)

![The same diagram as the previous, with the count of the first child MyButton component highlighted indicating a click with the count value incremented to one. The second MyButton component still contains value zero.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_child_clicked.png&w=828&q=75)

The first `MyButton` updates its `count` to `1`

However, often you’ll need components to *share data and always update together*.

To make both `MyButton` components display the same `count` and update together, you need to move the state from the individual buttons “upwards” to the closest component containing all of them.

In this example, it is `MyApp`:

![Diagram showing a tree of three components, one parent labeled MyApp and two children labeled MyButton. MyApp contains a count value of zero which is passed down to both of the MyButton components, which also show value zero.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_parent.dark.png&w=828&q=75)

![Diagram showing a tree of three components, one parent labeled MyApp and two children labeled MyButton. MyApp contains a count value of zero which is passed down to both of the MyButton components, which also show value zero.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_parent.png&w=828&q=75)

Initially, `MyApp`’s `count` state is `0` and is passed down to both children

![The same diagram as the previous, with the count of the parent MyApp component highlighted indicating a click with the value incremented to one. The flow to both of the children MyButton components is also highlighted, and the count value in each child is set to one indicating the value was passed down.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_parent_clicked.dark.png&w=828&q=75)

![The same diagram as the previous, with the count of the parent MyApp component highlighted indicating a click with the value incremented to one. The flow to both of the children MyButton components is also highlighted, and the count value in each child is set to one indicating the value was passed down.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_parent_clicked.png&w=828&q=75)

On click, `MyApp` updates its `count` state to `1` and passes it down to both children

Now when you click either button, the `count` in `MyApp` will change, which will change both of the counts in `MyButton`. Here’s how you can express this in code.

First, *move the state up* from `MyButton` into `MyApp`:

```
export default function MyApp() {

const [count, setCount] = useState(0);

function handleClick() {

setCount(count + 1);

}

return (

<div>

<h1>Counters that update separately</h1>

<MyButton />

<MyButton />

</div>

);

}

function MyButton() {

// ... we're moving code from here ...

}
```

Then, *pass the state down* from `MyApp` to each `MyButton`, together with the shared click handler. You can pass information to `MyButton` using the JSX curly braces, just like you previously did with built-in tags like `<img>`:

```
export default function MyApp() {

const [count, setCount] = useState(0);

function handleClick() {

setCount(count + 1);

}

return (

<div>

<h1>Counters that update together</h1>

<MyButton count={count} onClick={handleClick} />

<MyButton count={count} onClick={handleClick} />

</div>

);

}
```

The information you pass down like this is called *props*. Now the `MyApp` component contains the `count` state and the `handleClick` event handler, and *passes both of them down as props* to each of the buttons.

Finally, change `MyButton` to *read* the props you have passed from its parent component:

```
function MyButton({ count, onClick }) {

return (

<button onClick={onClick}>

Clicked {count} times

</button>

);

}
```

When you click the button, the `onClick` handler fires. Each button’s `onClick` prop was set to the `handleClick` function inside `MyApp`, so the code inside of it runs. That code calls `setCount(count + 1)`, incrementing the `count` state variable. The new `count` value is passed as a prop to each button, so they all show the new value. This is called “lifting state up”. By moving state up, you’ve shared it between components.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function MyApp() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div>
      <h1>Counters that update together</h1>
      <MyButton count={count} onClick={handleClick} />
      <MyButton count={count} onClick={handleClick} />
    </div>
  );
}

function MyButton({ count, onClick }) {
  return (
    <button onClick={onClick}>
      Clicked {count} times
    </button>
  );
}
```

Show more

## Next Steps

By now, you know the basics of how to write React code!

Check out the [Tutorial](https://react.dev/learn/tutorial-tic-tac-toe) to put them into practice and build your first mini-app with React.

[NextTutorial: Tic-Tac-Toe](https://react.dev/learn/tutorial-tic-tac-toe)

---

---


# React

URL: https://react.dev/

![logo by @sawaratsuki1004](https://react.dev/_next/image?url=%2Fimages%2Fuwu.png&w=640&q=75 "logo by @sawaratsuki1004")

# React

The library for web and native user interfaces

[Learn React](https://react.dev/learn)[API Reference](https://react.dev/reference/react)

## Create user interfaces from components

React lets you build user interfaces out of individual pieces called components. Create your own React components like `Thumbnail`, `LikeButton`, and `Video`. Then combine them into entire screens, pages, and apps.

### Video.js

```
function Video({ video }) {

return (

<div>

<Thumbnail video={video} />

<a href={video.url}>

<h3>{video.title}</h3>

<p>{video.description}</p>

</a>

<LikeButton video={video} />

</div>

);

}
```

### My video

Video description

Whether you work on your own or with thousands of other developers, using React feels the same. It is designed to let you seamlessly combine components written by independent people, teams, and organizations.

## Write components with code and markup

React components are JavaScript functions. Want to show some content conditionally? Use an `if` statement. Displaying a list? Try array `map()`. Learning React is learning programming.

### VideoList.js

```
function VideoList({ videos, emptyHeading }) {

const count = videos.length;

let heading = emptyHeading;

if (count > 0) {

const noun = count > 1 ? 'Videos' : 'Video';

heading = count + ' ' + noun;

}

return (

<section>

<h2>{heading}</h2>

{videos.map(video =>

<Video key={video.id} video={video} />

)}

</section>

);

}
```

## 3 Videos

### First video

Video description

### Second video

Video description

### Third video

Video description

This markup syntax is called JSX. It is a JavaScript syntax extension popularized by React. Putting JSX markup close to related rendering logic makes React components easy to create, maintain, and delete.

## Add interactivity wherever you need it

React components receive data and return what should appear on the screen. You can pass them new data in response to an interaction, like when the user types into an input. React will then update the screen to match the new data.

### SearchableVideoList.js

```
import { useState } from 'react';

function SearchableVideoList({ videos }) {

const [searchText, setSearchText] = useState('');

const foundVideos = filterVideos(videos, searchText);

return (

<>

<SearchInput

value={searchText}

onChange={newText => setSearchText(newText)} />

<VideoList

videos={foundVideos}

emptyHeading={`No matches for “${searchText}”`} />

</>

);

}
```

example.com/videos.html

# React Videos

A brief history of React

Search

## 5 Videos

[### React: The Documentary

The origin story of React](https://www.youtube.com/watch?v=8pDqJVdNa44)

[### Rethinking Best Practices

Pete Hunt (2013)](https://www.youtube.com/watch?v=x7cQ3mrcKaY)

[### Introducing React Native

Tom Occhino (2015)](https://www.youtube.com/watch?v=KVZ-P-ZI6W4)

[### Introducing React Hooks

Sophie Alpert and Dan Abramov (2018)](https://www.youtube.com/watch?v=V-QO-KO90iQ)

[### Introducing Server Components

Dan Abramov and Lauren Tan (2020)](https://www.youtube.com/watch?v=TQQPAU21ZUw)

You don’t have to build your whole page in React. Add React to your existing HTML page, and render interactive React components anywhere on it.

[Add React to your page](https://react.dev/learn/add-react-to-an-existing-project)

## Go full-stack with a framework

React is a library. It lets you put components together, but it doesn’t prescribe how to do routing and data fetching. To build an entire app with React, we recommend a full-stack React framework like [Next.js](https://nextjs.org) or [React Router](https://reactrouter.com).

### confs/[slug].js

```
import { db } from './database.js';

import { Suspense } from 'react';

async function ConferencePage({ slug }) {

const conf = await db.Confs.find({ slug });

return (

<ConferenceLayout conf={conf}>

<Suspense fallback={<TalksLoading />}>

<Talks confId={conf.id} />

</Suspense>

</ConferenceLayout>

);

}

async function Talks({ confId }) {

const talks = await db.Talks.findAll({ confId });

const videos = talks.map(talk => talk.video);

return <SearchableVideoList videos={videos} />;

}
```

example.com/confs/react-conf-2021

React Conf 2021React Conf 2019

![](https://react.dev/images/home/conf2021/cover.svg)

Search

## 19 Videos

[![](https://react.dev/images/home/conf2021/andrew.jpg)![](https://react.dev/images/home/conf2021/lauren.jpg)![](https://react.dev/images/home/conf2021/juan.jpg)![](https://react.dev/images/home/conf2021/rick.jpg)

React Conf](https://www.youtube.com/watch?v=FZ0cG47msEk&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=1)[### React 18 Keynote

The React Team](https://www.youtube.com/watch?v=FZ0cG47msEk&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=1)

[![](https://react.dev/images/home/conf2021/shruti.jpg)

React Conf](https://www.youtube.com/watch?v=ytudH8je5ko&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=2)[### React 18 for App Developers

Shruti Kapoor](https://www.youtube.com/watch?v=ytudH8je5ko&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=2)

[![](https://react.dev/images/home/conf2021/shaundai.jpg)

React Conf](https://www.youtube.com/watch?v=pj5N-Khihgc&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=3)[### Streaming Server Rendering with Suspense

Shaundai Person](https://www.youtube.com/watch?v=pj5N-Khihgc&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=3)

[![](https://react.dev/images/home/conf2021/aakansha.jpg)

React Conf](https://www.youtube.com/watch?v=qn7gRClrC9U&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=4)[### The First React Working Group

Aakansha Doshi](https://www.youtube.com/watch?v=qn7gRClrC9U&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=4)

[![](https://react.dev/images/home/conf2021/brian.jpg)

React Conf](https://www.youtube.com/watch?v=oxDfrke8rZg&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=5)[### React Developer Tooling

Brian Vaughn](https://www.youtube.com/watch?v=oxDfrke8rZg&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=5)

[![](https://react.dev/images/home/conf2021/xuan.jpg)

React Conf](https://www.youtube.com/watch?v=lGEMwh32soc&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=6)[### React without memo

Xuan Huang (黄玄)](https://www.youtube.com/watch?v=lGEMwh32soc&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=6)

[![](https://react.dev/images/home/conf2021/rachel.jpg)

React Conf](https://www.youtube.com/watch?v=mneDaMYOKP8&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=7)[### React Docs Keynote

Rachel Nabors](https://www.youtube.com/watch?v=mneDaMYOKP8&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=7)

[![](https://react.dev/images/home/conf2021/debbie.jpg)

React Conf](https://www.youtube.com/watch?v=-7odLW_hG7s&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=8)[### Things I Learnt from the New React Docs

Debbie O'Brien](https://www.youtube.com/watch?v=-7odLW_hG7s&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=8)

[![](https://react.dev/images/home/conf2021/sarah.jpg)

React Conf](https://www.youtube.com/watch?v=5X-WEQflCL0&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=9)[### Learning in the Browser

Sarah Rainsberger](https://www.youtube.com/watch?v=5X-WEQflCL0&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=9)

[![](https://react.dev/images/home/conf2021/linton.jpg)

React Conf](https://www.youtube.com/watch?v=7cPWmID5XAk&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=10)[### The ROI of Designing with React

Linton Ye](https://www.youtube.com/watch?v=7cPWmID5XAk&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=10)

[![](https://react.dev/images/home/conf2021/delba.jpg)

React Conf](https://www.youtube.com/watch?v=zL8cz2W0z34&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=11)[### Interactive Playgrounds with React

Delba de Oliveira](https://www.youtube.com/watch?v=zL8cz2W0z34&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=11)

[![](https://react.dev/images/home/conf2021/robert.jpg)

React Conf](https://www.youtube.com/watch?v=lhVGdErZuN4&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=12)[### Re-introducing Relay

Robert Balicki](https://www.youtube.com/watch?v=lhVGdErZuN4&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=12)

[![](https://react.dev/images/home/conf2021/eric.jpg)![](https://react.dev/images/home/conf2021/steven.jpg)

React Conf](https://www.youtube.com/watch?v=9L4FFrvwJwY&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=13)[### React Native Desktop

Eric Rozell and Steven Moyes](https://www.youtube.com/watch?v=9L4FFrvwJwY&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=13)

[![](https://react.dev/images/home/conf2021/roman.jpg)

React Conf](https://www.youtube.com/watch?v=NLj73vrc2I8&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=14)[### On-device Machine Learning for React Native

Roman Rädle](https://www.youtube.com/watch?v=NLj73vrc2I8&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=14)

[![](https://react.dev/images/home/conf2021/daishi.jpg)

React Conf](https://www.youtube.com/watch?v=oPfSC5bQPR8&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=15)[### React 18 for External Store Libraries

Daishi Kato](https://www.youtube.com/watch?v=oPfSC5bQPR8&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=15)

[![](https://react.dev/images/home/conf2021/diego.jpg)

React Conf](https://www.youtube.com/watch?v=dcm8fjBfro8&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=16)[### Building Accessible Components with React 18

Diego Haz](https://www.youtube.com/watch?v=dcm8fjBfro8&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=16)

[![](https://react.dev/images/home/conf2021/tafu.jpg)

React Conf](https://www.youtube.com/watch?v=S4a0QlsH0pU&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=17)[### Accessible Japanese Form Components with React

Tafu Nakazaki](https://www.youtube.com/watch?v=S4a0QlsH0pU&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=17)

[![](https://react.dev/images/home/conf2021/lyle.jpg)

React Conf](https://www.youtube.com/watch?v=b3l4WxipFsE&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=18)[### UI Tools for Artists

Lyle Troxell](https://www.youtube.com/watch?v=b3l4WxipFsE&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=18)

[![](https://react.dev/images/home/conf2021/helen.jpg)

React Conf](https://www.youtube.com/watch?v=HS6vIYkSNks&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=19)[### Hydrogen + React 18

Helen Lin](https://www.youtube.com/watch?v=HS6vIYkSNks&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=19)

React is also an architecture. Frameworks that implement it let you fetch data in asynchronous components that run on the server or even during the build. Read data from a file or a database, and pass it down to your interactive components.

[Get started with a framework](https://react.dev/learn/creating-a-react-app)

## Use the best from every platform

People love web and native apps for different reasons. React lets you build both web apps and native apps using the same skills. It leans upon each platform’s unique strengths to let your interfaces feel just right on every platform.

example.com

#### Stay true to the web

People expect web app pages to load fast. On the server, React lets you start streaming HTML while you’re still fetching data, progressively filling in the remaining content before any JavaScript code loads. On the client, React can use standard web APIs to keep your UI responsive even in the middle of rendering.

8:48 PM

#### Go truly native

People expect native apps to look and feel like their platform. [React Native](https://reactnative.dev) and [Expo](https://github.com/expo/expo) let you build apps in React for Android, iOS, and more. They look and feel native because their UIs *are* truly native. It’s not a web view—your React components render real Android and iOS views provided by the platform.

With React, you can be a web *and* a native developer. Your team can ship to many platforms without sacrificing the user experience. Your organization can bridge the platform silos, and form teams that own entire features end-to-end.

[Build for native platforms](https://reactnative.dev/)

## Upgrade when the future is ready

React approaches changes with care. Every React commit is tested on business-critical surfaces with over a billion users. Over 100,000 React components at Meta help validate every migration strategy.

The React team is always researching how to improve React. Some research takes years to pay off. React has a high bar for taking a research idea into production. Only proven approaches become a part of React.

[Read more React news](https://react.dev/blog)

Latest React News

[## Additional Vulnerabilities in RSC

December 11, 2025](https://react.dev/blog/2025/12/11/denial-of-service-and-source-code-exposure-in-react-server-components)

[## Vulnerability in React Server Components

December 3, 2025](https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components)

[## React Conf 2025 Recap

October 16, 2025](https://react.dev/blog/2025/10/16/react-conf-2025-recap)

[## React Compiler v1.0

October 7, 2025](https://react.dev/blog/2025/10/07/react-compiler-1)

[Read more React news](https://react.dev/blog)

## Join a community of millions

You’re not alone. Two million developers from all over the world visit the React docs every month. React is something that people and teams can agree on.

![People singing karaoke at React Conf](https://react.dev/images/home/community/react_conf_fun.webp)

![Sunil Pai speaking at React India](https://react.dev/images/home/community/react_india_sunil.webp)

![A hallway conversation between two people at React Conf](https://react.dev/images/home/community/react_conf_hallway.webp)

![A hallway conversation at React India](https://react.dev/images/home/community/react_india_hallway.webp)

![Elizabet Oliveira speaking at React Conf](https://react.dev/images/home/community/react_conf_elizabet.webp)

![People taking a group selfie at React India](https://react.dev/images/home/community/react_india_selfie.webp)

![Nat Alison speaking at React Conf](https://react.dev/images/home/community/react_conf_nat.webp)

![Organizers greeting attendees at React India](https://react.dev/images/home/community/react_india_team.webp)

![People singing karaoke at React Conf](https://react.dev/images/home/community/react_conf_fun.webp)

![Sunil Pai speaking at React India](https://react.dev/images/home/community/react_india_sunil.webp)

![A hallway conversation between two people at React Conf](https://react.dev/images/home/community/react_conf_hallway.webp)

![A hallway conversation at React India](https://react.dev/images/home/community/react_india_hallway.webp)

![Elizabet Oliveira speaking at React Conf](https://react.dev/images/home/community/react_conf_elizabet.webp)

![People taking a group selfie at React India](https://react.dev/images/home/community/react_india_selfie.webp)

![Nat Alison speaking at React Conf](https://react.dev/images/home/community/react_conf_nat.webp)

![Organizers greeting attendees at React India](https://react.dev/images/home/community/react_india_team.webp)

This is why React is more than a library, an architecture, or even an ecosystem. React is a community. It’s a place where you can ask for help, find opportunities, and meet new friends. You will meet both developers and designers, beginners and experts, researchers and artists, teachers and students. Our backgrounds may be very different, but React lets us all create user interfaces together.

![logo by @sawaratsuki1004](https://react.dev/images/uwu.png "logo by @sawaratsuki1004")

## Welcome to the React community

[Get Started](https://react.dev/learn)

---


# React Versions – React

URL: https://react.dev/versions

[React Docs](https://react.dev/)

# React Versions

The React docs at [react.dev](https://react.dev) provide documentation for the latest version of React.

We aim to keep the docs updated within major versions, and do not publish versions for each minor or patch version. When a new major is released, we archive the docs for the previous version as `x.react.dev`. See our [versioning policy](https://react.dev/community/versioning-policy) for more info.

You can find an archive of previous major versions below.

## Latest version: 19.2

* [react.dev](https://react.dev)

## Previous versions

* [18.react.dev](https://18.react.dev)
* [17.react.dev](https://17.react.dev)
* [16.react.dev](https://16.react.dev)
* [15.react.dev](https://15.react.dev)

### Note

#### Legacy Docs

In 2023, we [launched our new docs](https://react.dev/blog/2023/03/16/introducing-react-dev) for React 18 as [react.dev](https://react.dev). The legacy React 18 docs are available at [legacy.reactjs.org](https://legacy.reactjs.org). Versions 17 and below are hosted on legacy sites.

For versions older than React 15, see [15.react.dev](https://15.react.dev).

## Changelog

### React 19

**Blog Posts**

* [React v19](https://react.dev/blog/2024/12/05/react-19)
* [React 19 Upgrade Guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide)
* [React Compiler Beta Release](https://react.dev/blog/2024/10/21/react-compiler-beta-release)
* [React Compiler v1.0](https://react.dev/blog/2025/10/07/react-compiler-1)
* [React 19.2](https://react.dev/blog/2025/10/01/react-19-2)

**Talks**

* [React 19 Keynote](https://www.youtube.com/watch?v=lyEKhv8-3n0)
* [A Roadmap to React 19](https://www.youtube.com/watch?v=R0B2HsSM78s)
* [What’s new in React 19](https://www.youtube.com/watch?v=AJOGzVygGcY)
* [React for Two Computers](https://www.youtube.com/watch?v=ozI4V_29fj4)
* [React Compiler Deep Dive](https://www.youtube.com/watch?v=uA_PVyZP7AI)
* [React Compiler Case Studies](https://www.youtube.com/watch?v=lvhPq5chokM)
* [React 19 Deep Dive: Coordinating HTML](https://www.youtube.com/watch?v=IBBN-s77YSI)

**Releases**

* [v19.2.1 (December, 2025)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1922-dec-11-2025)
* [v19.2.1 (December, 2025)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1921-dec-3-2025)
* [v19.2.0 (October, 2025)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1920-october-1st-2025)
* [v19.1.3 (December, 2025)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1913-dec-11-2025)
* [v19.1.2 (December, 2025)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1912-dec-3-2025)
* [v19.1.1 (July, 2025)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1911-july-28-2025)
* [v19.1.0 (March, 2025)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1910-march-28-2025)
* [v19.0.2 (December, 2025)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1902-dec-11-2025)
* [v19.0.1 (December, 2025)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1901-dec-3-2025)
* [v19.0.0 (December, 2024)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1900-december-5-2024)

### React 18

**Blog Posts**

* [React v18.0](https://react.dev/blog/2022/03/29/react-v18)
* [How to Upgrade to React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide)
* [The Plan for React 18](https://react.dev/blog/2021/06/08/the-plan-for-react-18)

**Talks**

* [React 18 Keynote](https://www.youtube.com/watch?v=FZ0cG47msEk)
* [React 18 for app developers](https://www.youtube.com/watch?v=ytudH8je5ko)
* [Streaming Server Rendering with Suspense](https://www.youtube.com/watch?v=pj5N-Khihgc)
* [React without memo](https://www.youtube.com/watch?v=lGEMwh32soc)
* [React Docs Keynote](https://www.youtube.com/watch?v=mneDaMYOKP8)
* [React Developer Tooling](https://www.youtube.com/watch?v=oxDfrke8rZg)
* [The first React Working Group](https://www.youtube.com/watch?v=qn7gRClrC9U)
* [React 18 for External Store Libraries](https://www.youtube.com/watch?v=oPfSC5bQPR8)

**Releases**

* [v18.3.1 (April, 2024)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1831-april-26-2024)
* [v18.3.0 (April, 2024)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1830-april-25-2024)
* [v18.2.0 (June, 2022)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1820-june-14-2022)
* [v18.1.0 (April, 2022)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1810-april-26-2022)
* [v18.0.0 (March 2022)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1800-march-29-2022)

### React 17

**Blog Posts**

* [React v17.0](https://legacy.reactjs.org/blog/2020/10/20/react-v17.html)
* [Introducing the New JSX Transform](https://legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html)
* [React v17.0 Release Candidate: No New Features](https://legacy.reactjs.org/blog/2020/08/10/react-v17-rc.html)

**Releases**

* [v17.0.2 (March 2021)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1702-march-22-2021)
* [v17.0.1 (October 2020)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1701-october-22-2020)
* [v17.0.0 (October 2020)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1700-october-20-2020)

### React 16

**Blog Posts**

* [React v16.0](https://legacy.reactjs.org/blog/2017/09/26/react-v16.0.html)
* [DOM Attributes in React 16](https://legacy.reactjs.org/blog/2017/09/08/dom-attributes-in-react-16.html)
* [Error Handling in React 16](https://legacy.reactjs.org/blog/2017/07/26/error-handling-in-react-16.html)
* [React v16.2.0: Improved Support for Fragments](https://legacy.reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html)
* [React v16.4.0: Pointer Events](https://legacy.reactjs.org/blog/2018/05/23/react-v-16-4.html)
* [React v16.4.2: Server-side vulnerability fix](https://legacy.reactjs.org/blog/2018/08/01/react-v-16-4-2.html)
* [React v16.6.0: lazy, memo and contextType](https://legacy.reactjs.org/blog/2018/10/23/react-v-16-6.html)
* [React v16.7: No, This Is Not the One With Hooks](https://legacy.reactjs.org/blog/2018/12/19/react-v-16-7.html)
* [React v16.8: The One With Hooks](https://legacy.reactjs.org/blog/2019/02/06/react-v16.8.0.html)
* [React v16.9.0 and the Roadmap Update](https://legacy.reactjs.org/blog/2019/08/08/react-v16.9.0.html)
* [React v16.13.0](https://legacy.reactjs.org/blog/2020/02/26/react-v16.13.0.html)

**Releases**

* [v16.14.0 (October 2020)](https://github.com/facebook/react/blob/main/CHANGELOG.md#16140-october-14-2020)
* [v16.13.1 (March 2020)](https://github.com/facebook/react/blob/main/CHANGELOG.md#16131-march-19-2020)
* [v16.13.0 (February 2020)](https://github.com/facebook/react/blob/main/CHANGELOG.md#16130-february-26-2020)
* [v16.12.0 (November 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#16120-november-14-2019)
* [v16.11.0 (October 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#16110-october-22-2019)
* [v16.10.2 (October 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#16102-october-3-2019)
* [v16.10.1 (September 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#16101-september-28-2019)
* [v16.10.0 (September 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#16100-september-27-2019)
* [v16.9.0 (August 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1690-august-8-2019)
* [v16.8.6 (March 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1686-march-27-2019)
* [v16.8.5 (March 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1685-march-22-2019)
* [v16.8.4 (March 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1684-march-5-2019)
* [v16.8.3 (February 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1683-february-21-2019)
* [v16.8.2 (February 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1682-february-14-2019)
* [v16.8.1 (February 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1681-february-6-2019)
* [v16.8.0 (February 2019)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1680-february-6-2019)
* [v16.7.0 (December 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1670-december-19-2018)
* [v16.6.3 (November 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1663-november-12-2018)
* [v16.6.2 (November 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1662-november-12-2018)
* [v16.6.1 (November 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1661-november-6-2018)
* [v16.6.0 (October 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1660-october-23-2018)
* [v16.5.2 (September 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1652-september-18-2018)
* [v16.5.1 (September 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1651-september-13-2018)
* [v16.5.0 (September 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1650-september-5-2018)
* [v16.4.2 (August 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1642-august-1-2018)
* [v16.4.1 (June 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1641-june-13-2018)
* [v16.4.0 (May 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1640-may-23-2018)
* [v16.3.3 (August 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1633-august-1-2018)
* [v16.3.2 (April 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1632-april-16-2018)
* [v16.3.1 (April 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1631-april-3-2018)
* [v16.3.0 (March 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1630-march-29-2018)
* [v16.2.1 (August 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1621-august-1-2018)
* [v16.2.0 (November 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1620-november-28-2017)
* [v16.1.2 (August 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1612-august-1-2018)
* [v16.1.1 (November 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1611-november-13-2017)
* [v16.1.0 (November 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1610-november-9-2017)
* [v16.0.1 (August 2018)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1601-august-1-2018)
* [v16.0 (September 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1600-september-26-2017)

### React 15

**Blog Posts**

* [React v15.0](https://legacy.reactjs.org/blog/2016/04/07/react-v15.html)
* [React v15.0 Release Candidate 2](https://legacy.reactjs.org/blog/2016/03/16/react-v15-rc2.html)
* [React v15.0 Release Candidate](https://legacy.reactjs.org/blog/2016/03/07/react-v15-rc1.html)
* [New Versioning Scheme](https://legacy.reactjs.org/blog/2016/02/19/new-versioning-scheme.html)
* [Discontinuing IE 8 Support in React DOM](https://legacy.reactjs.org/blog/2016/01/12/discontinuing-ie8-support.html)
* [Introducing React’s Error Code System](https://legacy.reactjs.org/blog/2016/07/11/introducing-reacts-error-code-system.html)
* [React v15.0.1](https://legacy.reactjs.org/blog/2016/04/08/react-v15.0.1.html)
* [React v15.4.0](https://legacy.reactjs.org/blog/2016/11/16/react-v15.4.0.html)
* [React v15.5.0](https://legacy.reactjs.org/blog/2017/04/07/react-v15.5.0.html)
* [React v15.6.0](https://legacy.reactjs.org/blog/2017/06/13/react-v15.6.0.html)
* [React v15.6.2](https://legacy.reactjs.org/blog/2017/09/25/react-v15.6.2.html)

**Releases**

* [v15.7.0 (October 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1570-october-14-2020)
* [v15.6.2 (September 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1562-september-25-2017)
* [v15.6.1 (June 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1561-june-14-2017)
* [v15.6.0 (June 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1560-june-13-2017)
* [v15.5.4 (April 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1554-april-11-2017)
* [v15.5.3 (April 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1553-april-7-2017)
* [v15.5.2 (April 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1552-april-7-2017)
* [v15.5.1 (April 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1551-april-7-2017)
* [v15.5.0 (April 2017)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1550-april-7-2017)
* [v15.4.2 (January 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1542-january-6-2017)
* [v15.4.1 (November 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1541-november-22-2016)
* [v15.4.0 (November 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1540-november-16-2016)
* [v15.3.2 (September 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1532-september-19-2016)
* [v15.3.1 (August 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1531-august-19-2016)
* [v15.3.0 (July 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1530-july-29-2016)
* [v15.2.1 (July 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1521-july-8-2016)
* [v15.2.0 (July 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1520-july-1-2016)
* [v15.1.0 (May 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1510-may-20-2016)
* [v15.0.2 (April 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1502-april-29-2016)
* [v15.0.1 (April 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1501-april-8-2016)
* [v15.0.0 (April 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#1500-april-7-2016)

### React 0.14

**Blog Posts**

* [React v0.14](https://legacy.reactjs.org/blog/2015/10/07/react-v0.14.html)
* [React v0.14 Release Candidate](https://legacy.reactjs.org/blog/2015/09/10/react-v0.14-rc1.html)
* [React v0.14 Beta 1](https://legacy.reactjs.org/blog/2015/07/03/react-v0.14-beta-1.html)
* [New React Developer Tools](https://legacy.reactjs.org/blog/2015/09/02/new-react-developer-tools.html)
* [New React Devtools Beta](https://legacy.reactjs.org/blog/2015/08/03/new-react-devtools-beta.html)
* [React v0.14.1](https://legacy.reactjs.org/blog/2015/10/28/react-v0.14.1.html)
* [React v0.14.2](https://legacy.reactjs.org/blog/2015/11/02/react-v0.14.2.html)
* [React v0.14.3](https://legacy.reactjs.org/blog/2015/11/18/react-v0.14.3.html)
* [React v0.14.4](https://legacy.reactjs.org/blog/2015/12/29/react-v0.14.4.html)
* [React v0.14.8](https://legacy.reactjs.org/blog/2016/03/29/react-v0.14.8.html)

**Releases**

* [v0.14.10 (October 2020)](https://github.com/facebook/react/blob/main/CHANGELOG.md#01410-october-14-2020)
* [v0.14.8 (March 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0148-march-29-2016)
* [v0.14.7 (January 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0147-january-28-2016)
* [v0.14.6 (January 2016)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0146-january-6-2016)
* [v0.14.5 (December 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0145-december-29-2015)
* [v0.14.4 (December 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0144-december-29-2015)
* [v0.14.3 (November 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0143-november-18-2015)
* [v0.14.2 (November 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0142-november-2-2015)
* [v0.14.1 (October 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0141-october-28-2015)
* [v0.14.0 (October 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0140-october-7-2015)

### React 0.13

**Blog Posts**

* [React Native v0.4](https://legacy.reactjs.org/blog/2015/04/17/react-native-v0.4.html)
* [React v0.13](https://legacy.reactjs.org/blog/2015/03/10/react-v0.13.html)
* [React v0.13 RC2](https://legacy.reactjs.org/blog/2015/03/03/react-v0.13-rc2.html)
* [React v0.13 RC](https://legacy.reactjs.org/blog/2015/02/24/react-v0.13-rc1.html)
* [React v0.13.0 Beta 1](https://legacy.reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html)
* [Streamlining React Elements](https://legacy.reactjs.org/blog/2015/02/24/streamlining-react-elements.html)
* [Introducing Relay and GraphQL](https://legacy.reactjs.org/blog/2015/02/20/introducing-relay-and-graphql.html)
* [Introducing React Native](https://legacy.reactjs.org/blog/2015/03/26/introducing-react-native.html)
* [React v0.13.1](https://legacy.reactjs.org/blog/2015/03/16/react-v0.13.1.html)
* [React v0.13.2](https://legacy.reactjs.org/blog/2015/04/18/react-v0.13.2.html)
* [React v0.13.3](https://legacy.reactjs.org/blog/2015/05/08/react-v0.13.3.html)

**Releases**

* [v0.13.3 (May 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0133-may-8-2015)
* [v0.13.2 (April 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0132-april-18-2015)
* [v0.13.1 (March 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0131-march-16-2015)
* [v0.13.0 (March 2015)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0130-march-10-2015)

### React 0.12

**Blog Posts**

* [React v0.12](https://legacy.reactjs.org/blog/2014/10/28/react-v0.12.html)
* [React v0.12 RC](https://legacy.reactjs.org/blog/2014/10/16/react-v0.12-rc1.html)
* [Introducing React Elements](https://legacy.reactjs.org/blog/2014/10/14/introducing-react-elements.html)
* [React v0.12.2](https://legacy.reactjs.org/blog/2014/12/18/react-v0.12.2.html)

**Releases**

* [v0.12.2 (December 2014)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0122-december-18-2014)
* [v0.12.1 (November 2014)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0121-november-18-2014)
* [v0.12.0 (October 2014)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0120-october-28-2014)

### React 0.11

**Blog Posts**

* [React v0.11](https://legacy.reactjs.org/blog/2014/07/17/react-v0.11.html)
* [React v0.11 RC](https://legacy.reactjs.org/blog/2014/07/13/react-v0.11-rc1.html)
* [One Year of Open-Source React](https://legacy.reactjs.org/blog/2014/05/29/one-year-of-open-source-react.html)
* [The Road to 1.0](https://legacy.reactjs.org/blog/2014/03/28/the-road-to-1.0.html)
* [React v0.11.1](https://legacy.reactjs.org/blog/2014/07/25/react-v0.11.1.html)
* [React v0.11.2](https://legacy.reactjs.org/blog/2014/09/16/react-v0.11.2.html)
* [Introducing the JSX Specificaion](https://legacy.reactjs.org/blog/2014/09/03/introducing-the-jsx-specification.html)

**Releases**

* [v0.11.2 (September 2014)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0112-september-16-2014)
* [v0.11.1 (July 2014)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0111-july-24-2014)
* [v0.11.0 (July 2014)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0110-july-17-2014)

### React 0.10 and below

**Blog Posts**

* [React v0.10](https://legacy.reactjs.org/blog/2014/03/21/react-v0.10.html)
* [React v0.10 RC](https://legacy.reactjs.org/blog/2014/03/19/react-v0.10-rc1.html)
* [React v0.9](https://legacy.reactjs.org/blog/2014/02/20/react-v0.9.html)
* [React v0.9 RC](https://legacy.reactjs.org/blog/2014/02/16/react-v0.9-rc1.html)
* [React Chrome Developer Tools](https://legacy.reactjs.org/blog/2014/01/02/react-chrome-developer-tools.html)
* [React v0.8](https://legacy.reactjs.org/blog/2013/12/19/react-v0.8.0.html)
* [React v0.5.2, v0.4.2](https://legacy.reactjs.org/blog/2013/12/18/react-v0.5.2-v0.4.2.html)
* [React v0.5.1](https://legacy.reactjs.org/blog/2013/10/29/react-v0-5-1.html)
* [React v0.5](https://legacy.reactjs.org/blog/2013/10/16/react-v0.5.0.html)
* [React v0.4.1](https://legacy.reactjs.org/blog/2013/07/26/react-v0-4-1.html)
* [React v0.4.0](https://legacy.reactjs.org/blog/2013/07/17/react-v0-4-0.html)
* [New in React v0.4: Prop Validation and Default Values](https://legacy.reactjs.org/blog/2013/07/11/react-v0-4-prop-validation-and-default-values.html)
* [New in React v0.4: Autobind by Default](https://legacy.reactjs.org/blog/2013/07/02/react-v0-4-autobind-by-default.html)
* [React v0.3.3](https://legacy.reactjs.org/blog/2013/07/02/react-v0-4-autobind-by-default.html)

**Releases**

* [v0.10.0 (March 2014)](https://github.com/facebook/react/blob/main/CHANGELOG.md#0100-march-21-2014)
* [v0.9.0 (February 2014)](https://github.com/facebook/react/blob/main/CHANGELOG.md#090-february-20-2014)
* [v0.8.0 (December 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#080-december-19-2013)
* [v0.5.2 (December 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#052-042-december-18-2013)
* [v0.5.1 (October 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#051-october-29-2013)
* [v0.5.0 (October 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#050-october-16-2013)
* [v0.4.1 (July 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#041-july-26-2013)
* [v0.4.0 (July 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#040-july-17-2013)
* [v0.3.3 (June 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#033-june-20-2013)
* [v0.3.2 (May 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#032-may-31-2013)
* [v0.3.1 (May 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#031-may-30-2013)
* [v0.3.0 (May 2013)](https://github.com/facebook/react/blob/main/CHANGELOG.md#031-may-30-2013)

### Initial Commit

React was open-sourced on May 29, 2013. The initial commit is: [`75897c`: Initial public release](https://github.com/facebook/react/commit/75897c2dcd1dd3a6ca46284dd37e13d22b4b16b4)

See the first blog post: [Why did we build React?](https://legacy.reactjs.org/blog/2013/06/05/why-react.html)

React was open sourced at Facebook Seattle in 2013:

---

---


# React Reference Overview – React

URL: https://react.dev/reference/react

[API Reference](https://react.dev/reference/react)

# React Reference Overview

This section provides detailed reference documentation for working with React. For an introduction to React, please visit the [Learn](https://react.dev/learn) section.

The React reference documentation is broken down into functional subsections:

## React

Programmatic React features:

* [Hooks](https://react.dev/reference/react/hooks) - Use different React features from your components.
* [Components](https://react.dev/reference/react/components) - Built-in components that you can use in your JSX.
* [APIs](https://react.dev/reference/react/apis) - APIs that are useful for defining components.
* [Directives](https://react.dev/reference/rsc/directives) - Provide instructions to bundlers compatible with React Server Components.

## React DOM

React DOM contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:

* [Hooks](https://react.dev/reference/react-dom/hooks) - Hooks for web applications which run in the browser DOM environment.
* [Components](https://react.dev/reference/react-dom/components) - React supports all of the browser built-in HTML and SVG components.
* [APIs](https://react.dev/reference/react-dom) - The `react-dom` package contains methods supported only in web applications.
* [Client APIs](https://react.dev/reference/react-dom/client) - The `react-dom/client` APIs let you render React components on the client (in the browser).
* [Server APIs](https://react.dev/reference/react-dom/server) - The `react-dom/server` APIs let you render React components to HTML on the server.
* [Static APIs](https://react.dev/reference/react-dom/static) - The `react-dom/static` APIs let you generate static HTML for React components.

## React Compiler

The React Compiler is a build-time optimization tool that automatically memoizes your React components and values:

* [Configuration](https://react.dev/reference/react-compiler/configuration) - Configuration options for React Compiler.
* [Directives](https://react.dev/reference/react-compiler/directives) - Function-level directives to control compilation.
* [Compiling Libraries](https://react.dev/reference/react-compiler/compiling-libraries) - Guide for shipping pre-compiled library code.

## ESLint Plugin React Hooks

The [ESLint plugin for React Hooks](https://react.dev/reference/eslint-plugin-react-hooks) helps enforce the Rules of React:

* [Lints](https://react.dev/reference/eslint-plugin-react-hooks) - Detailed documentation for each lint with examples.

## Rules of React

React has idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications:

* [Components and Hooks must be pure](https://react.dev/reference/rules/components-and-hooks-must-be-pure) – Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.
* [React calls Components and Hooks](https://react.dev/reference/rules/react-calls-components-and-hooks) – React is responsible for rendering components and hooks when necessary to optimize the user experience.
* [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks) – Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.

## Legacy APIs

* [Legacy APIs](https://react.dev/reference/react/legacy) - Exported from the `react` package, but not recommended for use in newly written code.

[NextHooks](https://react.dev/reference/react/hooks)

---

---


# React Community – React

URL: https://react.dev/community

[Community](https://react.dev/community)

# React Community

React has a community of millions of developers. On this page we’ve listed some React-related communities that you can be a part of; see the other pages in this section for additional online and in-person learning materials.

## Code of Conduct

Before participating in React’s communities, [please read our Code of Conduct.](https://github.com/facebook/react/blob/main/CODE_OF_CONDUCT.md) We have adopted the [Contributor Covenant](https://www.contributor-covenant.org/) and we expect that all community members adhere to the guidelines within.

## Stack Overflow

Stack Overflow is a popular forum to ask code-level questions or if you’re stuck with a specific error. Read through the [existing questions](https://stackoverflow.com/questions/tagged/reactjs) tagged with **reactjs** or [ask your own](https://stackoverflow.com/questions/ask?tags=reactjs)!

## Popular Discussion Forums

There are many online forums which are a great place for discussion about best practices and application architecture as well as the future of React. If you have an answerable code-level question, Stack Overflow is usually a better fit.

Each community consists of many thousands of React users.

* [DEV’s React community](https://dev.to/t/react)
* [Hashnode’s React community](https://hashnode.com/n/reactjs)
* [Reactiflux online chat](https://discord.gg/reactiflux)
* [Reddit’s React community](https://www.reddit.com/r/reactjs/)

## News

For the latest news about React, [follow **@reactjs** on Twitter](https://twitter.com/reactjs), [**@react.dev** on Bluesky](https://bsky.app/profile/react.dev) and the [official React blog](https://react.dev/blog) on this website.

[NextReact Conferences](https://react.dev/community/conferences)

---

---


# React Blog – React

URL: https://react.dev/blog

[Blog](https://react.dev/blog)

# React Blog

This blog is the official source for the updates from the React team. Anything important, including release notes or deprecation notices, will be posted here first.

You can also follow the [@react.dev](https://bsky.app/profile/react.dev) account on Bluesky, or [@reactjs](https://twitter.com/reactjs) account on Twitter, but you won’t miss anything essential if you only read this blog.

[## Denial of Service and Source Code Exposure in React Server Components

December 11, 2025

Security researchers have found and disclosed two additional vulnerabilities in React Server Components while attempting to exploit the patches in last week’s critical vulnerability…

Read more](https://react.dev/blog/2025/12/11/denial-of-service-and-source-code-exposure-in-react-server-components)[## Critical Security Vulnerability in React Server Components

December 3, 2025

There is an unauthenticated remote code execution vulnerability in React Server Components. A fix has been published in versions 19.0.1, 19.1.2, and 19.2.1. We recommend upgrading immediately.

Read more](https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components)[## React Conf 2025 Recap

October 16, 2025

Last week we hosted React Conf 2025. In this post, we summarize the talks and announcements from the event…

Read more](https://react.dev/blog/2025/10/16/react-conf-2025-recap)[## React Compiler v1.0

October 7, 2025

We’re releasing the compiler’s first stable release today, plus linting and tooling improvements to make adoption easier.

Read more](https://react.dev/blog/2025/10/07/react-compiler-1)[## Introducing the React Foundation

October 7, 2025

Today, we’re announcing our plans to create the React Foundation and a new technical governance structure …

Read more](https://react.dev/blog/2025/10/07/introducing-the-react-foundation)[## React 19.2

October 1, 2025

React 19.2 adds new features like Activity, React Performance Tracks, useEffectEvent, and more. In this post …

Read more](https://react.dev/blog/2025/10/01/react-19-2)[## React Labs: View Transitions, Activity, and more

April 23, 2025

In React Labs posts, we write about projects in active research and development. In this post, we’re sharing two new experimental features that are ready to try today, and sharing other areas we’re working on now …

Read more](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more)[## Sunsetting Create React App

February 14, 2025

Today, we’re deprecating Create React App for new apps, and encouraging existing apps to migrate to a framework, or to migrate to a build tool like Vite, Parcel, or RSBuild. We’re also providing docs for when a framework isn’t a good fit for your project, you want to build your own framework, or you just want to learn how React works by building a React app from scratch …

Read more](https://react.dev/blog/2025/02/14/sunsetting-create-react-app)[## React v19

December 5, 2024

In the React 19 Upgrade Guide, we shared step-by-step instructions for upgrading your app to React 19. In this post, we’ll give an overview of the new features in React 19, and how you can adopt them …

Read more](https://react.dev/blog/2024/12/05/react-19)[## React Compiler Beta Release

October 21, 2024

We announced an experimental release of React Compiler at React Conf 2024. We’ve made a lot of progress since then, and in this post we want to share what’s next for React Compiler …

Read more](https://react.dev/blog/2024/10/21/react-compiler-beta-release)[## React Conf 2024 Recap

May 22, 2024

Last week we hosted React Conf 2024, a two-day conference in Henderson, Nevada where 700+ attendees gathered in-person to discuss the latest in UI engineering. This was our first in-person conference since 2019, and we were thrilled to be able to bring the community together again …

Read more](https://react.dev/blog/2024/05/22/react-conf-2024-recap)[## React 19 Upgrade Guide

April 25, 2024

The improvements added to React 19 require some breaking changes, but we’ve worked to make the upgrade as smooth as possible, and we don’t expect the changes to impact most apps. In this post, we will guide you through the steps for upgrading libraries to React 19 …

Read more](https://react.dev/blog/2024/04/25/react-19-upgrade-guide)[## React Labs: What We've Been Working On – February 2024

February 15, 2024

In React Labs posts, we write about projects in active research and development. Since our last update, we’ve made significant progress on React Compiler, new features, and React 19, and we’d like to share what we learned.

Read more](https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024)[## React Canaries: Incremental Feature Rollout Outside Meta

May 3, 2023

Traditionally, new React features used to only be available at Meta first, and land in the open source releases later. We’d like to offer the React community an option to adopt individual new features as soon as their design is close to final—similar to how Meta uses React internally. We are introducing a new officially supported Canary release channel. It lets curated setups like frameworks decouple adoption of individual React features from the React release schedule.

Read more](https://react.dev/blog/2023/05/03/react-canaries)[## React Labs: What We've Been Working On – March 2023

March 22, 2023

In React Labs posts, we write about projects in active research and development. Since our last update, we’ve made significant progress on React Server Components, Asset Loading, Optimizing Compiler, Offscreen Rendering, and Transition Tracing, and we’d like to share what we learned.

Read more](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023)[## Introducing react.dev

March 16, 2023

Today we are thrilled to launch react.dev, the new home for React and its documentation. In this post, we would like to give you a tour of the new site.

Read more](https://react.dev/blog/2023/03/16/introducing-react-dev)[## React Labs: What We've Been Working On – June 2022

June 15, 2022

React 18 was years in the making, and with it brought valuable lessons for the React team. Its release was the result of many years of research and exploring many paths. Some of those paths were successful; many more were dead-ends that led to new insights. One lesson we’ve learned is that it’s frustrating for the community to wait for new features without having insight into these paths that we’re exploring…

Read more](https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022)[## React v18.0

March 29, 2022

React 18 is now available on npm! In our last post, we shared step-by-step instructions for upgrading your app to React 18. In this post, we’ll give an overview of what’s new in React 18, and what it means for the future…

Read more](https://react.dev/blog/2022/03/29/react-v18)[## How to Upgrade to React 18

March 8, 2022

As we shared in the release post, React 18 introduces features powered by our new concurrent renderer, with a gradual adoption strategy for existing applications. In this post, we will guide you through the steps for upgrading to React 18…

Read more](https://react.dev/blog/2022/03/08/react-18-upgrade-guide)[## React Conf 2021 Recap

December 17, 2021

Last week we hosted our 6th React Conf. In previous years, we’ve used the React Conf stage to deliver industry changing announcements such as React Native and React Hooks. This year, we shared our multi-platform vision for React, starting with the release of React 18 and gradual adoption of concurrent features…

Read more](https://react.dev/blog/2021/12/17/react-conf-2021-recap)[## The Plan for React 18

June 8, 2021

The React team is excited to share a few updates:

* We’ve started work on the React 18 release, which will be our next major version.
* We’ve created a Working Group to prepare the community for gradual adoption of new features in React 18.
* We’ve published a React 18 Alpha so that library authors can try it and provide feedback…

Read more](https://react.dev/blog/2021/06/08/the-plan-for-react-18)[## Introducing Zero-Bundle-Size React Server Components

December 21, 2020

2020 has been a long year. As it comes to an end we wanted to share a special Holiday Update on our research into zero-bundle-size React Server Components. To introduce React Server Components, we have prepared a talk and a demo. If you want, you can check them out during the holidays, or later when work picks back up in the new year…

Read more](https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components)

---

### All release notes

Not every React release deserves its own blog post, but you can find a detailed changelog for every release in the [`CHANGELOG.md`](https://github.com/facebook/react/blob/main/CHANGELOG.md) file in the React repository, as well as on the [Releases](https://github.com/facebook/react/releases) page.

---

### Older posts

See the [older posts.](https://reactjs.org/blog/all.html)

---

---


# Translations – React

URL: https://react.dev/community/translations

[Community](https://react.dev/community)

# Translations

React docs are translated by the global community into many languages all over the world.

## Source site

All translations are provided from the canonical source docs:

* [English](https://react.dev/) — [Contribute](https://github.com/reactjs/react.dev/)

## Full translations

* [French (Français)](https://fr.react.dev/) — [Contribute](https://github.com/reactjs/fr.react.dev)
* [Japanese (日本語)](https://ja.react.dev/) — [Contribute](https://github.com/reactjs/ja.react.dev)
* [Korean (한국어)](https://ko.react.dev/) — [Contribute](https://github.com/reactjs/ko.react.dev)
* [Simplified Chinese (简体中文)](https://zh-hans.react.dev/) — [Contribute](https://github.com/reactjs/zh-hans.react.dev)
* [Spanish (Español)](https://es.react.dev/) — [Contribute](https://github.com/reactjs/es.react.dev)
* [Turkish (Türkçe)](https://tr.react.dev/) — [Contribute](https://github.com/reactjs/tr.react.dev)

## In-progress translations

For the progress of each translation, see: [Is React Translated Yet?](https://translations.react.dev/)

* [Arabic (العربية)](https://ar.react.dev/) — [Contribute](https://github.com/reactjs/ar.react.dev)
* [Azerbaijani (Azərbaycanca)](https://az.react.dev/) — [Contribute](https://github.com/reactjs/az.react.dev)
* [Belarusian (Беларуская)](https://be.react.dev/) — [Contribute](https://github.com/reactjs/be.react.dev)
* [Bengali (বাংলা)](https://bn.react.dev/) — [Contribute](https://github.com/reactjs/bn.react.dev)
* [Czech (Čeština)](https://cs.react.dev/) — [Contribute](https://github.com/reactjs/cs.react.dev)
* [Finnish (Suomi)](https://fi.react.dev/) — [Contribute](https://github.com/reactjs/fi.react.dev)
* [German (Deutsch)](https://de.react.dev/) — [Contribute](https://github.com/reactjs/de.react.dev)
* [Gujarati (ગુજરાતી)](https://gu.react.dev/) — [Contribute](https://github.com/reactjs/gu.react.dev)
* [Hebrew (עברית)](https://he.react.dev/) — [Contribute](https://github.com/reactjs/he.react.dev)
* [Hindi (हिन्दी)](https://hi.react.dev/) — [Contribute](https://github.com/reactjs/hi.react.dev)
* [Hungarian (magyar)](https://hu.react.dev/) — [Contribute](https://github.com/reactjs/hu.react.dev)
* [Icelandic (Íslenska)](https://is.react.dev/) — [Contribute](https://github.com/reactjs/is.react.dev)
* [Indonesian (Bahasa Indonesia)](https://id.react.dev/) — [Contribute](https://github.com/reactjs/id.react.dev)
* [Italian (Italiano)](https://it.react.dev/) — [Contribute](https://github.com/reactjs/it.react.dev)
* [Kazakh (Қазақша)](https://kk.react.dev/) — [Contribute](https://github.com/reactjs/kk.react.dev)
* [Lao (ພາສາລາວ)](https://lo.react.dev/) — [Contribute](https://github.com/reactjs/lo.react.dev)
* [Macedonian (Македонски)](https://mk.react.dev/) — [Contribute](https://github.com/reactjs/mk.react.dev)
* [Malayalam (മലയാളം)](https://ml.react.dev/) — [Contribute](https://github.com/reactjs/ml.react.dev)
* [Mongolian (Монгол хэл)](https://mn.react.dev/) — [Contribute](https://github.com/reactjs/mn.react.dev)
* [Persian (فارسی)](https://fa.react.dev/) — [Contribute](https://github.com/reactjs/fa.react.dev)
* [Polish (Polski)](https://pl.react.dev/) — [Contribute](https://github.com/reactjs/pl.react.dev)
* [Portuguese (Brazil) (Português do Brasil)](https://pt-br.react.dev/) — [Contribute](https://github.com/reactjs/pt-br.react.dev)
* [Russian (Русский)](https://ru.react.dev/) — [Contribute](https://github.com/reactjs/ru.react.dev)
* [Serbian (Srpski)](https://sr.react.dev/) — [Contribute](https://github.com/reactjs/sr.react.dev)
* [Sinhala (සිංහල)](https://si.react.dev/) — [Contribute](https://github.com/reactjs/si.react.dev)
* [Swahili (Kiswahili)](https://sw.react.dev/) — [Contribute](https://github.com/reactjs/sw.react.dev)
* [Tamil (தமிழ்)](https://ta.react.dev/) — [Contribute](https://github.com/reactjs/ta.react.dev)
* [Telugu (తెలుగు)](https://te.react.dev/) — [Contribute](https://github.com/reactjs/te.react.dev)
* [Traditional Chinese (繁體中文)](https://zh-hant.react.dev/) — [Contribute](https://github.com/reactjs/zh-hant.react.dev)
* [Ukrainian (Українська)](https://uk.react.dev/) — [Contribute](https://github.com/reactjs/uk.react.dev)
* [Urdu (اردو)](https://ur.react.dev/) — [Contribute](https://github.com/reactjs/ur.react.dev)
* [Vietnamese (Tiếng Việt)](https://vi.react.dev/) — [Contribute](https://github.com/reactjs/vi.react.dev)

## How to contribute

You can contribute to the translation efforts!

The community conducts the translation work for the React docs on each language-specific fork of react.dev. Typical translation work involves directly translating a Markdown file and creating a pull request. Click the “contribute” link above to the GitHub repository for your language, and follow the instructions there to help with the translation effort.

If you want to start a new translation for your language, visit: [translations.react.dev](https://github.com/reactjs/translations.react.dev)

[PreviousDocs Contributors](https://react.dev/community/docs-contributors)[NextAcknowledgements](https://react.dev/community/acknowledgements)

---

---


# Tutorial: Tic-Tac-Toe – React

URL: https://react.dev/learn/tutorial-tic-tac-toe

[Learn React](https://react.dev/learn)

[Quick Start](https://react.dev/learn)

# Tutorial: Tic-Tac-Toe

You will build a small tic-tac-toe game during this tutorial. This tutorial does not assume any existing React knowledge. The techniques you’ll learn in the tutorial are fundamental to building any React app, and fully understanding it will give you a deep understanding of React.

### Note

This tutorial is designed for people who prefer to **learn by doing** and want to quickly try making something tangible. If you prefer learning each concept step by step, start with [Describing the UI.](https://react.dev/learn/describing-the-ui)

The tutorial is divided into several sections:

* [Setup for the tutorial](https://react.dev/learn/tutorial-tic-tac-toe#setup-for-the-tutorial) will give you **a starting point** to follow the tutorial.
* [Overview](https://react.dev/learn/tutorial-tic-tac-toe#overview) will teach you **the fundamentals** of React: components, props, and state.
* [Completing the game](https://react.dev/learn/tutorial-tic-tac-toe#completing-the-game) will teach you **the most common techniques** in React development.
* [Adding time travel](https://react.dev/learn/tutorial-tic-tac-toe#adding-time-travel) will give you **a deeper insight** into the unique strengths of React.

### What are you building?

In this tutorial, you’ll build an interactive tic-tac-toe game with React.

You can see what it will look like when you’re finished here:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const [currentMove, setCurrentMove] = useState(0);
  const xIsNext = currentMove % 2 === 0;
  const currentSquares = history[currentMove];

  function handlePlay(nextSquares) {
    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];
    setHistory(nextHistory);
    setCurrentMove(nextHistory.length - 1);
  }

  function jumpTo(nextMove) {
    setCurrentMove(nextMove);
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li key={move}>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}
```

Show more

If the code doesn’t make sense to you yet, or if you are unfamiliar with the code’s syntax, don’t worry! The goal of this tutorial is to help you understand React and its syntax.

We recommend that you check out the tic-tac-toe game above before continuing with the tutorial. One of the features that you’ll notice is that there is a numbered list to the right of the game’s board. This list gives you a history of all of the moves that have occurred in the game, and it is updated as the game progresses.

Once you’ve played around with the finished tic-tac-toe game, keep scrolling. You’ll start with a simpler template in this tutorial. Our next step is to set you up so that you can start building the game.

## Setup for the tutorial

In the live code editor below, click **Fork** in the top-right corner to open the editor in a new tab using the website CodeSandbox. CodeSandbox lets you write code in your browser and preview how your users will see the app you’ve created. The new tab should display an empty square and the starter code for this tutorial.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Square() {
  return <button className="square">X</button>;
}
```

### Note

You can also follow this tutorial using your local development environment. To do this, you need to:

1. Install [Node.js](https://nodejs.org/en/)
2. In the CodeSandbox tab you opened earlier, press the top-left corner button to open the menu, and then choose **Download Sandbox** in that menu to download an archive of the files locally
3. Unzip the archive, then open a terminal and `cd` to the directory you unzipped
4. Install the dependencies with `npm install`
5. Run `npm start` to start a local server and follow the prompts to view the code running in a browser

If you get stuck, don’t let this stop you! Follow along online instead and try a local setup again later.

## Overview

Now that you’re set up, let’s get an overview of React!

### Inspecting the starter code

In CodeSandbox you’ll see three main sections:

![CodeSandbox with starter code](https://react.dev/images/tutorial/react-starter-code-codesandbox.png)

1. The *Files* section with a list of files like `App.js`, `index.js`, `styles.css` in `src` folder and a folder called `public`
2. The *code editor* where you’ll see the source code of your selected file
3. The *browser* section where you’ll see how the code you’ve written will be displayed

The `App.js` file should be selected in the *Files* section. The contents of that file in the *code editor* should be:

```
export default function Square() {

return <button className="square">X</button>;

}
```

The *browser* section should be displaying a square with an X in it like this:

![x-filled square](https://react.dev/images/tutorial/x-filled-square.png)

Now let’s have a look at the files in the starter code.

#### `App.js`

The code in `App.js` creates a *component*. In React, a component is a piece of reusable code that represents a part of a user interface. Components are used to render, manage, and update the UI elements in your application. Let’s look at the component line by line to see what’s going on:

```
export default function Square() {

return <button className="square">X</button>;

}
```

The first line defines a function called `Square`. The `export` JavaScript keyword makes this function accessible outside of this file. The `default` keyword tells other files using your code that it’s the main function in your file.

```
export default function Square() {

return <button className="square">X</button>;

}
```

The second line returns a button. The `return` JavaScript keyword means whatever comes after is returned as a value to the caller of the function. `<button>` is a *JSX element*. A JSX element is a combination of JavaScript code and HTML tags that describes what you’d like to display. `className="square"` is a button property or *prop* that tells CSS how to style the button. `X` is the text displayed inside of the button and `</button>` closes the JSX element to indicate that any following content shouldn’t be placed inside the button.

#### `styles.css`

Click on the file labeled `styles.css` in the *Files* section of CodeSandbox. This file defines the styles for your React app. The first two *CSS selectors* (`*` and `body`) define the style of large parts of your app while the `.square` selector defines the style of any component where the `className` property is set to `square`. In your code, that would match the button from your Square component in the `App.js` file.

#### `index.js`

Click on the file labeled `index.js` in the *Files* section of CodeSandbox. You won’t be editing this file during the tutorial but it is the bridge between the component you created in the `App.js` file and the web browser.

```
import { StrictMode } from 'react';

import { createRoot } from 'react-dom/client';

import './styles.css';

import App from './App';
```

Lines 1-5 bring all the necessary pieces together:

* React
* React’s library to talk to web browsers (React DOM)
* the styles for your components
* the component you created in `App.js`.

The remainder of the file brings all the pieces together and injects the final product into `index.html` in the `public` folder.

### Building the board

Let’s get back to `App.js`. This is where you’ll spend the rest of the tutorial.

Currently the board is only a single square, but you need nine! If you just try and copy paste your square to make two squares like this:

```
export default function Square() {

return <button className="square">X</button><button className="square">X</button>;

}
```

You’ll get this error:

Console

/src/App.js: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX Fragment `<>...</>`?

React components need to return a single JSX element and not multiple adjacent JSX elements like two buttons. To fix this you can use *Fragments* (`<>` and `</>`) to wrap multiple adjacent JSX elements like this:

```
export default function Square() {

return (

<>

<button className="square">X</button>

<button className="square">X</button>

</>

);

}
```

Now you should see:

![two x-filled squares](https://react.dev/images/tutorial/two-x-filled-squares.png)

Great! Now you just need to copy-paste a few times to add nine squares and…

![nine x-filled squares in a line](https://react.dev/images/tutorial/nine-x-filled-squares.png)

Oh no! The squares are all in a single line, not in a grid like you need for our board. To fix this you’ll need to group your squares into rows with `div`s and add some CSS classes. While you’re at it, you’ll give each square a number to make sure you know where each square is displayed.

In the `App.js` file, update the `Square` component to look like this:

```
export default function Square() {

return (

<>

<div className="board-row">

<button className="square">1</button>

<button className="square">2</button>

<button className="square">3</button>

</div>

<div className="board-row">

<button className="square">4</button>

<button className="square">5</button>

<button className="square">6</button>

</div>

<div className="board-row">

<button className="square">7</button>

<button className="square">8</button>

<button className="square">9</button>

</div>

</>

);

}
```

The CSS defined in `styles.css` styles the divs with the `className` of `board-row`. Now that you’ve grouped your components into rows with the styled `div`s you have your tic-tac-toe board:

![tic-tac-toe board filled with numbers 1 through 9](https://react.dev/images/tutorial/number-filled-board.png)

But you now have a problem. Your component named `Square`, really isn’t a square anymore. Let’s fix that by changing the name to `Board`:

```
export default function Board() {

//...

}
```

At this point your code should look something like this:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Board() {
  return (
    <>
      <div className="board-row">
        <button className="square">1</button>
        <button className="square">2</button>
        <button className="square">3</button>
      </div>
      <div className="board-row">
        <button className="square">4</button>
        <button className="square">5</button>
        <button className="square">6</button>
      </div>
      <div className="board-row">
        <button className="square">7</button>
        <button className="square">8</button>
        <button className="square">9</button>
      </div>
    </>
  );
}
```

Show more

### Note

Psssst… That’s a lot to type! It’s okay to copy and paste code from this page. However, if you’re up for a little challenge, we recommend only copying code that you’ve manually typed at least once yourself.

### Passing data through props

Next, you’ll want to change the value of a square from empty to “X” when the user clicks on the square. With how you’ve built the board so far you would need to copy-paste the code that updates the square nine times (once for each square you have)! Instead of copy-pasting, React’s component architecture allows you to create a reusable component to avoid messy, duplicated code.

First, you are going to copy the line defining your first square (`<button className="square">1</button>`) from your `Board` component into a new `Square` component:

```
function Square() {

return <button className="square">1</button>;

}

export default function Board() {

// ...

}
```

Then you’ll update the Board component to render that `Square` component using JSX syntax:

```
// ...

export default function Board() {

return (

<>

<div className="board-row">

<Square />

<Square />

<Square />

</div>

<div className="board-row">

<Square />

<Square />

<Square />

</div>

<div className="board-row">

<Square />

<Square />

<Square />

</div>

</>

);

}
```

Note how unlike the browser `div`s, your own components `Board` and `Square` must start with a capital letter.

Let’s take a look:

![one-filled board](https://react.dev/images/tutorial/board-filled-with-ones.png)

Oh no! You lost the numbered squares you had before. Now each square says “1”. To fix this, you will use *props* to pass the value each square should have from the parent component (`Board`) to its child (`Square`).

Update the `Square` component to read the `value` prop that you’ll pass from the `Board`:

```
function Square({ value }) {

return <button className="square">1</button>;

}
```

`function Square({ value })` indicates the Square component can be passed a prop called `value`.

Now you want to display that `value` instead of `1` inside every square. Try doing it like this:

```
function Square({ value }) {

return <button className="square">value</button>;

}
```

Oops, this is not what you wanted:

![value-filled board](https://react.dev/images/tutorial/board-filled-with-value.png)

You wanted to render the JavaScript variable called `value` from your component, not the word “value”. To “escape into JavaScript” from JSX, you need curly braces. Add curly braces around `value` in JSX like so:

```
function Square({ value }) {

return <button className="square">{value}</button>;

}
```

For now, you should see an empty board:

![empty board](https://react.dev/images/tutorial/empty-board.png)

This is because the `Board` component hasn’t passed the `value` prop to each `Square` component it renders yet. To fix it you’ll add the `value` prop to each `Square` component rendered by the `Board` component:

```
export default function Board() {

return (

<>

<div className="board-row">

<Square value="1" />

<Square value="2" />

<Square value="3" />

</div>

<div className="board-row">

<Square value="4" />

<Square value="5" />

<Square value="6" />

</div>

<div className="board-row">

<Square value="7" />

<Square value="8" />

<Square value="9" />

</div>

</>

);

}
```

Now you should see a grid of numbers again:

![tic-tac-toe board filled with numbers 1 through 9](https://react.dev/images/tutorial/number-filled-board.png)

Your updated code should look like this:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Square({ value }) {
  return <button className="square">{value}</button>;
}

export default function Board() {
  return (
    <>
      <div className="board-row">
        <Square value="1" />
        <Square value="2" />
        <Square value="3" />
      </div>
      <div className="board-row">
        <Square value="4" />
        <Square value="5" />
        <Square value="6" />
      </div>
      <div className="board-row">
        <Square value="7" />
        <Square value="8" />
        <Square value="9" />
      </div>
    </>
  );
}
```

Show more

### Making an interactive component

Let’s fill the `Square` component with an `X` when you click it. Declare a function called `handleClick` inside of the `Square`. Then, add `onClick` to the props of the button JSX element returned from the `Square`:

```
function Square({ value }) {

function handleClick() {

console.log('clicked!');

}

return (

<button

className="square"

onClick={handleClick}

>

{value}

</button>

);

}
```

If you click on a square now, you should see a log saying `"clicked!"` in the *Console* tab at the bottom of the *Browser* section in CodeSandbox. Clicking the square more than once will log `"clicked!"` again. Repeated console logs with the same message will not create more lines in the console. Instead, you will see an incrementing counter next to your first `"clicked!"` log.

### Note

If you are following this tutorial using your local development environment, you need to open your browser’s Console. For example, if you use the Chrome browser, you can view the Console with the keyboard shortcut **Shift + Ctrl + J** (on Windows/Linux) or **Option + ⌘ + J** (on macOS).

As a next step, you want the Square component to “remember” that it got clicked, and fill it with an “X” mark. To “remember” things, components use *state*.

React provides a special function called `useState` that you can call from your component to let it “remember” things. Let’s store the current value of the `Square` in state, and change it when the `Square` is clicked.

Import `useState` at the top of the file. Remove the `value` prop from the `Square` component. Instead, add a new line at the start of the `Square` that calls `useState`. Have it return a state variable called `value`:

```
import { useState } from 'react';

function Square() {

const [value, setValue] = useState(null);

function handleClick() {

//...
```

`value` stores the value and `setValue` is a function that can be used to change the value. The `null` passed to `useState` is used as the initial value for this state variable, so `value` here starts off equal to `null`.

Since the `Square` component no longer accepts props anymore, you’ll remove the `value` prop from all nine of the Square components created by the Board component:

```
// ...

export default function Board() {

return (

<>

<div className="board-row">

<Square />

<Square />

<Square />

</div>

<div className="board-row">

<Square />

<Square />

<Square />

</div>

<div className="board-row">

<Square />

<Square />

<Square />

</div>

</>

);

}
```

Now you’ll change `Square` to display an “X” when clicked. Replace the `console.log("clicked!");` event handler with `setValue('X');`. Now your `Square` component looks like this:

```
function Square() {

const [value, setValue] = useState(null);

function handleClick() {

setValue('X');

}

return (

<button

className="square"

onClick={handleClick}

>

{value}

</button>

);

}
```

By calling this `set` function from an `onClick` handler, you’re telling React to re-render that `Square` whenever its `<button>` is clicked. After the update, the `Square`’s `value` will be `'X'`, so you’ll see the “X” on the game board. Click on any Square, and “X” should show up:

![adding xes to board](https://react.dev/images/tutorial/tictac-adding-x-s.gif)

Each Square has its own state: the `value` stored in each Square is completely independent of the others. When you call a `set` function in a component, React automatically updates the child components inside too.

After you’ve made the above changes, your code will look like this:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square() {
  const [value, setValue] = useState(null);

  function handleClick() {
    setValue('X');
  }

  return (
    <button
      className="square"
      onClick={handleClick}
    >
      {value}
    </button>
  );
}

export default function Board() {
  return (
    <>
      <div className="board-row">
        <Square />
        <Square />
        <Square />
      </div>
      <div className="board-row">
        <Square />
        <Square />
        <Square />
      </div>
      <div className="board-row">
        <Square />
        <Square />
        <Square />
      </div>
    </>
  );
}
```

Show more

### React Developer Tools

React DevTools let you check the props and the state of your React components. You can find the React DevTools tab at the bottom of the *browser* section in CodeSandbox:

![React DevTools in CodeSandbox](https://react.dev/images/tutorial/codesandbox-devtools.png)

To inspect a particular component on the screen, use the button in the top left corner of React DevTools:

![Selecting components on the page with React DevTools](https://react.dev/images/tutorial/devtools-select.gif)

### Note

For local development, React DevTools is available as a [Chrome](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en), [Firefox](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/), and [Edge](https://microsoftedge.microsoft.com/addons/detail/react-developer-tools/gpphkfbcpidddadnkolkpfckpihlkkil) browser extension. Install it, and the *Components* tab will appear in your browser Developer Tools for sites using React.

## Completing the game

By this point, you have all the basic building blocks for your tic-tac-toe game. To have a complete game, you now need to alternate placing “X”s and “O”s on the board, and you need a way to determine a winner.

### Lifting state up

Currently, each `Square` component maintains a part of the game’s state. To check for a winner in a tic-tac-toe game, the `Board` would need to somehow know the state of each of the 9 `Square` components.

How would you approach that? At first, you might guess that the `Board` needs to “ask” each `Square` for that `Square`’s state. Although this approach is technically possible in React, we discourage it because the code becomes difficult to understand, susceptible to bugs, and hard to refactor. Instead, the best approach is to store the game’s state in the parent `Board` component instead of in each `Square`. The `Board` component can tell each `Square` what to display by passing a prop, like you did when you passed a number to each Square.

**To collect data from multiple children, or to have two child components communicate with each other, declare the shared state in their parent component instead. The parent component can pass that state back down to the children via props. This keeps the child components in sync with each other and with their parent.**

Lifting state into a parent component is common when React components are refactored.

Let’s take this opportunity to try it out. Edit the `Board` component so that it declares a state variable named `squares` that defaults to an array of 9 nulls corresponding to the 9 squares:

```
// ...

export default function Board() {

const [squares, setSquares] = useState(Array(9).fill(null));

return (

// ...

);

}
```

`Array(9).fill(null)` creates an array with nine elements and sets each of them to `null`. The `useState()` call around it declares a `squares` state variable that’s initially set to that array. Each entry in the array corresponds to the value of a square. When you fill the board in later, the `squares` array will look like this:

```
['O', null, 'X', 'X', 'X', 'O', 'O', null, null]
```

Now your `Board` component needs to pass the `value` prop down to each `Square` that it renders:

```
export default function Board() {

const [squares, setSquares] = useState(Array(9).fill(null));

return (

<>

<div className="board-row">

<Square value={squares[0]} />

<Square value={squares[1]} />

<Square value={squares[2]} />

</div>

<div className="board-row">

<Square value={squares[3]} />

<Square value={squares[4]} />

<Square value={squares[5]} />

</div>

<div className="board-row">

<Square value={squares[6]} />

<Square value={squares[7]} />

<Square value={squares[8]} />

</div>

</>

);

}
```

Next, you’ll edit the `Square` component to receive the `value` prop from the Board component. This will require removing the Square component’s own stateful tracking of `value` and the button’s `onClick` prop:

```
function Square({value}) {

return <button className="square">{value}</button>;

}
```

At this point you should see an empty tic-tac-toe board:

![empty board](https://react.dev/images/tutorial/empty-board.png)

And your code should look like this:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({ value }) {
  return <button className="square">{value}</button>;
}

export default function Board() {
  const [squares, setSquares] = useState(Array(9).fill(null));
  return (
    <>
      <div className="board-row">
        <Square value={squares[0]} />
        <Square value={squares[1]} />
        <Square value={squares[2]} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} />
        <Square value={squares[4]} />
        <Square value={squares[5]} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} />
        <Square value={squares[7]} />
        <Square value={squares[8]} />
      </div>
    </>
  );
}
```

Show more

Each Square will now receive a `value` prop that will either be `'X'`, `'O'`, or `null` for empty squares.

Next, you need to change what happens when a `Square` is clicked. The `Board` component now maintains which squares are filled. You’ll need to create a way for the `Square` to update the `Board`’s state. Since state is private to a component that defines it, you cannot update the `Board`’s state directly from `Square`.

Instead, you’ll pass down a function from the `Board` component to the `Square` component, and you’ll have `Square` call that function when a square is clicked. You’ll start with the function that the `Square` component will call when it is clicked. You’ll call that function `onSquareClick`:

```
function Square({ value }) {

return (

<button className="square" onClick={onSquareClick}>

{value}

</button>

);

}
```

Next, you’ll add the `onSquareClick` function to the `Square` component’s props:

```
function Square({ value, onSquareClick }) {

return (

<button className="square" onClick={onSquareClick}>

{value}

</button>

);

}
```

Now you’ll connect the `onSquareClick` prop to a function in the `Board` component that you’ll name `handleClick`. To connect `onSquareClick` to `handleClick` you’ll pass a function to the `onSquareClick` prop of the first `Square` component:

```
export default function Board() {

const [squares, setSquares] = useState(Array(9).fill(null));

return (

<>

<div className="board-row">

<Square value={squares[0]} onSquareClick={handleClick} />

//...

);

}
```

Lastly, you will define the `handleClick` function inside the Board component to update the `squares` array holding your board’s state:

```
export default function Board() {

const [squares, setSquares] = useState(Array(9).fill(null));

function handleClick() {

const nextSquares = squares.slice();

nextSquares[0] = "X";

setSquares(nextSquares);

}

return (

// ...

)

}
```

The `handleClick` function creates a copy of the `squares` array (`nextSquares`) with the JavaScript `slice()` Array method. Then, `handleClick` updates the `nextSquares` array to add `X` to the first (`[0]` index) square.

Calling the `setSquares` function lets React know the state of the component has changed. This will trigger a re-render of the components that use the `squares` state (`Board`) as well as its child components (the `Square` components that make up the board).

### Note

JavaScript supports [closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) which means an inner function (e.g. `handleClick`) has access to variables and functions defined in an outer function (e.g. `Board`). The `handleClick` function can read the `squares` state and call the `setSquares` method because they are both defined inside of the `Board` function.

Now you can add X’s to the board… but only to the upper left square. Your `handleClick` function is hardcoded to update the index for the upper left square (`0`). Let’s update `handleClick` to be able to update any square. Add an argument `i` to the `handleClick` function that takes the index of the square to update:

```
export default function Board() {

const [squares, setSquares] = useState(Array(9).fill(null));

function handleClick(i) {

const nextSquares = squares.slice();

nextSquares[i] = "X";

setSquares(nextSquares);

}

return (

// ...

)

}
```

Next, you will need to pass that `i` to `handleClick`. You could try to set the `onSquareClick` prop of square to be `handleClick(0)` directly in the JSX like this, but it won’t work:

```
<Square value={squares[0]} onSquareClick={handleClick(0)} />
```

Here is why this doesn’t work. The `handleClick(0)` call will be a part of rendering the board component. Because `handleClick(0)` alters the state of the board component by calling `setSquares`, your entire board component will be re-rendered again. But this runs `handleClick(0)` again, leading to an infinite loop:

Console

Too many re-renders. React limits the number of renders to prevent an infinite loop.

Why didn’t this problem happen earlier?

When you were passing `onSquareClick={handleClick}`, you were passing the `handleClick` function down as a prop. You were not calling it! But now you are *calling* that function right away—notice the parentheses in `handleClick(0)`—and that’s why it runs too early. You don’t *want* to call `handleClick` until the user clicks!

You could fix this by creating a function like `handleFirstSquareClick` that calls `handleClick(0)`, a function like `handleSecondSquareClick` that calls `handleClick(1)`, and so on. You would pass (rather than call) these functions down as props like `onSquareClick={handleFirstSquareClick}`. This would solve the infinite loop.

However, defining nine different functions and giving each of them a name is too verbose. Instead, let’s do this:

```
export default function Board() {

// ...

return (

<>

<div className="board-row">

<Square value={squares[0]} onSquareClick={() => handleClick(0)} />

// ...

);

}
```

Notice the new `() =>` syntax. Here, `() => handleClick(0)` is an *arrow function,* which is a shorter way to define functions. When the square is clicked, the code after the `=>` “arrow” will run, calling `handleClick(0)`.

Now you need to update the other eight squares to call `handleClick` from the arrow functions you pass. Make sure that the argument for each call of the `handleClick` corresponds to the index of the correct square:

```
export default function Board() {

// ...

return (

<>

<div className="board-row">

<Square value={squares[0]} onSquareClick={() => handleClick(0)} />

<Square value={squares[1]} onSquareClick={() => handleClick(1)} />

<Square value={squares[2]} onSquareClick={() => handleClick(2)} />

</div>

<div className="board-row">

<Square value={squares[3]} onSquareClick={() => handleClick(3)} />

<Square value={squares[4]} onSquareClick={() => handleClick(4)} />

<Square value={squares[5]} onSquareClick={() => handleClick(5)} />

</div>

<div className="board-row">

<Square value={squares[6]} onSquareClick={() => handleClick(6)} />

<Square value={squares[7]} onSquareClick={() => handleClick(7)} />

<Square value={squares[8]} onSquareClick={() => handleClick(8)} />

</div>

</>

);

};
```

Now you can again add X’s to any square on the board by clicking on them:

![filling the board with X](https://react.dev/images/tutorial/tictac-adding-x-s.gif)

But this time all the state management is handled by the `Board` component!

This is what your code should look like:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

export default function Board() {
  const [squares, setSquares] = useState(Array(9).fill(null));

  function handleClick(i) {
    const nextSquares = squares.slice();
    nextSquares[i] = 'X';
    setSquares(nextSquares);
  }

  return (
    <>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}
```

Show more

Now that your state handling is in the `Board` component, the parent `Board` component passes props to the child `Square` components so that they can be displayed correctly. When clicking on a `Square`, the child `Square` component now asks the parent `Board` component to update the state of the board. When the `Board`’s state changes, both the `Board` component and every child `Square` re-renders automatically. Keeping the state of all squares in the `Board` component will allow it to determine the winner in the future.

Let’s recap what happens when a user clicks the top left square on your board to add an `X` to it:

1. Clicking on the upper left square runs the function that the `button` received as its `onClick` prop from the `Square`. The `Square` component received that function as its `onSquareClick` prop from the `Board`. The `Board` component defined that function directly in the JSX. It calls `handleClick` with an argument of `0`.
2. `handleClick` uses the argument (`0`) to update the first element of the `squares` array from `null` to `X`.
3. The `squares` state of the `Board` component was updated, so the `Board` and all of its children re-render. This causes the `value` prop of the `Square` component with index `0` to change from `null` to `X`.

In the end the user sees that the upper left square has changed from empty to having an `X` after clicking it.

### Note

The DOM `<button>` element’s `onClick` attribute has a special meaning to React because it is a built-in component. For custom components like Square, the naming is up to you. You could give any name to the `Square`’s `onSquareClick` prop or `Board`’s `handleClick` function, and the code would work the same. In React, it’s conventional to use `onSomething` names for props which represent events and `handleSomething` for the function definitions which handle those events.

### Why immutability is important

Note how in `handleClick`, you call `.slice()` to create a copy of the `squares` array instead of modifying the existing array. To explain why, we need to discuss immutability and why immutability is important to learn.

There are generally two approaches to changing data. The first approach is to *mutate* the data by directly changing the data’s values. The second approach is to replace the data with a new copy which has the desired changes. Here is what it would look like if you mutated the `squares` array:

```
const squares = [null, null, null, null, null, null, null, null, null];

squares[0] = 'X';

// Now `squares` is ["X", null, null, null, null, null, null, null, null];
```

And here is what it would look like if you changed data without mutating the `squares` array:

```
const squares = [null, null, null, null, null, null, null, null, null];

const nextSquares = ['X', null, null, null, null, null, null, null, null];

// Now `squares` is unchanged, but `nextSquares` first element is 'X' rather than `null`
```

The result is the same but by not mutating (changing the underlying data) directly, you gain several benefits.

Immutability makes complex features much easier to implement. Later in this tutorial, you will implement a “time travel” feature that lets you review the game’s history and “jump back” to past moves. This functionality isn’t specific to games—an ability to undo and redo certain actions is a common requirement for apps. Avoiding direct data mutation lets you keep previous versions of the data intact, and reuse them later.

There is also another benefit of immutability. By default, all child components re-render automatically when the state of a parent component changes. This includes even the child components that weren’t affected by the change. Although re-rendering is not by itself noticeable to the user (you shouldn’t actively try to avoid it!), you might want to skip re-rendering a part of the tree that clearly wasn’t affected by it for performance reasons. Immutability makes it very cheap for components to compare whether their data has changed or not. You can learn more about how React chooses when to re-render a component in [the `memo` API reference](https://react.dev/reference/react/memo).

### Taking turns

It’s now time to fix a major defect in this tic-tac-toe game: the “O”s cannot be marked on the board.

You’ll set the first move to be “X” by default. Let’s keep track of this by adding another piece of state to the Board component:

```
function Board() {

const [xIsNext, setXIsNext] = useState(true);

const [squares, setSquares] = useState(Array(9).fill(null));

// ...

}
```

Each time a player moves, `xIsNext` (a boolean) will be flipped to determine which player goes next and the game’s state will be saved. You’ll update the `Board`’s `handleClick` function to flip the value of `xIsNext`:

```
export default function Board() {

const [xIsNext, setXIsNext] = useState(true);

const [squares, setSquares] = useState(Array(9).fill(null));

function handleClick(i) {

const nextSquares = squares.slice();

if (xIsNext) {

nextSquares[i] = "X";

} else {

nextSquares[i] = "O";

}

setSquares(nextSquares);

setXIsNext(!xIsNext);

}

return (

//...

);

}
```

Now, as you click on different squares, they will alternate between `X` and `O`, as they should!

But wait, there’s a problem. Try clicking on the same square multiple times:

![O overwriting an X](https://react.dev/images/tutorial/o-replaces-x.gif)

The `X` is overwritten by an `O`! While this would add a very interesting twist to the game, we’re going to stick to the original rules for now.

When you mark a square with an `X` or an `O` you aren’t first checking to see if the square already has an `X` or `O` value. You can fix this by *returning early*. You’ll check to see if the square already has an `X` or an `O`. If the square is already filled, you will `return` in the `handleClick` function early—before it tries to update the board state.

```
function handleClick(i) {

if (squares[i]) {

return;

}

const nextSquares = squares.slice();

//...

}
```

Now you can only add `X`’s or `O`’s to empty squares! Here is what your code should look like at this point:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({value, onSquareClick}) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

export default function Board() {
  const [xIsNext, setXIsNext] = useState(true);
  const [squares, setSquares] = useState(Array(9).fill(null));

  function handleClick(i) {
    if (squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    setSquares(nextSquares);
    setXIsNext(!xIsNext);
  }

  return (
    <>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}
```

Show more

### Declaring a winner

Now that the players can take turns, you’ll want to show when the game is won and there are no more turns to make. To do this you’ll add a helper function called `calculateWinner` that takes an array of 9 squares, checks for a winner and returns `'X'`, `'O'`, or `null` as appropriate. Don’t worry too much about the `calculateWinner` function; it’s not specific to React:

```
export default function Board() {

//...

}

function calculateWinner(squares) {

const lines = [

[0, 1, 2],

[3, 4, 5],

[6, 7, 8],

[0, 3, 6],

[1, 4, 7],

[2, 5, 8],

[0, 4, 8],

[2, 4, 6]

];

for (let i = 0; i < lines.length; i++) {

const [a, b, c] = lines[i];

if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {

return squares[a];

}

}

return null;

}
```

### Note

It does not matter whether you define `calculateWinner` before or after the `Board`. Let’s put it at the end so that you don’t have to scroll past it every time you edit your components.

You will call `calculateWinner(squares)` in the `Board` component’s `handleClick` function to check if a player has won. You can perform this check at the same time you check if a user has clicked a square that already has an `X` or an `O`. We’d like to return early in both cases:

```
function handleClick(i) {

if (squares[i] || calculateWinner(squares)) {

return;

}

const nextSquares = squares.slice();

//...

}
```

To let the players know when the game is over, you can display text such as “Winner: X” or “Winner: O”. To do that you’ll add a `status` section to the `Board` component. The status will display the winner if the game is over and if the game is ongoing you’ll display which player’s turn is next:

```
export default function Board() {

// ...

const winner = calculateWinner(squares);

let status;

if (winner) {

status = "Winner: " + winner;

} else {

status = "Next player: " + (xIsNext ? "X" : "O");

}

return (

<>

<div className="status">{status}</div>

<div className="board-row">

// ...

)

}
```

Congratulations! You now have a working tic-tac-toe game. And you’ve just learned the basics of React too. So *you* are the real winner here. Here is what the code should look like:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({value, onSquareClick}) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

export default function Board() {
  const [xIsNext, setXIsNext] = useState(true);
  const [squares, setSquares] = useState(Array(9).fill(null));

  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    setSquares(nextSquares);
    setXIsNext(!xIsNext);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}
```

Show more

## Adding time travel

As a final exercise, let’s make it possible to “go back in time” to the previous moves in the game.

### Storing a history of moves

If you mutated the `squares` array, implementing time travel would be very difficult.

However, you used `slice()` to create a new copy of the `squares` array after every move, and treated it as immutable. This will allow you to store every past version of the `squares` array, and navigate between the turns that have already happened.

You’ll store the past `squares` arrays in another array called `history`, which you’ll store as a new state variable. The `history` array represents all board states, from the first to the last move, and has a shape like this:

```
[

// Before first move

[null, null, null, null, null, null, null, null, null],

// After first move

[null, null, null, null, 'X', null, null, null, null],

// After second move

[null, null, null, null, 'X', null, null, null, 'O'],

// ...

]
```

### Lifting state up, again

You will now write a new top-level component called `Game` to display a list of past moves. That’s where you will place the `history` state that contains the entire game history.

Placing the `history` state into the `Game` component will let you remove the `squares` state from its child `Board` component. Just like you “lifted state up” from the `Square` component into the `Board` component, you will now lift it up from the `Board` into the top-level `Game` component. This gives the `Game` component full control over the `Board`’s data and lets it instruct the `Board` to render previous turns from the `history`.

First, add a `Game` component with `export default`. Have it render the `Board` component and some markup:

```
function Board() {

// ...

}

export default function Game() {

return (

<div className="game">

<div className="game-board">

<Board />

</div>

<div className="game-info">

<ol>{/*TODO*/}</ol>

</div>

</div>

);

}
```

Note that you are removing the `export default` keywords before the `function Board() {` declaration and adding them before the `function Game() {` declaration. This tells your `index.js` file to use the `Game` component as the top-level component instead of your `Board` component. The additional `div`s returned by the `Game` component are making room for the game information you’ll add to the board later.

Add some state to the `Game` component to track which player is next and the history of moves:

```
export default function Game() {

const [xIsNext, setXIsNext] = useState(true);

const [history, setHistory] = useState([Array(9).fill(null)]);

// ...
```

Notice how `[Array(9).fill(null)]` is an array with a single item, which itself is an array of 9 `null`s.

To render the squares for the current move, you’ll want to read the last squares array from the `history`. You don’t need `useState` for this—you already have enough information to calculate it during rendering:

```
export default function Game() {

const [xIsNext, setXIsNext] = useState(true);

const [history, setHistory] = useState([Array(9).fill(null)]);

const currentSquares = history[history.length - 1];

// ...
```

Next, create a `handlePlay` function inside the `Game` component that will be called by the `Board` component to update the game. Pass `xIsNext`, `currentSquares` and `handlePlay` as props to the `Board` component:

```
export default function Game() {

const [xIsNext, setXIsNext] = useState(true);

const [history, setHistory] = useState([Array(9).fill(null)]);

const currentSquares = history[history.length - 1];

function handlePlay(nextSquares) {

// TODO

}

return (

<div className="game">

<div className="game-board">

<Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />

//...

)

}
```

Let’s make the `Board` component fully controlled by the props it receives. Change the `Board` component to take three props: `xIsNext`, `squares`, and a new `onPlay` function that `Board` can call with the updated squares array when a player makes a move. Next, remove the first two lines of the `Board` function that call `useState`:

```
function Board({ xIsNext, squares, onPlay }) {

function handleClick(i) {

//...

}

// ...

}
```

Now replace the `setSquares` and `setXIsNext` calls in `handleClick` in the `Board` component with a single call to your new `onPlay` function so the `Game` component can update the `Board` when the user clicks a square:

```
function Board({ xIsNext, squares, onPlay }) {

function handleClick(i) {

if (calculateWinner(squares) || squares[i]) {

return;

}

const nextSquares = squares.slice();

if (xIsNext) {

nextSquares[i] = "X";

} else {

nextSquares[i] = "O";

}

onPlay(nextSquares);

}

//...

}
```

The `Board` component is fully controlled by the props passed to it by the `Game` component. You need to implement the `handlePlay` function in the `Game` component to get the game working again.

What should `handlePlay` do when called? Remember that Board used to call `setSquares` with an updated array; now it passes the updated `squares` array to `onPlay`.

The `handlePlay` function needs to update `Game`’s state to trigger a re-render, but you don’t have a `setSquares` function that you can call any more—you’re now using the `history` state variable to store this information. You’ll want to update `history` by appending the updated `squares` array as a new history entry. You also want to toggle `xIsNext`, just as Board used to do:

```
export default function Game() {

//...

function handlePlay(nextSquares) {

setHistory([...history, nextSquares]);

setXIsNext(!xIsNext);

}

//...

}
```

Here, `[...history, nextSquares]` creates a new array that contains all the items in `history`, followed by `nextSquares`. (You can read the `...history` [*spread syntax*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax) as “enumerate all the items in `history`”.)

For example, if `history` is `[[null,null,null], ["X",null,null]]` and `nextSquares` is `["X",null,"O"]`, then the new `[...history, nextSquares]` array will be `[[null,null,null], ["X",null,null], ["X",null,"O"]]`.

At this point, you’ve moved the state to live in the `Game` component, and the UI should be fully working, just as it was before the refactor. Here is what the code should look like at this point:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [xIsNext, setXIsNext] = useState(true);
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const currentSquares = history[history.length - 1];

  function handlePlay(nextSquares) {
    setHistory([...history, nextSquares]);
    setXIsNext(!xIsNext);
  }

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{/*TODO*/}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}
```

Show more

### Showing the past moves

Since you are recording the tic-tac-toe game’s history, you can now display a list of past moves to the player.

React elements like `<button>` are regular JavaScript objects; you can pass them around in your application. To render multiple items in React, you can use an array of React elements.

You already have an array of `history` moves in state, so now you need to transform it to an array of React elements. In JavaScript, to transform one array into another, you can use the [array `map` method:](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)

```
[1, 2, 3].map((x) => x * 2) // [2, 4, 6]
```

You’ll use `map` to transform your `history` of moves into React elements representing buttons on the screen, and display a list of buttons to “jump” to past moves. Let’s `map` over the `history` in the Game component:

```
export default function Game() {

const [xIsNext, setXIsNext] = useState(true);

const [history, setHistory] = useState([Array(9).fill(null)]);

const currentSquares = history[history.length - 1];

function handlePlay(nextSquares) {

setHistory([...history, nextSquares]);

setXIsNext(!xIsNext);

}

function jumpTo(nextMove) {

// TODO

}

const moves = history.map((squares, move) => {

let description;

if (move > 0) {

description = 'Go to move #' + move;

} else {

description = 'Go to game start';

}

return (

<li>

<button onClick={() => jumpTo(move)}>{description}</button>

</li>

);

});

return (

<div className="game">

<div className="game-board">

<Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />

</div>

<div className="game-info">

<ol>{moves}</ol>

</div>

</div>

);

}
```

You can see what your code should look like below. Note that you should see an error in the developer tools console that says:

Console

Warning: Each child in an array or iterator should have a unique “key” prop. Check the render method of `Game`.

You’ll fix this error in the next section.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [xIsNext, setXIsNext] = useState(true);
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const currentSquares = history[history.length - 1];

  function handlePlay(nextSquares) {
    setHistory([...history, nextSquares]);
    setXIsNext(!xIsNext);
  }

  function jumpTo(nextMove) {
    // TODO
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}
```

Show more

As you iterate through the `history` array inside the function you passed to `map`, the `squares` argument goes through each element of `history`, and the `move` argument goes through each array index: `0`, `1`, `2`, …. (In most cases, you’d need the actual array elements, but to render a list of moves you will only need indexes.)

For each move in the tic-tac-toe game’s history, you create a list item `<li>` which contains a button `<button>`. The button has an `onClick` handler which calls a function called `jumpTo` (that you haven’t implemented yet).

For now, you should see a list of the moves that occurred in the game and an error in the developer tools console. Let’s discuss what the “key” error means.

### Picking a key

When you render a list, React stores some information about each rendered list item. When you update a list, React needs to determine what has changed. You could have added, removed, re-arranged, or updated the list’s items.

Imagine transitioning from

```
<li>Alexa: 7 tasks left</li>

<li>Ben: 5 tasks left</li>
```

to

```
<li>Ben: 9 tasks left</li>

<li>Claudia: 8 tasks left</li>

<li>Alexa: 5 tasks left</li>
```

In addition to the updated counts, a human reading this would probably say that you swapped Alexa and Ben’s ordering and inserted Claudia between Alexa and Ben. However, React is a computer program and does not know what you intended, so you need to specify a *key* property for each list item to differentiate each list item from its siblings. If your data was from a database, Alexa, Ben, and Claudia’s database IDs could be used as keys.

```
<li key={user.id}>

{user.name}: {user.taskCount} tasks left

</li>
```

When a list is re-rendered, React takes each list item’s key and searches the previous list’s items for a matching key. If the current list has a key that didn’t exist before, React creates a component. If the current list is missing a key that existed in the previous list, React destroys the previous component. If two keys match, the corresponding component is moved.

Keys tell React about the identity of each component, which allows React to maintain state between re-renders. If a component’s key changes, the component will be destroyed and re-created with a new state.

`key` is a special and reserved property in React. When an element is created, React extracts the `key` property and stores the key directly on the returned element. Even though `key` may look like it is passed as props, React automatically uses `key` to decide which components to update. There’s no way for a component to ask what `key` its parent specified.

**It’s strongly recommended that you assign proper keys whenever you build dynamic lists.** If you don’t have an appropriate key, you may want to consider restructuring your data so that you do.

If no key is specified, React will report an error and use the array index as a key by default. Using the array index as a key is problematic when trying to re-order a list’s items or inserting/removing list items. Explicitly passing `key={i}` silences the error but has the same problems as array indices and is not recommended in most cases.

Keys do not need to be globally unique; they only need to be unique between components and their siblings.

### Implementing time travel

In the tic-tac-toe game’s history, each past move has a unique ID associated with it: it’s the sequential number of the move. Moves will never be re-ordered, deleted, or inserted in the middle, so it’s safe to use the move index as a key.

In the `Game` function, you can add the key as `<li key={move}>`, and if you reload the rendered game, React’s “key” error should disappear:

```
const moves = history.map((squares, move) => {

//...

return (

<li key={move}>

<button onClick={() => jumpTo(move)}>{description}</button>

</li>

);

});
```

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [xIsNext, setXIsNext] = useState(true);
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const currentSquares = history[history.length - 1];

  function handlePlay(nextSquares) {
    setHistory([...history, nextSquares]);
    setXIsNext(!xIsNext);
  }

  function jumpTo(nextMove) {
    // TODO
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li key={move}>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}
```

Show more

Before you can implement `jumpTo`, you need the `Game` component to keep track of which step the user is currently viewing. To do this, define a new state variable called `currentMove`, defaulting to `0`:

```
export default function Game() {

const [xIsNext, setXIsNext] = useState(true);

const [history, setHistory] = useState([Array(9).fill(null)]);

const [currentMove, setCurrentMove] = useState(0);

const currentSquares = history[history.length - 1];

//...

}
```

Next, update the `jumpTo` function inside `Game` to update that `currentMove`. You’ll also set `xIsNext` to `true` if the number that you’re changing `currentMove` to is even.

```
export default function Game() {

// ...

function jumpTo(nextMove) {

setCurrentMove(nextMove);

setXIsNext(nextMove % 2 === 0);

}

//...

}
```

You will now make two changes to the `Game`’s `handlePlay` function which is called when you click on a square.

* If you “go back in time” and then make a new move from that point, you only want to keep the history up to that point. Instead of adding `nextSquares` after all items (`...` spread syntax) in `history`, you’ll add it after all items in `history.slice(0, currentMove + 1)` so that you’re only keeping that portion of the old history.
* Each time a move is made, you need to update `currentMove` to point to the latest history entry.

```
function handlePlay(nextSquares) {

const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];

setHistory(nextHistory);

setCurrentMove(nextHistory.length - 1);

setXIsNext(!xIsNext);

}
```

Finally, you will modify the `Game` component to render the currently selected move, instead of always rendering the final move:

```
export default function Game() {

const [xIsNext, setXIsNext] = useState(true);

const [history, setHistory] = useState([Array(9).fill(null)]);

const [currentMove, setCurrentMove] = useState(0);

const currentSquares = history[currentMove];

// ...

}
```

If you click on any step in the game’s history, the tic-tac-toe board should immediately update to show what the board looked like after that step occurred.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({value, onSquareClick}) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [xIsNext, setXIsNext] = useState(true);
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const [currentMove, setCurrentMove] = useState(0);
  const currentSquares = history[currentMove];

  function handlePlay(nextSquares) {
    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];
    setHistory(nextHistory);
    setCurrentMove(nextHistory.length - 1);
    setXIsNext(!xIsNext);
  }

  function jumpTo(nextMove) {
    setCurrentMove(nextMove);
    setXIsNext(nextMove % 2 === 0);
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li key={move}>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}
```

Show more

### Final cleanup

If you look at the code very closely, you may notice that `xIsNext === true` when `currentMove` is even and `xIsNext === false` when `currentMove` is odd. In other words, if you know the value of `currentMove`, then you can always figure out what `xIsNext` should be.

There’s no reason for you to store both of these in state. In fact, always try to avoid redundant state. Simplifying what you store in state reduces bugs and makes your code easier to understand. Change `Game` so that it doesn’t store `xIsNext` as a separate state variable and instead figures it out based on the `currentMove`:

```
export default function Game() {

const [history, setHistory] = useState([Array(9).fill(null)]);

const [currentMove, setCurrentMove] = useState(0);

const xIsNext = currentMove % 2 === 0;

const currentSquares = history[currentMove];

function handlePlay(nextSquares) {

const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];

setHistory(nextHistory);

setCurrentMove(nextHistory.length - 1);

}

function jumpTo(nextMove) {

setCurrentMove(nextMove);

}

// ...

}
```

You no longer need the `xIsNext` state declaration or the calls to `setXIsNext`. Now, there’s no chance for `xIsNext` to get out of sync with `currentMove`, even if you make a mistake while coding the components.

### Wrapping up

Congratulations! You’ve created a tic-tac-toe game that:

* Lets you play tic-tac-toe,
* Indicates when a player has won the game,
* Stores a game’s history as a game progresses,
* Allows players to review a game’s history and see previous versions of a game’s board.

Nice work! We hope you now feel like you have a decent grasp of how React works.

Check out the final result here:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const [currentMove, setCurrentMove] = useState(0);
  const xIsNext = currentMove % 2 === 0;
  const currentSquares = history[currentMove];

  function handlePlay(nextSquares) {
    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];
    setHistory(nextHistory);
    setCurrentMove(nextHistory.length - 1);
  }

  function jumpTo(nextMove) {
    setCurrentMove(nextMove);
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li key={move}>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}
```

Show more

If you have extra time or want to practice your new React skills, here are some ideas for improvements that you could make to the tic-tac-toe game, listed in order of increasing difficulty:

1. For the current move only, show “You are at move #…” instead of a button.
2. Rewrite `Board` to use two loops to make the squares instead of hardcoding them.
3. Add a toggle button that lets you sort the moves in either ascending or descending order.
4. When someone wins, highlight the three squares that caused the win (and when no one wins, display a message about the result being a draw).
5. Display the location for each move in the format (row, col) in the move history list.

Throughout this tutorial, you’ve touched on React concepts including elements, components, props, and state. Now that you’ve seen how these concepts work when building a game, check out [Thinking in React](https://react.dev/learn/thinking-in-react) to see how the same React concepts work when building an app’s UI.

[PreviousQuick Start](https://react.dev/learn)[NextThinking in React](https://react.dev/learn/thinking-in-react)

---

---


# Thinking in React – React

URL: https://react.dev/learn/thinking-in-react

[Learn React](https://react.dev/learn)

[Quick Start](https://react.dev/learn)

# Thinking in React

React can change how you think about the designs you look at and the apps you build. When you build a user interface with React, you will first break it apart into pieces called *components*. Then, you will describe the different visual states for each of your components. Finally, you will connect your components together so that the data flows through them. In this tutorial, we’ll guide you through the thought process of building a searchable product data table with React.

## Start with the mockup

Imagine that you already have a JSON API and a mockup from a designer.

The JSON API returns some data that looks like this:

```
[

{ category: "Fruits", price: "$1", stocked: true, name: "Apple" },

{ category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit" },

{ category: "Fruits", price: "$2", stocked: false, name: "Passionfruit" },

{ category: "Vegetables", price: "$2", stocked: true, name: "Spinach" },

{ category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin" },

{ category: "Vegetables", price: "$1", stocked: true, name: "Peas" }

]
```

The mockup looks like this:

![](https://react.dev/images/docs/s_thinking-in-react_ui.png)

To implement a UI in React, you will usually follow the same five steps.

## Step 1: Break the UI into a component hierarchy

Start by drawing boxes around every component and subcomponent in the mockup and naming them. If you work with a designer, they may have already named these components in their design tool. Ask them!

Depending on your background, you can think about splitting up a design into components in different ways:

* **Programming**—use the same techniques for deciding if you should create a new function or object. One such technique is the [separation of concerns](https://en.wikipedia.org/wiki/Separation_of_concerns), that is, a component should ideally only be concerned with one thing. If it ends up growing, it should be decomposed into smaller subcomponents.
* **CSS**—consider what you would make class selectors for. (However, components are a bit less granular.)
* **Design**—consider how you would organize the design’s layers.

If your JSON is well-structured, you’ll often find that it naturally maps to the component structure of your UI. That’s because UI and data models often have the same information architecture—that is, the same shape. Separate your UI into components, where each component matches one piece of your data model.

There are five components on this screen:

![](https://react.dev/images/docs/s_thinking-in-react_ui_outline.png)

1. `FilterableProductTable` (grey) contains the entire app.
2. `SearchBar` (blue) receives the user input.
3. `ProductTable` (lavender) displays and filters the list according to the user input.
4. `ProductCategoryRow` (green) displays a heading for each category.
5. `ProductRow` (yellow) displays a row for each product.

If you look at `ProductTable` (lavender), you’ll see that the table header (containing the “Name” and “Price” labels) isn’t its own component. This is a matter of preference, and you could go either way. For this example, it is a part of `ProductTable` because it appears inside the `ProductTable`’s list. However, if this header grows to be complex (e.g., if you add sorting), you can move it into its own `ProductTableHeader` component.

Now that you’ve identified the components in the mockup, arrange them into a hierarchy. Components that appear within another component in the mockup should appear as a child in the hierarchy:

* `FilterableProductTable`
  + `SearchBar`
  + `ProductTable`
    - `ProductCategoryRow`
    - `ProductRow`

## Step 2: Build a static version in React

Now that you have your component hierarchy, it’s time to implement your app. The most straightforward approach is to build a version that renders the UI from your data model without adding any interactivity… yet! It’s often easier to build the static version first and add interactivity later. Building a static version requires a lot of typing and no thinking, but adding interactivity requires a lot of thinking and not a lot of typing.

To build a static version of your app that renders your data model, you’ll want to build [components](https://react.dev/learn/your-first-component) that reuse other components and pass data using [props.](https://react.dev/learn/passing-props-to-a-component) Props are a way of passing data from parent to child. (If you’re familiar with the concept of [state](https://react.dev/learn/state-a-components-memory), don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it.)

You can either build “top down” by starting with building the components higher up in the hierarchy (like `FilterableProductTable`) or “bottom up” by working from components lower down (like `ProductRow`). In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function ProductCategoryRow({ category }) {
  return (
    <tr>
      <th colSpan="2">
        {category}
      </th>
    </tr>
  );
}

function ProductRow({ product }) {
  const name = product.stocked ? product.name :
    <span style={{ color: 'red' }}>
      {product.name}
    </span>;

  return (
    <tr>
      <td>{name}</td>
      <td>{product.price}</td>
    </tr>
  );
}

function ProductTable({ products }) {
  const rows = [];
  let lastCategory = null;

  products.forEach((product) => {
    if (product.category !== lastCategory) {
      rows.push(
        <ProductCategoryRow
          category={product.category}
          key={product.category} />
      );
    }
    rows.push(
      <ProductRow
        product={product}
        key={product.name} />
    );
    lastCategory = product.category;
  });

  return (
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Price</th>
        </tr>
      </thead>
      <tbody>{rows}</tbody>
    </table>
  );
}

function SearchBar() {
  return (
    <form>
      <input type="text" placeholder="Search..." />
      <label>
        <input type="checkbox" />
        {' '}
        Only show products in stock
      </label>
    </form>
  );
}

function FilterableProductTable({ products }) {
  return (
    <div>
      <SearchBar />
      <ProductTable products={products} />
    </div>
  );
}

const PRODUCTS = [
  {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
  {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
  {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
  {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
  {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
  {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
];

export default function App() {
  return <FilterableProductTable products={PRODUCTS} />;
}
```

Show more

(If this code looks intimidating, go through the [Quick Start](https://react.dev/learn) first!)

After building your components, you’ll have a library of reusable components that render your data model. Because this is a static app, the components will only return JSX. The component at the top of the hierarchy (`FilterableProductTable`) will take your data model as a prop. This is called *one-way data flow* because the data flows down from the top-level component to the ones at the bottom of the tree.

### Pitfall

At this point, you should not be using any state values. That’s for the next step!

## Step 3: Find the minimal but complete representation of UI state

To make the UI interactive, you need to let users change your underlying data model. You will use *state* for this.

Think of state as the minimal set of changing data that your app needs to remember. The most important principle for structuring state is to keep it [DRY (Don’t Repeat Yourself).](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) Figure out the absolute minimal representation of the state your application needs and compute everything else on-demand. For example, if you’re building a shopping list, you can store the items as an array in state. If you want to also display the number of items in the list, don’t store the number of items as another state value—instead, read the length of your array.

Now think of all of the pieces of data in this example application:

1. The original list of products
2. The search text the user has entered
3. The value of the checkbox
4. The filtered list of products

Which of these are state? Identify the ones that are not:

* Does it **remain unchanged** over time? If so, it isn’t state.
* Is it **passed in from a parent** via props? If so, it isn’t state.
* **Can you compute it** based on existing state or props in your component? If so, it *definitely* isn’t state!

What’s left is probably state.

Let’s go through them one by one again:

1. The original list of products is **passed in as props, so it’s not state.**
2. The search text seems to be state since it changes over time and can’t be computed from anything.
3. The value of the checkbox seems to be state since it changes over time and can’t be computed from anything.
4. The filtered list of products **isn’t state because it can be computed** by taking the original list of products and filtering it according to the search text and value of the checkbox.

This means only the search text and the value of the checkbox are state! Nicely done!

##### Deep Dive

#### Props vs State

Show Details

There are two types of “model” data in React: props and state. The two are very different:

* [**Props** are like arguments you pass](https://react.dev/learn/passing-props-to-a-component) to a function. They let a parent component pass data to a child component and customize its appearance. For example, a `Form` can pass a `color` prop to a `Button`.
* [**State** is like a component’s memory.](https://react.dev/learn/state-a-components-memory) It lets a component keep track of some information and change it in response to interactions. For example, a `Button` might keep track of `isHovered` state.

Props and state are different, but they work together. A parent component will often keep some information in state (so that it can change it), and *pass it down* to child components as their props. It’s okay if the difference still feels fuzzy on the first read. It takes a bit of practice for it to really stick!

## Step 4: Identify where your state should live

After identifying your app’s minimal state data, you need to identify which component is responsible for changing this state, or *owns* the state. Remember: React uses one-way data flow, passing data down the component hierarchy from parent to child component. It may not be immediately clear which component should own what state. This can be challenging if you’re new to this concept, but you can figure it out by following these steps!

For each piece of state in your application:

1. Identify *every* component that renders something based on that state.
2. Find their closest common parent component—a component above them all in the hierarchy.
3. Decide where the state should live:
   1. Often, you can put the state directly into their common parent.
   2. You can also put the state into some component above their common parent.
   3. If you can’t find a component where it makes sense to own the state, create a new component solely for holding the state and add it somewhere in the hierarchy above the common parent component.

In the previous step, you found two pieces of state in this application: the search input text, and the value of the checkbox. In this example, they always appear together, so it makes sense to put them into the same place.

Now let’s run through our strategy for them:

1. **Identify components that use state:**
   * `ProductTable` needs to filter the product list based on that state (search text and checkbox value).
   * `SearchBar` needs to display that state (search text and checkbox value).
2. **Find their common parent:** The first parent component both components share is `FilterableProductTable`.
3. **Decide where the state lives**: We’ll keep the filter text and checked state values in `FilterableProductTable`.

So the state values will live in `FilterableProductTable`.

Add state to the component with the [`useState()` Hook.](https://react.dev/reference/react/useState) Hooks are special functions that let you “hook into” React. Add two state variables at the top of `FilterableProductTable` and specify their initial state:

```
function FilterableProductTable({ products }) {

const [filterText, setFilterText] = useState('');

const [inStockOnly, setInStockOnly] = useState(false);
```

Then, pass `filterText` and `inStockOnly` to `ProductTable` and `SearchBar` as props:

```
<div>

<SearchBar

filterText={filterText}

inStockOnly={inStockOnly} />

<ProductTable

products={products}

filterText={filterText}

inStockOnly={inStockOnly} />

</div>
```

You can start seeing how your application will behave. Edit the `filterText` initial value from `useState('')` to `useState('fruit')` in the sandbox code below. You’ll see both the search input text and the table update:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function FilterableProductTable({ products }) {
  const [filterText, setFilterText] = useState('');
  const [inStockOnly, setInStockOnly] = useState(false);

  return (
    <div>
      <SearchBar 
        filterText={filterText} 
        inStockOnly={inStockOnly} />
      <ProductTable 
        products={products}
        filterText={filterText}
        inStockOnly={inStockOnly} />
    </div>
  );
}

function ProductCategoryRow({ category }) {
  return (
    <tr>
      <th colSpan="2">
        {category}
      </th>
    </tr>
  );
}

function ProductRow({ product }) {
  const name = product.stocked ? product.name :
    <span style={{ color: 'red' }}>
      {product.name}
    </span>;

  return (
    <tr>
      <td>{name}</td>
      <td>{product.price}</td>
    </tr>
  );
}

function ProductTable({ products, filterText, inStockOnly }) {
  const rows = [];
  let lastCategory = null;

  products.forEach((product) => {
    if (
      product.name.toLowerCase().indexOf(
        filterText.toLowerCase()
      ) === -1
    ) {
      return;
    }
    if (inStockOnly && !product.stocked) {
      return;
    }
    if (product.category !== lastCategory) {
      rows.push(
        <ProductCategoryRow
          category={product.category}
          key={product.category} />
      );
    }
    rows.push(
      <ProductRow
        product={product}
        key={product.name} />
    );
    lastCategory = product.category;
  });

  return (
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Price</th>
        </tr>
      </thead>
      <tbody>{rows}</tbody>
    </table>
  );
}

function SearchBar({ filterText, inStockOnly }) {
  return (
    <form>
      <input 
        type="text" 
        value={filterText} 
        placeholder="Search..."/>
      <label>
        <input 
          type="checkbox" 
          checked={inStockOnly} />
        {' '}
        Only show products in stock
      </label>
    </form>
  );
}

const PRODUCTS = [
  {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
  {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
  {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
  {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
  {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
  {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
];

export default function App() {
  return <FilterableProductTable products={PRODUCTS} />;
}
```

Show more

Notice that editing the form doesn’t work yet. There is a console error in the sandbox above explaining why:

Console

You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field.

In the sandbox above, `ProductTable` and `SearchBar` read the `filterText` and `inStockOnly` props to render the table, the input, and the checkbox. For example, here is how `SearchBar` populates the input value:

```
function SearchBar({ filterText, inStockOnly }) {

return (

<form>

<input

type="text"

value={filterText}

placeholder="Search..."/>
```

However, you haven’t added any code to respond to the user actions like typing yet. This will be your final step.

## Step 5: Add inverse data flow

Currently your app renders correctly with props and state flowing down the hierarchy. But to change the state according to user input, you will need to support data flowing the other way: the form components deep in the hierarchy need to update the state in `FilterableProductTable`.

React makes this data flow explicit, but it requires a little more typing than two-way data binding. If you try to type or check the box in the example above, you’ll see that React ignores your input. This is intentional. By writing `<input value={filterText} />`, you’ve set the `value` prop of the `input` to always be equal to the `filterText` state passed in from `FilterableProductTable`. Since `filterText` state is never set, the input never changes.

You want to make it so whenever the user changes the form inputs, the state updates to reflect those changes. The state is owned by `FilterableProductTable`, so only it can call `setFilterText` and `setInStockOnly`. To let `SearchBar` update the `FilterableProductTable`’s state, you need to pass these functions down to `SearchBar`:

```
function FilterableProductTable({ products }) {

const [filterText, setFilterText] = useState('');

const [inStockOnly, setInStockOnly] = useState(false);

return (

<div>

<SearchBar

filterText={filterText}

inStockOnly={inStockOnly}

onFilterTextChange={setFilterText}

onInStockOnlyChange={setInStockOnly} />
```

Inside the `SearchBar`, you will add the `onChange` event handlers and set the parent state from them:

```
function SearchBar({

filterText,

inStockOnly,

onFilterTextChange,

onInStockOnlyChange

}) {

return (

<form>

<input

type="text"

value={filterText}

placeholder="Search..."

onChange={(e) => onFilterTextChange(e.target.value)}

/>

<label>

<input

type="checkbox"

checked={inStockOnly}

onChange={(e) => onInStockOnlyChange(e.target.checked)}
```

Now the application fully works!

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function FilterableProductTable({ products }) {
  const [filterText, setFilterText] = useState('');
  const [inStockOnly, setInStockOnly] = useState(false);

  return (
    <div>
      <SearchBar 
        filterText={filterText} 
        inStockOnly={inStockOnly} 
        onFilterTextChange={setFilterText} 
        onInStockOnlyChange={setInStockOnly} />
      <ProductTable 
        products={products} 
        filterText={filterText}
        inStockOnly={inStockOnly} />
    </div>
  );
}

function ProductCategoryRow({ category }) {
  return (
    <tr>
      <th colSpan="2">
        {category}
      </th>
    </tr>
  );
}

function ProductRow({ product }) {
  const name = product.stocked ? product.name :
    <span style={{ color: 'red' }}>
      {product.name}
    </span>;

  return (
    <tr>
      <td>{name}</td>
      <td>{product.price}</td>
    </tr>
  );
}

function ProductTable({ products, filterText, inStockOnly }) {
  const rows = [];
  let lastCategory = null;

  products.forEach((product) => {
    if (
      product.name.toLowerCase().indexOf(
        filterText.toLowerCase()
      ) === -1
    ) {
      return;
    }
    if (inStockOnly && !product.stocked) {
      return;
    }
    if (product.category !== lastCategory) {
      rows.push(
        <ProductCategoryRow
          category={product.category}
          key={product.category} />
      );
    }
    rows.push(
      <ProductRow
        product={product}
        key={product.name} />
    );
    lastCategory = product.category;
  });

  return (
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Price</th>
        </tr>
      </thead>
      <tbody>{rows}</tbody>
    </table>
  );
}

function SearchBar({
  filterText,
  inStockOnly,
  onFilterTextChange,
  onInStockOnlyChange
}) {
  return (
    <form>
      <input 
        type="text" 
        value={filterText} placeholder="Search..." 
        onChange={(e) => onFilterTextChange(e.target.value)} />
      <label>
        <input 
          type="checkbox" 
          checked={inStockOnly} 
          onChange={(e) => onInStockOnlyChange(e.target.checked)} />
        {' '}
        Only show products in stock
      </label>
    </form>
  );
}

const PRODUCTS = [
  {category: "Fruits", price: "$1", stocked: true, name: "Apple"},
  {category: "Fruits", price: "$1", stocked: true, name: "Dragonfruit"},
  {category: "Fruits", price: "$2", stocked: false, name: "Passionfruit"},
  {category: "Vegetables", price: "$2", stocked: true, name: "Spinach"},
  {category: "Vegetables", price: "$4", stocked: false, name: "Pumpkin"},
  {category: "Vegetables", price: "$1", stocked: true, name: "Peas"}
];

export default function App() {
  return <FilterableProductTable products={PRODUCTS} />;
}
```

Show more

You can learn all about handling events and updating state in the [Adding Interactivity](https://react.dev/learn/adding-interactivity) section.

## Where to go from here

This was a very brief introduction to how to think about building components and applications with React. You can [start a React project](https://react.dev/learn/installation) right now or [dive deeper on all the syntax](https://react.dev/learn/describing-the-ui) used in this tutorial.

[PreviousTutorial: Tic-Tac-Toe](https://react.dev/learn/tutorial-tic-tac-toe)[NextInstallation](https://react.dev/learn/installation)

---

---


# Installation – React

URL: https://react.dev/learn/installation

[Learn React](https://react.dev/learn)

# Installation

React has been designed from the start for gradual adoption. You can use as little or as much React as you need. Whether you want to get a taste of React, add some interactivity to an HTML page, or start a complex React-powered app, this section will help you get started.

## Try React

You don’t need to install anything to play with React. Try editing this sandbox!

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Greeting({ name }) {
  return <h1>Hello, {name}</h1>;
}

export default function App() {
  return <Greeting name="world" />
}
```

You can edit it directly or open it in a new tab by pressing the “Fork” button in the upper right corner.

Most pages in the React documentation contain sandboxes like this. Outside of the React documentation, there are many online sandboxes that support React: for example, [CodeSandbox](https://codesandbox.io/s/new), [StackBlitz](https://stackblitz.com/fork/react), or [CodePen.](https://codepen.io/pen?template=QWYVwWN)

To try React locally on your computer, [download this HTML page.](https://gist.githubusercontent.com/gaearon/0275b1e1518599bbeafcde4722e79ed1/raw/db72dcbf3384ee1708c4a07d3be79860db04bff0/example.html) Open it in your editor and in your browser!

## Creating a React App

If you want to start a new React app, you can [create a React app](https://react.dev/learn/creating-a-react-app) using a recommended framework.

## Build a React App from Scratch

If a framework is not a good fit for your project, you prefer to build your own framework, or you just want to learn the basics of a React app you can [build a React app from scratch](https://react.dev/learn/build-a-react-app-from-scratch).

## Add React to an existing project

If want to try using React in your existing app or a website, you can [add React to an existing project.](https://react.dev/learn/add-react-to-an-existing-project)

### Note

#### Should I use Create React App?

No. Create React App has been deprecated. For more information, see [Sunsetting Create React App](https://react.dev/blog/2025/02/14/sunsetting-create-react-app).

## Next steps

Head to the [Quick Start](https://react.dev/learn) guide for a tour of the most important React concepts you will encounter every day.

[PreviousThinking in React](https://react.dev/learn/thinking-in-react)[NextCreating a React App](https://react.dev/learn/creating-a-react-app)

---

---


# Creating a React App – React

URL: https://react.dev/learn/creating-a-react-app

[Learn React](https://react.dev/learn)

[Installation](https://react.dev/learn/installation)

# Creating a React App

If you want to build a new app or website with React, we recommend starting with a framework.

If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can [build a React app from scratch](https://react.dev/learn/build-a-react-app-from-scratch).

## Full-stack frameworks

These recommended frameworks support all the features you need to deploy and scale your app in production. They have integrated the latest React features and take advantage of React’s architecture.

### Note

#### Full-stack frameworks do not require a server.

All the frameworks on this page support client-side rendering ([CSR](https://developer.mozilla.org/en-US/docs/Glossary/CSR)), single-page apps ([SPA](https://developer.mozilla.org/en-US/docs/Glossary/SPA)), and static-site generation ([SSG](https://developer.mozilla.org/en-US/docs/Glossary/SSG)). These apps can be deployed to a [CDN](https://developer.mozilla.org/en-US/docs/Glossary/CDN) or static hosting service without a server. Additionally, these frameworks allow you to add server-side rendering on a per-route basis, when it makes sense for your use case.

This allows you to start with a client-only app, and if your needs change later, you can opt-in to using server features on individual routes without rewriting your app. See your framework’s documentation for configuring the rendering strategy.

### Next.js (App Router)

**[Next.js’s App Router](https://nextjs.org/docs) is a React framework that takes full advantage of React’s architecture to enable full-stack React apps.**

Terminal

Copy

```
npx create-next-app@latest
```

Next.js is maintained by [Vercel](https://vercel.com/). You can [deploy a Next.js app](https://nextjs.org/docs/app/building-your-application/deploying) to any hosting provider that supports Node.js or Docker containers, or to your own server. Next.js also supports [static export](https://nextjs.org/docs/app/building-your-application/deploying/static-exports) which doesn’t require a server.

### React Router (v7)

**[React Router](https://reactrouter.com/start/framework/installation) is the most popular routing library for React and can be paired with Vite to create a full-stack React framework**. It emphasizes standard Web APIs and has several [ready to deploy templates](https://github.com/remix-run/react-router-templates) for various JavaScript runtimes and platforms.

To create a new React Router framework project, run:

Terminal

Copy

```
npx create-react-router@latest
```

React Router is maintained by [Shopify](https://www.shopify.com).

### Expo (for native apps)

**[Expo](https://expo.dev/) is a React framework that lets you create universal Android, iOS, and web apps with truly native UIs.** It provides an SDK for [React Native](https://reactnative.dev/) that makes the native parts easier to use. To create a new Expo project, run:

Terminal

Copy

```
npx create-expo-app@latest
```

If you’re new to Expo, check out the [Expo tutorial](https://docs.expo.dev/tutorial/introduction/).

Expo is maintained by [Expo (the company)](https://expo.dev/about). Building apps with Expo is free, and you can submit them to the Google and Apple app stores without restrictions. Expo additionally provides opt-in paid cloud services.

## Other frameworks

There are other up-and-coming frameworks that are working towards our full stack React vision:

* [TanStack Start (Beta)](https://tanstack.com/start/): TanStack Start is a full-stack React framework powered by TanStack Router. It provides a full-document SSR, streaming, server functions, bundling, and more using tools like Nitro and Vite.
* [RedwoodSDK](https://rwsdk.com/): Redwood is a full stack React framework with lots of pre-installed packages and configuration that makes it easy to build full-stack web applications.

##### Deep Dive

#### Which features make up the React team’s full-stack architecture vision?

Show Details

Next.js’s App Router bundler fully implements the official [React Server Components specification](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md). This lets you mix build-time, server-only, and interactive components in a single React tree.

For example, you can write a server-only React component as an `async` function that reads from a database or from a file. Then you can pass data down from it to your interactive components:

```
// This component runs *only* on the server (or during the build).

async function Talks({ confId }) {

// 1. You're on the server, so you can talk to your data layer. API endpoint not required.

const talks = await db.Talks.findAll({ confId });

// 2. Add any amount of rendering logic. It won't make your JavaScript bundle larger.

const videos = talks.map(talk => talk.video);

// 3. Pass the data down to the components that will run in the browser.

return <SearchableVideoList videos={videos} />;

}
```

Next.js’s App Router also integrates [data fetching with Suspense](https://react.dev/blog/2022/03/29/react-v18#suspense-in-data-frameworks). This lets you specify a loading state (like a skeleton placeholder) for different parts of your user interface directly in your React tree:

```
<Suspense fallback={<TalksLoading />}>

<Talks confId={conf.id} />

</Suspense>
```

Server Components and Suspense are React features rather than Next.js features. However, adopting them at the framework level requires buy-in and non-trivial implementation work. At the moment, the Next.js App Router is the most complete implementation. The React team is working with bundler developers to make these features easier to implement in the next generation of frameworks.

## Start From Scratch

If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, there are other options available for starting a React project from scratch.

Starting from scratch gives you more flexibility, but does require that you make choices on which tools to use for routing, data fetching, and other common usage patterns. It’s a lot like building your own framework, instead of using a framework that already exists. The [frameworks we recommend](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) have built-in solutions for these problems.

If you want to build your own solutions, see our guide to [build a React app from Scratch](https://react.dev/learn/build-a-react-app-from-scratch) for instructions on how to set up a new React project starting with a build tool like [Vite](https://vite.dev/), [Parcel](https://parceljs.org/), or [RSbuild](https://rsbuild.dev/).

---

*If you’re a framework author interested in being included on this page, [please let us know](https://github.com/reactjs/react.dev/issues/new?assignees=&labels=type%3A+framework&projects=&template=3-framework.yml&title=%5BFramework%5D%3A+).*

[PreviousInstallation](https://react.dev/learn/installation)[NextBuild a React App from Scratch](https://react.dev/learn/build-a-react-app-from-scratch)

---

---


# Build a React app from Scratch – React

URL: https://react.dev/learn/build-a-react-app-from-scratch

[Learn React](https://react.dev/learn)

[Installation](https://react.dev/learn/installation)

# Build a React app from Scratch

If your app has constraints not well-served by existing frameworks, you prefer to build your own framework, or you just want to learn the basics of a React app, you can build a React app from scratch.

##### Deep Dive

#### Consider using a framework

Show Details

Starting from scratch is an easy way to get started using React, but a major tradeoff to be aware of is that going this route is often the same as building your own adhoc framework. As your requirements evolve, you may need to solve more framework-like problems that our recommended frameworks already have well developed and supported solutions for.

For example, if in the future your app needs support for server-side rendering (SSR), static site generation (SSG), and/or React Server Components (RSC), you will have to implement those on your own. Similarly, future React features that require integrating at the framework level will have to be implemented on your own if you want to use them.

Our recommended frameworks also help you build better performing apps. For example, reducing or eliminating waterfalls from network requests makes for a better user experience. This might not be a high priority when you are building a toy project, but if your app gains users you may want to improve its performance.

Going this route also makes it more difficult to get support, since the way you develop routing, data-fetching, and other features will be unique to your situation. You should only choose this option if you are comfortable tackling these problems on your own, or if you’re confident that you will never need these features.

For a list of recommended frameworks, check out [Creating a React App](https://react.dev/learn/creating-a-react-app).

## Step 1: Install a build tool

The first step is to install a build tool like `vite`, `parcel`, or `rsbuild`. These build tools provide features to package and run source code, provide a development server for local development and a build command to deploy your app to a production server.

### Vite

[Vite](https://vite.dev/) is a build tool that aims to provide a faster and leaner development experience for modern web projects.

Terminal

Copy

```
npm create vite@latest my-app -- --template react-ts
```

Vite is opinionated and comes with sensible defaults out of the box. Vite has a rich ecosystem of plugins to support fast refresh, JSX, Babel/SWC, and other common features. See Vite’s [React plugin](https://vite.dev/plugins/#vitejs-plugin-react) or [React SWC plugin](https://vite.dev/plugins/#vitejs-plugin-react-swc) and [React SSR example project](https://vite.dev/guide/ssr.html#example-projects) to get started.

Vite is already being used as a build tool in one of our [recommended frameworks](https://react.dev/learn/creating-a-react-app): [React Router](https://reactrouter.com/start/framework/installation).

### Parcel

[Parcel](https://parceljs.org/) combines a great out-of-the-box development experience with a scalable architecture that can take your project from just getting started to massive production applications.

Terminal

Copy

```
npm install --save-dev parcel
```

Parcel supports fast refresh, JSX, TypeScript, Flow, and styling out of the box. See [Parcel’s React recipe](https://parceljs.org/recipes/react/#getting-started) to get started.

### Rsbuild

[Rsbuild](https://rsbuild.dev/) is an Rspack-powered build tool that provides a seamless development experience for React applications. It comes with carefully tuned defaults and performance optimizations ready to use.

Terminal

Copy

```
npx create-rsbuild --template react
```

Rsbuild includes built-in support for React features like fast refresh, JSX, TypeScript, and styling. See [Rsbuild’s React guide](https://rsbuild.dev/guide/framework/react) to get started.

### Note

#### Metro for React Native

If you’re starting from scratch with React Native you’ll need to use [Metro](https://metrobundler.dev/), the JavaScript bundler for React Native. Metro supports bundling for platforms like iOS and Android, but lacks many features when compared to the tools here. We recommend starting with Vite, Parcel, or Rsbuild unless your project requires React Native support.

## Step 2: Build Common Application Patterns

The build tools listed above start off with a client-only, single-page app (SPA), but don’t include any further solutions for common functionality like routing, data fetching, or styling.

The React ecosystem includes many tools for these problems. We’ve listed a few that are widely used as a starting point, but feel free to choose other tools if those work better for you.

### Routing

Routing determines what content or pages to display when a user visits a particular URL. You need to set up a router to map URLs to different parts of your app. You’ll also need to handle nested routes, route parameters, and query parameters. Routers can be configured within your code, or defined based on your component folder and file structures.

Routers are a core part of modern applications, and are usually integrated with data fetching (including prefetching data for a whole page for faster loading), code splitting (to minimize client bundle sizes), and page rendering approaches (to decide how each page gets generated).

We suggest using:

* [React Router](https://reactrouter.com/start/data/custom)
* [Tanstack Router](https://tanstack.com/router/latest)

### Data Fetching

Fetching data from a server or other data source is a key part of most applications. Doing this properly requires handling loading states, error states, and caching the fetched data, which can be complex.

Purpose-built data fetching libraries do the hard work of fetching and caching the data for you, letting you focus on what data your app needs and how to display it. These libraries are typically used directly in your components, but can also be integrated into routing loaders for faster pre-fetching and better performance, and in server rendering as well.

Note that fetching data directly in components can lead to slower loading times due to network request waterfalls, so we recommend prefetching data in router loaders or on the server as much as possible! This allows a page’s data to be fetched all at once as the page is being displayed.

If you’re fetching data from most backends or REST-style APIs, we suggest using:

* [TanStack Query](https://tanstack.com/query/)
* [SWR](https://swr.vercel.app/)
* [RTK Query](https://redux-toolkit.js.org/rtk-query/overview)

If you’re fetching data from a GraphQL API, we suggest using:

* [Apollo](https://www.apollographql.com/docs/react)
* [Relay](https://relay.dev/)

### Code-splitting

Code-splitting is the process of breaking your app into smaller bundles that can be loaded on demand. An app’s code size increases with every new feature and additional dependency. Apps can become slow to load because all of the code for the entire app needs to be sent before it can be used. Caching, reducing features/dependencies, and moving some code to run on the server can help mitigate slow loading but are incomplete solutions that can sacrifice functionality if overused.

Similarly, if you rely on the apps using your framework to split the code, you might encounter situations where loading becomes slower than if no code splitting were happening at all. For example, [lazily loading](https://react.dev/reference/react/lazy) a chart delays sending the code needed to render the chart, splitting the chart code from the rest of the app. [Parcel supports code splitting with React.lazy](https://parceljs.org/recipes/react/#code-splitting). However, if the chart loads its data *after* it has been initially rendered you are now waiting twice. This is a waterfall: rather than fetching the data for the chart and sending the code to render it simultaneously, you must wait for each step to complete one after the other.

Splitting code by route, when integrated with bundling and data fetching, can reduce the initial load time of your app and the time it takes for the largest visible content of the app to render ([Largest Contentful Paint](https://web.dev/articles/lcp)).

For code-splitting instructions, see your build tool docs:

* [Vite build optimizations](https://vite.dev/guide/features.html#build-optimizations)
* [Parcel code splitting](https://parceljs.org/features/code-splitting/)
* [Rsbuild code splitting](https://rsbuild.dev/guide/optimization/code-splitting)

### Improving Application Performance

Since the build tool you select only supports single page apps (SPAs), you’ll need to implement other [rendering patterns](https://www.patterns.dev/vanilla/rendering-patterns) like server-side rendering (SSR), static site generation (SSG), and/or React Server Components (RSC). Even if you don’t need these features at first, in the future there may be some routes that would benefit SSR, SSG or RSC.

* **Single-page apps (SPA)** load a single HTML page and dynamically updates the page as the user interacts with the app. SPAs are easier to get started with, but they can have slower initial load times. SPAs are the default architecture for most build tools.
* **Streaming Server-side rendering (SSR)** renders a page on the server and sends the fully rendered page to the client. SSR can improve performance, but it can be more complex to set up and maintain than a single-page app. With the addition of streaming, SSR can be very complex to set up and maintain. See [Vite’s SSR guide](https://vite.dev/guide/ssr).
* **Static site generation (SSG)** generates static HTML files for your app at build time. SSG can improve performance, but it can be more complex to set up and maintain than server-side rendering. See [Vite’s SSG guide](https://vite.dev/guide/ssr.html#pre-rendering-ssg).
* **React Server Components (RSC)** lets you mix build-time, server-only, and interactive components in a single React tree. RSC can improve performance, but it currently requires deep expertise to set up and maintain. See [Parcel’s RSC examples](https://github.com/parcel-bundler/rsc-examples).

Your rendering strategies need to integrate with your router so apps built with your framework can choose the rendering strategy on a per-route level. This will enable different rendering strategies without having to rewrite your whole app. For example, the landing page for your app might benefit from being statically generated (SSG), while a page with a content feed might perform best with server-side rendering.

Using the right rendering strategy for the right routes can decrease the time it takes for the first byte of content to be loaded ([Time to First Byte](https://web.dev/articles/ttfb)), the first piece of content to render ([First Contentful Paint](https://web.dev/articles/fcp)), and the largest visible content of the app to render ([Largest Contentful Paint](https://web.dev/articles/lcp)).

### And more…

These are just a few examples of the features a new app will need to consider when building from scratch. Many limitations you’ll hit can be difficult to solve as each problem is interconnected with the others and can require deep expertise in problem areas you may not be familiar with.

If you don’t want to solve these problems on your own, you can [get started with a framework](https://react.dev/learn/creating-a-react-app) that provides these features out of the box.

[PreviousCreating a React App](https://react.dev/learn/creating-a-react-app)[NextAdd React to an Existing Project](https://react.dev/learn/add-react-to-an-existing-project)

---

---


# Add React to an Existing Project – React

URL: https://react.dev/learn/add-react-to-an-existing-project

[Learn React](https://react.dev/learn)

[Installation](https://react.dev/learn/installation)

# Add React to an Existing Project

If you want to add some interactivity to your existing project, you don’t have to rewrite it in React. Add React to your existing stack, and render interactive React components anywhere.

### Note

**You need to install [Node.js](https://nodejs.org/en/) for local development.** Although you can [try React](https://react.dev/learn/installation#try-react) online or with a simple HTML page, realistically most JavaScript tooling you’ll want to use for development requires Node.js.

## Using React for an entire subroute of your existing website

Let’s say you have an existing web app at `example.com` built with another server technology (like Rails), and you want to implement all routes starting with `example.com/some-app/` fully with React.

Here’s how we recommend to set it up:

1. **Build the React part of your app** using one of the [React-based frameworks](https://react.dev/learn/creating-a-react-app).
2. **Specify `/some-app` as the *base path*** in your framework’s configuration (here’s how: [Next.js](https://nextjs.org/docs/app/api-reference/config/next-config-js/basePath), [Gatsby](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/path-prefix/)).
3. **Configure your server or a proxy** so that all requests under `/some-app/` are handled by your React app.

This ensures the React part of your app can [benefit from the best practices](https://react.dev/learn/build-a-react-app-from-scratch#consider-using-a-framework) baked into those frameworks.

Many React-based frameworks are full-stack and let your React app take advantage of the server. However, you can use the same approach even if you can’t or don’t want to run JavaScript on the server. In that case, serve the HTML/CSS/JS export ([`next export` output](https://nextjs.org/docs/advanced-features/static-html-export) for Next.js, default for Gatsby) at `/some-app/` instead.

## Using React for a part of your existing page

Let’s say you have an existing page built with another technology (either a server one like Rails, or a client one like Backbone), and you want to render interactive React components somewhere on that page. That’s a common way to integrate React—in fact, it’s how most React usage looked at Meta for many years!

You can do this in two steps:

1. **Set up a JavaScript environment** that lets you use the [JSX syntax](https://react.dev/learn/writing-markup-with-jsx), split your code into modules with the [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) / [`export`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export) syntax, and use packages (for example, React) from the [npm](https://www.npmjs.com/) package registry.
2. **Render your React components** where you want to see them on the page.

The exact approach depends on your existing page setup, so let’s walk through some details.

### Step 1: Set up a modular JavaScript environment

A modular JavaScript environment lets you write your React components in individual files, as opposed to writing all of your code in a single file. It also lets you use all the wonderful packages published by other developers on the [npm](https://www.npmjs.com/) registry—including React itself! How you do this depends on your existing setup:

* **If your app is already split into files that use `import` statements,** try to use the setup you already have. Check whether writing `<div />` in your JS code causes a syntax error. If it causes a syntax error, you might need to [transform your JavaScript code with Babel](https://babeljs.io/setup), and enable the [Babel React preset](https://babeljs.io/docs/babel-preset-react) to use JSX.
* **If your app doesn’t have an existing setup for compiling JavaScript modules,** set it up with [Vite](https://vite.dev/). The Vite community maintains [many integrations with backend frameworks](https://github.com/vitejs/awesome-vite#integrations-with-backends), including Rails, Django, and Laravel. If your backend framework is not listed, [follow this guide](https://vite.dev/guide/backend-integration.html) to manually integrate Vite builds with your backend.

To check whether your setup works, run this command in your project folder:

Terminal

Copy

```
npm install react react-dom
```

Then add these lines of code at the top of your main JavaScript file (it might be called `index.js` or `main.js`):

index.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRoot } from 'react-dom/client';

// Clear the existing HTML content
document.body.innerHTML = '<div id="app"></div>';

// Render your React component instead
const root = createRoot(document.getElementById('app'));
root.render(<h1>Hello, world</h1>);
```

If the entire content of your page was replaced by a “Hello, world!”, everything worked! Keep reading.

### Note

Integrating a modular JavaScript environment into an existing project for the first time can feel intimidating, but it’s worth it! If you get stuck, try our [community resources](https://react.dev/community) or the [Vite Chat](https://chat.vite.dev/).

### Step 2: Render React components anywhere on the page

In the previous step, you put this code at the top of your main file:

```
import { createRoot } from 'react-dom/client';

// Clear the existing HTML content

document.body.innerHTML = '<div id="app"></div>';

// Render your React component instead

const root = createRoot(document.getElementById('app'));

root.render(<h1>Hello, world</h1>);
```

Of course, you don’t actually want to clear the existing HTML content!

Delete this code.

Instead, you probably want to render your React components in specific places in your HTML. Open your HTML page (or the server templates that generate it) and add a unique [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id) attribute to any tag, for example:

```
<!-- ... somewhere in your html ... -->

<nav id="navigation"></nav>

<!-- ... more html ... -->
```

This lets you find that HTML element with [`document.getElementById`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById) and pass it to [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) so that you can render your own React component inside:

index.jsindex.html

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRoot } from 'react-dom/client';

function NavigationBar() {
  // TODO: Actually implement a navigation bar
  return <h1>Hello from React!</h1>;
}

const domNode = document.getElementById('navigation');
const root = createRoot(domNode);
root.render(<NavigationBar />);
```

Notice how the original HTML content from `index.html` is preserved, but your own `NavigationBar` React component now appears inside the `<nav id="navigation">` from your HTML. Read the [`createRoot` usage documentation](https://react.dev/reference/react-dom/client/createRoot#rendering-a-page-partially-built-with-react) to learn more about rendering React components inside an existing HTML page.

When you adopt React in an existing project, it’s common to start with small interactive components (like buttons), and then gradually keep “moving upwards” until eventually your entire page is built with React. If you ever reach that point, we recommend migrating to [a React framework](https://react.dev/learn/creating-a-react-app) right after to get the most out of React.

## Using React Native in an existing native mobile app

[React Native](https://reactnative.dev/) can also be integrated into existing native apps incrementally. If you have an existing native app for Android (Java or Kotlin) or iOS (Objective-C or Swift), [follow this guide](https://reactnative.dev/docs/integration-with-existing-apps) to add a React Native screen to it.

[PreviousBuild a React App from Scratch](https://react.dev/learn/build-a-react-app-from-scratch)[NextSetup](https://react.dev/learn/setup)

---

---


# Setup – React

URL: https://react.dev/learn/setup

[Learn React](https://react.dev/learn)

# Setup

React integrates with tools like editors, TypeScript, browser extensions, and compilers. This section will help you get your environment set up.

## Editor Setup

See our [recommended editors](https://react.dev/learn/editor-setup) and learn how to set them up to work with React.

## Using TypeScript

TypeScript is a popular way to add type definitions to JavaScript codebases. [Learn how to integrate TypeScript into your React projects](https://react.dev/learn/typescript).

## React Developer Tools

React Developer Tools is a browser extension that can inspect React components, edit props and state, and identify performance problems. Learn how to install it [here](https://react.dev/learn/react-developer-tools).

## React Compiler

React Compiler is a tool that automatically optimizes your React app. [Learn more](https://react.dev/learn/react-compiler).

## Next steps

Head to the [Quick Start](https://react.dev/learn) guide for a tour of the most important React concepts you will encounter every day.

[PreviousAdd React to an Existing Project](https://react.dev/learn/add-react-to-an-existing-project)[NextEditor Setup](https://react.dev/learn/editor-setup)

---

---


# Editor Setup – React

URL: https://react.dev/learn/editor-setup

[Learn React](https://react.dev/learn)

[Setup](https://react.dev/learn/setup)

# Editor Setup

A properly configured editor can make code clearer to read and faster to write. It can even help you catch bugs as you write them! If this is your first time setting up an editor or you’re looking to tune up your current editor, we have a few recommendations.

### You will learn

* What the most popular editors are
* How to format your code automatically

## Your editor

[VS Code](https://code.visualstudio.com/) is one of the most popular editors in use today. It has a large marketplace of extensions and integrates well with popular services like GitHub. Most of the features listed below can be added to VS Code as extensions as well, making it highly configurable!

Other popular text editors used in the React community include:

* [WebStorm](https://www.jetbrains.com/webstorm/) is an integrated development environment designed specifically for JavaScript.
* [Sublime Text](https://www.sublimetext.com/) has support for JSX and TypeScript, [syntax highlighting](https://stackoverflow.com/a/70960574/458193) and autocomplete built in.
* [Vim](https://www.vim.org/) is a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as “vi” with most UNIX systems and with Apple OS X.

## Recommended text editor features

Some editors come with these features built in, but others might require adding an extension. Check to see what support your editor of choice provides to be sure!

### Linting

Code linters find problems in your code as you write, helping you fix them early. [ESLint](https://eslint.org/) is a popular, open source linter for JavaScript.

* [Install ESLint with the recommended configuration for React](https://www.npmjs.com/package/eslint-config-react-app) (be sure you have [Node installed!](https://nodejs.org/en/download/current/))
* [Integrate ESLint in VSCode with the official extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)

**Make sure that you’ve enabled all the [`eslint-plugin-react-hooks`](https://www.npmjs.com/package/eslint-plugin-react-hooks) rules for your project.** They are essential and catch the most severe bugs early. The recommended [`eslint-config-react-app`](https://www.npmjs.com/package/eslint-config-react-app) preset already includes them.

### Formatting

The last thing you want to do when sharing your code with another contributor is get into a discussion about [tabs vs spaces](https://www.google.com/search?q=tabs+vs+spaces)! Fortunately, [Prettier](https://prettier.io/) will clean up your code by reformatting it to conform to preset, configurable rules. Run Prettier, and all your tabs will be converted to spaces—and your indentation, quotes, etc will also all be changed to conform to the configuration. In the ideal setup, Prettier will run when you save your file, quickly making these edits for you.

You can install the [Prettier extension in VSCode](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) by following these steps:

1. Launch VS Code
2. Use Quick Open (press Ctrl/Cmd+P)
3. Paste in `ext install esbenp.prettier-vscode`
4. Press Enter

#### Formatting on save

Ideally, you should format your code on every save. VS Code has settings for this!

1. In VS Code, press `CTRL/CMD + SHIFT + P`.
2. Type “settings”
3. Hit Enter
4. In the search bar, type “format on save”
5. Be sure the “format on save” option is ticked!

> If your ESLint preset has formatting rules, they may conflict with Prettier. We recommend disabling all formatting rules in your ESLint preset using [`eslint-config-prettier`](https://github.com/prettier/eslint-config-prettier) so that ESLint is *only* used for catching logical mistakes. If you want to enforce that files are formatted before a pull request is merged, use [`prettier --check`](https://prettier.io/docs/en/cli.html#--check) for your continuous integration.

[PreviousSetup](https://react.dev/learn/setup)[NextUsing TypeScript](https://react.dev/learn/typescript)

---

---


# Using TypeScript – React

URL: https://react.dev/learn/typescript

[Learn React](https://react.dev/learn)

[Setup](https://react.dev/learn/setup)

# Using TypeScript

TypeScript is a popular way to add type definitions to JavaScript codebases. Out of the box, TypeScript [supports JSX](https://react.dev/learn/writing-markup-with-jsx) and you can get full React Web support by adding [`@types/react`](https://www.npmjs.com/package/@types/react) and [`@types/react-dom`](https://www.npmjs.com/package/@types/react-dom) to your project.

### You will learn

* [TypeScript with React Components](https://react.dev/learn/typescript#typescript-with-react-components)
* [Examples of typing with Hooks](https://react.dev/learn/typescript#example-hooks)
* [Common types from `@types/react`](https://react.dev/learn/typescript#useful-types)
* [Further learning locations](https://react.dev/learn/typescript#further-learning)

## Installation

All [production-grade React frameworks](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) offer support for using TypeScript. Follow the framework specific guide for installation:

* [Next.js](https://nextjs.org/docs/app/building-your-application/configuring/typescript)
* [Remix](https://remix.run/docs/en/1.19.2/guides/typescript)
* [Gatsby](https://www.gatsbyjs.com/docs/how-to/custom-configuration/typescript/)
* [Expo](https://docs.expo.dev/guides/typescript/)

### Adding TypeScript to an existing React project

To install the latest version of React’s type definitions:

Terminal

Copy

```
npm install --save-dev @types/react @types/react-dom
```

The following compiler options need to be set in your `tsconfig.json`:

1. `dom` must be included in [`lib`](https://www.typescriptlang.org/tsconfig/#lib) (Note: If no `lib` option is specified, `dom` is included by default).
2. [`jsx`](https://www.typescriptlang.org/tsconfig/#jsx) must be set to one of the valid options. `preserve` should suffice for most applications.
   If you’re publishing a library, consult the [`jsx` documentation](https://www.typescriptlang.org/tsconfig/#jsx) on what value to choose.

## TypeScript with React Components

### Note

Every file containing JSX must use the `.tsx` file extension. This is a TypeScript-specific extension that tells TypeScript that this file contains JSX.

Writing TypeScript with React is very similar to writing JavaScript with React. The key difference when working with a component is that you can provide types for your component’s props. These types can be used for correctness checking and providing inline documentation in editors.

Taking the [`MyButton` component](https://react.dev/learn#components) from the [Quick Start](https://react.dev/learn) guide, we can add a type describing the `title` for the button:

App.tsx

App.tsx

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")[TypeScript Playground](https://www.typescriptlang.org/play#src=import%20*%20as%20React%20from%20'react'%3B%0A%0Afunction%20MyButton(%7B%20title%20%7D%3A%20%7B%20title%3A%20string%20%7D)%20%7B%0A%20%20return%20(%0A%20%20%20%20%3Cbutton%3E%7Btitle%7D%3C%2Fbutton%3E%0A%20%20)%3B%0A%7D%0A%0Aexport%20default%20function%20MyApp()%20%7B%0A%20%20return%20(%0A%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%3Ch1%3EWelcome%20to%20my%20app%3C%2Fh1%3E%0A%20%20%20%20%20%20%3CMyButton%20title%3D%22I'm%20a%20button%22%20%2F%3E%0A%20%20%20%20%3C%2Fdiv%3E%0A%20%20)%3B%0A%7D%0A "Open in TypeScript Playground")

```
function MyButton({ title }: { title: string }) {
  return (
    <button>{title}</button>
  );
}

export default function MyApp() {
  return (
    <div>
      <h1>Welcome to my app</h1>
      <MyButton title="I'm a button" />
    </div>
  );
}
```

### Note

These sandboxes can handle TypeScript code, but they do not run the type-checker. This means you can amend the TypeScript sandboxes to learn, but you won’t get any type errors or warnings. To get type-checking, you can use the [TypeScript Playground](https://www.typescriptlang.org/play) or use a more fully-featured online sandbox.

This inline syntax is the simplest way to provide types for a component, though once you start to have a few fields to describe it can become unwieldy. Instead, you can use an `interface` or `type` to describe the component’s props:

App.tsx

App.tsx

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")[TypeScript Playground](https://www.typescriptlang.org/play#src=import%20*%20as%20React%20from%20'react'%3B%0A%0Ainterface%20MyButtonProps%20%7B%0A%20%20%2F**%20The%20text%20to%20display%20inside%20the%20button%20*%2F%0A%20%20title%3A%20string%3B%0A%20%20%2F**%20Whether%20the%20button%20can%20be%20interacted%20with%20*%2F%0A%20%20disabled%3A%20boolean%3B%0A%7D%0A%0Afunction%20MyButton(%7B%20title%2C%20disabled%20%7D%3A%20MyButtonProps)%20%7B%0A%20%20return%20(%0A%20%20%20%20%3Cbutton%20disabled%3D%7Bdisabled%7D%3E%7Btitle%7D%3C%2Fbutton%3E%0A%20%20)%3B%0A%7D%0A%0Aexport%20default%20function%20MyApp()%20%7B%0A%20%20return%20(%0A%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%3Ch1%3EWelcome%20to%20my%20app%3C%2Fh1%3E%0A%20%20%20%20%20%20%3CMyButton%20title%3D%22I'm%20a%20disabled%20button%22%20disabled%3D%7Btrue%7D%2F%3E%0A%20%20%20%20%3C%2Fdiv%3E%0A%20%20)%3B%0A%7D%0A "Open in TypeScript Playground")

```
interface MyButtonProps {
  /** The text to display inside the button */
  title: string;
  /** Whether the button can be interacted with */
  disabled: boolean;
}

function MyButton({ title, disabled }: MyButtonProps) {
  return (
    <button disabled={disabled}>{title}</button>
  );
}

export default function MyApp() {
  return (
    <div>
      <h1>Welcome to my app</h1>
      <MyButton title="I'm a disabled button" disabled={true}/>
    </div>
  );
}
```

Show more

The type describing your component’s props can be as simple or as complex as you need, though they should be an object type described with either a `type` or `interface`. You can learn about how TypeScript describes objects in [Object Types](https://www.typescriptlang.org/docs/handbook/2/objects.html) but you may also be interested in using [Union Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types) to describe a prop that can be one of a few different types and the [Creating Types from Types](https://www.typescriptlang.org/docs/handbook/2/types-from-types.html) guide for more advanced use cases.

## Example Hooks

The type definitions from `@types/react` include types for the built-in Hooks, so you can use them in your components without any additional setup. They are built to take into account the code you write in your component, so you will get [inferred types](https://www.typescriptlang.org/docs/handbook/type-inference.html) a lot of the time and ideally do not need to handle the minutiae of providing the types.

However, we can look at a few examples of how to provide types for Hooks.

### `useState`

The [`useState` Hook](https://react.dev/reference/react/useState) will re-use the value passed in as the initial state to determine what the type of the value should be. For example:

```
// Infer the type as "boolean"

const [enabled, setEnabled] = useState(false);
```

This will assign the type of `boolean` to `enabled`, and `setEnabled` will be a function accepting either a `boolean` argument, or a function that returns a `boolean`. If you want to explicitly provide a type for the state, you can do so by providing a type argument to the `useState` call:

```
// Explicitly set the type to "boolean"

const [enabled, setEnabled] = useState<boolean>(false);
```

This isn’t very useful in this case, but a common case where you may want to provide a type is when you have a union type. For example, `status` here can be one of a few different strings:

```
type Status = "idle" | "loading" | "success" | "error";

const [status, setStatus] = useState<Status>("idle");
```

Or, as recommended in [Principles for structuring state](https://react.dev/learn/choosing-the-state-structure#principles-for-structuring-state), you can group related state as an object and describe the different possibilities via object types:

```
type RequestState =

| { status: 'idle' }

| { status: 'loading' }

| { status: 'success', data: any }

| { status: 'error', error: Error };

const [requestState, setRequestState] = useState<RequestState>({ status: 'idle' });
```

### `useReducer`

The [`useReducer` Hook](https://react.dev/reference/react/useReducer) is a more complex Hook that takes a reducer function and an initial state. The types for the reducer function are inferred from the initial state. You can optionally provide a type argument to the `useReducer` call to provide a type for the state, but it is often better to set the type on the initial state instead:

App.tsx

App.tsx

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")[TypeScript Playground](https://www.typescriptlang.org/play#src=import%20*%20as%20React%20from%20'react'%3B%0A%0Aimport%20%7BuseReducer%7D%20from%20'react'%3B%0A%0Ainterface%20State%20%7B%0A%20%20%20count%3A%20number%0A%7D%3B%0A%0Atype%20CounterAction%20%3D%0A%20%20%7C%20%7B%20type%3A%20%22reset%22%20%7D%0A%20%20%7C%20%7B%20type%3A%20%22setCount%22%3B%20value%3A%20State%5B%22count%22%5D%20%7D%0A%0Aconst%20initialState%3A%20State%20%3D%20%7B%20count%3A%200%20%7D%3B%0A%0Afunction%20stateReducer(state%3A%20State%2C%20action%3A%20CounterAction)%3A%20State%20%7B%0A%20%20switch%20(action.type)%20%7B%0A%20%20%20%20case%20%22reset%22%3A%0A%20%20%20%20%20%20return%20initialState%3B%0A%20%20%20%20case%20%22setCount%22%3A%0A%20%20%20%20%20%20return%20%7B%20...state%2C%20count%3A%20action.value%20%7D%3B%0A%20%20%20%20default%3A%0A%20%20%20%20%20%20throw%20new%20Error(%22Unknown%20action%22)%3B%0A%20%20%7D%0A%7D%0A%0Aexport%20default%20function%20App()%20%7B%0A%20%20const%20%5Bstate%2C%20dispatch%5D%20%3D%20useReducer(stateReducer%2C%20initialState)%3B%0A%0A%20%20const%20addFive%20%3D%20()%20%3D%3E%20dispatch(%7B%20type%3A%20%22setCount%22%2C%20value%3A%20state.count%20%2B%205%20%7D)%3B%0A%20%20const%20reset%20%3D%20()%20%3D%3E%20dispatch(%7B%20type%3A%20%22reset%22%20%7D)%3B%0A%0A%20%20return%20(%0A%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%3Ch1%3EWelcome%20to%20my%20counter%3C%2Fh1%3E%0A%0A%20%20%20%20%20%20%3Cp%3ECount%3A%20%7Bstate.count%7D%3C%2Fp%3E%0A%20%20%20%20%20%20%3Cbutton%20onClick%3D%7BaddFive%7D%3EAdd%205%3C%2Fbutton%3E%0A%20%20%20%20%20%20%3Cbutton%20onClick%3D%7Breset%7D%3EReset%3C%2Fbutton%3E%0A%20%20%20%20%3C%2Fdiv%3E%0A%20%20)%3B%0A%7D%0A%0A "Open in TypeScript Playground")

```
import {useReducer} from 'react';

interface State {
   count: number
};

type CounterAction =
  | { type: "reset" }
  | { type: "setCount"; value: State["count"] }

const initialState: State = { count: 0 };

function stateReducer(state: State, action: CounterAction): State {
  switch (action.type) {
    case "reset":
      return initialState;
    case "setCount":
      return { ...state, count: action.value };
    default:
      throw new Error("Unknown action");
  }
}

export default function App() {
  const [state, dispatch] = useReducer(stateReducer, initialState);

  const addFive = () => dispatch({ type: "setCount", value: state.count + 5 });
  const reset = () => dispatch({ type: "reset" });

  return (
    <div>
      <h1>Welcome to my counter</h1>

      <p>Count: {state.count}</p>
      <button onClick={addFive}>Add 5</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

Show more

We are using TypeScript in a few key places:

* `interface State` describes the shape of the reducer’s state.
* `type CounterAction` describes the different actions which can be dispatched to the reducer.
* `const initialState: State` provides a type for the initial state, and also the type which is used by `useReducer` by default.
* `stateReducer(state: State, action: CounterAction): State` sets the types for the reducer function’s arguments and return value.

A more explicit alternative to setting the type on `initialState` is to provide a type argument to `useReducer`:

```
import { stateReducer, State } from './your-reducer-implementation';

const initialState = { count: 0 };

export default function App() {

const [state, dispatch] = useReducer<State>(stateReducer, initialState);

}
```

### `useContext`

The [`useContext` Hook](https://react.dev/reference/react/useContext) is a technique for passing data down the component tree without having to pass props through components. It is used by creating a provider component and often by creating a Hook to consume the value in a child component.

The type of the value provided by the context is inferred from the value passed to the `createContext` call:

App.tsx

App.tsx

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")[TypeScript Playground](https://www.typescriptlang.org/play#src=import%20*%20as%20React%20from%20'react'%3B%0A%0Aimport%20%7B%20createContext%2C%20useContext%2C%20useState%20%7D%20from%20'react'%3B%0A%0Atype%20Theme%20%3D%20%22light%22%20%7C%20%22dark%22%20%7C%20%22system%22%3B%0Aconst%20ThemeContext%20%3D%20createContext%3CTheme%3E(%22system%22)%3B%0A%0Aconst%20useGetTheme%20%3D%20()%20%3D%3E%20useContext(ThemeContext)%3B%0A%0Aexport%20default%20function%20MyApp()%20%7B%0A%20%20const%20%5Btheme%2C%20setTheme%5D%20%3D%20useState%3CTheme%3E('light')%3B%0A%0A%20%20return%20(%0A%20%20%20%20%3CThemeContext%20value%3D%7Btheme%7D%3E%0A%20%20%20%20%20%20%3CMyComponent%20%2F%3E%0A%20%20%20%20%3C%2FThemeContext%3E%0A%20%20)%0A%7D%0A%0Afunction%20MyComponent()%20%7B%0A%20%20const%20theme%20%3D%20useGetTheme()%3B%0A%0A%20%20return%20(%0A%20%20%20%20%3Cdiv%3E%0A%20%20%20%20%20%20%3Cp%3ECurrent%20theme%3A%20%7Btheme%7D%3C%2Fp%3E%0A%20%20%20%20%3C%2Fdiv%3E%0A%20%20)%0A%7D%0A "Open in TypeScript Playground")

```
import { createContext, useContext, useState } from 'react';

type Theme = "light" | "dark" | "system";
const ThemeContext = createContext<Theme>("system");

const useGetTheme = () => useContext(ThemeContext);

export default function MyApp() {
  const [theme, setTheme] = useState<Theme>('light');

  return (
    <ThemeContext value={theme}>
      <MyComponent />
    </ThemeContext>
  )
}

function MyComponent() {
  const theme = useGetTheme();

  return (
    <div>
      <p>Current theme: {theme}</p>
    </div>
  )
}
```

Show more

This technique works when you have a default value which makes sense - but there are occasionally cases when you do not, and in those cases `null` can feel reasonable as a default value. However, to allow the type-system to understand your code, you need to explicitly set `ContextShape | null` on the `createContext`.

This causes the issue that you need to eliminate the `| null` in the type for context consumers. Our recommendation is to have the Hook do a runtime check for it’s existence and throw an error when not present:

```
import { createContext, useContext, useState, useMemo } from 'react';

// This is a simpler example, but you can imagine a more complex object here

type ComplexObject = {

kind: string

};

// The context is created with `| null` in the type, to accurately reflect the default value.

const Context = createContext<ComplexObject | null>(null);

// The `| null` will be removed via the check in the Hook.

const useGetComplexObject = () => {

const object = useContext(Context);

if (!object) { throw new Error("useGetComplexObject must be used within a Provider") }

return object;

}

export default function MyApp() {

const object = useMemo(() => ({ kind: "complex" }), []);

return (

<Context value={object}>

<MyComponent />

</Context>

)

}

function MyComponent() {

const object = useGetComplexObject();

return (

<div>

<p>Current object: {object.kind}</p>

</div>

)

}
```

### `useMemo`

### Note

[React Compiler](https://react.dev/learn/react-compiler) automatically memoizes values and functions, reducing the need for manual `useMemo` calls. You can use the compiler to handle memoization automatically.

The [`useMemo`](https://react.dev/reference/react/useMemo) Hooks will create/re-access a memorized value from a function call, re-running the function only when dependencies passed as the 2nd parameter are changed. The result of calling the Hook is inferred from the return value from the function in the first parameter. You can be more explicit by providing a type argument to the Hook.

```
// The type of visibleTodos is inferred from the return value of filterTodos

const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);
```

### `useCallback`

### Note

[React Compiler](https://react.dev/learn/react-compiler) automatically memoizes values and functions, reducing the need for manual `useCallback` calls. You can use the compiler to handle memoization automatically.

The [`useCallback`](https://react.dev/reference/react/useCallback) provide a stable reference to a function as long as the dependencies passed into the second parameter are the same. Like `useMemo`, the function’s type is inferred from the return value of the function in the first parameter, and you can be more explicit by providing a type argument to the Hook.

```
const handleClick = useCallback(() => {

// ...

}, [todos]);
```

When working in TypeScript strict mode `useCallback` requires adding types for the parameters in your callback. This is because the type of the callback is inferred from the return value of the function, and without parameters the type cannot be fully understood.

Depending on your code-style preferences, you could use the `*EventHandler` functions from the React types to provide the type for the event handler at the same time as defining the callback:

```
import { useState, useCallback } from 'react';

export default function Form() {

const [value, setValue] = useState("Change me");

const handleChange = useCallback<React.ChangeEventHandler<HTMLInputElement>>((event) => {

setValue(event.currentTarget.value);

}, [setValue])

return (

<>

<input value={value} onChange={handleChange} />

<p>Value: {value}</p>

</>

);

}
```

## Useful Types

There is quite an expansive set of types which come from the `@types/react` package, it is worth a read when you feel comfortable with how React and TypeScript interact. You can find them [in React’s folder in DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/react/index.d.ts). We will cover a few of the more common types here.

### DOM Events

When working with DOM events in React, the type of the event can often be inferred from the event handler. However, when you want to extract a function to be passed to an event handler, you will need to explicitly set the type of the event.

App.tsx

App.tsx

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")[TypeScript Playground](https://www.typescriptlang.org/play#src=import%20*%20as%20React%20from%20'react'%3B%0A%0Aimport%20%7B%20useState%20%7D%20from%20'react'%3B%0A%0Aexport%20default%20function%20Form()%20%7B%0A%20%20const%20%5Bvalue%2C%20setValue%5D%20%3D%20useState(%22Change%20me%22)%3B%0A%0A%20%20function%20handleChange(event%3A%20React.ChangeEvent%3CHTMLInputElement%3E)%20%7B%0A%20%20%20%20setValue(event.currentTarget.value)%3B%0A%20%20%7D%0A%0A%20%20return%20(%0A%20%20%20%20%3C%3E%0A%20%20%20%20%20%20%3Cinput%20value%3D%7Bvalue%7D%20onChange%3D%7BhandleChange%7D%20%2F%3E%0A%20%20%20%20%20%20%3Cp%3EValue%3A%20%7Bvalue%7D%3C%2Fp%3E%0A%20%20%20%20%3C%2F%3E%0A%20%20)%3B%0A%7D%0A "Open in TypeScript Playground")

```
import { useState } from 'react';

export default function Form() {
  const [value, setValue] = useState("Change me");

  function handleChange(event: React.ChangeEvent<HTMLInputElement>) {
    setValue(event.currentTarget.value);
  }

  return (
    <>
      <input value={value} onChange={handleChange} />
      <p>Value: {value}</p>
    </>
  );
}
```

Show more

There are many types of events provided in the React types - the full list can be found [here](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/b580df54c0819ec9df62b0835a315dd48b8594a9/types/react/index.d.ts#L1247C1-L1373) which is based on the [most popular events from the DOM](https://developer.mozilla.org/en-US/docs/Web/Events).

When determining the type you are looking for you can first look at the hover information for the event handler you are using, which will show the type of the event.

If you need to use an event that is not included in this list, you can use the `React.SyntheticEvent` type, which is the base type for all events.

### Children

There are two common paths to describing the children of a component. The first is to use the `React.ReactNode` type, which is a union of all the possible types that can be passed as children in JSX:

```
interface ModalRendererProps {

title: string;

children: React.ReactNode;

}
```

This is a very broad definition of children. The second is to use the `React.ReactElement` type, which is only JSX elements and not JavaScript primitives like strings or numbers:

```
interface ModalRendererProps {

title: string;

children: React.ReactElement;

}
```

Note, that you cannot use TypeScript to describe that the children are a certain type of JSX elements, so you cannot use the type-system to describe a component which only accepts `<li>` children.

You can see an example of both `React.ReactNode` and `React.ReactElement` with the type-checker in [this TypeScript playground](https://www.typescriptlang.org/play#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgIilQ3wChSB6CxYmAOmXRgDkIATJOdNJMGAZzgwAFpxAR+8YADswAVwGkZMJFEzpOjDKw4AFHGEEBvUnDhphwADZsi0gFw0mDWjqQBuUgF9yaCNMlENzgAXjgACjADfkctFnYkfQhDAEpQgD44AB42YAA3dKMo5P46C2tbJGkvLIpcgt9-QLi3AEEwMFCItJDMrPTTbIQ3dKywdIB5aU4kKyQQKpha8drhhIGzLLWODbNs3b3s8YAxKBQAcwXpAThMaGWDvbH0gFloGbmrgQfBzYpd1YjQZbEYARkB6zMwO2SHSAAlZlYIBCdtCRkZpHIrFYahQYQD8UYYFA5EhcfjyGYqHAXnJAsIUHlOOUbHYhMIIHJzsI0Qk4P9SLUBuRqXEXEwAKKfRZcNA8PiCfxWACecAAUgBlAAacFm80W-CU11U6h4TgwUv11yShjgJjMLMqDnN9Dilq+nh8pD8AXgCHdMrCkWisVoAet0R6fXqhWKhjKllZVVxMcavpd4Zg7U6Qaj+2hmdG4zeRF10uu-Aeq0LBfLMEe-V+T2L7zLVu+FBWLdLeq+lc7DYFf39deFVOotMCACNOCh1dq219a+30uC8YWoZsRyuEdjkevR8uvoVMdjyTWt4WiSSydXD4NqZP4AymeZE072ZzuUeZQKheQgA).

### Style Props

When using inline styles in React, you can use `React.CSSProperties` to describe the object passed to the `style` prop. This type is a union of all the possible CSS properties, and is a good way to ensure you are passing valid CSS properties to the `style` prop, and to get auto-complete in your editor.

```
interface MyComponentProps {

style: React.CSSProperties;

}
```

## Further learning

This guide has covered the basics of using TypeScript with React, but there is a lot more to learn.
Individual API pages on the docs may contain more in-depth documentation on how to use them with TypeScript.

We recommend the following resources:

* [The TypeScript handbook](https://www.typescriptlang.org/docs/handbook/) is the official documentation for TypeScript, and covers most key language features.
* [The TypeScript release notes](https://devblogs.microsoft.com/typescript/) cover new features in depth.
* [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/) is a community-maintained cheatsheet for using TypeScript with React, covering a lot of useful edge cases and providing more breadth than this document.
* [TypeScript Community Discord](https://discord.com/invite/typescript) is a great place to ask questions and get help with TypeScript and React issues.

[PreviousEditor Setup](https://react.dev/learn/editor-setup)[NextReact Developer Tools](https://react.dev/learn/react-developer-tools)

---

---


# React Developer Tools – React

URL: https://react.dev/learn/react-developer-tools

[Learn React](https://react.dev/learn)

[Setup](https://react.dev/learn/setup)

# React Developer Tools

Use React Developer Tools to inspect React [components](https://react.dev/learn/your-first-component), edit [props](https://react.dev/learn/passing-props-to-a-component) and [state](https://react.dev/learn/state-a-components-memory), and identify performance problems.

### You will learn

* How to install React Developer Tools

## Browser extension

The easiest way to debug websites built with React is to install the React Developer Tools browser extension. It is available for several popular browsers:

* [Install for **Chrome**](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en)
* [Install for **Firefox**](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/)
* [Install for **Edge**](https://microsoftedge.microsoft.com/addons/detail/react-developer-tools/gpphkfbcpidddadnkolkpfckpihlkkil)

Now, if you visit a website **built with React,** you will see the *Components* and *Profiler* panels.

![React Developer Tools extension](https://react.dev/images/docs/react-devtools-extension.png)

### Safari and other browsers

For other browsers (for example, Safari), install the [`react-devtools`](https://www.npmjs.com/package/react-devtools) npm package:

```
# Yarn

yarn global add react-devtools

# Npm

npm install -g react-devtools
```

Next open the developer tools from the terminal:

```
react-devtools
```

Then connect your website by adding the following `<script>` tag to the beginning of your website’s `<head>`:

```
<html>

<head>

<script src="http://localhost:8097"></script>
```

Reload your website in the browser now to view it in developer tools.

![React Developer Tools standalone](https://react.dev/images/docs/react-devtools-standalone.png)

## Mobile (React Native)

To inspect apps built with [React Native](https://reactnative.dev/), you can use [React Native DevTools](https://reactnative.dev/docs/react-native-devtools), the built-in debugger that deeply integrates React Developer Tools. All features work identically to the browser extension, including native element highlighting and selection.

[Learn more about debugging in React Native.](https://reactnative.dev/docs/debugging)

> For versions of React Native earlier than 0.76, please use the standalone build of React DevTools by following the [Safari and other browsers](https://react.dev/learn/react-developer-tools#safari-and-other-browsers) guide above.

[PreviousUsing TypeScript](https://react.dev/learn/typescript)[NextReact Compiler](https://react.dev/learn/react-compiler)

---

---


# React Compiler – React

URL: https://react.dev/learn/react-compiler

[Learn React](https://react.dev/learn)

# React Compiler

## Introduction

Learn [what React Compiler does](https://react.dev/learn/react-compiler/introduction) and how it automatically optimizes your React application by handling memoization for you, eliminating the need for manual `useMemo`, `useCallback`, and `React.memo`.

## Installation

Get started with [installing React Compiler](https://react.dev/learn/react-compiler/installation) and learn how to configure it with your build tools.

## Incremental Adoption

Learn [strategies for gradually adopting React Compiler](https://react.dev/learn/react-compiler/incremental-adoption) in your existing codebase if you’re not ready to enable it everywhere yet.

## Debugging and Troubleshooting

When things don’t work as expected, use our [debugging guide](https://react.dev/learn/react-compiler/debugging) to understand the difference between compiler errors and runtime issues, identify common breaking patterns, and follow a systematic debugging workflow.

## Configuration and Reference

For detailed configuration options and API reference:

* [Configuration Options](https://react.dev/reference/react-compiler/configuration) - All compiler configuration options including React version compatibility
* [Directives](https://react.dev/reference/react-compiler/directives) - Function-level compilation control
* [Compiling Libraries](https://react.dev/reference/react-compiler/compiling-libraries) - Shipping pre-compiled libraries

## Additional resources

In addition to these docs, we recommend checking the [React Compiler Working Group](https://github.com/reactwg/react-compiler) for additional information and discussion about the compiler.

[PreviousReact Developer Tools](https://react.dev/learn/react-developer-tools)[NextIntroduction](https://react.dev/learn/react-compiler/introduction)

---

---


# Introduction – React

URL: https://react.dev/learn/react-compiler/introduction

[Learn React](https://react.dev/learn)

[React Compiler](https://react.dev/learn/react-compiler)

# Introduction

React Compiler is a new build-time tool that automatically optimizes your React app. It works with plain JavaScript, and understands the [Rules of React](https://react.dev/reference/rules), so you don’t need to rewrite any code to use it.

### You will learn

* What React Compiler does
* Getting started with the compiler
* Incremental adoption strategies
* Debugging and troubleshooting when things go wrong
* Using the compiler on your React library

## What does React Compiler do?

React Compiler automatically optimizes your React application at build time. React is often fast enough without optimization, but sometimes you need to manually memoize components and values to keep your app responsive. This manual memoization is tedious, easy to get wrong, and adds extra code to maintain. React Compiler does this optimization automatically for you, freeing you from this mental burden so you can focus on building features.

### Before React Compiler

Without the compiler, you need to manually memoize components and values to optimize re-renders:

```
import { useMemo, useCallback, memo } from 'react';

const ExpensiveComponent = memo(function ExpensiveComponent({ data, onClick }) {

const processedData = useMemo(() => {

return expensiveProcessing(data);

}, [data]);

const handleClick = useCallback((item) => {

onClick(item.id);

}, [onClick]);

return (

<div>

{processedData.map(item => (

<Item key={item.id} onClick={() => handleClick(item)} />

))}

</div>

);

});
```

### Note

This manual memoization has a subtle bug that breaks memoization:

```
<Item key={item.id} onClick={() => handleClick(item)} />
```

Even though `handleClick` is wrapped in `useCallback`, the arrow function `() => handleClick(item)` creates a new function every time the component renders. This means that `Item` will always receive a new `onClick` prop, breaking memoization.

React Compiler is able to optimize this correctly with or without the arrow function, ensuring that `Item` only re-renders when `props.onClick` changes.

### After React Compiler

With React Compiler, you write the same code without manual memoization:

```
function ExpensiveComponent({ data, onClick }) {

const processedData = expensiveProcessing(data);

const handleClick = (item) => {

onClick(item.id);

};

return (

<div>

{processedData.map(item => (

<Item key={item.id} onClick={() => handleClick(item)} />

))}

</div>

);

}
```

*[See this example in the React Compiler Playground](https://playground.react.dev/#N4Igzg9grgTgxgUxALhAMygOzgFwJYSYAEAogB4AOCmYeAbggMIQC2Fh1OAFMEQCYBDHAIA0RQowA2eOAGsiAXwCURYAB1iROITA4iFGBERgwCPgBEhAogF4iCStVoMACoeO1MAcy6DhSgG4NDSItHT0ACwFMPkkmaTlbIi48HAQWFRsAPlUQ0PFMKRlZFLSWADo8PkC8hSDMPJgEHFhiLjzQgB4+eiyO-OADIwQTM0thcpYBClL02xz2zXz8zoBJMqJZBABPG2BU9Mq+BQKiuT2uTJyomLizkoOMk4B6PqX8pSUFfs7nnro3qEapgFCAFEA)*

React Compiler automatically applies the optimal memoization, ensuring your app only re-renders when necessary.

##### Deep Dive

#### What kind of memoization does React Compiler add?

Show Details

React Compiler’s automatic memoization is primarily focused on **improving update performance** (re-rendering existing components), so it focuses on these two use cases:

1. **Skipping cascading re-rendering of components**
   * Re-rendering `<Parent />` causes many components in its component tree to re-render, even though only `<Parent />` has changed
2. **Skipping expensive calculations from outside of React**
   * For example, calling `expensivelyProcessAReallyLargeArrayOfObjects()` inside of your component or hook that needs that data

#### Optimizing Re-renders

React lets you express your UI as a function of their current state (more concretely: their props, state, and context). In its current implementation, when a component’s state changes, React will re-render that component *and all of its children* — unless you have applied some form of manual memoization with `useMemo()`, `useCallback()`, or `React.memo()`. For example, in the following example, `<MessageButton>` will re-render whenever `<FriendList>`’s state changes:

```
function FriendList({ friends }) {

const onlineCount = useFriendOnlineCount();

if (friends.length === 0) {

return <NoFriends />;

}

return (

<div>

<span>{onlineCount} online</span>

{friends.map((friend) => (

<FriendListCard key={friend.id} friend={friend} />

))}

<MessageButton />

</div>

);

}
```

[*See this example in the React Compiler Playground*](https://playground.react.dev/#N4Igzg9grgTgxgUxALhAMygOzgFwJYSYAEAYjHgpgCYAyeYOAFMEWuZVWEQL4CURwADrEicQgyKEANnkwIAwtEw4iAXiJQwCMhWoB5TDLmKsTXgG5hRInjRFGbXZwB0UygHMcACzWr1ABn4hEWsYBBxYYgAeADkIHQ4uAHoAPksRbisiMIiYYkYs6yiqPAA3FMLrIiiwAAcAQ0wU4GlZBSUcbklDNqikusaKkKrgR0TnAFt62sYHdmp+VRT7SqrqhOo6Bnl6mCoiAGsEAE9VUfmqZzwqLrHqM7ubolTVol5eTOGigFkEMDB6u4EAAhKA4HCEZ5DNZ9ErlLIWYTcEDcIA)

React Compiler automatically applies the equivalent of manual memoization, ensuring that only the relevant parts of an app re-render as state changes, which is sometimes referred to as “fine-grained reactivity”. In the above example, React Compiler determines that the return value of `<FriendListCard />` can be reused even as `friends` changes, and can avoid recreating this JSX *and* avoid re-rendering `<MessageButton>` as the count changes.

#### Expensive calculations also get memoized

React Compiler can also automatically memoize expensive calculations used during rendering:

```
// **Not** memoized by React Compiler, since this is not a component or hook

function expensivelyProcessAReallyLargeArrayOfObjects() { /* ... */ }

// Memoized by React Compiler since this is a component

function TableContainer({ items }) {

// This function call would be memoized:

const data = expensivelyProcessAReallyLargeArrayOfObjects(items);

// ...

}
```

[*See this example in the React Compiler Playground*](https://playground.react.dev/#N4Igzg9grgTgxgUxALhAejQAgFTYHIQAuumAtgqRAJYBeCAJpgEYCemASggIZyGYDCEUgAcqAGwQwANJjBUAdokyEAFlTCZ1meUUxdMcIcIjyE8vhBiYVECAGsAOvIBmURYSonMCAB7CzcgBuCGIsAAowEIhgYACCnFxioQAyXDAA5gixMDBcLADyzvlMAFYIvGAAFACUmMCYaNiYAHStOFgAvk5OGJgAshTUdIysHNy8AkbikrIKSqpaWvqGIiZmhE6u7p7ymAAqXEwSguZcCpKV9VSEFBodtcBOmAYmYHz0XIT6ALzefgFUYKhCJRBAxeLcJIsVIZLI5PKFYplCqVa63aoAbm6u0wMAQhFguwAPPRAQA+YAfL4dIloUmBMlODogDpAA)

However, if `expensivelyProcessAReallyLargeArrayOfObjects` is truly an expensive function, you may want to consider implementing its own memoization outside of React, because:

* React Compiler only memoizes React components and hooks, not every function
* React Compiler’s memoization is not shared across multiple components or hooks

So if `expensivelyProcessAReallyLargeArrayOfObjects` was used in many different components, even if the same exact items were passed down, that expensive calculation would be run repeatedly. We recommend [profiling](https://react.dev/reference/react/useMemo#how-to-tell-if-a-calculation-is-expensive) first to see if it really is that expensive before making code more complicated.

## Should I try out the compiler?

We encourage everyone to start using React Compiler. While the compiler is still an optional addition to React today, in the future some features may require the compiler in order to fully work.

### Is it safe to use?

React Compiler is now stable and has been tested extensively in production. While it has been used in production at companies like Meta, rolling out the compiler to production for your app will depend on the health of your codebase and how well you’ve followed the [Rules of React](https://react.dev/reference/rules).

## What build tools are supported?

React Compiler can be installed across [several build tools](https://react.dev/learn/react-compiler/installation) such as Babel, Vite, Metro, and Rsbuild.

React Compiler is primarily a light Babel plugin wrapper around the core compiler, which was designed to be decoupled from Babel itself. While the initial stable version of the compiler will remain primarily a Babel plugin, we are working with the swc and [oxc](https://github.com/oxc-project/oxc/issues/10048) teams to build first class support for React Compiler so you won’t have to add Babel back to your build pipelines in the future.

Next.js users can enable the swc-invoked React Compiler by using [v15.3.1](https://github.com/vercel/next.js/releases/tag/v15.3.1) and up.

## What should I do about useMemo, useCallback, and React.memo?

By default, React Compiler will memoize your code based on its analysis and heuristics. In most cases, this memoization will be as precise, or moreso, than what you may have written.

However, in some cases developers may need more control over memoization. The `useMemo` and `useCallback` hooks can continue to be used with React Compiler as an escape hatch to provide control over which values are memoized. A common use-case for this is if a memoized value is used as an effect dependency, in order to ensure that an effect does not fire repeatedly even when its dependencies do not meaningfully change.

For new code, we recommend relying on the compiler for memoization and using `useMemo`/`useCallback` where needed to achieve precise control.

For existing code, we recommend either leaving existing memoization in place (removing it can change compilation output) or carefully testing before removing the memoization.

## Try React Compiler

This section will help you get started with React Compiler and understand how to use it effectively in your projects.

* **[Installation](https://react.dev/learn/react-compiler/installation)** - Install React Compiler and configure it for your build tools
* **[React Version Compatibility](https://react.dev/reference/react-compiler/target)** - Support for React 17, 18, and 19
* **[Configuration](https://react.dev/reference/react-compiler/configuration)** - Customize the compiler for your specific needs
* **[Incremental Adoption](https://react.dev/learn/react-compiler/incremental-adoption)** - Strategies for gradually rolling out the compiler in existing codebases
* **[Debugging and Troubleshooting](https://react.dev/learn/react-compiler/debugging)** - Identify and fix issues when using the compiler
* **[Compiling Libraries](https://react.dev/reference/react-compiler/compiling-libraries)** - Best practices for shipping compiled code
* **[API Reference](https://react.dev/reference/react-compiler/configuration)** - Detailed documentation of all configuration options

## Additional resources

In addition to these docs, we recommend checking the [React Compiler Working Group](https://github.com/reactwg/react-compiler) for additional information and discussion about the compiler.

[PreviousReact Compiler](https://react.dev/learn/react-compiler)[NextInstallation](https://react.dev/learn/react-compiler/installation)

---

---


# Installation – React

URL: https://react.dev/learn/react-compiler/installation

[Learn React](https://react.dev/learn)

[React Compiler](https://react.dev/learn/react-compiler)

# Installation

This guide will help you install and configure React Compiler in your React application.

### You will learn

* How to install React Compiler
* Basic configuration for different build tools
* How to verify your setup is working

## Prerequisites

React Compiler is designed to work best with React 19, but it also supports React 17 and 18. Learn more about [React version compatibility](https://react.dev/reference/react-compiler/target).

## Installation

Install React Compiler as a `devDependency`:

Terminal

Copy

```
npm install -D babel-plugin-react-compiler@latest
```

Or with Yarn:

Terminal

Copy

```
yarn add -D babel-plugin-react-compiler@latest
```

Or with pnpm:

Terminal

Copy

```
pnpm install -D babel-plugin-react-compiler@latest
```

## Basic Setup

React Compiler is designed to work by default without any configuration. However, if you need to configure it in special circumstances (for example, to target React versions below 19), refer to the [compiler options reference](https://react.dev/reference/react-compiler/configuration).

The setup process depends on your build tool. React Compiler includes a Babel plugin that integrates with your build pipeline.

### Pitfall

React Compiler must run **first** in your Babel plugin pipeline. The compiler needs the original source information for proper analysis, so it must process your code before other transformations.

### Babel

Create or update your `babel.config.js`:

```
module.exports = {

plugins: [

'babel-plugin-react-compiler', // must run first!

// ... other plugins

],

// ... other config

};
```

### Vite

If you use Vite, you can add the plugin to vite-plugin-react:

```
// vite.config.js

import { defineConfig } from 'vite';

import react from '@vitejs/plugin-react';

export default defineConfig({

plugins: [

react({

babel: {

plugins: ['babel-plugin-react-compiler'],

},

}),

],

});
```

Alternatively, if you prefer a separate Babel plugin for Vite:

Terminal

Copy

```
npm install -D vite-plugin-babel
```

```
// vite.config.js

import babel from 'vite-plugin-babel';

import { defineConfig } from 'vite';

import react from '@vitejs/plugin-react';

export default defineConfig({

plugins: [

react(),

babel({

babelConfig: {

plugins: ['babel-plugin-react-compiler'],

},

}),

],

});
```

### Next.js

Please refer to the [Next.js docs](https://nextjs.org/docs/app/api-reference/next-config-js/reactCompiler) for more information.

### React Router

Install `vite-plugin-babel`, and add the compiler’s Babel plugin to it:

Terminal

Copy

```
npm install vite-plugin-babel
```

```
// vite.config.js

import { defineConfig } from "vite";

import babel from "vite-plugin-babel";

import { reactRouter } from "@react-router/dev/vite";

const ReactCompilerConfig = { /* ... */ };

export default defineConfig({

plugins: [

reactRouter(),

babel({

filter: /\.[jt]sx?$/,

babelConfig: {

presets: ["@babel/preset-typescript"], // if you use TypeScript

plugins: [

["babel-plugin-react-compiler", ReactCompilerConfig],

],

},

}),

],

});
```

### Webpack

A community webpack loader is [now available here](https://github.com/SukkaW/react-compiler-webpack).

### Expo

Please refer to [Expo’s docs](https://docs.expo.dev/guides/react-compiler/) to enable and use the React Compiler in Expo apps.

### Metro (React Native)

React Native uses Babel via Metro, so refer to the [Usage with Babel](https://react.dev/learn/react-compiler/installation#babel) section for installation instructions.

### Rspack

Please refer to [Rspack’s docs](https://rspack.dev/guide/tech/react#react-compiler) to enable and use the React Compiler in Rspack apps.

### Rsbuild

Please refer to [Rsbuild’s docs](https://rsbuild.dev/guide/framework/react#react-compiler) to enable and use the React Compiler in Rsbuild apps.

## ESLint Integration

React Compiler includes an ESLint rule that helps identify code that can’t be optimized. When the ESLint rule reports an error, it means the compiler will skip optimizing that specific component or hook. This is safe: the compiler will continue optimizing other parts of your codebase. You don’t need to fix all violations immediately. Address them at your own pace to gradually increase the number of optimized components.

Install the ESLint plugin:

Terminal

Copy

```
npm install -D eslint-plugin-react-hooks@latest
```

If you haven’t already configured eslint-plugin-react-hooks, follow the [installation instructions in the readme](https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md#installation). The compiler rules are available in the `recommended-latest` preset.

The ESLint rule will:

* Identify violations of the [Rules of React](https://react.dev/reference/rules)
* Show which components can’t be optimized
* Provide helpful error messages for fixing issues

## Verify Your Setup

After installation, verify that React Compiler is working correctly.

### Check React DevTools

Components optimized by React Compiler will show a “Memo ✨” badge in React DevTools:

1. Install the [React Developer Tools](https://react.dev/learn/react-developer-tools) browser extension
2. Open your app in development mode
3. Open React DevTools
4. Look for the ✨ emoji next to component names

If the compiler is working:

* Components will show a “Memo ✨” badge in React DevTools
* Expensive calculations will be automatically memoized
* No manual `useMemo` is required

### Check Build Output

You can also verify the compiler is running by checking your build output. The compiled code will include automatic memoization logic that the compiler adds automatically.

```
import { c as _c } from "react/compiler-runtime";

export default function MyApp() {

const $ = _c(1);

let t0;

if ($[0] === Symbol.for("react.memo_cache_sentinel")) {

t0 = <div>Hello World</div>;

$[0] = t0;

} else {

t0 = $[0];

}

return t0;

}
```

## Troubleshooting

### Opting out specific components

If a component is causing issues after compilation, you can temporarily opt it out using the `"use no memo"` directive:

```
function ProblematicComponent() {

"use no memo";

// Component code here

}
```

This tells the compiler to skip optimization for this specific component. You should fix the underlying issue and remove the directive once resolved.

For more troubleshooting help, see the [debugging guide](https://react.dev/learn/react-compiler/debugging).

## Next Steps

Now that you have React Compiler installed, learn more about:

* [React version compatibility](https://react.dev/reference/react-compiler/target) for React 17 and 18
* [Configuration options](https://react.dev/reference/react-compiler/configuration) to customize the compiler
* [Incremental adoption strategies](https://react.dev/learn/react-compiler/incremental-adoption) for existing codebases
* [Debugging techniques](https://react.dev/learn/react-compiler/debugging) for troubleshooting issues
* [Compiling Libraries guide](https://react.dev/reference/react-compiler/compiling-libraries) for compiling your React library

[PreviousIntroduction](https://react.dev/learn/react-compiler/introduction)[NextIncremental Adoption](https://react.dev/learn/react-compiler/incremental-adoption)

---

---


# Incremental Adoption – React

URL: https://react.dev/learn/react-compiler/incremental-adoption

[Learn React](https://react.dev/learn)

[React Compiler](https://react.dev/learn/react-compiler)

# Incremental Adoption

React Compiler can be adopted incrementally, allowing you to try it on specific parts of your codebase first. This guide shows you how to gradually roll out the compiler in existing projects.

### You will learn

* Why incremental adoption is recommended
* Using Babel overrides for directory-based adoption
* Using the “use memo” directive for opt-in compilation
* Using the “use no memo” directive to exclude components
* Runtime feature flags with gating
* Monitoring your adoption progress

## Why Incremental Adoption?

React Compiler is designed to optimize your entire codebase automatically, but you don’t have to adopt it all at once. Incremental adoption gives you control over the rollout process, letting you test the compiler on small parts of your app before expanding to the rest.

Starting small helps you build confidence in the compiler’s optimizations. You can verify that your app behaves correctly with compiled code, measure performance improvements, and identify any edge cases specific to your codebase. This approach is especially valuable for production applications where stability is critical.

Incremental adoption also makes it easier to address any Rules of React violations the compiler might find. Instead of fixing violations across your entire codebase at once, you can tackle them systematically as you expand compiler coverage. This keeps the migration manageable and reduces the risk of introducing bugs.

By controlling which parts of your code get compiled, you can also run A/B tests to measure the real-world impact of the compiler’s optimizations. This data helps you make informed decisions about full adoption and demonstrates the value to your team.

## Approaches to Incremental Adoption

There are three main approaches to adopt React Compiler incrementally:

1. **Babel overrides** - Apply the compiler to specific directories
2. **Opt-in with “use memo”** - Only compile components that explicitly opt in
3. **Runtime gating** - Control compilation with feature flags

All approaches allow you to test the compiler on specific parts of your application before full rollout.

## Directory-Based Adoption with Babel Overrides

Babel’s `overrides` option lets you apply different plugins to different parts of your codebase. This is ideal for gradually adopting React Compiler directory by directory.

### Basic Configuration

Start by applying the compiler to a specific directory:

```
// babel.config.js

module.exports = {

plugins: [

// Global plugins that apply to all files

],

overrides: [

{

test: './src/modern/**/*.{js,jsx,ts,tsx}',

plugins: [

'babel-plugin-react-compiler'

]

}

]

};
```

### Expanding Coverage

As you gain confidence, add more directories:

```
// babel.config.js

module.exports = {

plugins: [

// Global plugins

],

overrides: [

{

test: ['./src/modern/**/*.{js,jsx,ts,tsx}', './src/features/**/*.{js,jsx,ts,tsx}'],

plugins: [

'babel-plugin-react-compiler'

]

},

{

test: './src/legacy/**/*.{js,jsx,ts,tsx}',

plugins: [

// Different plugins for legacy code

]

}

]

};
```

### With Compiler Options

You can also configure compiler options per override:

```
// babel.config.js

module.exports = {

plugins: [],

overrides: [

{

test: './src/experimental/**/*.{js,jsx,ts,tsx}',

plugins: [

['babel-plugin-react-compiler', {

// options ...

}]

]

},

{

test: './src/production/**/*.{js,jsx,ts,tsx}',

plugins: [

['babel-plugin-react-compiler', {

// options ...

}]

]

}

]

};
```

## Opt-in Mode with “use memo”

For maximum control, you can use `compilationMode: 'annotation'` to only compile components and hooks that explicitly opt in with the `"use memo"` directive.

### Note

This approach gives you fine-grained control over individual components and hooks. It’s useful when you want to test the compiler on specific components without affecting entire directories.

### Annotation Mode Configuration

```
// babel.config.js

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

compilationMode: 'annotation',

}],

],

};
```

### Using the Directive

Add `"use memo"` at the beginning of functions you want to compile:

```
function TodoList({ todos }) {

"use memo"; // Opt this component into compilation

const sortedTodos = todos.slice().sort();

return (

<ul>

{sortedTodos.map(todo => (

<TodoItem key={todo.id} todo={todo} />

))}

</ul>

);

}

function useSortedData(data) {

"use memo"; // Opt this hook into compilation

return data.slice().sort();

}
```

With `compilationMode: 'annotation'`, you must:

* Add `"use memo"` to every component you want optimized
* Add `"use memo"` to every custom hook
* Remember to add it to new components

This gives you precise control over which components are compiled while you evaluate the compiler’s impact.

## Runtime Feature Flags with Gating

The `gating` option enables you to control compilation at runtime using feature flags. This is useful for running A/B tests or gradually rolling out the compiler based on user segments.

### How Gating Works

The compiler wraps optimized code in a runtime check. If the gate returns `true`, the optimized version runs. Otherwise, the original code runs.

### Gating Configuration

```
// babel.config.js

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

gating: {

source: 'ReactCompilerFeatureFlags',

importSpecifierName: 'isCompilerEnabled',

},

}],

],

};
```

### Implementing the Feature Flag

Create a module that exports your gating function:

```
// ReactCompilerFeatureFlags.js

export function isCompilerEnabled() {

// Use your feature flag system

return getFeatureFlag('react-compiler-enabled');

}
```

## Troubleshooting Adoption

If you encounter issues during adoption:

1. Use `"use no memo"` to temporarily exclude problematic components
2. Check the [debugging guide](https://react.dev/learn/react-compiler/debugging) for common issues
3. Fix Rules of React violations identified by the ESLint plugin
4. Consider using `compilationMode: 'annotation'` for more gradual adoption

## Next Steps

* Read the [configuration guide](https://react.dev/reference/react-compiler/configuration) for more options
* Learn about [debugging techniques](https://react.dev/learn/react-compiler/debugging)
* Check the [API reference](https://react.dev/reference/react-compiler/configuration) for all compiler options

[PreviousInstallation](https://react.dev/learn/react-compiler/installation)[NextDebugging and Troubleshooting](https://react.dev/learn/react-compiler/debugging)

---

---


# Debugging and Troubleshooting – React

URL: https://react.dev/learn/react-compiler/debugging

[Learn React](https://react.dev/learn)

[React Compiler](https://react.dev/learn/react-compiler)

# Debugging and Troubleshooting

This guide helps you identify and fix issues when using React Compiler. Learn how to debug compilation problems and resolve common issues.

### You will learn

* The difference between compiler errors and runtime issues
* Common patterns that break compilation
* Step-by-step debugging workflow

## Understanding Compiler Behavior

React Compiler is designed to handle code that follows the [Rules of React](https://react.dev/reference/rules). When it encounters code that might break these rules, it safely skips optimization rather than risk changing your app’s behavior.

### Compiler Errors vs Runtime Issues

**Compiler errors** occur at build time and prevent your code from compiling. These are rare because the compiler is designed to skip problematic code rather than fail.

**Runtime issues** occur when compiled code behaves differently than expected. Most of the time, if you encounter an issue with React Compiler, it’s a runtime issue. This typically happens when your code violates the Rules of React in subtle ways that the compiler couldn’t detect, and the compiler mistakenly compiled a component it should have skipped.

When debugging runtime issues, focus your efforts on finding Rules of React violations in the affected components that were not detected by the ESLint rule. The compiler relies on your code following these rules, and when they’re broken in ways it can’t detect, that’s when runtime problems occur.

## Common Breaking Patterns

One of the main ways React Compiler can break your app is if your code was written to rely on memoization for correctness. This means your app depends on specific values being memoized to work properly. Since the compiler may memoize differently than your manual approach, this can lead to unexpected behavior like effects over-firing, infinite loops, or missing updates.

Common scenarios where this occurs:

* **Effects that rely on referential equality** - When effects depend on objects or arrays maintaining the same reference across renders
* **Dependency arrays that need stable references** - When unstable dependencies cause effects to fire too often or create infinite loops
* **Conditional logic based on reference checks** - When code uses referential equality checks for caching or optimization

## Debugging Workflow

Follow these steps when you encounter issues:

### Compiler Build Errors

If you encounter a compiler error that unexpectedly breaks your build, this is likely a bug in the compiler. Report it to the [facebook/react](https://github.com/facebook/react/issues) repository with:

* The error message
* The code that caused the error
* Your React and compiler versions

### Runtime Issues

For runtime behavior issues:

### 1. Temporarily Disable Compilation

Use `"use no memo"` to isolate whether an issue is compiler-related:

```
function ProblematicComponent() {

"use no memo"; // Skip compilation for this component

// ... rest of component

}
```

If the issue disappears, it’s likely related to a Rules of React violation.

You can also try removing manual memoization (useMemo, useCallback, memo) from the problematic component to verify that your app works correctly without any memoization. If the bug still occurs when all memoization is removed, you have a Rules of React violation that needs to be fixed.

### 2. Fix Issues Step by Step

1. Identify the root cause (often memoization-for-correctness)
2. Test after each fix
3. Remove `"use no memo"` once fixed
4. Verify the component shows the ✨ badge in React DevTools

## Reporting Compiler Bugs

If you believe you’ve found a compiler bug:

1. **Verify it’s not a Rules of React violation** - Check with ESLint
2. **Create a minimal reproduction** - Isolate the issue in a small example
3. **Test without the compiler** - Confirm the issue only occurs with compilation
4. **File an [issue](https://github.com/facebook/react/issues/new?template=compiler_bug_report.yml)**:
   * React and compiler versions
   * Minimal reproduction code
   * Expected vs actual behavior
   * Any error messages

## Next Steps

* Review the [Rules of React](https://react.dev/reference/rules) to prevent issues
* Check the [incremental adoption guide](https://react.dev/learn/react-compiler/incremental-adoption) for gradual rollout strategies

[PreviousIncremental Adoption](https://react.dev/learn/react-compiler/incremental-adoption)

---

---


# Describing the UI – React

URL: https://react.dev/learn/describing-the-ui

[Learn React](https://react.dev/learn)

# Describing the UI

React is a JavaScript library for rendering user interfaces (UI). UI is built from small units like buttons, text, and images. React lets you combine them into reusable, nestable *components.* From web sites to phone apps, everything on the screen can be broken down into components. In this chapter, you’ll learn to create, customize, and conditionally display React components.

### In this chapter

* [How to write your first React component](https://react.dev/learn/your-first-component)
* [When and how to create multi-component files](https://react.dev/learn/importing-and-exporting-components)
* [How to add markup to JavaScript with JSX](https://react.dev/learn/writing-markup-with-jsx)
* [How to use curly braces with JSX to access JavaScript functionality from your components](https://react.dev/learn/javascript-in-jsx-with-curly-braces)
* [How to configure components with props](https://react.dev/learn/passing-props-to-a-component)
* [How to conditionally render components](https://react.dev/learn/conditional-rendering)
* [How to render multiple components at a time](https://react.dev/learn/rendering-lists)
* [How to avoid confusing bugs by keeping components pure](https://react.dev/learn/keeping-components-pure)
* [Why understanding your UI as trees is useful](https://react.dev/learn/understanding-your-ui-as-a-tree)

## Your first component

React applications are built from isolated pieces of UI called *components*. A React component is a JavaScript function that you can sprinkle with markup. Components can be as small as a button, or as large as an entire page. Here is a `Gallery` component rendering three `Profile` components:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Profile() {
  return (
    <img
      src="https://i.imgur.com/MK3eW3As.jpg"
      alt="Katherine Johnson"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```

Show more

## Ready to learn this topic?

Read **[Your First Component](https://react.dev/learn/your-first-component)** to learn how to declare and use React components.

[Read More](https://react.dev/learn/your-first-component)

---

## Importing and exporting components

You can declare many components in one file, but large files can get difficult to navigate. To solve this, you can *export* a component into its own file, and then *import* that component from another file:

Gallery.jsProfile.js

Gallery.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Profile from './Profile.js';

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```

## Ready to learn this topic?

Read **[Importing and Exporting Components](https://react.dev/learn/importing-and-exporting-components)** to learn how to split components into their own files.

[Read More](https://react.dev/learn/importing-and-exporting-components)

---

## Writing markup with JSX

Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information.

If we paste existing HTML markup into a React component, it won’t always work:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function TodoList() {
  return (
    // This doesn't quite work!
    <h1>Hedy Lamarr's Todos</h1>
    <img
      src="https://i.imgur.com/yXOvdOSs.jpg"
      alt="Hedy Lamarr"
      class="photo"
    >
    <ul>
      <li>Invent new traffic lights
      <li>Rehearse a movie scene
      <li>Improve spectrum technology
    </ul>
```

Show more

If you have existing HTML like this, you can fix it using a [converter](https://transform.tools/html-to-jsx):

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function TodoList() {
  return (
    <>
      <h1>Hedy Lamarr's Todos</h1>
      <img
        src="https://i.imgur.com/yXOvdOSs.jpg"
        alt="Hedy Lamarr"
        className="photo"
      />
      <ul>
        <li>Invent new traffic lights</li>
        <li>Rehearse a movie scene</li>
        <li>Improve spectrum technology</li>
      </ul>
    </>
  );
}
```

Show more

## Ready to learn this topic?

Read **[Writing Markup with JSX](https://react.dev/learn/writing-markup-with-jsx)** to learn how to write valid JSX.

[Read More](https://react.dev/learn/writing-markup-with-jsx)

---

## JavaScript in JSX with curly braces

JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to “open a window” to JavaScript:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img
        className="avatar"
        src="https://i.imgur.com/7vQD0fPs.jpg"
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```

Show more

## Ready to learn this topic?

Read **[JavaScript in JSX with Curly Braces](https://react.dev/learn/javascript-in-jsx-with-curly-braces)** to learn how to access JavaScript data from JSX.

[Read More](https://react.dev/learn/javascript-in-jsx-with-curly-braces)

---

## Passing props to a component

React components use *props* to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, functions, and even JSX!

App.jsutils.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { getImageUrl } from './utils.js'

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}

function Avatar({ person, size }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person)}
      alt={person.name}
      width={size}
      height={size}
    />
  );
}

function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}
```

Show more

## Ready to learn this topic?

Read **[Passing Props to a Component](https://react.dev/learn/passing-props-to-a-component)** to learn how to pass and read props.

[Read More](https://react.dev/learn/passing-props-to-a-component)

---

## Conditional rendering

Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax like `if` statements, `&&`, and `? :` operators.

In this example, the JavaScript `&&` operator is used to conditionally render a checkmark:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✅'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item
          isPacked={true}
          name="Space suit"
        />
        <Item
          isPacked={true}
          name="Helmet with a golden leaf"
        />
        <Item
          isPacked={false}
          name="Photo of Tam"
        />
      </ul>
    </section>
  );
}
```

Show more

## Ready to learn this topic?

Read **[Conditional Rendering](https://react.dev/learn/conditional-rendering)** to learn the different ways to render content conditionally.

[Read More](https://react.dev/learn/conditional-rendering)

---

## Rendering lists

You will often want to display multiple similar components from a collection of data. You can use JavaScript’s `filter()` and `map()` with React to filter and transform your array of data into an array of components.

For each array item, you will need to specify a `key`. Usually, you will want to use an ID from the database as a `key`. Keys let React keep track of each item’s place in the list even if the list changes.

App.jsdata.jsutils.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { people } from './data.js';
import { getImageUrl } from './utils.js';

export default function List() {
  const listItems = people.map(person =>
    <li key={person.id}>
      <img
        src={getImageUrl(person)}
        alt={person.name}
      />
      <p>
        <b>{person.name}:</b>
        {' ' + person.profession + ' '}
        known for {person.accomplishment}
      </p>
    </li>
  );
  return (
    <article>
      <h1>Scientists</h1>
      <ul>{listItems}</ul>
    </article>
  );
}
```

Show more

## Ready to learn this topic?

Read **[Rendering Lists](https://react.dev/learn/rendering-lists)** to learn how to render a list of components, and how to choose a key.

[Read More](https://react.dev/learn/rendering-lists)

---

## Keeping components pure

Some JavaScript functions are *pure.* A pure function:

* **Minds its own business.** It does not change any objects or variables that existed before it was called.
* **Same inputs, same output.** Given the same inputs, a pure function should always return the same result.

By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. Here is an example of an impure component:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

Show more

You can make this component pure by passing a prop instead of modifying a preexisting variable:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

## Ready to learn this topic?

Read **[Keeping Components Pure](https://react.dev/learn/keeping-components-pure)** to learn how to write components as pure, predictable functions.

[Read More](https://react.dev/learn/keeping-components-pure)

---

## Your UI as a tree

React uses trees to model the relationships between components and modules.

A React render tree is a representation of the parent and child relationship between components.

![A tree graph with five nodes, with each node representing a component. The root node is located at the top the tree graph and is labelled 'Root Component'. It has two arrows extending down to two nodes labelled 'Component A' and 'Component C'. Each of the arrows is labelled with 'renders'. 'Component A' has a single 'renders' arrow to a node labelled 'Component B'. 'Component C' has a single 'renders' arrow to a node labelled 'Component D'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fgeneric_render_tree.dark.png&w=1080&q=75)

![A tree graph with five nodes, with each node representing a component. The root node is located at the top the tree graph and is labelled 'Root Component'. It has two arrows extending down to two nodes labelled 'Component A' and 'Component C'. Each of the arrows is labelled with 'renders'. 'Component A' has a single 'renders' arrow to a node labelled 'Component B'. 'Component C' has a single 'renders' arrow to a node labelled 'Component D'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fgeneric_render_tree.png&w=1080&q=75)

An example React render tree.

Components near the top of the tree, near the root component, are considered top-level components. Components with no child components are leaf components. This categorization of components is useful for understanding data flow and rendering performance.

Modelling the relationship between JavaScript modules is another useful way to understand your app. We refer to it as a module dependency tree.

![A tree graph with five nodes. Each node represents a JavaScript module. The top-most node is labelled 'RootModule.js'. It has three arrows extending to the nodes: 'ModuleA.js', 'ModuleB.js', and 'ModuleC.js'. Each arrow is labelled as 'imports'. 'ModuleC.js' node has a single 'imports' arrow that points to a node labelled 'ModuleD.js'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fgeneric_dependency_tree.dark.png&w=1080&q=75)

![A tree graph with five nodes. Each node represents a JavaScript module. The top-most node is labelled 'RootModule.js'. It has three arrows extending to the nodes: 'ModuleA.js', 'ModuleB.js', and 'ModuleC.js'. Each arrow is labelled as 'imports'. 'ModuleC.js' node has a single 'imports' arrow that points to a node labelled 'ModuleD.js'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fgeneric_dependency_tree.png&w=1080&q=75)

An example module dependency tree.

A dependency tree is often used by build tools to bundle all the relevant JavaScript code for the client to download and render. A large bundle size regresses user experience for React apps. Understanding the module dependency tree is helpful to debug such issues.

## Ready to learn this topic?

Read **[Your UI as a Tree](https://react.dev/learn/understanding-your-ui-as-a-tree)** to learn how to create a render and module dependency trees for a React app and how they’re useful mental models for improving user experience and performance.

[Read More](https://react.dev/learn/understanding-your-ui-as-a-tree)

---

## What’s next?

Head over to [Your First Component](https://react.dev/learn/your-first-component) to start reading this chapter page by page!

Or, if you’re already familiar with these topics, why not read about [Adding Interactivity](https://react.dev/learn/adding-interactivity)?

[NextYour First Component](https://react.dev/learn/your-first-component)

---

---


# Your First Component – React

URL: https://react.dev/learn/your-first-component

[Learn React](https://react.dev/learn)

[Describing the UI](https://react.dev/learn/describing-the-ui)

# Your First Component

*Components* are one of the core concepts of React. They are the foundation upon which you build user interfaces (UI), which makes them the perfect place to start your React journey!

### You will learn

* What a component is
* What role components play in a React application
* How to write your first React component

## Components: UI building blocks

On the Web, HTML lets us create rich structured documents with its built-in set of tags like `<h1>` and `<li>`:

```
<article>

<h1>My First Component</h1>

<ol>

<li>Components: UI Building Blocks</li>

<li>Defining a Component</li>

<li>Using a Component</li>

</ol>

</article>
```

This markup represents this article `<article>`, its heading `<h1>`, and an (abbreviated) table of contents as an ordered list `<ol>`. Markup like this, combined with CSS for style, and JavaScript for interactivity, lies behind every sidebar, avatar, modal, dropdown—every piece of UI you see on the Web.

React lets you combine your markup, CSS, and JavaScript into custom “components”, **reusable UI elements for your app.** The table of contents code you saw above could be turned into a `<TableOfContents />` component you could render on every page. Under the hood, it still uses the same HTML tags like `<article>`, `<h1>`, etc.

Just like with HTML tags, you can compose, order and nest components to design whole pages. For example, the documentation page you’re reading is made out of React components:

```
<PageLayout>

<NavigationHeader>

<SearchBar />

<Link to="/docs">Docs</Link>

</NavigationHeader>

<Sidebar />

<PageContent>

<TableOfContents />

<DocumentationText />

</PageContent>

</PageLayout>
```

As your project grows, you will notice that many of your designs can be composed by reusing components you already wrote, speeding up your development. Our table of contents above could be added to any screen with `<TableOfContents />`! You can even jumpstart your project with the thousands of components shared by the React open source community like [Chakra UI](https://chakra-ui.com/) and [Material UI.](https://material-ui.com/)

## Defining a component

Traditionally when creating web pages, web developers marked up their content and then added interaction by sprinkling on some JavaScript. This worked great when interaction was a nice-to-have on the web. Now it is expected for many sites and all apps. React puts interactivity first while still using the same technology: **a React component is a JavaScript function that you can *sprinkle with markup*.** Here’s what that looks like (you can edit the example below):

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Profile() {
  return (
    <img
      src="https://i.imgur.com/MK3eW3Am.jpg"
      alt="Katherine Johnson"
    />
  )
}
```

And here’s how to build a component:

### Step 1: Export the component

The `export default` prefix is a [standard JavaScript syntax](https://developer.mozilla.org/docs/web/javascript/reference/statements/export) (not specific to React). It lets you mark the main function in a file so that you can later import it from other files. (More on importing in [Importing and Exporting Components](https://react.dev/learn/importing-and-exporting-components)!)

### Step 2: Define the function

With `function Profile() { }` you define a JavaScript function with the name `Profile`.

### Pitfall

React components are regular JavaScript functions, but **their names must start with a capital letter** or they won’t work!

### Step 3: Add markup

The component returns an `<img />` tag with `src` and `alt` attributes. `<img />` is written like HTML, but it is actually JavaScript under the hood! This syntax is called [JSX](https://react.dev/learn/writing-markup-with-jsx), and it lets you embed markup inside JavaScript.

Return statements can be written all on one line, as in this component:

```
return <img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />;
```

But if your markup isn’t all on the same line as the `return` keyword, you must wrap it in a pair of parentheses:

```
return (

<div>

<img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />

</div>

);
```

### Pitfall

Without parentheses, any code on the lines after `return` [will be ignored](https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi)!

## Using a component

Now that you’ve defined your `Profile` component, you can nest it inside other components. For example, you can export a `Gallery` component that uses multiple `Profile` components:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Profile() {
  return (
    <img
      src="https://i.imgur.com/MK3eW3As.jpg"
      alt="Katherine Johnson"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```

Show more

### What the browser sees

Notice the difference in casing:

* `<section>` is lowercase, so React knows we refer to an HTML tag.
* `<Profile />` starts with a capital `P`, so React knows that we want to use our component called `Profile`.

And `Profile` contains even more HTML: `<img />`. In the end, this is what the browser sees:

```
<section>

<h1>Amazing scientists</h1>

<img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />

<img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />

<img src="https://i.imgur.com/MK3eW3As.jpg" alt="Katherine Johnson" />

</section>
```

### Nesting and organizing components

Components are regular JavaScript functions, so you can keep multiple components in the same file. This is convenient when components are relatively small or tightly related to each other. If this file gets crowded, you can always move `Profile` to a separate file. You will learn how to do this shortly on the [page about imports.](https://react.dev/learn/importing-and-exporting-components)

Because the `Profile` components are rendered inside `Gallery`—even several times!—we can say that `Gallery` is a **parent component,** rendering each `Profile` as a “child”. This is part of the magic of React: you can define a component once, and then use it in as many places and as many times as you like.

### Pitfall

Components can render other components, but **you must never nest their definitions:**

```
export default function Gallery() {

// 🔴 Never define a component inside another component!

function Profile() {

// ...

}

// ...

}
```

The snippet above is [very slow and causes bugs.](https://react.dev/learn/preserving-and-resetting-state#different-components-at-the-same-position-reset-state) Instead, define every component at the top level:

```
export default function Gallery() {

// ...

}

// ✅ Declare components at the top level

function Profile() {

// ...

}
```

When a child component needs some data from a parent, [pass it by props](https://react.dev/learn/passing-props-to-a-component) instead of nesting definitions.

##### Deep Dive

#### Components all the way down

Show Details

Your React application begins at a “root” component. Usually, it is created automatically when you start a new project. For example, if you use [CodeSandbox](https://codesandbox.io/) or if you use the framework [Next.js](https://nextjs.org/), the root component is defined in `pages/index.js`. In these examples, you’ve been exporting root components.

Most React apps use components all the way down. This means that you won’t only use components for reusable pieces like buttons, but also for larger pieces like sidebars, lists, and ultimately, complete pages! Components are a handy way to organize UI code and markup, even if some of them are only used once.

[React-based frameworks](https://react.dev/learn/creating-a-react-app) take this a step further. Instead of using an empty HTML file and letting React “take over” managing the page with JavaScript, they *also* generate the HTML automatically from your React components. This allows your app to show some content before the JavaScript code loads.

Still, many websites only use React to [add interactivity to existing HTML pages.](https://react.dev/learn/add-react-to-an-existing-project#using-react-for-a-part-of-your-existing-page) They have many root components instead of a single one for the entire page. You can use as much—or as little—React as you need.

## Recap

You’ve just gotten your first taste of React! Let’s recap some key points.

* React lets you create components, **reusable UI elements for your app.**
* In a React app, every piece of UI is a component.
* React components are regular JavaScript functions except:

  1. Their names always begin with a capital letter.
  2. They return JSX markup.

## Try out some challenges

1. Export the component 2. Fix the return statement 3. Spot the mistake 4. Your own component

#### Challenge 1 of 4: Export the component

This sandbox doesn’t work because the root component is not exported:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Profile() {
  return (
    <img
      src="https://i.imgur.com/lICfvbD.jpg"
      alt="Aklilu Lemma"
    />
  );
}
```

Try to fix it yourself before looking at the solution!

Show solutionNext Challenge

[PreviousDescribing the UI](https://react.dev/learn/describing-the-ui)[NextImporting and Exporting Components](https://react.dev/learn/importing-and-exporting-components)

---

---


# Importing and Exporting Components – React

URL: https://react.dev/learn/importing-and-exporting-components

[Learn React](https://react.dev/learn)

[Describing the UI](https://react.dev/learn/describing-the-ui)

# Importing and Exporting Components

The magic of components lies in their reusability: you can create components that are composed of other components. But as you nest more and more components, it often makes sense to start splitting them into different files. This lets you keep your files easy to scan and reuse components in more places.

### You will learn

* What a root component file is
* How to import and export a component
* When to use default and named imports and exports
* How to import and export multiple components from one file
* How to split components into multiple files

## The root component file

In [Your First Component](https://react.dev/learn/your-first-component), you made a `Profile` component and a `Gallery` component that renders it:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Profile() {
  return (
    <img
      src="https://i.imgur.com/MK3eW3As.jpg"
      alt="Katherine Johnson"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```

Show more

These currently live in a **root component file,** named `App.js` in this example. Depending on your setup, your root component could be in another file, though. If you use a framework with file-based routing, such as Next.js, your root component will be different for every page.

## Exporting and importing a component

What if you want to change the landing screen in the future and put a list of science books there? Or place all the profiles somewhere else? It makes sense to move `Gallery` and `Profile` out of the root component file. This will make them more modular and reusable in other files. You can move a component in three steps:

1. **Make** a new JS file to put the components in.
2. **Export** your function component from that file (using either [default](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/export#using_the_default_export) or [named](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/export#using_named_exports) exports).
3. **Import** it in the file where you’ll use the component (using the corresponding technique for importing [default](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/import#importing_defaults) or [named](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/import#import_a_single_export_from_a_module) exports).

Here both `Profile` and `Gallery` have been moved out of `App.js` into a new file called `Gallery.js`. Now you can change `App.js` to import `Gallery` from `Gallery.js`:

App.jsGallery.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Gallery from './Gallery.js';

export default function App() {
  return (
    <Gallery />
  );
}
```

Notice how this example is broken down into two component files now:

1. `Gallery.js`:
   * Defines the `Profile` component which is only used within the same file and is not exported.
   * Exports the `Gallery` component as a **default export.**
2. `App.js`:
   * Imports `Gallery` as a **default import** from `Gallery.js`.
   * Exports the root `App` component as a **default export.**

### Note

You may encounter files that leave off the `.js` file extension like so:

```
import Gallery from './Gallery';
```

Either `'./Gallery.js'` or `'./Gallery'` will work with React, though the former is closer to how [native ES Modules](https://developer.mozilla.org/docs/Web/JavaScript/Guide/Modules) work.

##### Deep Dive

#### Default vs named exports

Show Details

There are two primary ways to export values with JavaScript: default exports and named exports. So far, our examples have only used default exports. But you can use one or both of them in the same file. **A file can have no more than one *default* export, but it can have as many *named* exports as you like.**

![Default and named exports](https://react.dev/images/docs/illustrations/i_import-export.svg)

How you export your component dictates how you must import it. You will get an error if you try to import a default export the same way you would a named export! This chart can help you keep track:

| Syntax | Export statement | Import statement |
| --- | --- | --- |
| Default | `export default function Button() {}` | `import Button from './Button.js';` |
| Named | `export function Button() {}` | `import { Button } from './Button.js';` |

When you write a *default* import, you can put any name you want after `import`. For example, you could write `import Banana from './Button.js'` instead and it would still provide you with the same default export. In contrast, with named imports, the name has to match on both sides. That’s why they are called *named* imports!

**People often use default exports if the file exports only one component, and use named exports if it exports multiple components and values.** Regardless of which coding style you prefer, always give meaningful names to your component functions and the files that contain them. Components without names, like `export default () => {}`, are discouraged because they make debugging harder.

## Exporting and importing multiple components from the same file

What if you want to show just one `Profile` instead of a gallery? You can export the `Profile` component, too. But `Gallery.js` already has a *default* export, and you can’t have *two* default exports. You could create a new file with a default export, or you could add a *named* export for `Profile`. **A file can only have one default export, but it can have numerous named exports!**

### Note

To reduce the potential confusion between default and named exports, some teams choose to only stick to one style (default or named), or avoid mixing them in a single file. Do what works best for you!

First, **export** `Profile` from `Gallery.js` using a named export (no `default` keyword):

```
export function Profile() {

// ...

}
```

Then, **import** `Profile` from `Gallery.js` to `App.js` using a named import (with the curly braces):

```
import { Profile } from './Gallery.js';
```

Finally, **render** `<Profile />` from the `App` component:

```
export default function App() {

return <Profile />;

}
```

Now `Gallery.js` contains two exports: a default `Gallery` export, and a named `Profile` export. `App.js` imports both of them. Try editing `<Profile />` to `<Gallery />` and back in this example:

App.jsGallery.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Gallery from './Gallery.js';
import { Profile } from './Gallery.js';

export default function App() {
  return (
    <Profile />
  );
}
```

Now you’re using a mix of default and named exports:

* `Gallery.js`:
  + Exports the `Profile` component as a **named export called `Profile`.**
  + Exports the `Gallery` component as a **default export.**
* `App.js`:
  + Imports `Profile` as a **named import called `Profile`** from `Gallery.js`.
  + Imports `Gallery` as a **default import** from `Gallery.js`.
  + Exports the root `App` component as a **default export.**

## Recap

On this page you learned:

* What a root component file is
* How to import and export a component
* When and how to use default and named imports and exports
* How to export multiple components from the same file

## Try out some challenges

#### Challenge 1 of 1: Split the components further

Currently, `Gallery.js` exports both `Profile` and `Gallery`, which is a bit confusing.

Move the `Profile` component to its own `Profile.js`, and then change the `App` component to render both `<Profile />` and `<Gallery />` one after another.

You may use either a default or a named export for `Profile`, but make sure that you use the corresponding import syntax in both `App.js` and `Gallery.js`! You can refer to the table from the deep dive above:

| Syntax | Export statement | Import statement |
| --- | --- | --- |
| Default | `export default function Button() {}` | `import Button from './Button.js';` |
| Named | `export function Button() {}` | `import { Button } from './Button.js';` |

App.jsGallery.jsProfile.js

Gallery.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
// Move me to Profile.js!
export function Profile() {
  return (
    <img
      src="https://i.imgur.com/QIrZWGIs.jpg"
      alt="Alan L. Hart"
    />
  );
}

export default function Gallery() {
  return (
    <section>
      <h1>Amazing scientists</h1>
      <Profile />
      <Profile />
      <Profile />
    </section>
  );
}
```

Show more

After you get it working with one kind of exports, make it work with the other kind.

Show hint Show solution

[PreviousYour First Component](https://react.dev/learn/your-first-component)[NextWriting Markup with JSX](https://react.dev/learn/writing-markup-with-jsx)

---

---


# Writing Markup with JSX – React

URL: https://react.dev/learn/writing-markup-with-jsx

[Learn React](https://react.dev/learn)

[Describing the UI](https://react.dev/learn/describing-the-ui)

# Writing Markup with JSX

*JSX* is a syntax extension for JavaScript that lets you write HTML-like markup inside a JavaScript file. Although there are other ways to write components, most React developers prefer the conciseness of JSX, and most codebases use it.

### You will learn

* Why React mixes markup with rendering logic
* How JSX is different from HTML
* How to display information with JSX

## JSX: Putting markup into JavaScript

The Web has been built on HTML, CSS, and JavaScript. For many years, web developers kept content in HTML, design in CSS, and logic in JavaScript—often in separate files! Content was marked up inside HTML while the page’s logic lived separately in JavaScript:

![HTML markup with purple background and a div with two child tags: p and form. ](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fwriting_jsx_html.dark.png&w=750&q=75)

![HTML markup with purple background and a div with two child tags: p and form. ](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fwriting_jsx_html.png&w=750&q=75)

HTML

![Three JavaScript handlers with yellow background: onSubmit, onLogin, and onClick.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fwriting_jsx_js.dark.png&w=750&q=75)

![Three JavaScript handlers with yellow background: onSubmit, onLogin, and onClick.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fwriting_jsx_js.png&w=750&q=75)

JavaScript

But as the Web became more interactive, logic increasingly determined content. JavaScript was in charge of the HTML! This is why **in React, rendering logic and markup live together in the same place—components.**

![React component with HTML and JavaScript from previous examples mixed. Function name is Sidebar which calls the function isLoggedIn, highlighted in yellow. Nested inside the function highlighted in purple is the p tag from before, and a Form tag referencing the component shown in the next diagram.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fwriting_jsx_sidebar.dark.png&w=750&q=75)

![React component with HTML and JavaScript from previous examples mixed. Function name is Sidebar which calls the function isLoggedIn, highlighted in yellow. Nested inside the function highlighted in purple is the p tag from before, and a Form tag referencing the component shown in the next diagram.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fwriting_jsx_sidebar.png&w=750&q=75)

`Sidebar.js` React component

![React component with HTML and JavaScript from previous examples mixed. Function name is Form containing two handlers onClick and onSubmit highlighted in yellow. Following the handlers is HTML highlighted in purple. The HTML contains a form element with a nested input element, each with an onClick prop.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fwriting_jsx_form.dark.png&w=750&q=75)

![React component with HTML and JavaScript from previous examples mixed. Function name is Form containing two handlers onClick and onSubmit highlighted in yellow. Following the handlers is HTML highlighted in purple. The HTML contains a form element with a nested input element, each with an onClick prop.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fwriting_jsx_form.png&w=750&q=75)

`Form.js` React component

Keeping a button’s rendering logic and markup together ensures that they stay in sync with each other on every edit. Conversely, details that are unrelated, such as the button’s markup and a sidebar’s markup, are isolated from each other, making it safer to change either of them on their own.

Each React component is a JavaScript function that may contain some markup that React renders into the browser. React components use a syntax extension called JSX to represent that markup. JSX looks a lot like HTML, but it is a bit stricter and can display dynamic information. The best way to understand this is to convert some HTML markup to JSX markup.

### Note

JSX and React are two separate things. They’re often used together, but you *can* [use them independently](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-a-jsx-transform) of each other. JSX is a syntax extension, while React is a JavaScript library.

## Converting HTML to JSX

Suppose that you have some (perfectly valid) HTML:

```
<h1>Hedy Lamarr's Todos</h1>

<img

src="https://i.imgur.com/yXOvdOSs.jpg"

alt="Hedy Lamarr"

class="photo"

>

<ul>

<li>Invent new traffic lights

<li>Rehearse a movie scene

<li>Improve the spectrum technology

</ul>
```

And you want to put it into your component:

```
export default function TodoList() {

return (

// ???

)

}
```

If you copy and paste it as is, it will not work:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function TodoList() {
  return (
    // This doesn't quite work!
    <h1>Hedy Lamarr's Todos</h1>
    <img 
      src="https://i.imgur.com/yXOvdOSs.jpg" 
      alt="Hedy Lamarr" 
      class="photo"
    >
    <ul>
      <li>Invent new traffic lights
      <li>Rehearse a movie scene
      <li>Improve the spectrum technology
    </ul>
```

Show more

This is because JSX is stricter and has a few more rules than HTML! If you read the error messages above, they’ll guide you to fix the markup, or you can follow the guide below.

### Note

Most of the time, React’s on-screen error messages will help you find where the problem is. Give them a read if you get stuck!

## The Rules of JSX

### 1. Return a single root element

To return multiple elements from a component, **wrap them with a single parent tag.**

For example, you can use a `<div>`:

```
<div>

<h1>Hedy Lamarr's Todos</h1>

<img

src="https://i.imgur.com/yXOvdOSs.jpg"

alt="Hedy Lamarr"

class="photo"

>

<ul>

...

</ul>

</div>
```

If you don’t want to add an extra `<div>` to your markup, you can write `<>` and `</>` instead:

```
<>

<h1>Hedy Lamarr's Todos</h1>

<img

src="https://i.imgur.com/yXOvdOSs.jpg"

alt="Hedy Lamarr"

class="photo"

>

<ul>

...

</ul>

</>
```

This empty tag is called a *[Fragment.](https://react.dev/reference/react/Fragment)* Fragments let you group things without leaving any trace in the browser HTML tree.

##### Deep Dive

#### Why do multiple JSX tags need to be wrapped?

Show Details

JSX looks like HTML, but under the hood it is transformed into plain JavaScript objects. You can’t return two objects from a function without wrapping them into an array. This explains why you also can’t return two JSX tags without wrapping them into another tag or a Fragment.

### 2. Close all the tags

JSX requires tags to be explicitly closed: self-closing tags like `<img>` must become `<img />`, and wrapping tags like `<li>oranges` must be written as `<li>oranges</li>`.

This is how Hedy Lamarr’s image and list items look closed:

```
<>

<img

src="https://i.imgur.com/yXOvdOSs.jpg"

alt="Hedy Lamarr"

class="photo"

/>

<ul>

<li>Invent new traffic lights</li>

<li>Rehearse a movie scene</li>

<li>Improve the spectrum technology</li>

</ul>

</>
```

### 3. camelCase ~~all~~ most of the things!

JSX turns into JavaScript and attributes written in JSX become keys of JavaScript objects. In your own components, you will often want to read those attributes into variables. But JavaScript has limitations on variable names. For example, their names can’t contain dashes or be reserved words like `class`.

This is why, in React, many HTML and SVG attributes are written in camelCase. For example, instead of `stroke-width` you use `strokeWidth`. Since `class` is a reserved word, in React you write `className` instead, named after the [corresponding DOM property](https://developer.mozilla.org/en-US/docs/Web/API/Element/className):

```
<img

src="https://i.imgur.com/yXOvdOSs.jpg"

alt="Hedy Lamarr"

className="photo"

/>
```

You can [find all these attributes in the list of DOM component props.](https://react.dev/reference/react-dom/components/common) If you get one wrong, don’t worry—React will print a message with a possible correction to the [browser console.](https://developer.mozilla.org/docs/Tools/Browser_Console)

### Pitfall

For historical reasons, [`aria-*`](https://developer.mozilla.org/docs/Web/Accessibility/ARIA) and [`data-*`](https://developer.mozilla.org/docs/Learn/HTML/Howto/Use_data_attributes) attributes are written as in HTML with dashes.

### Pro-tip: Use a JSX Converter

Converting all these attributes in existing markup can be tedious! We recommend using a [converter](https://transform.tools/html-to-jsx) to translate your existing HTML and SVG to JSX. Converters are very useful in practice, but it’s still worth understanding what is going on so that you can comfortably write JSX on your own.

Here is your final result:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function TodoList() {
  return (
    <>
      <h1>Hedy Lamarr's Todos</h1>
      <img 
        src="https://i.imgur.com/yXOvdOSs.jpg" 
        alt="Hedy Lamarr" 
        className="photo" 
      />
      <ul>
        <li>Invent new traffic lights</li>
        <li>Rehearse a movie scene</li>
        <li>Improve the spectrum technology</li>
      </ul>
    </>
  );
}
```

Show more

## Recap

Now you know why JSX exists and how to use it in components:

* React components group rendering logic together with markup because they are related.
* JSX is similar to HTML, with a few differences. You can use a [converter](https://transform.tools/html-to-jsx) if you need to.
* Error messages will often point you in the right direction to fixing your markup.

## Try out some challenges

#### Challenge 1 of 1: Convert some HTML to JSX

This HTML was pasted into a component, but it’s not valid JSX. Fix it:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Bio() {
  return (
    <div class="intro">
      <h1>Welcome to my website!</h1>
    </div>
    <p class="summary">
      You can find my thoughts here.
      <br><br>
      <b>And <i>pictures</b></i> of scientists!
    </p>
  );
}
```

Whether to do it by hand or using the converter is up to you!

Show solution

[PreviousImporting and Exporting Components](https://react.dev/learn/importing-and-exporting-components)[NextJavaScript in JSX with Curly Braces](https://react.dev/learn/javascript-in-jsx-with-curly-braces)

---

---


# JavaScript in JSX with Curly Braces – React

URL: https://react.dev/learn/javascript-in-jsx-with-curly-braces

[Learn React](https://react.dev/learn)

[Describing the UI](https://react.dev/learn/describing-the-ui)

# JavaScript in JSX with Curly Braces

JSX lets you write HTML-like markup inside a JavaScript file, keeping rendering logic and content in the same place. Sometimes you will want to add a little JavaScript logic or reference a dynamic property inside that markup. In this situation, you can use curly braces in your JSX to open a window to JavaScript.

### You will learn

* How to pass strings with quotes
* How to reference a JavaScript variable inside JSX with curly braces
* How to call a JavaScript function inside JSX with curly braces
* How to use a JavaScript object inside JSX with curly braces

## Passing strings with quotes

When you want to pass a string attribute to JSX, you put it in single or double quotes:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Avatar() {
  return (
    <img
      className="avatar"
      src="https://i.imgur.com/7vQD0fPs.jpg"
      alt="Gregorio Y. Zara"
    />
  );
}
```

Here, `"https://i.imgur.com/7vQD0fPs.jpg"` and `"Gregorio Y. Zara"` are being passed as strings.

But what if you want to dynamically specify the `src` or `alt` text? You could **use a value from JavaScript by replacing `"` and `"` with `{` and `}`**:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Avatar() {
  const avatar = 'https://i.imgur.com/7vQD0fPs.jpg';
  const description = 'Gregorio Y. Zara';
  return (
    <img
      className="avatar"
      src={avatar}
      alt={description}
    />
  );
}
```

Notice the difference between `className="avatar"`, which specifies an `"avatar"` CSS class name that makes the image round, and `src={avatar}` that reads the value of the JavaScript variable called `avatar`. That’s because curly braces let you work with JavaScript right there in your markup!

## Using curly braces: A window into the JavaScript world

JSX is a special way of writing JavaScript. That means it’s possible to use JavaScript inside it—with curly braces `{ }`. The example below first declares a name for the scientist, `name`, then embeds it with curly braces inside the `<h1>`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function TodoList() {
  const name = 'Gregorio Y. Zara';
  return (
    <h1>{name}'s To Do List</h1>
  );
}
```

Try changing the `name`’s value from `'Gregorio Y. Zara'` to `'Hedy Lamarr'`. See how the list title changes?

Any JavaScript expression will work between curly braces, including function calls like `formatDate()`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
const today = new Date();

function formatDate(date) {
  return new Intl.DateTimeFormat(
    'en-US',
    { weekday: 'long' }
  ).format(date);
}

export default function TodoList() {
  return (
    <h1>To Do List for {formatDate(today)}</h1>
  );
}
```

### Where to use curly braces

You can only use curly braces in two ways inside JSX:

1. **As text** directly inside a JSX tag: `<h1>{name}'s To Do List</h1>` works, but `<{tag}>Gregorio Y. Zara's To Do List</{tag}>` will not.
2. **As attributes** immediately following the `=` sign: `src={avatar}` will read the `avatar` variable, but `src="{avatar}"` will pass the string `"{avatar}"`.

## Using “double curlies”: CSS and other objects in JSX

In addition to strings, numbers, and other JavaScript expressions, you can even pass objects in JSX. Objects are also denoted with curly braces, like `{ name: "Hedy Lamarr", inventions: 5 }`. Therefore, to pass a JS object in JSX, you must wrap the object in another pair of curly braces: `person={{ name: "Hedy Lamarr", inventions: 5 }}`.

You may see this with inline CSS styles in JSX. React does not require you to use inline styles (CSS classes work great for most cases). But when you need an inline style, you pass an object to the `style` attribute:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function TodoList() {
  return (
    <ul style={{
      backgroundColor: 'black',
      color: 'pink'
    }}>
      <li>Improve the videophone</li>
      <li>Prepare aeronautics lectures</li>
      <li>Work on the alcohol-fuelled engine</li>
    </ul>
  );
}
```

Try changing the values of `backgroundColor` and `color`.

You can really see the JavaScript object inside the curly braces when you write it like this:

```
<ul style={

{

backgroundColor: 'black',

color: 'pink'

}

}>
```

The next time you see `{{` and `}}` in JSX, know that it’s nothing more than an object inside the JSX curlies!

### Pitfall

Inline `style` properties are written in camelCase. For example, HTML `<ul style="background-color: black">` would be written as `<ul style={{ backgroundColor: 'black' }}>` in your component.

## More fun with JavaScript objects and curly braces

You can move several expressions into one object, and reference them in your JSX inside curly braces:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person.name}'s Todos</h1>
      <img
        className="avatar"
        src="https://i.imgur.com/7vQD0fPs.jpg"
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```

Show more

In this example, the `person` JavaScript object contains a `name` string and a `theme` object:

```
const person = {

name: 'Gregorio Y. Zara',

theme: {

backgroundColor: 'black',

color: 'pink'

}

};
```

The component can use these values from `person` like so:

```
<div style={person.theme}>

<h1>{person.name}'s Todos</h1>
```

JSX is very minimal as a templating language because it lets you organize data and logic using JavaScript.

## Recap

Now you know almost everything about JSX:

* JSX attributes inside quotes are passed as strings.
* Curly braces let you bring JavaScript logic and variables into your markup.
* They work inside the JSX tag content or immediately after `=` in attributes.
* `{{` and `}}` is not special syntax: it’s a JavaScript object tucked inside JSX curly braces.

## Try out some challenges

1. Fix the mistake 2. Extract information into an object 3. Write an expression inside JSX curly braces

#### Challenge 1 of 3: Fix the mistake

This code crashes with an error saying `Objects are not valid as a React child`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
const person = {
  name: 'Gregorio Y. Zara',
  theme: {
    backgroundColor: 'black',
    color: 'pink'
  }
};

export default function TodoList() {
  return (
    <div style={person.theme}>
      <h1>{person}'s Todos</h1>
      <img
        className="avatar"
        src="https://i.imgur.com/7vQD0fPs.jpg"
        alt="Gregorio Y. Zara"
      />
      <ul>
        <li>Improve the videophone</li>
        <li>Prepare aeronautics lectures</li>
        <li>Work on the alcohol-fuelled engine</li>
      </ul>
    </div>
  );
}
```

Show more

Can you find the problem?

Show hint Show solution

Next Challenge

[PreviousWriting Markup with JSX](https://react.dev/learn/writing-markup-with-jsx)[NextPassing Props to a Component](https://react.dev/learn/passing-props-to-a-component)

---

---


# Passing Props to a Component – React

URL: https://react.dev/learn/passing-props-to-a-component

[Learn React](https://react.dev/learn)

[Describing the UI](https://react.dev/learn/describing-the-ui)

# Passing Props to a Component

React components use *props* to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions.

### You will learn

* How to pass props to a component
* How to read props from a component
* How to specify default values for props
* How to pass some JSX to a component
* How props change over time

## Familiar props

Props are the information that you pass to a JSX tag. For example, `className`, `src`, `alt`, `width`, and `height` are some of the props you can pass to an `<img>`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Avatar() {
  return (
    <img
      className="avatar"
      src="https://i.imgur.com/1bX5QH6.jpg"
      alt="Lin Lanying"
      width={100}
      height={100}
    />
  );
}

export default function Profile() {
  return (
    <Avatar />
  );
}
```

Show more

The props you can pass to an `<img>` tag are predefined (ReactDOM conforms to [the HTML standard](https://www.w3.org/TR/html52/semantics-embedded-content.html#the-img-element)). But you can pass any props to *your own* components, such as `<Avatar>`, to customize them. Here’s how!

## Passing props to a component

In this code, the `Profile` component isn’t passing any props to its child component, `Avatar`:

```
export default function Profile() {

return (

<Avatar />

);

}
```

You can give `Avatar` some props in two steps.

### Step 1: Pass props to the child component

First, pass some props to `Avatar`. For example, let’s pass two props: `person` (an object), and `size` (a number):

```
export default function Profile() {

return (

<Avatar

person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}

size={100}

/>

);

}
```

### Note

If double curly braces after `person=` confuse you, recall [they’re merely an object](https://react.dev/learn/javascript-in-jsx-with-curly-braces#using-double-curlies-css-and-other-objects-in-jsx) inside the JSX curlies.

Now you can read these props inside the `Avatar` component.

### Step 2: Read props inside the child component

You can read these props by listing their names `person, size` separated by the commas inside `({` and `})` directly after `function Avatar`. This lets you use them inside the `Avatar` code, like you would with a variable.

```
function Avatar({ person, size }) {

// person and size are available here

}
```

Add some logic to `Avatar` that uses the `person` and `size` props for rendering, and you’re done.

Now you can configure `Avatar` to render in many different ways with different props. Try tweaking the values!

App.jsutils.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { getImageUrl } from './utils.js';

function Avatar({ person, size }) {
  return (
    <img
      className="avatar"
      src={getImageUrl(person)}
      alt={person.name}
      width={size}
      height={size}
    />
  );
}

export default function Profile() {
  return (
    <div>
      <Avatar
        size={100}
        person={{ 
          name: 'Katsuko Saruhashi', 
          imageId: 'YfeOqp2'
        }}
      />
      <Avatar
        size={80}
        person={{
          name: 'Aklilu Lemma', 
          imageId: 'OKS67lh'
        }}
      />
      <Avatar
        size={50}
        person={{ 
          name: 'Lin Lanying',
          imageId: '1bX5QH6'
        }}
      />
    </div>
  );
}
```

Show more

Props let you think about parent and child components independently. For example, you can change the `person` or the `size` props inside `Profile` without having to think about how `Avatar` uses them. Similarly, you can change how the `Avatar` uses these props, without looking at the `Profile`.

You can think of props like “knobs” that you can adjust. They serve the same role as arguments serve for functions—in fact, props *are* the only argument to your component! React component functions accept a single argument, a `props` object:

```
function Avatar(props) {

let person = props.person;

let size = props.size;

// ...

}
```

Usually you don’t need the whole `props` object itself, so you destructure it into individual props.

### Pitfall

**Don’t miss the pair of `{` and `}` curlies** inside of `(` and `)` when declaring props:

```
function Avatar({ person, size }) {

// ...

}
```

This syntax is called [“destructuring”](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Unpacking_fields_from_objects_passed_as_a_function_parameter) and is equivalent to reading properties from a function parameter:

```
function Avatar(props) {

let person = props.person;

let size = props.size;

// ...

}
```

## Specifying a default value for a prop

If you want to give a prop a default value to fall back on when no value is specified, you can do it with the destructuring by putting `=` and the default value right after the parameter:

```
function Avatar({ person, size = 100 }) {

// ...

}
```

Now, if `<Avatar person={...} />` is rendered with no `size` prop, the `size` will be set to `100`.

The default value is only used if the `size` prop is missing or if you pass `size={undefined}`. But if you pass `size={null}` or `size={0}`, the default value will **not** be used.

## Forwarding props with the JSX spread syntax

Sometimes, passing props gets very repetitive:

```
function Profile({ person, size, isSepia, thickBorder }) {

return (

<div className="card">

<Avatar

person={person}

size={size}

isSepia={isSepia}

thickBorder={thickBorder}

/>

</div>

);

}
```

There’s nothing wrong with repetitive code—it can be more legible. But at times you may value conciseness. Some components forward all of their props to their children, like how this `Profile` does with `Avatar`. Because they don’t use any of their props directly, it can make sense to use a more concise “spread” syntax:

```
function Profile(props) {

return (

<div className="card">

<Avatar {...props} />

</div>

);

}
```

This forwards all of `Profile`’s props to the `Avatar` without listing each of their names.

**Use spread syntax with restraint.** If you’re using it in every other component, something is wrong. Often, it indicates that you should split your components and pass children as JSX. More on that next!

## Passing JSX as children

It is common to nest built-in browser tags:

```
<div>

<img />

</div>
```

Sometimes you’ll want to nest your own components the same way:

```
<Card>

<Avatar />

</Card>
```

When you nest content inside a JSX tag, the parent component will receive that content in a prop called `children`. For example, the `Card` component below will receive a `children` prop set to `<Avatar />` and render it in a wrapper div:

App.jsAvatar.jsutils.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Avatar from './Avatar.js';

function Card({ children }) {
  return (
    <div className="card">
      {children}
    </div>
  );
}

export default function Profile() {
  return (
    <Card>
      <Avatar
        size={100}
        person={{ 
          name: 'Katsuko Saruhashi',
          imageId: 'YfeOqp2'
        }}
      />
    </Card>
  );
}
```

Show more

Try replacing the `<Avatar>` inside `<Card>` with some text to see how the `Card` component can wrap any nested content. It doesn’t need to “know” what’s being rendered inside of it. You will see this flexible pattern in many places.

You can think of a component with a `children` prop as having a “hole” that can be “filled in” by its parent components with arbitrary JSX. You will often use the `children` prop for visual wrappers: panels, grids, etc.

![A puzzle-like Card tile with a slot for "children" pieces like text and Avatar](https://react.dev/images/docs/illustrations/i_children-prop.png)

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

## How props change over time

The `Clock` component below receives two props from its parent component: `color` and `time`. (The parent component’s code is omitted because it uses [state](https://react.dev/learn/state-a-components-memory), which we won’t dive into just yet.)

Try changing the color in the select box below:

Clock.js

Clock.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Clock({ color, time }) {
  return (
    <h1 style={{ color: color }}>
      {time}
    </h1>
  );
}
```

This example illustrates that **a component may receive different props over time.** Props are not always static! Here, the `time` prop changes every second, and the `color` prop changes when you select another color. Props reflect a component’s data at any point in time, rather than only in the beginning.

However, props are [immutable](https://en.wikipedia.org/wiki/Immutable_object)—a term from computer science meaning “unchangeable”. When a component needs to change its props (for example, in response to a user interaction or new data), it will have to “ask” its parent component to pass it *different props*—a new object! Its old props will then be cast aside, and eventually the JavaScript engine will reclaim the memory taken by them.

**Don’t try to “change props”.** When you need to respond to the user input (like changing the selected color), you will need to “set state”, which you can learn about in [State: A Component’s Memory.](https://react.dev/learn/state-a-components-memory)

## Recap

* To pass props, add them to the JSX, just like you would with HTML attributes.
* To read props, use the `function Avatar({ person, size })` destructuring syntax.
* You can specify a default value like `size = 100`, which is used for missing and `undefined` props.
* You can forward all props with `<Avatar {...props} />` JSX spread syntax, but don’t overuse it!
* Nested JSX like `<Card><Avatar /></Card>` will appear as `Card` component’s `children` prop.
* Props are read-only snapshots in time: every render receives a new version of props.
* You can’t change props. When you need interactivity, you’ll need to set state.

## Try out some challenges

1. Extract a component 2. Adjust the image size based on a prop 3. Passing JSX in a `children` prop

#### Challenge 1 of 3: Extract a component

This `Gallery` component contains some very similar markup for two profiles. Extract a `Profile` component out of it to reduce the duplication. You’ll need to choose what props to pass to it.

App.jsutils.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { getImageUrl } from './utils.js';

export default function Gallery() {
  return (
    <div>
      <h1>Notable Scientists</h1>
      <section className="profile">
        <h2>Maria Skłodowska-Curie</h2>
        <img
          className="avatar"
          src={getImageUrl('szV5sdG')}
          alt="Maria Skłodowska-Curie"
          width={70}
          height={70}
        />
        <ul>
          <li>
            <b>Profession: </b> 
            physicist and chemist
          </li>
          <li>
            <b>Awards: 4 </b> 
            (Nobel Prize in Physics, Nobel Prize in Chemistry, Davy Medal, Matteucci Medal)
          </li>
          <li>
            <b>Discovered: </b>
            polonium (chemical element)
          </li>
        </ul>
      </section>
      <section className="profile">
        <h2>Katsuko Saruhashi</h2>
        <img
          className="avatar"
          src={getImageUrl('YfeOqp2')}
          alt="Katsuko Saruhashi"
          width={70}
          height={70}
        />
        <ul>
          <li>
            <b>Profession: </b> 
            geochemist
          </li>
          <li>
            <b>Awards: 2 </b> 
            (Miyake Prize for geochemistry, Tanaka Prize)
          </li>
          <li>
            <b>Discovered: </b>
            a method for measuring carbon dioxide in seawater
          </li>
        </ul>
      </section>
    </div>
  );
}
```

Show more

Show hint Show solution

Next Challenge

[PreviousJavaScript in JSX with Curly Braces](https://react.dev/learn/javascript-in-jsx-with-curly-braces)[NextConditional Rendering](https://react.dev/learn/conditional-rendering)

---

---


# Conditional Rendering – React

URL: https://react.dev/learn/conditional-rendering

[Learn React](https://react.dev/learn)

[Describing the UI](https://react.dev/learn/describing-the-ui)

# Conditional Rendering

Your components will often need to display different things depending on different conditions. In React, you can conditionally render JSX using JavaScript syntax like `if` statements, `&&`, and `? :` operators.

### You will learn

* How to return different JSX depending on a condition
* How to conditionally include or exclude a piece of JSX
* Common conditional syntax shortcuts you’ll encounter in React codebases

## Conditionally returning JSX

Let’s say you have a `PackingList` component rendering several `Item`s, which can be marked as packed or not:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  return <li className="item">{name}</li>;
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

Show more

Notice that some of the `Item` components have their `isPacked` prop set to `true` instead of `false`. You want to add a checkmark (✅) to packed items if `isPacked={true}`.

You can write this as an [`if`/`else` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else) like so:

```
if (isPacked) {

return <li className="item">{name} ✅</li>;

}

return <li className="item">{name}</li>;
```

If the `isPacked` prop is `true`, this code **returns a different JSX tree.** With this change, some of the items get a checkmark at the end:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  if (isPacked) {
    return <li className="item">{name} ✅</li>;
  }
  return <li className="item">{name}</li>;
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

Show more

Try editing what gets returned in either case, and see how the result changes!

Notice how you’re creating branching logic with JavaScript’s `if` and `return` statements. In React, control flow (like conditions) is handled by JavaScript.

### Conditionally returning nothing with `null`

In some situations, you won’t want to render anything at all. For example, say you don’t want to show packed items at all. A component must return something. In this case, you can return `null`:

```
if (isPacked) {

return null;

}

return <li className="item">{name}</li>;
```

If `isPacked` is true, the component will return nothing, `null`. Otherwise, it will return JSX to render.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  if (isPacked) {
    return null;
  }
  return <li className="item">{name}</li>;
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

Show more

In practice, returning `null` from a component isn’t common because it might surprise a developer trying to render it. More often, you would conditionally include or exclude the component in the parent component’s JSX. Here’s how to do that!

## Conditionally including JSX

In the previous example, you controlled which (if any!) JSX tree would be returned by the component. You may already have noticed some duplication in the render output:

```
<li className="item">{name} ✅</li>
```

is very similar to

```
<li className="item">{name}</li>
```

Both of the conditional branches return `<li className="item">...</li>`:

```
if (isPacked) {

return <li className="item">{name} ✅</li>;

}

return <li className="item">{name}</li>;
```

While this duplication isn’t harmful, it could make your code harder to maintain. What if you want to change the `className`? You’d have to do it in two places in your code! In such a situation, you could conditionally include a little JSX to make your code more [DRY.](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)

### Conditional (ternary) operator (`? :`)

JavaScript has a compact syntax for writing a conditional expression — the [conditional operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator) or “ternary operator”.

Instead of this:

```
if (isPacked) {

return <li className="item">{name} ✅</li>;

}

return <li className="item">{name}</li>;
```

You can write this:

```
return (

<li className="item">

{isPacked ? name + ' ✅' : name}

</li>

);
```

You can read it as *“if `isPacked` is true, then (`?`) render `name + ' ✅'`, otherwise (`:`) render `name`”*.

##### Deep Dive

#### Are these two examples fully equivalent?

Show Details

If you’re coming from an object-oriented programming background, you might assume that the two examples above are subtly different because one of them may create two different “instances” of `<li>`. But JSX elements aren’t “instances” because they don’t hold any internal state and aren’t real DOM nodes. They’re lightweight descriptions, like blueprints. So these two examples, in fact, *are* completely equivalent. [Preserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state) goes into detail about how this works.

Now let’s say you want to wrap the completed item’s text into another HTML tag, like `<del>` to strike it out. You can add even more newlines and parentheses so that it’s easier to nest more JSX in each of the cases:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {isPacked ? (
        <del>
          {name + ' ✅'}
        </del>
      ) : (
        name
      )}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

Show more

This style works well for simple conditions, but use it in moderation. If your components get messy with too much nested conditional markup, consider extracting child components to clean things up. In React, markup is a part of your code, so you can use tools like variables and functions to tidy up complex expressions.

### Logical AND operator (`&&`)

Another common shortcut you’ll encounter is the [JavaScript logical AND (`&&`) operator.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND#:~:text=The%20logical%20AND%20(%20%26%26%20)%20operator,it%20returns%20a%20Boolean%20value.) Inside React components, it often comes up when you want to render some JSX when the condition is true, **or render nothing otherwise.** With `&&`, you could conditionally render the checkmark only if `isPacked` is `true`:

```
return (

<li className="item">

{name} {isPacked && '✅'}

</li>

);
```

You can read this as *“if `isPacked`, then (`&&`) render the checkmark, otherwise, render nothing”*.

Here it is in action:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✅'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

Show more

A [JavaScript && expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND) returns the value of its right side (in our case, the checkmark) if the left side (our condition) is `true`. But if the condition is `false`, the whole expression becomes `false`. React considers `false` as a “hole” in the JSX tree, just like `null` or `undefined`, and doesn’t render anything in its place.

### Pitfall

**Don’t put numbers on the left side of `&&`.**

To test the condition, JavaScript converts the left side to a boolean automatically. However, if the left side is `0`, then the whole expression gets that value (`0`), and React will happily render `0` rather than nothing.

For example, a common mistake is to write code like `messageCount && <p>New messages</p>`. It’s easy to assume that it renders nothing when `messageCount` is `0`, but it really renders the `0` itself!

To fix it, make the left side a boolean: `messageCount > 0 && <p>New messages</p>`.

### Conditionally assigning JSX to a variable

When the shortcuts get in the way of writing plain code, try using an `if` statement and a variable. You can reassign variables defined with [`let`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let), so start by providing the default content you want to display, the name:

```
let itemContent = name;
```

Use an `if` statement to reassign a JSX expression to `itemContent` if `isPacked` is `true`:

```
if (isPacked) {

itemContent = name + " ✅";

}
```

[Curly braces open the “window into JavaScript”.](https://react.dev/learn/javascript-in-jsx-with-curly-braces#using-curly-braces-a-window-into-the-javascript-world) Embed the variable with curly braces in the returned JSX tree, nesting the previously calculated expression inside of JSX:

```
<li className="item">

{itemContent}

</li>
```

This style is the most verbose, but it’s also the most flexible. Here it is in action:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  let itemContent = name;
  if (isPacked) {
    itemContent = name + " ✅";
  }
  return (
    <li className="item">
      {itemContent}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

Show more

Like before, this works not only for text, but for arbitrary JSX too:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  let itemContent = name;
  if (isPacked) {
    itemContent = (
      <del>
        {name + " ✅"}
      </del>
    );
  }
  return (
    <li className="item">
      {itemContent}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

Show more

If you’re not familiar with JavaScript, this variety of styles might seem overwhelming at first. However, learning them will help you read and write any JavaScript code — and not just React components! Pick the one you prefer for a start, and then consult this reference again if you forget how the other ones work.

## Recap

* In React, you control branching logic with JavaScript.
* You can return a JSX expression conditionally with an `if` statement.
* You can conditionally save some JSX to a variable and then include it inside other JSX by using the curly braces.
* In JSX, `{cond ? <A /> : <B />}` means *“if `cond`, render `<A />`, otherwise `<B />`”*.
* In JSX, `{cond && <A />}` means *“if `cond`, render `<A />`, otherwise nothing”*.
* The shortcuts are common, but you don’t have to use them if you prefer plain `if`.

## Try out some challenges

1. Show an icon for incomplete items with `? :` 2. Show the item importance with `&&` 3. Refactor a series of `? :` to `if` and variables

#### Challenge 1 of 3: Show an icon for incomplete items with `? :`

Use the conditional operator (`cond ? a : b`) to render a ❌ if `isPacked` isn’t `true`.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✅'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

Show more

Show solutionNext Challenge

[PreviousPassing Props to a Component](https://react.dev/learn/passing-props-to-a-component)[NextRendering Lists](https://react.dev/learn/rendering-lists)

---

---


# Rendering Lists – React

URL: https://react.dev/learn/rendering-lists

[Learn React](https://react.dev/learn)

[Describing the UI](https://react.dev/learn/describing-the-ui)

# Rendering Lists

You will often want to display multiple similar components from a collection of data. You can use the [JavaScript array methods](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array) to manipulate an array of data. On this page, you’ll use [`filter()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) and [`map()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map) with React to filter and transform your array of data into an array of components.

### You will learn

* How to render components from an array using JavaScript’s `map()`
* How to render only specific components using JavaScript’s `filter()`
* When and why to use React keys

## Rendering data from arrays

Say that you have a list of content.

```
<ul>

<li>Creola Katherine Johnson: mathematician</li>

<li>Mario José Molina-Pasquel Henríquez: chemist</li>

<li>Mohammad Abdus Salam: physicist</li>

<li>Percy Lavon Julian: chemist</li>

<li>Subrahmanyan Chandrasekhar: astrophysicist</li>

</ul>
```

The only difference among those list items is their contents, their data. You will often need to show several instances of the same component using different data when building interfaces: from lists of comments to galleries of profile images. In these situations, you can store that data in JavaScript objects and arrays and use methods like [`map()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) and [`filter()`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) to render lists of components from them.

Here’s a short example of how to generate a list of items from an array:

1. **Move** the data into an array:

```
const people = [

'Creola Katherine Johnson: mathematician',

'Mario José Molina-Pasquel Henríquez: chemist',

'Mohammad Abdus Salam: physicist',

'Percy Lavon Julian: chemist',

'Subrahmanyan Chandrasekhar: astrophysicist'

];
```

2. **Map** the `people` members into a new array of JSX nodes, `listItems`:

```
const listItems = people.map(person => <li>{person}</li>);
```

3. **Return** `listItems` from your component wrapped in a `<ul>`:

```
return <ul>{listItems}</ul>;
```

Here is the result:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
const people = [
  'Creola Katherine Johnson: mathematician',
  'Mario José Molina-Pasquel Henríquez: chemist',
  'Mohammad Abdus Salam: physicist',
  'Percy Lavon Julian: chemist',
  'Subrahmanyan Chandrasekhar: astrophysicist'
];

export default function List() {
  const listItems = people.map(person =>
    <li>{person}</li>
  );
  return <ul>{listItems}</ul>;
}
```

Notice the sandbox above displays a console error:

Console

Warning: Each child in a list should have a unique “key” prop.

You’ll learn how to fix this error later on this page. Before we get to that, let’s add some structure to your data.

## Filtering arrays of items

This data can be structured even more.

```
const people = [{

id: 0,

name: 'Creola Katherine Johnson',

profession: 'mathematician',

}, {

id: 1,

name: 'Mario José Molina-Pasquel Henríquez',

profession: 'chemist',

}, {

id: 2,

name: 'Mohammad Abdus Salam',

profession: 'physicist',

}, {

id: 3,

name: 'Percy Lavon Julian',

profession: 'chemist',

}, {

id: 4,

name: 'Subrahmanyan Chandrasekhar',

profession: 'astrophysicist',

}];
```

Let’s say you want a way to only show people whose profession is `'chemist'`. You can use JavaScript’s `filter()` method to return just those people. This method takes an array of items, passes them through a “test” (a function that returns `true` or `false`), and returns a new array of only those items that passed the test (returned `true`).

You only want the items where `profession` is `'chemist'`. The “test” function for this looks like `(person) => person.profession === 'chemist'`. Here’s how to put it together:

1. **Create** a new array of just “chemist” people, `chemists`, by calling `filter()` on the `people` filtering by `person.profession === 'chemist'`:

```
const chemists = people.filter(person =>

person.profession === 'chemist'

);
```

2. Now **map** over `chemists`:

```
const listItems = chemists.map(person =>

<li>

<img

src={getImageUrl(person)}

alt={person.name}

/>

<p>

<b>{person.name}:</b>

{' ' + person.profession + ' '}

known for {person.accomplishment}

</p>

</li>

);
```

3. Lastly, **return** the `listItems` from your component:

```
return <ul>{listItems}</ul>;
```

App.jsdata.jsutils.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { people } from './data.js';
import { getImageUrl } from './utils.js';

export default function List() {
  const chemists = people.filter(person =>
    person.profession === 'chemist'
  );
  const listItems = chemists.map(person =>
    <li>
      <img
        src={getImageUrl(person)}
        alt={person.name}
      />
      <p>
        <b>{person.name}:</b>
        {' ' + person.profession + ' '}
        known for {person.accomplishment}
      </p>
    </li>
  );
  return <ul>{listItems}</ul>;
}
```

Show more

### Pitfall

Arrow functions implicitly return the expression right after `=>`, so you didn’t need a `return` statement:

```
const listItems = chemists.map(person =>

<li>...</li> // Implicit return!

);
```

However, **you must write `return` explicitly if your `=>` is followed by a `{` curly brace!**

```
const listItems = chemists.map(person => { // Curly brace

return <li>...</li>;

});
```

Arrow functions containing `=> {` are said to have a [“block body”.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#function_body) They let you write more than a single line of code, but you *have to* write a `return` statement yourself. If you forget it, nothing gets returned!

## Keeping list items in order with `key`

Notice that all the sandboxes above show an error in the console:

Console

Warning: Each child in a list should have a unique “key” prop.

You need to give each array item a `key` — a string or a number that uniquely identifies it among other items in that array:

```
<li key={person.id}>...</li>
```

### Note

JSX elements directly inside a `map()` call always need keys!

Keys tell React which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen `key` helps React infer what exactly has happened, and make the correct updates to the DOM tree.

Rather than generating keys on the fly, you should include them in your data:

App.jsdata.jsutils.js

data.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export const people = [{
  id: 0, // Used in JSX as a key
  name: 'Creola Katherine Johnson',
  profession: 'mathematician',
  accomplishment: 'spaceflight calculations',
  imageId: 'MK3eW3A'
}, {
  id: 1, // Used in JSX as a key
  name: 'Mario José Molina-Pasquel Henríquez',
  profession: 'chemist',
  accomplishment: 'discovery of Arctic ozone hole',
  imageId: 'mynHUSa'
}, {
  id: 2, // Used in JSX as a key
  name: 'Mohammad Abdus Salam',
  profession: 'physicist',
  accomplishment: 'electromagnetism theory',
  imageId: 'bE7W1ji'
}, {
  id: 3, // Used in JSX as a key
  name: 'Percy Lavon Julian',
  profession: 'chemist',
  accomplishment: 'pioneering cortisone drugs, steroids and birth control pills',
  imageId: 'IOjWm71'
}, {
  id: 4, // Used in JSX as a key
  name: 'Subrahmanyan Chandrasekhar',
  profession: 'astrophysicist',
  accomplishment: 'white dwarf star mass calculations',
  imageId: 'lrWQx8l'
}];
```

Show more

##### Deep Dive

#### Displaying several DOM nodes for each list item

Show Details

What do you do when each item needs to render not one, but several DOM nodes?

The short [`<>...</>` Fragment](https://react.dev/reference/react/Fragment) syntax won’t let you pass a key, so you need to either group them into a single `<div>`, or use the slightly longer and [more explicit `<Fragment>` syntax:](https://react.dev/reference/react/Fragment#rendering-a-list-of-fragments)

```
import { Fragment } from 'react';

// ...

const listItems = people.map(person =>

<Fragment key={person.id}>

<h1>{person.name}</h1>

<p>{person.bio}</p>

</Fragment>

);
```

Fragments disappear from the DOM, so this will produce a flat list of `<h1>`, `<p>`, `<h1>`, `<p>`, and so on.

### Where to get your `key`

Different sources of data provide different sources of keys:

* **Data from a database:** If your data is coming from a database, you can use the database keys/IDs, which are unique by nature.
* **Locally generated data:** If your data is generated and persisted locally (e.g. notes in a note-taking app), use an incrementing counter, [`crypto.randomUUID()`](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/randomUUID) or a package like [`uuid`](https://www.npmjs.com/package/uuid) when creating items.

### Rules of keys

* **Keys must be unique among siblings.** However, it’s okay to use the same keys for JSX nodes in *different* arrays.
* **Keys must not change** or that defeats their purpose! Don’t generate them while rendering.

### Why does React need keys?

Imagine that files on your desktop didn’t have names. Instead, you’d refer to them by their order — the first file, the second file, and so on. You could get used to it, but once you delete a file, it would get confusing. The second file would become the first file, the third file would be the second file, and so on.

File names in a folder and JSX keys in an array serve a similar purpose. They let us uniquely identify an item between its siblings. A well-chosen key provides more information than the position within the array. Even if the *position* changes due to reordering, the `key` lets React identify the item throughout its lifetime.

### Pitfall

You might be tempted to use an item’s index in the array as its key. In fact, that’s what React will use if you don’t specify a `key` at all. But the order in which you render items will change over time if an item is inserted, deleted, or if the array gets reordered. Index as a key often leads to subtle and confusing bugs.

Similarly, do not generate keys on the fly, e.g. with `key={Math.random()}`. This will cause keys to never match up between renders, leading to all your components and DOM being recreated every time. Not only is this slow, but it will also lose any user input inside the list items. Instead, use a stable ID based on the data.

Note that your components won’t receive `key` as a prop. It’s only used as a hint by React itself. If your component needs an ID, you have to pass it as a separate prop: `<Profile key={id} userId={id} />`.

## Recap

On this page you learned:

* How to move data out of components and into data structures like arrays and objects.
* How to generate sets of similar components with JavaScript’s `map()`.
* How to create arrays of filtered items with JavaScript’s `filter()`.
* Why and how to set `key` on each component in a collection so React can keep track of each of them even if their position or data changes.

## Try out some challenges

1. Splitting a list in two 2. Nested lists in one component 3. Extracting a list item component 4. List with a separator

#### Challenge 1 of 4: Splitting a list in two

This example shows a list of all people.

Change it to show two separate lists one after another: **Chemists** and **Everyone Else.** Like previously, you can determine whether a person is a chemist by checking if `person.profession === 'chemist'`.

App.jsdata.jsutils.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { people } from './data.js';
import { getImageUrl } from './utils.js';

export default function List() {
  const listItems = people.map(person =>
    <li key={person.id}>
      <img
        src={getImageUrl(person)}
        alt={person.name}
      />
      <p>
        <b>{person.name}:</b>
        {' ' + person.profession + ' '}
        known for {person.accomplishment}
      </p>
    </li>
  );
  return (
    <article>
      <h1>Scientists</h1>
      <ul>{listItems}</ul>
    </article>
  );
}
```

Show more

Show solutionNext Challenge

[PreviousConditional Rendering](https://react.dev/learn/conditional-rendering)[NextKeeping Components Pure](https://react.dev/learn/keeping-components-pure)

---

---


# Keeping Components Pure – React

URL: https://react.dev/learn/keeping-components-pure

[Learn React](https://react.dev/learn)

[Describing the UI](https://react.dev/learn/describing-the-ui)

# Keeping Components Pure

Some JavaScript functions are *pure.* Pure functions only perform a calculation and nothing more. By strictly only writing your components as pure functions, you can avoid an entire class of baffling bugs and unpredictable behavior as your codebase grows. To get these benefits, though, there are a few rules you must follow.

### You will learn

* What purity is and how it helps you avoid bugs
* How to keep components pure by keeping changes out of the render phase
* How to use Strict Mode to find mistakes in your components

## Purity: Components as formulas

In computer science (and especially the world of functional programming), [a pure function](https://wikipedia.org/wiki/Pure_function) is a function with the following characteristics:

* **It minds its own business.** It does not change any objects or variables that existed before it was called.
* **Same inputs, same output.** Given the same inputs, a pure function should always return the same result.

You might already be familiar with one example of pure functions: formulas in math.

Consider this math formula: y = 2x.

If x = 2 then y = 4. Always.

If x = 3 then y = 6. Always.

If x = 3, y won’t sometimes be 9 or –1 or 2.5 depending on the time of day or the state of the stock market.

If y = 2x and x = 3, y will *always* be 6.

If we made this into a JavaScript function, it would look like this:

```
function double(number) {

return 2 * number;

}
```

In the above example, `double` is a **pure function.** If you pass it `3`, it will return `6`. Always.

React is designed around this concept. **React assumes that every component you write is a pure function.** This means that React components you write must always return the same JSX given the same inputs:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Recipe({ drinkers }) {
  return (
    <ol>    
      <li>Boil {drinkers} cups of water.</li>
      <li>Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.</li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

export default function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}
```

Show more

When you pass `drinkers={2}` to `Recipe`, it will return JSX containing `2 cups of water`. Always.

If you pass `drinkers={4}`, it will return JSX containing `4 cups of water`. Always.

Just like a math formula.

You could think of your components as recipes: if you follow them and don’t introduce new ingredients during the cooking process, you will get the same dish every time. That “dish” is the JSX that the component serves to React to [render.](https://react.dev/learn/render-and-commit)

![A tea recipe for x people: take x cups of water, add x spoons of tea and 0.5x spoons of spices, and 0.5x cups of milk](https://react.dev/images/docs/illustrations/i_puritea-recipe.png)

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

## Side Effects: (un)intended consequences

React’s rendering process must always be pure. Components should only *return* their JSX, and not *change* any objects or variables that existed before rendering—that would make them impure!

Here is a component that breaks this rule:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

Show more

This component is reading and writing a `guest` variable declared outside of it. This means that **calling this component multiple times will produce different JSX!** And what’s more, if *other* components read `guest`, they will produce different JSX, too, depending on when they were rendered! That’s not predictable.

Going back to our formula y = 2x, now even if x = 2, we cannot trust that y = 4. Our tests could fail, our users would be baffled, planes would fall out of the sky—you can see how this would lead to confusing bugs!

You can fix this component by [passing `guest` as a prop instead](https://react.dev/learn/passing-props-to-a-component):

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

Now your component is pure, as the JSX it returns only depends on the `guest` prop.

In general, you should not expect your components to be rendered in any particular order. It doesn’t matter if you call y = 2x before or after y = 5x: both formulas will resolve independently of each other. In the same way, each component should only “think for itself”, and not attempt to coordinate with or depend upon others during rendering. Rendering is like a school exam: each component should calculate JSX on their own!

##### Deep Dive

#### Detecting impure calculations with StrictMode

Show Details

Although you might not have used them all yet, in React there are three kinds of inputs that you can read while rendering: [props](https://react.dev/learn/passing-props-to-a-component), [state](https://react.dev/learn/state-a-components-memory), and [context.](https://react.dev/learn/passing-data-deeply-with-context) You should always treat these inputs as read-only.

When you want to *change* something in response to user input, you should [set state](https://react.dev/learn/state-a-components-memory) instead of writing to a variable. You should never change preexisting variables or objects while your component is rendering.

React offers a “Strict Mode” in which it calls each component’s function twice during development. **By calling the component functions twice, Strict Mode helps find components that break these rules.**

Notice how the original example displayed “Guest #2”, “Guest #4”, and “Guest #6” instead of “Guest #1”, “Guest #2”, and “Guest #3”. The original function was impure, so calling it twice broke it. But the fixed pure version works even if the function is called twice every time. **Pure functions only calculate, so calling them twice won’t change anything**—just like calling `double(2)` twice doesn’t change what’s returned, and solving y = 2x twice doesn’t change what y is. Same inputs, same outputs. Always.

Strict Mode has no effect in production, so it won’t slow down the app for your users. To opt into Strict Mode, you can wrap your root component into `<React.StrictMode>`. Some frameworks do this by default.

### Local mutation: Your component’s little secret

In the above example, the problem was that the component changed a *preexisting* variable while rendering. This is often called a **“mutation”** to make it sound a bit scarier. Pure functions don’t mutate variables outside of the function’s scope or objects that were created before the call—that makes them impure!

However, **it’s completely fine to change variables and objects that you’ve *just* created while rendering.** In this example, you create an `[]` array, assign it to a `cups` variable, and then `push` a dozen cups into it:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  const cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

If the `cups` variable or the `[]` array were created outside the `TeaGathering` function, this would be a huge problem! You would be changing a *preexisting* object by pushing items into that array.

However, it’s fine because you’ve created them *during the same render*, inside `TeaGathering`. No code outside of `TeaGathering` will ever know that this happened. This is called **“local mutation”**—it’s like your component’s little secret.

## Where you *can* cause side effects

While functional programming relies heavily on purity, at some point, somewhere, *something* has to change. That’s kind of the point of programming! These changes—updating the screen, starting an animation, changing the data—are called **side effects.** They’re things that happen *“on the side”*, not during rendering.

In React, **side effects usually belong inside [event handlers.](https://react.dev/learn/responding-to-events)** Event handlers are functions that React runs when you perform some action—for example, when you click a button. Even though event handlers are defined *inside* your component, they don’t run *during* rendering! **So event handlers don’t need to be pure.**

If you’ve exhausted all other options and can’t find the right event handler for your side effect, you can still attach it to your returned JSX with a [`useEffect`](https://react.dev/reference/react/useEffect) call in your component. This tells React to execute it later, after rendering, when side effects are allowed. **However, this approach should be your last resort.**

When possible, try to express your logic with rendering alone. You’ll be surprised how far this can take you!

##### Deep Dive

#### Why does React care about purity?

Show Details

Writing pure functions takes some habit and discipline. But it also unlocks marvelous opportunities:

* Your components could run in a different environment—for example, on the server! Since they return the same result for the same inputs, one component can serve many user requests.
* You can improve performance by [skipping rendering](https://react.dev/reference/react/memo) components whose inputs have not changed. This is safe because pure functions always return the same results, so they are safe to cache.
* If some data changes in the middle of rendering a deep component tree, React can restart rendering without wasting time to finish the outdated render. Purity makes it safe to stop calculating at any time.

Every new React feature we’re building takes advantage of purity. From data fetching to animations to performance, keeping components pure unlocks the power of the React paradigm.

## Recap

* A component must be pure, meaning:
  + **It minds its own business.** It should not change any objects or variables that existed before rendering.
  + **Same inputs, same output.** Given the same inputs, a component should always return the same JSX.
* Rendering can happen at any time, so components should not depend on each others’ rendering sequence.
* You should not mutate any of the inputs that your components use for rendering. That includes props, state, and context. To update the screen, [“set” state](https://react.dev/learn/state-a-components-memory) instead of mutating preexisting objects.
* Strive to express your component’s logic in the JSX you return. When you need to “change things”, you’ll usually want to do it in an event handler. As a last resort, you can `useEffect`.
* Writing pure functions takes a bit of practice, but it unlocks the power of React’s paradigm.

## Try out some challenges

1. Fix a broken clock 2. Fix a broken profile 3. Fix a broken story tray

#### Challenge 1 of 3: Fix a broken clock

This component tries to set the `<h1>`’s CSS class to `"night"` during the time from midnight to six hours in the morning, and `"day"` at all other times. However, it doesn’t work. Can you fix this component?

You can verify whether your solution works by temporarily changing the computer’s timezone. When the current time is between midnight and six in the morning, the clock should have inverted colors!

Clock.js

Clock.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Clock({ time }) {
  const hours = time.getHours();
  if (hours >= 0 && hours <= 6) {
    document.getElementById('time').className = 'night';
  } else {
    document.getElementById('time').className = 'day';
  }
  return (
    <h1 id="time">
      {time.toLocaleTimeString()}
    </h1>
  );
}
```

Show hint Show solution

Next Challenge

[PreviousRendering Lists](https://react.dev/learn/rendering-lists)[NextYour UI as a Tree](https://react.dev/learn/understanding-your-ui-as-a-tree)

---

---


# Understanding Your UI as a Tree – React

URL: https://react.dev/learn/understanding-your-ui-as-a-tree

[Learn React](https://react.dev/learn)

[Describing the UI](https://react.dev/learn/describing-the-ui)

# Understanding Your UI as a Tree

Your React app is taking shape with many components being nested within each other. How does React keep track of your app’s component structure?

React, and many other UI libraries, model UI as a tree. Thinking of your app as a tree is useful for understanding the relationship between components. This understanding will help you debug future concepts like performance and state management.

### You will learn

* How React “sees” component structures
* What a render tree is and what it is useful for
* What a module dependency tree is and what it is useful for

## Your UI as a tree

Trees are a relationship model between items. The UI is often represented using tree structures. For example, browsers use tree structures to model HTML ([DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)) and CSS ([CSSOM](https://developer.mozilla.org/docs/Web/API/CSS_Object_Model)). Mobile platforms also use trees to represent their view hierarchy.

![Diagram with three sections arranged horizontally. In the first section, there are three rectangles stacked vertically, with labels 'Component A', 'Component B', and 'Component C'. Transitioning to the next pane is an arrow with the React logo on top labeled 'React'. The middle section contains a tree of components, with the root labeled 'A' and two children labeled 'B' and 'C'. The next section is again transitioned using an arrow with the React logo on top labeled 'React DOM'. The third and final section is a wireframe of a browser, containing a tree of 8 nodes, which has only a subset highlighted (indicating the subtree from the middle section).](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_dom_tree.dark.png&w=1920&q=75)

![Diagram with three sections arranged horizontally. In the first section, there are three rectangles stacked vertically, with labels 'Component A', 'Component B', and 'Component C'. Transitioning to the next pane is an arrow with the React logo on top labeled 'React'. The middle section contains a tree of components, with the root labeled 'A' and two children labeled 'B' and 'C'. The next section is again transitioned using an arrow with the React logo on top labeled 'React DOM'. The third and final section is a wireframe of a browser, containing a tree of 8 nodes, which has only a subset highlighted (indicating the subtree from the middle section).](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_dom_tree.png&w=1920&q=75)

React creates a UI tree from your components. In this example, the UI tree is then used to render to the DOM.

Like browsers and mobile platforms, React also uses tree structures to manage and model the relationship between components in a React app. These trees are useful tools to understand how data flows through a React app and how to optimize rendering and app size.

## The Render Tree

A major feature of components is the ability to compose components of other components. As we [nest components](https://react.dev/learn/your-first-component#nesting-and-organizing-components), we have the concept of parent and child components, where each parent component may itself be a child of another component.

When we render a React app, we can model this relationship in a tree, known as the render tree.

Here is a React app that renders inspirational quotes.

App.jsFancyText.jsInspirationGenerator.jsCopyright.jsquotes.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import FancyText from './FancyText';
import InspirationGenerator from './InspirationGenerator';
import Copyright from './Copyright';

export default function App() {
  return (
    <>
      <FancyText title text="Get Inspired App" />
      <InspirationGenerator>
        <Copyright year={2004} />
      </InspirationGenerator>
    </>
  );
}
```

![Tree graph with five nodes. Each node represents a component. The root of the tree is App, with two arrows extending from it to 'InspirationGenerator' and 'FancyText'. The arrows are labelled with the word 'renders'. 'InspirationGenerator' node also has two arrows pointing to nodes 'FancyText' and 'Copyright'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Frender_tree.dark.png&w=1080&q=75)

![Tree graph with five nodes. Each node represents a component. The root of the tree is App, with two arrows extending from it to 'InspirationGenerator' and 'FancyText'. The arrows are labelled with the word 'renders'. 'InspirationGenerator' node also has two arrows pointing to nodes 'FancyText' and 'Copyright'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Frender_tree.png&w=1080&q=75)

React creates a *render tree*, a UI tree, composed of the rendered components.

From the example app, we can construct the above render tree.

The tree is composed of nodes, each of which represents a component. `App`, `FancyText`, `Copyright`, to name a few, are all nodes in our tree.

The root node in a React render tree is the [root component](https://react.dev/learn/importing-and-exporting-components#the-root-component-file) of the app. In this case, the root component is `App` and it is the first component React renders. Each arrow in the tree points from a parent component to a child component.

##### Deep Dive

#### Where are the HTML tags in the render tree?

Show Details

You’ll notice in the above render tree, there is no mention of the HTML tags that each component renders. This is because the render tree is only composed of React [components](https://react.dev/learn/your-first-component#components-ui-building-blocks).

React, as a UI framework, is platform agnostic. On react.dev, we showcase examples that render to the web, which uses HTML markup as its UI primitives. But a React app could just as likely render to a mobile or desktop platform, which may use different UI primitives like [UIView](https://developer.apple.com/documentation/uikit/uiview) or [FrameworkElement](https://learn.microsoft.com/en-us/dotnet/api/system.windows.frameworkelement?view=windowsdesktop-7.0).

These platform UI primitives are not a part of React. React render trees can provide insight to our React app regardless of what platform your app renders to.

A render tree represents a single render pass of a React application. With [conditional rendering](https://react.dev/learn/conditional-rendering), a parent component may render different children depending on the data passed.

We can update the app to conditionally render either an inspirational quote or color.

App.jsFancyText.jsColor.jsInspirationGenerator.jsCopyright.jsinspirations.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import FancyText from './FancyText';
import InspirationGenerator from './InspirationGenerator';
import Copyright from './Copyright';

export default function App() {
  return (
    <>
      <FancyText title text="Get Inspired App" />
      <InspirationGenerator>
        <Copyright year={2004} />
      </InspirationGenerator>
    </>
  );
}
```

![Tree graph with six nodes. The top node of the tree is labelled 'App' with two arrows extending to nodes labelled 'InspirationGenerator' and 'FancyText'. The arrows are solid lines and are labelled with the word 'renders'. 'InspirationGenerator' node also has three arrows. The arrows to nodes 'FancyText' and 'Color' are dashed and labelled with 'renders?'. The last arrow points to the node labelled 'Copyright' and is solid and labelled with 'renders'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fconditional_render_tree.dark.png&w=1200&q=75)

![Tree graph with six nodes. The top node of the tree is labelled 'App' with two arrows extending to nodes labelled 'InspirationGenerator' and 'FancyText'. The arrows are solid lines and are labelled with the word 'renders'. 'InspirationGenerator' node also has three arrows. The arrows to nodes 'FancyText' and 'Color' are dashed and labelled with 'renders?'. The last arrow points to the node labelled 'Copyright' and is solid and labelled with 'renders'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fconditional_render_tree.png&w=1200&q=75)

With conditional rendering, across different renders, the render tree may render different components.

In this example, depending on what `inspiration.type` is, we may render `<FancyText>` or `<Color>`. The render tree may be different for each render pass.

Although render trees may differ across render passes, these trees are generally helpful for identifying what the *top-level* and *leaf components* are in a React app. Top-level components are the components nearest to the root component and affect the rendering performance of all the components beneath them and often contain the most complexity. Leaf components are near the bottom of the tree and have no child components and are often frequently re-rendered.

Identifying these categories of components are useful for understanding data flow and performance of your app.

## The Module Dependency Tree

Another relationship in a React app that can be modeled with a tree are an app’s module dependencies. As we [break up our components](https://react.dev/learn/importing-and-exporting-components#exporting-and-importing-a-component) and logic into separate files, we create [JS modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) where we may export components, functions, or constants.

Each node in a module dependency tree is a module and each branch represents an `import` statement in that module.

If we take the previous Inspirations app, we can build a module dependency tree, or dependency tree for short.

![A tree graph with seven nodes. Each node is labelled with a module name. The top level node of the tree is labelled 'App.js'. There are three arrows pointing to the modules 'InspirationGenerator.js', 'FancyText.js' and 'Copyright.js' and the arrows are labelled with 'imports'. From the 'InspirationGenerator.js' node, there are three arrows that extend to three modules: 'FancyText.js', 'Color.js', and 'inspirations.js'. The arrows are labelled with 'imports'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fmodule_dependency_tree.dark.png&w=1920&q=75)

![A tree graph with seven nodes. Each node is labelled with a module name. The top level node of the tree is labelled 'App.js'. There are three arrows pointing to the modules 'InspirationGenerator.js', 'FancyText.js' and 'Copyright.js' and the arrows are labelled with 'imports'. From the 'InspirationGenerator.js' node, there are three arrows that extend to three modules: 'FancyText.js', 'Color.js', and 'inspirations.js'. The arrows are labelled with 'imports'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fmodule_dependency_tree.png&w=1920&q=75)

The module dependency tree for the Inspirations app.

The root node of the tree is the root module, also known as the entrypoint file. It often is the module that contains the root component.

Comparing to the render tree of the same app, there are similar structures but some notable differences:

* The nodes that make-up the tree represent modules, not components.
* Non-component modules, like `inspirations.js`, are also represented in this tree. The render tree only encapsulates components.
* `Copyright.js` appears under `App.js` but in the render tree, `Copyright`, the component, appears as a child of `InspirationGenerator`. This is because `InspirationGenerator` accepts JSX as [children props](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children), so it renders `Copyright` as a child component but does not import the module.

Dependency trees are useful to determine what modules are necessary to run your React app. When building a React app for production, there is typically a build step that will bundle all the necessary JavaScript to ship to the client. The tool responsible for this is called a [bundler](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Overview#the_modern_tooling_ecosystem), and bundlers will use the dependency tree to determine what modules should be included.

As your app grows, often the bundle size does too. Large bundle sizes are expensive for a client to download and run. Large bundle sizes can delay the time for your UI to get drawn. Getting a sense of your app’s dependency tree may help with debugging these issues.

## Recap

* Trees are a common way to represent the relationship between entities. They are often used to model UI.
* Render trees represent the nested relationship between React components across a single render.
* With conditional rendering, the render tree may change across different renders. With different prop values, components may render different children components.
* Render trees help identify what the top-level and leaf components are. Top-level components affect the rendering performance of all components beneath them and leaf components are often re-rendered frequently. Identifying them is useful for understanding and debugging rendering performance.
* Dependency trees represent the module dependencies in a React app.
* Dependency trees are used by build tools to bundle the necessary code to ship an app.
* Dependency trees are useful for debugging large bundle sizes that slow time to paint and expose opportunities for optimizing what code is bundled.

[PreviousKeeping Components Pure](https://react.dev/learn/keeping-components-pure)[NextAdding Interactivity](https://react.dev/learn/adding-interactivity)

---

---


# Adding Interactivity – React

URL: https://react.dev/learn/adding-interactivity

[Learn React](https://react.dev/learn)

# Adding Interactivity

Some things on the screen update in response to user input. For example, clicking an image gallery switches the active image. In React, data that changes over time is called *state.* You can add state to any component, and update it as needed. In this chapter, you’ll learn how to write components that handle interactions, update their state, and display different output over time.

### In this chapter

* [How to handle user-initiated events](https://react.dev/learn/responding-to-events)
* [How to make components “remember” information with state](https://react.dev/learn/state-a-components-memory)
* [How React updates the UI in two phases](https://react.dev/learn/render-and-commit)
* [Why state doesn’t update right after you change it](https://react.dev/learn/state-as-a-snapshot)
* [How to queue multiple state updates](https://react.dev/learn/queueing-a-series-of-state-updates)
* [How to update an object in state](https://react.dev/learn/updating-objects-in-state)
* [How to update an array in state](https://react.dev/learn/updating-arrays-in-state)

## Responding to events

React lets you add *event handlers* to your JSX. Event handlers are your own functions that will be triggered in response to user interactions like clicking, hovering, focusing on form inputs, and so on.

Built-in components like `<button>` only support built-in browser events like `onClick`. However, you can also create your own components, and give their event handler props any application-specific names that you like.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function App() {
  return (
    <Toolbar
      onPlayMovie={() => alert('Playing!')}
      onUploadImage={() => alert('Uploading!')}
    />
  );
}

function Toolbar({ onPlayMovie, onUploadImage }) {
  return (
    <div>
      <Button onClick={onPlayMovie}>
        Play Movie
      </Button>
      <Button onClick={onUploadImage}>
        Upload Image
      </Button>
    </div>
  );
}

function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}
```

Show more

## Ready to learn this topic?

Read **[Responding to Events](https://react.dev/learn/responding-to-events)** to learn how to add event handlers.

[Read More](https://react.dev/learn/responding-to-events)

---

## State: a component’s memory

Components often need to change what’s on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” puts a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called *state.*

You can add state to a component with a [`useState`](https://react.dev/reference/react/useState) Hook. *Hooks* are special functions that let your components use React features (state is one of those features). The `useState` Hook lets you declare a state variable. It takes the initial state and returns a pair of values: the current state, and a state setter function that lets you update it.

```
const [index, setIndex] = useState(0);

const [showMore, setShowMore] = useState(false);
```

Here is how an image gallery uses and updates state on click:

App.jsdata.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);
  const hasNext = index < sculptureList.length - 1;

  function handleNextClick() {
    if (hasNext) {
      setIndex(index + 1);
    } else {
      setIndex(0);
    }
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i>
        by {sculpture.artist}
      </h2>
      <h3>
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img
        src={sculpture.url}
        alt={sculpture.alt}
      />
    </>
  );
}
```

Show more

## Ready to learn this topic?

Read **[State: A Component’s Memory](https://react.dev/learn/state-a-components-memory)** to learn how to remember a value and update it on interaction.

[Read More](https://react.dev/learn/state-a-components-memory)

---

## Render and commit

Before your components are displayed on the screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior.

Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:

1. **Triggering** a render (delivering the diner’s order to the kitchen)
2. **Rendering** the component (preparing the order in the kitchen)
3. **Committing** to the DOM (placing the order on the table)

1. ![React as a server in a restaurant, fetching orders from the users and delivering them to the Component Kitchen.](https://react.dev/images/docs/illustrations/i_render-and-commit1.png)

   Trigger
2. ![The Card Chef gives React a fresh Card component.](https://react.dev/images/docs/illustrations/i_render-and-commit2.png)

   Render
3. ![React delivers the Card to the user at their table.](https://react.dev/images/docs/illustrations/i_render-and-commit3.png)

   Commit

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

## Ready to learn this topic?

Read **[Render and Commit](https://react.dev/learn/render-and-commit)** to learn the lifecycle of a UI update.

[Read More](https://react.dev/learn/render-and-commit)

---

## State as a snapshot

Unlike regular JavaScript variables, React state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render. This can be surprising at first!

```
console.log(count);  // 0

setCount(count + 1); // Request a re-render with 1

console.log(count);  // Still 0!
```

This behavior helps you avoid subtle bugs. Here is a little chat app. Try to guess what happens if you press “Send” first and *then* change the recipient to Bob. Whose name will appear in the `alert` five seconds later?

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Hello');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`You said ${message} to ${to}`);
    }, 5000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        To:{' '}
        <select
          value={to}
          onChange={e => setTo(e.target.value)}>
          <option value="Alice">Alice</option>
          <option value="Bob">Bob</option>
        </select>
      </label>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}
```

Show more

## Ready to learn this topic?

Read **[State as a Snapshot](https://react.dev/learn/state-as-a-snapshot)** to learn why state appears “fixed” and unchanging inside the event handlers.

[Read More](https://react.dev/learn/state-as-a-snapshot)

---

## Queueing a series of state updates

This component is buggy: clicking “+3” increments the score only once.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [score, setScore] = useState(0);

  function increment() {
    setScore(score + 1);
  }

  return (
    <>
      <button onClick={() => increment()}>+1</button>
      <button onClick={() => {
        increment();
        increment();
        increment();
      }}>+3</button>
      <h1>Score: {score}</h1>
    </>
  )
}
```

Show more

[State as a Snapshot](https://react.dev/learn/state-as-a-snapshot) explains why this is happening. Setting state requests a new re-render, but does not change it in the already running code. So `score` continues to be `0` right after you call `setScore(score + 1)`.

```
console.log(score);  // 0

setScore(score + 1); // setScore(0 + 1);

console.log(score);  // 0

setScore(score + 1); // setScore(0 + 1);

console.log(score);  // 0

setScore(score + 1); // setScore(0 + 1);

console.log(score);  // 0
```

You can fix this by passing an *updater function* when setting state. Notice how replacing `setScore(score + 1)` with `setScore(s => s + 1)` fixes the “+3” button. This lets you queue multiple state updates.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [score, setScore] = useState(0);

  function increment() {
    setScore(s => s + 1);
  }

  return (
    <>
      <button onClick={() => increment()}>+1</button>
      <button onClick={() => {
        increment();
        increment();
        increment();
      }}>+3</button>
      <h1>Score: {score}</h1>
    </>
  )
}
```

Show more

## Ready to learn this topic?

Read **[Queueing a Series of State Updates](https://react.dev/learn/queueing-a-series-of-state-updates)** to learn how to queue a sequence of state updates.

[Read More](https://react.dev/learn/queueing-a-series-of-state-updates)

---

## Updating objects in state

State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects and arrays that you hold in the React state directly. Instead, when you want to update an object and array, you need to create a new one (or make a copy of an existing one), and then update the state to use that copy.

Usually, you will use the `...` spread syntax to copy objects and arrays that you want to change. For example, updating a nested object could look like this:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });

  function handleNameChange(e) {
    setPerson({
      ...person,
      name: e.target.value
    });
  }

  function handleTitleChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value
      }
    });
  }

  function handleCityChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        city: e.target.value
      }
    });
  }

  function handleImageChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        image: e.target.value
      }
    });
  }

  return (
    <>
      <label>
        Name:
        <input
          value={person.name}
          onChange={handleNameChange}
        />
      </label>
      <label>
        Title:
        <input
          value={person.artwork.title}
          onChange={handleTitleChange}
        />
      </label>
      <label>
        City:
        <input
          value={person.artwork.city}
          onChange={handleCityChange}
        />
      </label>
      <label>
        Image:
        <input
          value={person.artwork.image}
          onChange={handleImageChange}
        />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img
        src={person.artwork.image}
        alt={person.artwork.title}
      />
    </>
  );
}
```

Show more

If copying objects in code gets tedious, you can use a library like [Immer](https://github.com/immerjs/use-immer) to reduce repetitive code:

package.jsonApp.js

package.json

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

## Ready to learn this topic?

Read **[Updating Objects in State](https://react.dev/learn/updating-objects-in-state)** to learn how to update objects correctly.

[Read More](https://react.dev/learn/updating-objects-in-state)

---

## Updating arrays in state

Arrays are another type of mutable JavaScript objects you can store in state and should treat as read-only. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [list, setList] = useState(
    initialList
  );

  function handleToggle(artworkId, nextSeen) {
    setList(list.map(artwork => {
      if (artwork.id === artworkId) {
        return { ...artwork, seen: nextSeen };
      } else {
        return artwork;
      }
    }));
  }

  return (
    <>
      <h1>Art Bucket List</h1>
      <h2>My list of art to see:</h2>
      <ItemList
        artworks={list}
        onToggle={handleToggle} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map(artwork => (
        <li key={artwork.id}>
          <label>
            <input
              type="checkbox"
              checked={artwork.seen}
              onChange={e => {
                onToggle(
                  artwork.id,
                  e.target.checked
                );
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

Show more

If copying arrays in code gets tedious, you can use a library like [Immer](https://github.com/immerjs/use-immer) to reduce repetitive code:

package.jsonApp.js

package.json

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

## Ready to learn this topic?

Read **[Updating Arrays in State](https://react.dev/learn/updating-arrays-in-state)** to learn how to update arrays correctly.

[Read More](https://react.dev/learn/updating-arrays-in-state)

---

## What’s next?

Head over to [Responding to Events](https://react.dev/learn/responding-to-events) to start reading this chapter page by page!

Or, if you’re already familiar with these topics, why not read about [Managing State](https://react.dev/learn/managing-state)?

[PreviousYour UI as a Tree](https://react.dev/learn/understanding-your-ui-as-a-tree)[NextResponding to Events](https://react.dev/learn/responding-to-events)

---

---


# Responding to Events – React

URL: https://react.dev/learn/responding-to-events

[Learn React](https://react.dev/learn)

[Adding Interactivity](https://react.dev/learn/adding-interactivity)

# Responding to Events

React lets you add *event handlers* to your JSX. Event handlers are your own functions that will be triggered in response to interactions like clicking, hovering, focusing form inputs, and so on.

### You will learn

* Different ways to write an event handler
* How to pass event handling logic from a parent component
* How events propagate and how to stop them

## Adding event handlers

To add an event handler, you will first define a function and then [pass it as a prop](https://react.dev/learn/passing-props-to-a-component) to the appropriate JSX tag. For example, here is a button that doesn’t do anything yet:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Button() {
  return (
    <button>
      I don't do anything
    </button>
  );
}
```

You can make it show a message when a user clicks by following these three steps:

1. Declare a function called `handleClick` *inside* your `Button` component.
2. Implement the logic inside that function (use `alert` to show the message).
3. Add `onClick={handleClick}` to the `<button>` JSX.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

You defined the `handleClick` function and then [passed it as a prop](https://react.dev/learn/passing-props-to-a-component) to `<button>`. `handleClick` is an **event handler.** Event handler functions:

* Are usually defined *inside* your components.
* Have names that start with `handle`, followed by the name of the event.

By convention, it is common to name event handlers as `handle` followed by the event name. You’ll often see `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}`, and so on.

Alternatively, you can define an event handler inline in the JSX:

```
<button onClick={function handleClick() {

alert('You clicked me!');

}}>
```

Or, more concisely, using an arrow function:

```
<button onClick={() => {

alert('You clicked me!');

}}>
```

All of these styles are equivalent. Inline event handlers are convenient for short functions.

### Pitfall

Functions passed to event handlers must be passed, not called. For example:

| passing a function (correct) | calling a function (incorrect) |
| --- | --- |
| `<button onClick={handleClick}>` | `<button onClick={handleClick()}>` |

The difference is subtle. In the first example, the `handleClick` function is passed as an `onClick` event handler. This tells React to remember it and only call your function when the user clicks the button.

In the second example, the `()` at the end of `handleClick()` fires the function *immediately* during [rendering](https://react.dev/learn/render-and-commit), without any clicks. This is because JavaScript inside the [JSX `{` and `}`](https://react.dev/learn/javascript-in-jsx-with-curly-braces) executes right away.

When you write code inline, the same pitfall presents itself in a different way:

| passing a function (correct) | calling a function (incorrect) |
| --- | --- |
| `<button onClick={() => alert('...')}>` | `<button onClick={alert('...')}>` |

Passing inline code like this won’t fire on click—it fires every time the component renders:

```
// This alert fires when the component renders, not when clicked!

<button onClick={alert('You clicked me!')}>
```

If you want to define your event handler inline, wrap it in an anonymous function like so:

```
<button onClick={() => alert('You clicked me!')}>
```

Rather than executing the code inside with every render, this creates a function to be called later.

In both cases, what you want to pass is a function:

* `<button onClick={handleClick}>` passes the `handleClick` function.
* `<button onClick={() => alert('...')}>` passes the `() => alert('...')` function.

[Read more about arrow functions.](https://javascript.info/arrow-functions-basics)

### Reading props in event handlers

Because event handlers are declared inside of a component, they have access to the component’s props. Here is a button that, when clicked, shows an alert with its `message` prop:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function AlertButton({ message, children }) {
  return (
    <button onClick={() => alert(message)}>
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div>
      <AlertButton message="Playing!">
        Play Movie
      </AlertButton>
      <AlertButton message="Uploading!">
        Upload Image
      </AlertButton>
    </div>
  );
}
```

Show more

This lets these two buttons show different messages. Try changing the messages passed to them.

### Passing event handlers as props

Often you’ll want the parent component to specify a child’s event handler. Consider buttons: depending on where you’re using a `Button` component, you might want to execute a different function—perhaps one plays a movie and another uploads an image.

To do this, pass a prop the component receives from its parent as the event handler like so:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`Playing ${movieName}!`);
  }

  return (
    <Button onClick={handlePlayClick}>
      Play "{movieName}"
    </Button>
  );
}

function UploadButton() {
  return (
    <Button onClick={() => alert('Uploading!')}>
      Upload Image
    </Button>
  );
}

export default function Toolbar() {
  return (
    <div>
      <PlayButton movieName="Kiki's Delivery Service" />
      <UploadButton />
    </div>
  );
}
```

Show more

Here, the `Toolbar` component renders a `PlayButton` and an `UploadButton`:

* `PlayButton` passes `handlePlayClick` as the `onClick` prop to the `Button` inside.
* `UploadButton` passes `() => alert('Uploading!')` as the `onClick` prop to the `Button` inside.

Finally, your `Button` component accepts a prop called `onClick`. It passes that prop directly to the built-in browser `<button>` with `onClick={onClick}`. This tells React to call the passed function on click.

If you use a [design system](https://uxdesign.cc/everything-you-need-to-know-about-design-systems-54b109851969), it’s common for components like buttons to contain styling but not specify behavior. Instead, components like `PlayButton` and `UploadButton` will pass event handlers down.

### Naming event handler props

Built-in components like `<button>` and `<div>` only support [browser event names](https://react.dev/reference/react-dom/components/common#common-props) like `onClick`. However, when you’re building your own components, you can name their event handler props any way that you like.

By convention, event handler props should start with `on`, followed by a capital letter.

For example, the `Button` component’s `onClick` prop could have been called `onSmash`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Button({ onSmash, children }) {
  return (
    <button onClick={onSmash}>
      {children}
    </button>
  );
}

export default function App() {
  return (
    <div>
      <Button onSmash={() => alert('Playing!')}>
        Play Movie
      </Button>
      <Button onSmash={() => alert('Uploading!')}>
        Upload Image
      </Button>
    </div>
  );
}
```

Show more

In this example, `<button onClick={onSmash}>` shows that the browser `<button>` (lowercase) still needs a prop called `onClick`, but the prop name received by your custom `Button` component is up to you!

When your component supports multiple interactions, you might name event handler props for app-specific concepts. For example, this `Toolbar` component receives `onPlayMovie` and `onUploadImage` event handlers:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function App() {
  return (
    <Toolbar
      onPlayMovie={() => alert('Playing!')}
      onUploadImage={() => alert('Uploading!')}
    />
  );
}

function Toolbar({ onPlayMovie, onUploadImage }) {
  return (
    <div>
      <Button onClick={onPlayMovie}>
        Play Movie
      </Button>
      <Button onClick={onUploadImage}>
        Upload Image
      </Button>
    </div>
  );
}

function Button({ onClick, children }) {
  return (
    <button onClick={onClick}>
      {children}
    </button>
  );
}
```

Show more

Notice how the `App` component does not need to know *what* `Toolbar` will do with `onPlayMovie` or `onUploadImage`. That’s an implementation detail of the `Toolbar`. Here, `Toolbar` passes them down as `onClick` handlers to its `Button`s, but it could later also trigger them on a keyboard shortcut. Naming props after app-specific interactions like `onPlayMovie` gives you the flexibility to change how they’re used later.

### Note

Make sure that you use the appropriate HTML tags for your event handlers. For example, to handle clicks, use [`<button onClick={handleClick}>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) instead of `<div onClick={handleClick}>`. Using a real browser `<button>` enables built-in browser behaviors like keyboard navigation. If you don’t like the default browser styling of a button and want to make it look more like a link or a different UI element, you can achieve it with CSS. [Learn more about writing accessible markup.](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML)

## Event propagation

Event handlers will also catch events from any children your component might have. We say that an event “bubbles” or “propagates” up the tree: it starts with where the event happened, and then goes up the tree.

This `<div>` contains two buttons. Both the `<div>` *and* each button have their own `onClick` handlers. Which handlers do you think will fire when you click a button?

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Toolbar() {
  return (
    <div className="Toolbar" onClick={() => {
      alert('You clicked on the toolbar!');
    }}>
      <button onClick={() => alert('Playing!')}>
        Play Movie
      </button>
      <button onClick={() => alert('Uploading!')}>
        Upload Image
      </button>
    </div>
  );
}
```

If you click on either button, its `onClick` will run first, followed by the parent `<div>`’s `onClick`. So two messages will appear. If you click the toolbar itself, only the parent `<div>`’s `onClick` will run.

### Pitfall

All events propagate in React except `onScroll`, which only works on the JSX tag you attach it to.

### Stopping propagation

Event handlers receive an **event object** as their only argument. By convention, it’s usually called `e`, which stands for “event”. You can use this object to read information about the event.

That event object also lets you stop the propagation. If you want to prevent an event from reaching parent components, you need to call `e.stopPropagation()` like this `Button` component does:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Button({ onClick, children }) {
  return (
    <button onClick={e => {
      e.stopPropagation();
      onClick();
    }}>
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div className="Toolbar" onClick={() => {
      alert('You clicked on the toolbar!');
    }}>
      <Button onClick={() => alert('Playing!')}>
        Play Movie
      </Button>
      <Button onClick={() => alert('Uploading!')}>
        Upload Image
      </Button>
    </div>
  );
}
```

Show more

When you click on a button:

1. React calls the `onClick` handler passed to `<button>`.
2. That handler, defined in `Button`, does the following:
   * Calls `e.stopPropagation()`, preventing the event from bubbling further.
   * Calls the `onClick` function, which is a prop passed from the `Toolbar` component.
3. That function, defined in the `Toolbar` component, displays the button’s own alert.
4. Since the propagation was stopped, the parent `<div>`’s `onClick` handler does *not* run.

As a result of `e.stopPropagation()`, clicking on the buttons now only shows a single alert (from the `<button>`) rather than the two of them (from the `<button>` and the parent toolbar `<div>`). Clicking a button is not the same thing as clicking the surrounding toolbar, so stopping the propagation makes sense for this UI.

##### Deep Dive

#### Capture phase events

Show Details

In rare cases, you might need to catch all events on child elements, *even if they stopped propagation*. For example, maybe you want to log every click to analytics, regardless of the propagation logic. You can do this by adding `Capture` at the end of the event name:

```
<div onClickCapture={() => { /* this runs first */ }}>

<button onClick={e => e.stopPropagation()} />

<button onClick={e => e.stopPropagation()} />

</div>
```

Each event propagates in three phases:

1. It travels down, calling all `onClickCapture` handlers.
2. It runs the clicked element’s `onClick` handler.
3. It travels upwards, calling all `onClick` handlers.

Capture events are useful for code like routers or analytics, but you probably won’t use them in app code.

### Passing handlers as alternative to propagation

Notice how this click handler runs a line of code *and then* calls the `onClick` prop passed by the parent:

```
function Button({ onClick, children }) {

return (

<button onClick={e => {

e.stopPropagation();

onClick();

}}>

{children}

</button>

);

}
```

You could add more code to this handler before calling the parent `onClick` event handler, too. This pattern provides an *alternative* to propagation. It lets the child component handle the event, while also letting the parent component specify some additional behavior. Unlike propagation, it’s not automatic. But the benefit of this pattern is that you can clearly follow the whole chain of code that executes as a result of some event.

If you rely on propagation and it’s difficult to trace which handlers execute and why, try this approach instead.

### Preventing default behavior

Some browser events have default behavior associated with them. For example, a `<form>` submit event, which happens when a button inside of it is clicked, will reload the whole page by default:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Signup() {
  return (
    <form onSubmit={() => alert('Submitting!')}>
      <input />
      <button>Send</button>
    </form>
  );
}
```

You can call `e.preventDefault()` on the event object to stop this from happening:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Signup() {
  return (
    <form onSubmit={e => {
      e.preventDefault();
      alert('Submitting!');
    }}>
      <input />
      <button>Send</button>
    </form>
  );
}
```

Don’t confuse `e.stopPropagation()` and `e.preventDefault()`. They are both useful, but are unrelated:

* [`e.stopPropagation()`](https://developer.mozilla.org/docs/Web/API/Event/stopPropagation) stops the event handlers attached to the tags above from firing.
* [`e.preventDefault()`](https://developer.mozilla.org/docs/Web/API/Event/preventDefault)  prevents the default browser behavior for the few events that have it.

## Can event handlers have side effects?

Absolutely! Event handlers are the best place for side effects.

Unlike rendering functions, event handlers don’t need to be [pure](https://react.dev/learn/keeping-components-pure), so it’s a great place to *change* something—for example, change an input’s value in response to typing, or change a list in response to a button press. However, in order to change some information, you first need some way to store it. In React, this is done by using [state, a component’s memory.](https://react.dev/learn/state-a-components-memory) You will learn all about it on the next page.

## Recap

* You can handle events by passing a function as a prop to an element like `<button>`.
* Event handlers must be passed, **not called!** `onClick={handleClick}`, not `onClick={handleClick()}`.
* You can define an event handler function separately or inline.
* Event handlers are defined inside a component, so they can access props.
* You can declare an event handler in a parent and pass it as a prop to a child.
* You can define your own event handler props with application-specific names.
* Events propagate upwards. Call `e.stopPropagation()` on the first argument to prevent that.
* Events may have unwanted default browser behavior. Call `e.preventDefault()` to prevent that.
* Explicitly calling an event handler prop from a child handler is a good alternative to propagation.

## Try out some challenges

1. Fix an event handler 2. Wire up the events

#### Challenge 1 of 2: Fix an event handler

Clicking this button is supposed to switch the page background between white and black. However, nothing happens when you click it. Fix the problem. (Don’t worry about the logic inside `handleClick`—that part is fine.)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function LightSwitch() {
  function handleClick() {
    let bodyStyle = document.body.style;
    if (bodyStyle.backgroundColor === 'black') {
      bodyStyle.backgroundColor = 'white';
    } else {
      bodyStyle.backgroundColor = 'black';
    }
  }

  return (
    <button onClick={handleClick()}>
      Toggle the lights
    </button>
  );
}
```

Show more

Show solutionNext Challenge

[PreviousAdding Interactivity](https://react.dev/learn/adding-interactivity)[NextState: A Component's Memory](https://react.dev/learn/state-a-components-memory)

---

---


# State: A Component's Memory – React

URL: https://react.dev/learn/state-a-components-memory

[Learn React](https://react.dev/learn)

[Adding Interactivity](https://react.dev/learn/adding-interactivity)

# State: A Component's Memory

Components often need to change what’s on the screen as a result of an interaction. Typing into the form should update the input field, clicking “next” on an image carousel should change which image is displayed, clicking “buy” should put a product in the shopping cart. Components need to “remember” things: the current input value, the current image, the shopping cart. In React, this kind of component-specific memory is called *state*.

### You will learn

* How to add a state variable with the [`useState`](https://react.dev/reference/react/useState) Hook
* What pair of values the `useState` Hook returns
* How to add more than one state variable
* Why state is called local

## When a regular variable isn’t enough

Here’s a component that renders a sculpture image. Clicking the “Next” button should show the next sculpture by changing the `index` to `1`, then `2`, and so on. However, this **won’t work** (you can try it!):

App.jsdata.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { sculptureList } from './data.js';

export default function Gallery() {
  let index = 0;

  function handleClick() {
    index = index + 1;
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
      <p>
        {sculpture.description}
      </p>
    </>
  );
}
```

Show more

The `handleClick` event handler is updating a local variable, `index`. But two things prevent that change from being visible:

1. **Local variables don’t persist between renders.** When React renders this component a second time, it renders it from scratch—it doesn’t consider any changes to the local variables.
2. **Changes to local variables won’t trigger renders.** React doesn’t realize it needs to render the component again with the new data.

To update a component with new data, two things need to happen:

1. **Retain** the data between renders.
2. **Trigger** React to render the component with new data (re-rendering).

The [`useState`](https://react.dev/reference/react/useState) Hook provides those two things:

1. A **state variable** to retain the data between renders.
2. A **state setter function** to update the variable and trigger React to render the component again.

## Adding a state variable

To add a state variable, import `useState` from React at the top of the file:

```
import { useState } from 'react';
```

Then, replace this line:

```
let index = 0;
```

with

```
const [index, setIndex] = useState(0);
```

`index` is a state variable and `setIndex` is the setter function.

> The `[` and `]` syntax here is called [array destructuring](https://javascript.info/destructuring-assignment) and it lets you read values from an array. The array returned by `useState` always has exactly two items.

This is how they work together in `handleClick`:

```
function handleClick() {

setIndex(index + 1);

}
```

Now clicking the “Next” button switches the current sculpture:

App.jsdata.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);

  function handleClick() {
    setIndex(index + 1);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
      <p>
        {sculpture.description}
      </p>
    </>
  );
}
```

Show more

### Meet your first Hook

In React, `useState`, as well as any other function starting with “`use`”, is called a Hook.

*Hooks* are special functions that are only available while React is [rendering](https://react.dev/learn/render-and-commit#step-1-trigger-a-render) (which we’ll get into in more detail on the next page). They let you “hook into” different React features.

State is just one of those features, but you will meet the other Hooks later.

### Pitfall

**Hooks—functions starting with `use`—can only be called at the top level of your components or [your own Hooks.](https://react.dev/learn/reusing-logic-with-custom-hooks)** You can’t call Hooks inside conditions, loops, or other nested functions. Hooks are functions, but it’s helpful to think of them as unconditional declarations about your component’s needs. You “use” React features at the top of your component similar to how you “import” modules at the top of your file.

### Anatomy of `useState`

When you call [`useState`](https://react.dev/reference/react/useState), you are telling React that you want this component to remember something:

```
const [index, setIndex] = useState(0);
```

In this case, you want React to remember `index`.

### Note

The convention is to name this pair like `const [something, setSomething]`. You could name it anything you like, but conventions make things easier to understand across projects.

The only argument to `useState` is the **initial value** of your state variable. In this example, the `index`’s initial value is set to `0` with `useState(0)`.

Every time your component renders, `useState` gives you an array containing two values:

1. The **state variable** (`index`) with the value you stored.
2. The **state setter function** (`setIndex`) which can update the state variable and trigger React to render the component again.

Here’s how that happens in action:

```
const [index, setIndex] = useState(0);
```

1. **Your component renders the first time.** Because you passed `0` to `useState` as the initial value for `index`, it will return `[0, setIndex]`. React remembers `0` is the latest state value.
2. **You update the state.** When a user clicks the button, it calls `setIndex(index + 1)`. `index` is `0`, so it’s `setIndex(1)`. This tells React to remember `index` is `1` now and triggers another render.
3. **Your component’s second render.** React still sees `useState(0)`, but because React *remembers* that you set `index` to `1`, it returns `[1, setIndex]` instead.
4. And so on!

## Giving a component multiple state variables

You can have as many state variables of as many types as you like in one component. This component has two state variables, a number `index` and a boolean `showMore` that’s toggled when you click “Show details”:

App.jsdata.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
    </>
  );
}
```

Show more

It is a good idea to have multiple state variables if their state is unrelated, like `index` and `showMore` in this example. But if you find that you often change two state variables together, it might be easier to combine them into one. For example, if you have a form with many fields, it’s more convenient to have a single state variable that holds an object than state variable per field. Read [Choosing the State Structure](https://react.dev/learn/choosing-the-state-structure) for more tips.

##### Deep Dive

#### How does React know which state to return?

Show Details

You might have noticed that the `useState` call does not receive any information about *which* state variable it refers to. There is no “identifier” that is passed to `useState`, so how does it know which of the state variables to return? Does it rely on some magic like parsing your functions? The answer is no.

Instead, to enable their concise syntax, Hooks **rely on a stable call order on every render of the same component.** This works well in practice because if you follow the rule above (“only call Hooks at the top level”), Hooks will always be called in the same order. Additionally, a [linter plugin](https://www.npmjs.com/package/eslint-plugin-react-hooks) catches most mistakes.

Internally, React holds an array of state pairs for every component. It also maintains the current pair index, which is set to `0` before rendering. Each time you call `useState`, React gives you the next state pair and increments the index. You can read more about this mechanism in [React Hooks: Not Magic, Just Arrays.](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)

This example **doesn’t use React** but it gives you an idea of how `useState` works internally:

index.jsindex.html

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
let componentHooks = [];
let currentHookIndex = 0;

// How useState works inside React (simplified).
function useState(initialState) {
  let pair = componentHooks[currentHookIndex];
  if (pair) {
    // This is not the first render,
    // so the state pair already exists.
    // Return it and prepare for next Hook call.
    currentHookIndex++;
    return pair;
  }

  // This is the first time we're rendering,
  // so create a state pair and store it.
  pair = [initialState, setState];

  function setState(nextState) {
    // When the user requests a state change,
    // put the new value into the pair.
    pair[0] = nextState;
    updateDOM();
  }

  // Store the pair for future renders
  // and prepare for the next Hook call.
  componentHooks[currentHookIndex] = pair;
  currentHookIndex++;
  return pair;
}

function Gallery() {
  // Each useState() call will get the next pair.
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  // This example doesn't use React, so
  // return an output object instead of JSX.
  return {
    onNextClick: handleNextClick,
    onMoreClick: handleMoreClick,
    header: `${sculpture.name} by ${sculpture.artist}`,
    counter: `${index + 1} of ${sculptureList.length}`,
    more: `${showMore ? 'Hide' : 'Show'} details`,
    description: showMore ? sculpture.description : null,
    imageSrc: sculpture.url,
    imageAlt: sculpture.alt
  };
}

function updateDOM() {
  // Reset the current Hook index
  // before rendering the component.
  currentHookIndex = 0;
  let output = Gallery();

  // Update the DOM to match the output.
  // This is the part React does for you.
  nextButton.onclick = output.onNextClick;
  header.textContent = output.header;
  moreButton.onclick = output.onMoreClick;
  moreButton.textContent = output.more;
  image.src = output.imageSrc;
  image.alt = output.imageAlt;
  if (output.description !== null) {
    description.textContent = output.description;
    description.style.display = '';
  } else {
    description.style.display = 'none';
  }
}

let nextButton = document.getElementById('nextButton');
let header = document.getElementById('header');
let moreButton = document.getElementById('moreButton');
let description = document.getElementById('description');
let image = document.getElementById('image');
let sculptureList = [{
  name: 'Homenaje a la Neurocirugía',
  artist: 'Marta Colvin Andrade',
  description: 'Although Colvin is predominantly known for abstract themes that allude to pre-Hispanic symbols, this gigantic sculpture, an homage to neurosurgery, is one of her most recognizable public art pieces.',
  url: 'https://i.imgur.com/Mx7dA2Y.jpg',
  alt: 'A bronze statue of two crossed hands delicately holding a human brain in their fingertips.'  
}, {
  name: 'Floralis Genérica',
  artist: 'Eduardo Catalano',
  description: 'This enormous (75 ft. or 23m) silver flower is located in Buenos Aires. It is designed to move, closing its petals in the evening or when strong winds blow and opening them in the morning.',
  url: 'https://i.imgur.com/ZF6s192m.jpg',
  alt: 'A gigantic metallic flower sculpture with reflective mirror-like petals and strong stamens.'
}, {
  name: 'Eternal Presence',
  artist: 'John Woodrow Wilson',
  description: 'Wilson was known for his preoccupation with equality, social justice, as well as the essential and spiritual qualities of humankind. This massive (7ft. or 2,13m) bronze represents what he described as "a symbolic Black presence infused with a sense of universal humanity."',
  url: 'https://i.imgur.com/aTtVpES.jpg',
  alt: 'The sculpture depicting a human head seems ever-present and solemn. It radiates calm and serenity.'
}, {
  name: 'Moai',
  artist: 'Unknown Artist',
  description: 'Located on the Easter Island, there are 1,000 moai, or extant monumental statues, created by the early Rapa Nui people, which some believe represented deified ancestors.',
  url: 'https://i.imgur.com/RCwLEoQm.jpg',
  alt: 'Three monumental stone busts with the heads that are disproportionately large with somber faces.'
}, {
  name: 'Blue Nana',
  artist: 'Niki de Saint Phalle',
  description: 'The Nanas are triumphant creatures, symbols of femininity and maternity. Initially, Saint Phalle used fabric and found objects for the Nanas, and later on introduced polyester to achieve a more vibrant effect.',
  url: 'https://i.imgur.com/Sd1AgUOm.jpg',
  alt: 'A large mosaic sculpture of a whimsical dancing female figure in a colorful costume emanating joy.'
}, {
  name: 'Ultimate Form',
  artist: 'Barbara Hepworth',
  description: 'This abstract bronze sculpture is a part of The Family of Man series located at Yorkshire Sculpture Park. Hepworth chose not to create literal representations of the world but developed abstract forms inspired by people and landscapes.',
  url: 'https://i.imgur.com/2heNQDcm.jpg',
  alt: 'A tall sculpture made of three elements stacked on each other reminding of a human figure.'
}, {
  name: 'Cavaliere',
  artist: 'Lamidi Olonade Fakeye',
  description: "Descended from four generations of woodcarvers, Fakeye's work blended traditional and contemporary Yoruba themes.",
  url: 'https://i.imgur.com/wIdGuZwm.png',
  alt: 'An intricate wood sculpture of a warrior with a focused face on a horse adorned with patterns.'
}, {
  name: 'Big Bellies',
  artist: 'Alina Szapocznikow',
  description: "Szapocznikow is known for her sculptures of the fragmented body as a metaphor for the fragility and impermanence of youth and beauty. This sculpture depicts two very realistic large bellies stacked on top of each other, each around five feet (1,5m) tall.",
  url: 'https://i.imgur.com/AlHTAdDm.jpg',
  alt: 'The sculpture reminds a cascade of folds, quite different from bellies in classical sculptures.'
}, {
  name: 'Terracotta Army',
  artist: 'Unknown Artist',
  description: 'The Terracotta Army is a collection of terracotta sculptures depicting the armies of Qin Shi Huang, the first Emperor of China. The army consisted of more than 8,000 soldiers, 130 chariots with 520 horses, and 150 cavalry horses.',
  url: 'https://i.imgur.com/HMFmH6m.jpg',
  alt: '12 terracotta sculptures of solemn warriors, each with a unique facial expression and armor.'
}, {
  name: 'Lunar Landscape',
  artist: 'Louise Nevelson',
  description: 'Nevelson was known for scavenging objects from New York City debris, which she would later assemble into monumental constructions. In this one, she used disparate parts like a bedpost, juggling pin, and seat fragment, nailing and gluing them into boxes that reflect the influence of Cubism’s geometric abstraction of space and form.',
  url: 'https://i.imgur.com/rN7hY6om.jpg',
  alt: 'A black matte sculpture where the individual elements are initially indistinguishable.'
}, {
  name: 'Aureole',
  artist: 'Ranjani Shettar',
  description: 'Shettar merges the traditional and the modern, the natural and the industrial. Her art focuses on the relationship between man and nature. Her work was described as compelling both abstractly and figuratively, gravity defying, and a "fine synthesis of unlikely materials."',
  url: 'https://i.imgur.com/okTpbHhm.jpg',
  alt: 'A pale wire-like sculpture mounted on concrete wall and descending on the floor. It appears light.'
}, {
  name: 'Hippos',
  artist: 'Taipei Zoo',
  description: 'The Taipei Zoo commissioned a Hippo Square featuring submerged hippos at play.',
  url: 'https://i.imgur.com/6o5Vuyu.jpg',
  alt: 'A group of bronze hippo sculptures emerging from the sett sidewalk as if they were swimming.'
}];

// Make UI match the initial state.
updateDOM();
```

Show more

You don’t have to understand it to use React, but you might find this a helpful mental model.

## State is isolated and private

State is local to a component instance on the screen. In other words, **if you render the same component twice, each copy will have completely isolated state!** Changing one of them will not affect the other.

In this example, the `Gallery` component from earlier is rendered twice with no changes to its logic. Try clicking the buttons inside each of the galleries. Notice that their state is independent:

App.jsGallery.jsdata.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Gallery from './Gallery.js';

export default function Page() {
  return (
    <div className="Page">
      <Gallery />
      <Gallery />
    </div>
  );
}
```

This is what makes state different from regular variables that you might declare at the top of your module. State is not tied to a particular function call or a place in the code, but it’s “local” to the specific place on the screen. You rendered two `<Gallery />` components, so their state is stored separately.

Also notice how the `Page` component doesn’t “know” anything about the `Gallery` state or even whether it has any. Unlike props, **state is fully private to the component declaring it.** The parent component can’t change it. This lets you add state to any component or remove it without impacting the rest of the components.

What if you wanted both galleries to keep their states in sync? The right way to do it in React is to *remove* state from child components and add it to their closest shared parent. The next few pages will focus on organizing state of a single component, but we will return to this topic in [Sharing State Between Components.](https://react.dev/learn/sharing-state-between-components)

## Recap

* Use a state variable when a component needs to “remember” some information between renders.
* State variables are declared by calling the `useState` Hook.
* Hooks are special functions that start with `use`. They let you “hook into” React features like state.
* Hooks might remind you of imports: they need to be called unconditionally. Calling Hooks, including `useState`, is only valid at the top level of a component or another Hook.
* The `useState` Hook returns a pair of values: the current state and the function to update it.
* You can have more than one state variable. Internally, React matches them up by their order.
* State is private to the component. If you render it in two places, each copy gets its own state.

## Try out some challenges

1. Complete the gallery 2. Fix stuck form inputs 3. Fix a crash 4. Remove unnecessary state

#### Challenge 1 of 4: Complete the gallery

When you press “Next” on the last sculpture, the code crashes. Fix the logic to prevent the crash. You may do this by adding extra logic to event handler or by disabling the button when the action is not possible.

After fixing the crash, add a “Previous” button that shows the previous sculpture. It shouldn’t crash on the first sculpture.

App.jsdata.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { sculptureList } from './data.js';

export default function Gallery() {
  const [index, setIndex] = useState(0);
  const [showMore, setShowMore] = useState(false);

  function handleNextClick() {
    setIndex(index + 1);
  }

  function handleMoreClick() {
    setShowMore(!showMore);
  }

  let sculpture = sculptureList[index];
  return (
    <>
      <button onClick={handleNextClick}>
        Next
      </button>
      <h2>
        <i>{sculpture.name} </i> 
        by {sculpture.artist}
      </h2>
      <h3>  
        ({index + 1} of {sculptureList.length})
      </h3>
      <button onClick={handleMoreClick}>
        {showMore ? 'Hide' : 'Show'} details
      </button>
      {showMore && <p>{sculpture.description}</p>}
      <img 
        src={sculpture.url} 
        alt={sculpture.alt}
      />
    </>
  );
}
```

Show more

Show solutionNext Challenge

[PreviousResponding to Events](https://react.dev/learn/responding-to-events)[NextRender and Commit](https://react.dev/learn/render-and-commit)

---

---


# Render and Commit – React

URL: https://react.dev/learn/render-and-commit

[Learn React](https://react.dev/learn)

[Adding Interactivity](https://react.dev/learn/adding-interactivity)

# Render and Commit

Before your components are displayed on screen, they must be rendered by React. Understanding the steps in this process will help you think about how your code executes and explain its behavior.

### You will learn

* What rendering means in React
* When and why React renders a component
* The steps involved in displaying a component on screen
* Why rendering does not always produce a DOM update

Imagine that your components are cooks in the kitchen, assembling tasty dishes from ingredients. In this scenario, React is the waiter who puts in requests from customers and brings them their orders. This process of requesting and serving UI has three steps:

1. **Triggering** a render (delivering the guest’s order to the kitchen)
2. **Rendering** the component (preparing the order in the kitchen)
3. **Committing** to the DOM (placing the order on the table)

1. ![React as a server in a restaurant, fetching orders from the users and delivering them to the Component Kitchen.](https://react.dev/images/docs/illustrations/i_render-and-commit1.png)

   Trigger
2. ![The Card Chef gives React a fresh Card component.](https://react.dev/images/docs/illustrations/i_render-and-commit2.png)

   Render
3. ![React delivers the Card to the user at their table.](https://react.dev/images/docs/illustrations/i_render-and-commit3.png)

   Commit

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

## Step 1: Trigger a render

There are two reasons for a component to render:

1. It’s the component’s **initial render.**
2. The component’s (or one of its ancestors’) **state has been updated.**

### Initial render

When your app starts, you need to trigger the initial render. Frameworks and sandboxes sometimes hide this code, but it’s done by calling [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) with the target DOM node, and then calling its `render` method with your component:

index.jsImage.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);
```

Try commenting out the `root.render()` call and see the component disappear!

### Re-renders when state updates

Once the component has been initially rendered, you can trigger further renders by updating its state with the [`set` function.](https://react.dev/reference/react/useState#setstate) Updating your component’s state automatically queues a render. (You can imagine these as a restaurant guest ordering tea, dessert, and all sorts of things after putting in their first order, depending on the state of their thirst or hunger.)

1. ![React as a server in a restaurant, serving a Card UI to the user, represented as a patron with a cursor for their head. The patron expresses they want a pink card, not a black one!](https://react.dev/images/docs/illustrations/i_rerender1.png)

   State update...
2. ![React returns to the Component Kitchen and tells the Card Chef they need a pink Card.](https://react.dev/images/docs/illustrations/i_rerender2.png)

   ...triggers...
3. ![The Card Chef gives React the pink Card.](https://react.dev/images/docs/illustrations/i_rerender3.png)

   ...render!

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

## Step 2: React renders your components

After you trigger a render, React calls your components to figure out what to display on screen. **“Rendering” is React calling your components.**

* **On initial render,** React will call the root component.
* **For subsequent renders,** React will call the function component whose state update triggered the render.

This process is recursive: if the updated component returns some other component, React will render *that* component next, and if that component also returns something, it will render *that* component next, and so on. The process will continue until there are no more nested components and React knows exactly what should be displayed on screen.

In the following example, React will call `Gallery()` and `Image()` several times:

index.jsGallery.js

Gallery.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

Show more

* **During the initial render,** React will [create the DOM nodes](https://developer.mozilla.org/docs/Web/API/Document/createElement) for `<section>`, `<h1>`, and three `<img>` tags.
* **During a re-render,** React will calculate which of their properties, if any, have changed since the previous render. It won’t do anything with that information until the next step, the commit phase.

### Pitfall

Rendering must always be a [pure calculation](https://react.dev/learn/keeping-components-pure):

* **Same inputs, same output.** Given the same inputs, a component should always return the same JSX. (When someone orders a salad with tomatoes, they should not receive a salad with onions!)
* **It minds its own business.** It should not change any objects or variables that existed before rendering. (One order should not change anyone else’s order.)

Otherwise, you can encounter confusing bugs and unpredictable behavior as your codebase grows in complexity. When developing in “Strict Mode”, React calls each component’s function twice, which can help surface mistakes caused by impure functions.

##### Deep Dive

#### Optimizing performance

Show Details

The default behavior of rendering all components nested within the updated component is not optimal for performance if the updated component is very high in the tree. If you run into a performance issue, there are several opt-in ways to solve it described in the [Performance](https://reactjs.org/docs/optimizing-performance.html) section. **Don’t optimize prematurely!**

## Step 3: React commits changes to the DOM

After rendering (calling) your components, React will modify the DOM.

* **For the initial render,** React will use the [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild) DOM API to put all the DOM nodes it has created on screen.
* **For re-renders,** React will apply the minimal necessary operations (calculated while rendering!) to make the DOM match the latest rendering output.

**React only changes the DOM nodes if there’s a difference between renders.** For example, here is a component that re-renders with different props passed from its parent every second. Notice how you can add some text into the `<input>`, updating its `value`, but the text doesn’t disappear when the component re-renders:

Clock.js

Clock.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

This works because during this last step, React only updates the content of `<h1>` with the new `time`. It sees that the `<input>` appears in the JSX in the same place as last time, so React doesn’t touch the `<input>`—or its `value`!

## Epilogue: Browser paint

After rendering is done and React updated the DOM, the browser will repaint the screen. Although this process is known as “browser rendering”, we’ll refer to it as “painting” to avoid confusion throughout the docs.

![A browser painting 'still life with card element'.](https://react.dev/images/docs/illustrations/i_browser-paint.png)

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

## Recap

* Any screen update in a React app happens in three steps:
  1. Trigger
  2. Render
  3. Commit
* You can use Strict Mode to find mistakes in your components
* React does not touch the DOM if the rendering result is the same as last time

[PreviousState: A Component's Memory](https://react.dev/learn/state-a-components-memory)[NextState as a Snapshot](https://react.dev/learn/state-as-a-snapshot)

---

---


# State as a Snapshot – React

URL: https://react.dev/learn/state-as-a-snapshot

[Learn React](https://react.dev/learn)

[Adding Interactivity](https://react.dev/learn/adding-interactivity)

# State as a Snapshot

State variables might look like regular JavaScript variables that you can read and write to. However, state behaves more like a snapshot. Setting it does not change the state variable you already have, but instead triggers a re-render.

### You will learn

* How setting state triggers re-renders
* When and how state updates
* Why state does not update immediately after you set it
* How event handlers access a “snapshot” of the state

## Setting state triggers renders

You might think of your user interface as changing directly in response to the user event like a click. In React, it works a little differently from this mental model. On the previous page, you saw that [setting state requests a re-render](https://react.dev/learn/render-and-commit#step-1-trigger-a-render) from React. This means that for an interface to react to the event, you need to *update the state*.

In this example, when you press “send”, `setIsSent(true)` tells React to re-render the UI:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [isSent, setIsSent] = useState(false);
  const [message, setMessage] = useState('Hi!');
  if (isSent) {
    return <h1>Your message is on its way!</h1>
  }
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      setIsSent(true);
      sendMessage(message);
    }}>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}

function sendMessage(message) {
  // ...
}
```

Show more

Here’s what happens when you click the button:

1. The `onSubmit` event handler executes.
2. `setIsSent(true)` sets `isSent` to `true` and queues a new render.
3. React re-renders the component according to the new `isSent` value.

Let’s take a closer look at the relationship between state and rendering.

## Rendering takes a snapshot in time

[“Rendering”](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components) means that React is calling your component, which is a function. The JSX you return from that function is like a snapshot of the UI in time. Its props, event handlers, and local variables were all calculated **using its state at the time of the render.**

Unlike a photograph or a movie frame, the UI “snapshot” you return is interactive. It includes logic like event handlers that specify what happens in response to inputs. React updates the screen to match this snapshot and connects the event handlers. As a result, pressing a button will trigger the click handler from your JSX.

When React re-renders a component:

1. React calls your function again.
2. Your function returns a new JSX snapshot.
3. React then updates the screen to match the snapshot your function returned.

1. ![](https://react.dev/images/docs/illustrations/i_render1.png)

   React executing the function
2. ![](https://react.dev/images/docs/illustrations/i_render2.png)

   Calculating the snapshot
3. ![](https://react.dev/images/docs/illustrations/i_render3.png)

   Updating the DOM tree

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

As a component’s memory, state is not like a regular variable that disappears after your function returns. State actually “lives” in React itself—as if on a shelf!—outside of your function. When React calls your component, it gives you a snapshot of the state for that particular render. Your component returns a snapshot of the UI with a fresh set of props and event handlers in its JSX, all calculated **using the state values from that render!**

1. ![](https://react.dev/images/docs/illustrations/i_state-snapshot1.png)

   You tell React to update the state
2. ![](https://react.dev/images/docs/illustrations/i_state-snapshot2.png)

   React updates the state value
3. ![](https://react.dev/images/docs/illustrations/i_state-snapshot3.png)

   React passes a snapshot of the state value into the component

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

Here’s a little experiment to show you how this works. In this example, you might expect that clicking the “+3” button would increment the counter three times because it calls `setNumber(number + 1)` three times.

See what happens when you click the “+3” button:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}
```

Show more

Notice that `number` only increments once per click!

**Setting state only changes it for the *next* render.** During the first render, `number` was `0`. This is why, in *that render’s* `onClick` handler, the value of `number` is still `0` even after `setNumber(number + 1)` was called:

```
<button onClick={() => {

setNumber(number + 1);

setNumber(number + 1);

setNumber(number + 1);

}}>+3</button>
```

Here is what this button’s click handler tells React to do:

1. `setNumber(number + 1)`: `number` is `0` so `setNumber(0 + 1)`.
   * React prepares to change `number` to `1` on the next render.
2. `setNumber(number + 1)`: `number` is `0` so `setNumber(0 + 1)`.
   * React prepares to change `number` to `1` on the next render.
3. `setNumber(number + 1)`: `number` is `0` so `setNumber(0 + 1)`.
   * React prepares to change `number` to `1` on the next render.

Even though you called `setNumber(number + 1)` three times, in *this render’s* event handler `number` is always `0`, so you set the state to `1` three times. This is why, after your event handler finishes, React re-renders the component with `number` equal to `1` rather than `3`.

You can also visualize this by mentally substituting state variables with their values in your code. Since the `number` state variable is `0` for *this render*, its event handler looks like this:

```
<button onClick={() => {

setNumber(0 + 1);

setNumber(0 + 1);

setNumber(0 + 1);

}}>+3</button>
```

For the next render, `number` is `1`, so *that render’s* click handler looks like this:

```
<button onClick={() => {

setNumber(1 + 1);

setNumber(1 + 1);

setNumber(1 + 1);

}}>+3</button>
```

This is why clicking the button again will set the counter to `2`, then to `3` on the next click, and so on.

## State over time

Well, that was fun. Try to guess what clicking this button will alert:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        alert(number);
      }}>+5</button>
    </>
  )
}
```

If you use the substitution method from before, you can guess that the alert shows “0”:

```
setNumber(0 + 5);

alert(0);
```

But what if you put a timer on the alert, so it only fires *after* the component re-rendered? Would it say “0” or “5”? Have a guess!

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setTimeout(() => {
          alert(number);
        }, 3000);
      }}>+5</button>
    </>
  )
}
```

Show more

Surprised? If you use the substitution method, you can see the “snapshot” of the state passed to the alert.

```
setNumber(0 + 5);

setTimeout(() => {

alert(0);

}, 3000);
```

The state stored in React may have changed by the time the alert runs, but it was scheduled using a snapshot of the state at the time the user interacted with it!

**A state variable’s value never changes within a render,** even if its event handler’s code is asynchronous. Inside *that render’s* `onClick`, the value of `number` continues to be `0` even after `setNumber(number + 5)` was called. Its value was “fixed” when React “took the snapshot” of the UI by calling your component.

Here is an example of how that makes your event handlers less prone to timing mistakes. Below is a form that sends a message with a five-second delay. Imagine this scenario:

1. You press the “Send” button, sending “Hello” to Alice.
2. Before the five-second delay ends, you change the value of the “To” field to “Bob”.

What do you expect the `alert` to display? Would it display, “You said Hello to Alice”? Or would it display, “You said Hello to Bob”? Make a guess based on what you know, and then try it:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [to, setTo] = useState('Alice');
  const [message, setMessage] = useState('Hello');

  function handleSubmit(e) {
    e.preventDefault();
    setTimeout(() => {
      alert(`You said ${message} to ${to}`);
    }, 5000);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>
        To:{' '}
        <select
          value={to}
          onChange={e => setTo(e.target.value)}>
          <option value="Alice">Alice</option>
          <option value="Bob">Bob</option>
        </select>
      </label>
      <textarea
        placeholder="Message"
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
      <button type="submit">Send</button>
    </form>
  );
}
```

Show more

**React keeps the state values “fixed” within one render’s event handlers.** You don’t need to worry whether the state has changed while the code is running.

But what if you wanted to read the latest state before a re-render? You’ll want to use a [state updater function](https://react.dev/learn/queueing-a-series-of-state-updates), covered on the next page!

## Recap

* Setting state requests a new render.
* React stores state outside of your component, as if on a shelf.
* When you call `useState`, React gives you a snapshot of the state *for that render*.
* Variables and event handlers don’t “survive” re-renders. Every render has its own event handlers.
* Every render (and functions inside it) will always “see” the snapshot of the state that React gave to *that* render.
* You can mentally substitute state in event handlers, similarly to how you think about the rendered JSX.
* Event handlers created in the past have the state values from the render in which they were created.

## Try out some challenges

#### Challenge 1 of 1: Implement a traffic light

Here is a crosswalk light component that toggles when the button is pressed:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function TrafficLight() {
  const [walk, setWalk] = useState(true);

  function handleClick() {
    setWalk(!walk);
  }

  return (
    <>
      <button onClick={handleClick}>
        Change to {walk ? 'Stop' : 'Walk'}
      </button>
      <h1 style={{
        color: walk ? 'darkgreen' : 'darkred'
      }}>
        {walk ? 'Walk' : 'Stop'}
      </h1>
    </>
  );
}
```

Show more

Add an `alert` to the click handler. When the light is green and says “Walk”, clicking the button should say “Stop is next”. When the light is red and says “Stop”, clicking the button should say “Walk is next”.

Does it make a difference whether you put the `alert` before or after the `setWalk` call?

Show solution

[PreviousRender and Commit](https://react.dev/learn/render-and-commit)[NextQueueing a Series of State Updates](https://react.dev/learn/queueing-a-series-of-state-updates)

---

---


# Queueing a Series of State Updates – React

URL: https://react.dev/learn/queueing-a-series-of-state-updates

[Learn React](https://react.dev/learn)

[Adding Interactivity](https://react.dev/learn/adding-interactivity)

# Queueing a Series of State Updates

Setting a state variable will queue another render. But sometimes you might want to perform multiple operations on the value before queueing the next render. To do this, it helps to understand how React batches state updates.

### You will learn

* What “batching” is and how React uses it to process multiple state updates
* How to apply several updates to the same state variable in a row

## React batches state updates

You might expect that clicking the “+3” button will increment the counter three times because it calls `setNumber(number + 1)` three times:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}
```

Show more

However, as you might recall from the previous section, [each render’s state values are fixed](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time), so the value of `number` inside the first render’s event handler is always `0`, no matter how many times you call `setNumber(1)`:

```
setNumber(0 + 1);

setNumber(0 + 1);

setNumber(0 + 1);
```

But there is one other factor at play here. **React waits until *all* code in the event handlers has run before processing your state updates.** This is why the re-render only happens *after* all these `setNumber()` calls.

This might remind you of a waiter taking an order at the restaurant. A waiter doesn’t run to the kitchen at the mention of your first dish! Instead, they let you finish your order, let you make changes to it, and even take orders from other people at the table.

![An elegant cursor at a restaurant places and order multiple times with React, playing the part of the waiter. After she calls setState() multiple times, the waiter writes down the last one she requested as her final order.](https://react.dev/images/docs/illustrations/i_react-batching.png)

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

This lets you update multiple state variables—even from multiple components—without triggering too many [re-renders.](https://react.dev/learn/render-and-commit#re-renders-when-state-updates) But this also means that the UI won’t be updated until *after* your event handler, and any code in it, completes. This behavior, also known as **batching,** makes your React app run much faster. It also avoids dealing with confusing “half-finished” renders where only some of the variables have been updated.

**React does not batch across *multiple* intentional events like clicks**—each click is handled separately. Rest assured that React only does batching when it’s generally safe to do. This ensures that, for example, if the first button click disables a form, the second click would not submit it again.

## Updating the same state multiple times before the next render

It is an uncommon use case, but if you would like to update the same state variable multiple times before the next render, instead of passing the *next state value* like `setNumber(number + 1)`, you can pass a *function* that calculates the next state based on the previous one in the queue, like `setNumber(n => n + 1)`. It is a way to tell React to “do something with the state value” instead of just replacing it.

Try incrementing the counter now:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(n => n + 1);
        setNumber(n => n + 1);
        setNumber(n => n + 1);
      }}>+3</button>
    </>
  )
}
```

Show more

Here, `n => n + 1` is called an **updater function.** When you pass it to a state setter:

1. React queues this function to be processed after all the other code in the event handler has run.
2. During the next render, React goes through the queue and gives you the final updated state.

```
setNumber(n => n + 1);

setNumber(n => n + 1);

setNumber(n => n + 1);
```

Here’s how React works through these lines of code while executing the event handler:

1. `setNumber(n => n + 1)`: `n => n + 1` is a function. React adds it to a queue.
2. `setNumber(n => n + 1)`: `n => n + 1` is a function. React adds it to a queue.
3. `setNumber(n => n + 1)`: `n => n + 1` is a function. React adds it to a queue.

When you call `useState` during the next render, React goes through the queue. The previous `number` state was `0`, so that’s what React passes to the first updater function as the `n` argument. Then React takes the return value of your previous updater function and passes it to the next updater as `n`, and so on:

| queued update | `n` | returns |
| --- | --- | --- |
| `n => n + 1` | `0` | `0 + 1 = 1` |
| `n => n + 1` | `1` | `1 + 1 = 2` |
| `n => n + 1` | `2` | `2 + 1 = 3` |

React stores `3` as the final result and returns it from `useState`.

This is why clicking “+3” in the above example correctly increments the value by 3.

### What happens if you update state after replacing it

What about this event handler? What do you think `number` will be in the next render?

```
<button onClick={() => {

setNumber(number + 5);

setNumber(n => n + 1);

}}>
```

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setNumber(n => n + 1);
      }}>Increase the number</button>
    </>
  )
}
```

Here’s what this event handler tells React to do:

1. `setNumber(number + 5)`: `number` is `0`, so `setNumber(0 + 5)`. React adds *“replace with `5`”* to its queue.
2. `setNumber(n => n + 1)`: `n => n + 1` is an updater function. React adds *that function* to its queue.

During the next render, React goes through the state queue:

| queued update | `n` | returns |
| --- | --- | --- |
| ”replace with `5`” | `0` (unused) | `5` |
| `n => n + 1` | `5` | `5 + 1 = 6` |

React stores `6` as the final result and returns it from `useState`.

### Note

You may have noticed that `setState(5)` actually works like `setState(n => 5)`, but `n` is unused!

### What happens if you replace state after updating it

Let’s try one more example. What do you think `number` will be in the next render?

```
<button onClick={() => {

setNumber(number + 5);

setNumber(n => n + 1);

setNumber(42);

}}>
```

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 5);
        setNumber(n => n + 1);
        setNumber(42);
      }}>Increase the number</button>
    </>
  )
}
```

Show more

Here’s how React works through these lines of code while executing this event handler:

1. `setNumber(number + 5)`: `number` is `0`, so `setNumber(0 + 5)`. React adds *“replace with `5`”* to its queue.
2. `setNumber(n => n + 1)`: `n => n + 1` is an updater function. React adds *that function* to its queue.
3. `setNumber(42)`: React adds *“replace with `42`”* to its queue.

During the next render, React goes through the state queue:

| queued update | `n` | returns |
| --- | --- | --- |
| ”replace with `5`” | `0` (unused) | `5` |
| `n => n + 1` | `5` | `5 + 1 = 6` |
| ”replace with `42`” | `6` (unused) | `42` |

Then React stores `42` as the final result and returns it from `useState`.

To summarize, here’s how you can think of what you’re passing to the `setNumber` state setter:

* **An updater function** (e.g. `n => n + 1`) gets added to the queue.
* **Any other value** (e.g. number `5`) adds “replace with `5`” to the queue, ignoring what’s already queued.

After the event handler completes, React will trigger a re-render. During the re-render, React will process the queue. Updater functions run during rendering, so **updater functions must be [pure](https://react.dev/learn/keeping-components-pure)** and only *return* the result. Don’t try to set state from inside of them or run other side effects. In Strict Mode, React will run each updater function twice (but discard the second result) to help you find mistakes.

### Naming conventions

It’s common to name the updater function argument by the first letters of the corresponding state variable:

```
setEnabled(e => !e);

setLastName(ln => ln.reverse());

setFriendCount(fc => fc * 2);
```

If you prefer more verbose code, another common convention is to repeat the full state variable name, like `setEnabled(enabled => !enabled)`, or to use a prefix like `setEnabled(prevEnabled => !prevEnabled)`.

## Recap

* Setting state does not change the variable in the existing render, but it requests a new render.
* React processes state updates after event handlers have finished running. This is called batching.
* To update some state multiple times in one event, you can use `setNumber(n => n + 1)` updater function.

## Try out some challenges

1. Fix a request counter 2. Implement the state queue yourself

#### Challenge 1 of 2: Fix a request counter

You’re working on an art marketplace app that lets the user submit multiple orders for an art item at the same time. Each time the user presses the “Buy” button, the “Pending” counter should increase by one. After three seconds, the “Pending” counter should decrease, and the “Completed” counter should increase.

However, the “Pending” counter does not behave as intended. When you press “Buy”, it decreases to `-1` (which should not be possible!). And if you click fast twice, both counters seem to behave unpredictably.

Why does this happen? Fix both counters.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function RequestTracker() {
  const [pending, setPending] = useState(0);
  const [completed, setCompleted] = useState(0);

  async function handleClick() {
    setPending(pending + 1);
    await delay(3000);
    setPending(pending - 1);
    setCompleted(completed + 1);
  }

  return (
    <>
      <h3>
        Pending: {pending}
      </h3>
      <h3>
        Completed: {completed}
      </h3>
      <button onClick={handleClick}>
        Buy     
      </button>
    </>
  );
}

function delay(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}
```

Show more

Show solutionNext Challenge

[PreviousState as a Snapshot](https://react.dev/learn/state-as-a-snapshot)[NextUpdating Objects in State](https://react.dev/learn/updating-objects-in-state)

---

---


# Updating Objects in State – React

URL: https://react.dev/learn/updating-objects-in-state

[Learn React](https://react.dev/learn)

[Adding Interactivity](https://react.dev/learn/adding-interactivity)

# Updating Objects in State

State can hold any kind of JavaScript value, including objects. But you shouldn’t change objects that you hold in the React state directly. Instead, when you want to update an object, you need to create a new one (or make a copy of an existing one), and then set the state to use that copy.

### You will learn

* How to correctly update an object in React state
* How to update a nested object without mutating it
* What immutability is, and how not to break it
* How to make object copying less repetitive with Immer

## What’s a mutation?

You can store any kind of JavaScript value in state.

```
const [x, setX] = useState(0);
```

So far you’ve been working with numbers, strings, and booleans. These kinds of JavaScript values are “immutable”, meaning unchangeable or “read-only”. You can trigger a re-render to *replace* a value:

```
setX(5);
```

The `x` state changed from `0` to `5`, but the *number `0` itself* did not change. It’s not possible to make any changes to the built-in primitive values like numbers, strings, and booleans in JavaScript.

Now consider an object in state:

```
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Technically, it is possible to change the contents of *the object itself*. **This is called a mutation:**

```
position.x = 5;
```

However, although objects in React state are technically mutable, you should treat them **as if** they were immutable—like numbers, booleans, and strings. Instead of mutating them, you should always replace them.

## Treat state as read-only

In other words, you should **treat any JavaScript object that you put into state as read-only.**

This example holds an object in state to represent the current pointer position. The red dot is supposed to move when you touch or move the cursor over the preview area. But the dot stays in the initial position:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
      onPointerMove={e => {
        position.x = e.clientX;
        position.y = e.clientY;
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: `translate(${position.x}px, ${position.y}px)`,
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} />
    </div>
  );
}
```

Show more

The problem is with this bit of code.

```
onPointerMove={e => {

position.x = e.clientX;

position.y = e.clientY;

}}
```

This code modifies the object assigned to `position` from [the previous render.](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time) But without using the state setting function, React has no idea that object has changed. So React does not do anything in response. It’s like trying to change the order after you’ve already eaten the meal. While mutating state can work in some cases, we don’t recommend it. You should treat the state value you have access to in a render as read-only.

To actually [trigger a re-render](https://react.dev/learn/state-as-a-snapshot#setting-state-triggers-renders) in this case, **create a *new* object and pass it to the state setting function:**

```
onPointerMove={e => {

setPosition({

x: e.clientX,

y: e.clientY

});

}}
```

With `setPosition`, you’re telling React:

* Replace `position` with this new object
* And render this component again

Notice how the red dot now follows your pointer when you touch or hover over the preview area:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
      onPointerMove={e => {
        setPosition({
          x: e.clientX,
          y: e.clientY
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: `translate(${position.x}px, ${position.y}px)`,
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} />
    </div>
  );
}
```

Show more

##### Deep Dive

#### Local mutation is fine

Show Details

Code like this is a problem because it modifies an *existing* object in state:

```
position.x = e.clientX;

position.y = e.clientY;
```

But code like this is **absolutely fine** because you’re mutating a fresh object you have *just created*:

```
const nextPosition = {};

nextPosition.x = e.clientX;

nextPosition.y = e.clientY;

setPosition(nextPosition);
```

In fact, it is completely equivalent to writing this:

```
setPosition({

x: e.clientX,

y: e.clientY

});
```

Mutation is only a problem when you change *existing* objects that are already in state. Mutating an object you’ve just created is okay because *no other code references it yet.* Changing it isn’t going to accidentally impact something that depends on it. This is called a “local mutation”. You can even do local mutation [while rendering.](https://react.dev/learn/keeping-components-pure#local-mutation-your-components-little-secret) Very convenient and completely okay!

## Copying objects with the spread syntax

In the previous example, the `position` object is always created fresh from the current cursor position. But often, you will want to include *existing* data as a part of the new object you’re creating. For example, you may want to update *only one* field in a form, but keep the previous values for all other fields.

These input fields don’t work because the `onChange` handlers mutate the state:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    person.firstName = e.target.value;
  }

  function handleLastNameChange(e) {
    person.lastName = e.target.value;
  }

  function handleEmailChange(e) {
    person.email = e.target.value;
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
```

Show more

For example, this line mutates the state from a past render:

```
person.firstName = e.target.value;
```

The reliable way to get the behavior you’re looking for is to create a new object and pass it to `setPerson`. But here, you want to also **copy the existing data into it** because only one of the fields has changed:

```
setPerson({

firstName: e.target.value, // New first name from the input

lastName: person.lastName,

email: person.email

});
```

You can use the `...` [object spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals) syntax so that you don’t need to copy every property separately.

```
setPerson({

...person, // Copy the old fields

firstName: e.target.value // But override this one

});
```

Now the form works!

Notice how you didn’t declare a separate state variable for each input field. For large forms, keeping all data grouped in an object is very convenient—as long as you update it correctly!

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleFirstNameChange(e) {
    setPerson({
      ...person,
      firstName: e.target.value
    });
  }

  function handleLastNameChange(e) {
    setPerson({
      ...person,
      lastName: e.target.value
    });
  }

  function handleEmailChange(e) {
    setPerson({
      ...person,
      email: e.target.value
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          value={person.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={person.lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <label>
        Email:
        <input
          value={person.email}
          onChange={handleEmailChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
```

Show more

Note that the `...` spread syntax is “shallow”—it only copies things one level deep. This makes it fast, but it also means that if you want to update a nested property, you’ll have to use it more than once.

##### Deep Dive

#### Using a single event handler for multiple fields

Show Details

You can also use the `[` and `]` braces inside your object definition to specify a property with a dynamic name. Here is the same example, but with a single event handler instead of three different ones:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com'
  });

  function handleChange(e) {
    setPerson({
      ...person,
      [e.target.name]: e.target.value
    });
  }

  return (
    <>
      <label>
        First name:
        <input
          name="firstName"
          value={person.firstName}
          onChange={handleChange}
        />
      </label>
      <label>
        Last name:
        <input
          name="lastName"
          value={person.lastName}
          onChange={handleChange}
        />
      </label>
      <label>
        Email:
        <input
          name="email"
          value={person.email}
          onChange={handleChange}
        />
      </label>
      <p>
        {person.firstName}{' '}
        {person.lastName}{' '}
        ({person.email})
      </p>
    </>
  );
}
```

Show more

Here, `e.target.name` refers to the `name` property given to the `<input>` DOM element.

## Updating a nested object

Consider a nested object structure like this:

```
const [person, setPerson] = useState({

name: 'Niki de Saint Phalle',

artwork: {

title: 'Blue Nana',

city: 'Hamburg',

image: 'https://i.imgur.com/Sd1AgUOm.jpg',

}

});
```

If you wanted to update `person.artwork.city`, it’s clear how to do it with mutation:

```
person.artwork.city = 'New Delhi';
```

But in React, you treat state as immutable! In order to change `city`, you would first need to produce the new `artwork` object (pre-populated with data from the previous one), and then produce the new `person` object which points at the new `artwork`:

```
const nextArtwork = { ...person.artwork, city: 'New Delhi' };

const nextPerson = { ...person, artwork: nextArtwork };

setPerson(nextPerson);
```

Or, written as a single function call:

```
setPerson({

...person, // Copy other fields

artwork: { // but replace the artwork

...person.artwork, // with the same one

city: 'New Delhi' // but in New Delhi!

}

});
```

This gets a bit wordy, but it works fine for many cases:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [person, setPerson] = useState({
    name: 'Niki de Saint Phalle',
    artwork: {
      title: 'Blue Nana',
      city: 'Hamburg',
      image: 'https://i.imgur.com/Sd1AgUOm.jpg',
    }
  });

  function handleNameChange(e) {
    setPerson({
      ...person,
      name: e.target.value
    });
  }

  function handleTitleChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        title: e.target.value
      }
    });
  }

  function handleCityChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        city: e.target.value
      }
    });
  }

  function handleImageChange(e) {
    setPerson({
      ...person,
      artwork: {
        ...person.artwork,
        image: e.target.value
      }
    });
  }

  return (
    <>
      <label>
        Name:
        <input
          value={person.name}
          onChange={handleNameChange}
        />
      </label>
      <label>
        Title:
        <input
          value={person.artwork.title}
          onChange={handleTitleChange}
        />
      </label>
      <label>
        City:
        <input
          value={person.artwork.city}
          onChange={handleCityChange}
        />
      </label>
      <label>
        Image:
        <input
          value={person.artwork.image}
          onChange={handleImageChange}
        />
      </label>
      <p>
        <i>{person.artwork.title}</i>
        {' by '}
        {person.name}
        <br />
        (located in {person.artwork.city})
      </p>
      <img 
        src={person.artwork.image} 
        alt={person.artwork.title}
      />
    </>
  );
}
```

Show more

##### Deep Dive

#### Objects are not really nested

Show Details

An object like this appears “nested” in code:

```
let obj = {

name: 'Niki de Saint Phalle',

artwork: {

title: 'Blue Nana',

city: 'Hamburg',

image: 'https://i.imgur.com/Sd1AgUOm.jpg',

}

};
```

However, “nesting” is an inaccurate way to think about how objects behave. When the code executes, there is no such thing as a “nested” object. You are really looking at two different objects:

```
let obj1 = {

title: 'Blue Nana',

city: 'Hamburg',

image: 'https://i.imgur.com/Sd1AgUOm.jpg',

};

let obj2 = {

name: 'Niki de Saint Phalle',

artwork: obj1

};
```

The `obj1` object is not “inside” `obj2`. For example, `obj3` could “point” at `obj1` too:

```
let obj1 = {

title: 'Blue Nana',

city: 'Hamburg',

image: 'https://i.imgur.com/Sd1AgUOm.jpg',

};

let obj2 = {

name: 'Niki de Saint Phalle',

artwork: obj1

};

let obj3 = {

name: 'Copycat',

artwork: obj1

};
```

If you were to mutate `obj3.artwork.city`, it would affect both `obj2.artwork.city` and `obj1.city`. This is because `obj3.artwork`, `obj2.artwork`, and `obj1` are the same object. This is difficult to see when you think of objects as “nested”. Instead, they are separate objects “pointing” at each other with properties.

### Write concise update logic with Immer

If your state is deeply nested, you might want to consider [flattening it.](https://react.dev/learn/choosing-the-state-structure#avoid-deeply-nested-state) But, if you don’t want to change your state structure, you might prefer a shortcut to nested spreads. [Immer](https://github.com/immerjs/use-immer) is a popular library that lets you write using the convenient but mutating syntax and takes care of producing the copies for you. With Immer, the code you write looks like you are “breaking the rules” and mutating an object:

```
updatePerson(draft => {

draft.artwork.city = 'Lagos';

});
```

But unlike a regular mutation, it doesn’t overwrite the past state!

##### Deep Dive

#### How does Immer work?

Show Details

The `draft` provided by Immer is a special type of object, called a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy), that “records” what you do with it. This is why you can mutate it freely as much as you like! Under the hood, Immer figures out which parts of the `draft` have been changed, and produces a completely new object that contains your edits.

To try Immer:

1. Run `npm install use-immer` to add Immer as a dependency
2. Then replace `import { useState } from 'react'` with `import { useImmer } from 'use-immer'`

Here is the above example converted to Immer:

package.jsonApp.js

package.json

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

Notice how much more concise the event handlers have become. You can mix and match `useState` and `useImmer` in a single component as much as you like. Immer is a great way to keep the update handlers concise, especially if there’s nesting in your state, and copying objects leads to repetitive code.

##### Deep Dive

#### Why is mutating state not recommended in React?

Show Details

There are a few reasons:

* **Debugging:** If you use `console.log` and don’t mutate state, your past logs won’t get clobbered by the more recent state changes. So you can clearly see how state has changed between renders.
* **Optimizations:** Common React [optimization strategies](https://react.dev/reference/react/memo) rely on skipping work if previous props or state are the same as the next ones. If you never mutate state, it is very fast to check whether there were any changes. If `prevObj === obj`, you can be sure that nothing could have changed inside of it.
* **New Features:** The new React features we’re building rely on state being [treated like a snapshot.](https://react.dev/learn/state-as-a-snapshot) If you’re mutating past versions of state, that may prevent you from using the new features.
* **Requirement Changes:** Some application features, like implementing Undo/Redo, showing a history of changes, or letting the user reset a form to earlier values, are easier to do when nothing is mutated. This is because you can keep past copies of state in memory, and reuse them when appropriate. If you start with a mutative approach, features like this can be difficult to add later on.
* **Simpler Implementation:** Because React does not rely on mutation, it does not need to do anything special with your objects. It does not need to hijack their properties, always wrap them into Proxies, or do other work at initialization as many “reactive” solutions do. This is also why React lets you put any object into state—no matter how large—without additional performance or correctness pitfalls.

In practice, you can often “get away” with mutating state in React, but we strongly advise you not to do that so that you can use new React features developed with this approach in mind. Future contributors and perhaps even your future self will thank you!

## Recap

* Treat all state in React as immutable.
* When you store objects in state, mutating them will not trigger renders and will change the state in previous render “snapshots”.
* Instead of mutating an object, create a *new* version of it, and trigger a re-render by setting state to it.
* You can use the `{...obj, something: 'newValue'}` object spread syntax to create copies of objects.
* Spread syntax is shallow: it only copies one level deep.
* To update a nested object, you need to create copies all the way up from the place you’re updating.
* To reduce repetitive copying code, use Immer.

## Try out some challenges

1. Fix incorrect state updates 2. Find and fix the mutation 3. Update an object with Immer

#### Challenge 1 of 3: Fix incorrect state updates

This form has a few bugs. Click the button that increases the score a few times. Notice that it does not increase. Then edit the first name, and notice that the score has suddenly “caught up” with your changes. Finally, edit the last name, and notice that the score has disappeared completely.

Your task is to fix all of these bugs. As you fix them, explain why each of them happens.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Scoreboard() {
  const [player, setPlayer] = useState({
    firstName: 'Ranjani',
    lastName: 'Shettar',
    score: 10,
  });

  function handlePlusClick() {
    player.score++;
  }

  function handleFirstNameChange(e) {
    setPlayer({
      ...player,
      firstName: e.target.value,
    });
  }

  function handleLastNameChange(e) {
    setPlayer({
      lastName: e.target.value
    });
  }

  return (
    <>
      <label>
        Score: <b>{player.score}</b>
        {' '}
        <button onClick={handlePlusClick}>
          +1
        </button>
      </label>
      <label>
        First name:
        <input
          value={player.firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:
        <input
          value={player.lastName}
          onChange={handleLastNameChange}
        />
      </label>
    </>
  );
}
```

Show more

Show solutionNext Challenge

[PreviousQueueing a Series of State Updates](https://react.dev/learn/queueing-a-series-of-state-updates)[NextUpdating Arrays in State](https://react.dev/learn/updating-arrays-in-state)

---

---


# Updating Arrays in State – React

URL: https://react.dev/learn/updating-arrays-in-state

[Learn React](https://react.dev/learn)

[Adding Interactivity](https://react.dev/learn/adding-interactivity)

# Updating Arrays in State

Arrays are mutable in JavaScript, but you should treat them as immutable when you store them in state. Just like with objects, when you want to update an array stored in state, you need to create a new one (or make a copy of an existing one), and then set state to use the new array.

### You will learn

* How to add, remove, or change items in an array in React state
* How to update an object inside of an array
* How to make array copying less repetitive with Immer

## Updating arrays without mutation

In JavaScript, arrays are just another kind of object. [Like with objects](https://react.dev/learn/updating-objects-in-state), **you should treat arrays in React state as read-only.** This means that you shouldn’t reassign items inside an array like `arr[0] = 'bird'`, and you also shouldn’t use methods that mutate the array, such as `push()` and `pop()`.

Instead, every time you want to update an array, you’ll want to pass a *new* array to your state setting function. To do that, you can create a new array from the original array in your state by calling its non-mutating methods like `filter()` and `map()`. Then you can set your state to the resulting new array.

Here is a reference table of common array operations. When dealing with arrays inside React state, you will need to avoid the methods in the left column, and instead prefer the methods in the right column:

|  | avoid (mutates the array) | prefer (returns a new array) |
| --- | --- | --- |
| adding | `push`, `unshift` | `concat`, `[...arr]` spread syntax ([example](https://react.dev/learn/updating-arrays-in-state#adding-to-an-array)) |
| removing | `pop`, `shift`, `splice` | `filter`, `slice` ([example](https://react.dev/learn/updating-arrays-in-state#removing-from-an-array)) |
| replacing | `splice`, `arr[i] = ...` assignment | `map` ([example](https://react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array)) |
| sorting | `reverse`, `sort` | copy the array first ([example](https://react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array)) |

Alternatively, you can [use Immer](https://react.dev/learn/updating-arrays-in-state#write-concise-update-logic-with-immer) which lets you use methods from both columns.

### Pitfall

Unfortunately, [`slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) and [`splice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice) are named similarly but are very different:

* `slice` lets you copy an array or a part of it.
* `splice` **mutates** the array (to insert or delete items).

In React, you will be using `slice` (no `p`!) a lot more often because you don’t want to mutate objects or arrays in state. [Updating Objects](https://react.dev/learn/updating-objects-in-state) explains what mutation is and why it’s not recommended for state.

### Adding to an array

`push()` will mutate an array, which you don’t want:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <button onClick={() => {
        artists.push({
          id: nextId++,
          name: name,
        });
      }}>Add</button>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

Show more

Instead, create a *new* array which contains the existing items *and* a new item at the end. There are multiple ways to do this, but the easiest one is to use the `...` [array spread](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_array_literals) syntax:

```
setArtists( // Replace the state

[ // with a new array

...artists, // that contains all the old items

{ id: nextId++, name: name } // and one new item at the end

]

);
```

Now it works correctly:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

let nextId = 0;

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState([]);

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <button onClick={() => {
        setArtists([
          ...artists,
          { id: nextId++, name: name }
        ]);
      }}>Add</button>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

Show more

The array spread syntax also lets you prepend an item by placing it *before* the original `...artists`:

```
setArtists([

{ id: nextId++, name: name },

...artists // Put old items at the end

]);
```

In this way, spread can do the job of both `push()` by adding to the end of an array and `unshift()` by adding to the beginning of an array. Try it in the sandbox above!

### Removing from an array

The easiest way to remove an item from an array is to *filter it out*. In other words, you will produce a new array that will not contain that item. To do this, use the `filter` method, for example:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

let initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye'},
  { id: 2, name: 'Louise Nevelson'},
];

export default function List() {
  const [artists, setArtists] = useState(
    initialArtists
  );

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>
            {artist.name}{' '}
            <button onClick={() => {
              setArtists(
                artists.filter(a =>
                  a.id !== artist.id
                )
              );
            }}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}
```

Show more

Click the “Delete” button a few times, and look at its click handler.

```
setArtists(

artists.filter(a => a.id !== artist.id)

);
```

Here, `artists.filter(a => a.id !== artist.id)` means “create an array that consists of those `artists` whose IDs are different from `artist.id`”. In other words, each artist’s “Delete” button will filter *that* artist out of the array, and then request a re-render with the resulting array. Note that `filter` does not modify the original array.

### Transforming an array

If you want to change some or all items of the array, you can use `map()` to create a **new** array. The function you will pass to `map` can decide what to do with each item, based on its data or its index (or both).

In this example, an array holds coordinates of two circles and a square. When you press the button, it moves only the circles down by 50 pixels. It does this by producing a new array of data using `map()`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

let initialShapes = [
  { id: 0, type: 'circle', x: 50, y: 100 },
  { id: 1, type: 'square', x: 150, y: 100 },
  { id: 2, type: 'circle', x: 250, y: 100 },
];

export default function ShapeEditor() {
  const [shapes, setShapes] = useState(
    initialShapes
  );

  function handleClick() {
    const nextShapes = shapes.map(shape => {
      if (shape.type === 'square') {
        // No change
        return shape;
      } else {
        // Return a new circle 50px below
        return {
          ...shape,
          y: shape.y + 50,
        };
      }
    });
    // Re-render with the new array
    setShapes(nextShapes);
  }

  return (
    <>
      <button onClick={handleClick}>
        Move circles down!
      </button>
      {shapes.map(shape => (
        <div
          key={shape.id}
          style={{
          background: 'purple',
          position: 'absolute',
          left: shape.x,
          top: shape.y,
          borderRadius:
            shape.type === 'circle'
              ? '50%' : '',
          width: 20,
          height: 20,
        }} />
      ))}
    </>
  );
}
```

Show more

### Replacing items in an array

It is particularly common to want to replace one or more items in an array. Assignments like `arr[0] = 'bird'` are mutating the original array, so instead you’ll want to use `map` for this as well.

To replace an item, create a new array with `map`. Inside your `map` call, you will receive the item index as the second argument. Use it to decide whether to return the original item (the first argument) or something else:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

let initialCounters = [
  0, 0, 0
];

export default function CounterList() {
  const [counters, setCounters] = useState(
    initialCounters
  );

  function handleIncrementClick(index) {
    const nextCounters = counters.map((c, i) => {
      if (i === index) {
        // Increment the clicked counter
        return c + 1;
      } else {
        // The rest haven't changed
        return c;
      }
    });
    setCounters(nextCounters);
  }

  return (
    <ul>
      {counters.map((counter, i) => (
        <li key={i}>
          {counter}
          <button onClick={() => {
            handleIncrementClick(i);
          }}>+1</button>
        </li>
      ))}
    </ul>
  );
}
```

Show more

### Inserting into an array

Sometimes, you may want to insert an item at a particular position that’s neither at the beginning nor at the end. To do this, you can use the `...` array spread syntax together with the `slice()` method. The `slice()` method lets you cut a “slice” of the array. To insert an item, you will create an array that spreads the slice *before* the insertion point, then the new item, and then the rest of the original array.

In this example, the Insert button always inserts at the index `1`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

let nextId = 3;
const initialArtists = [
  { id: 0, name: 'Marta Colvin Andrade' },
  { id: 1, name: 'Lamidi Olonade Fakeye'},
  { id: 2, name: 'Louise Nevelson'},
];

export default function List() {
  const [name, setName] = useState('');
  const [artists, setArtists] = useState(
    initialArtists
  );

  function handleClick() {
    const insertAt = 1; // Could be any index
    const nextArtists = [
      // Items before the insertion point:
      ...artists.slice(0, insertAt),
      // New item:
      { id: nextId++, name: name },
      // Items after the insertion point:
      ...artists.slice(insertAt)
    ];
    setArtists(nextArtists);
    setName('');
  }

  return (
    <>
      <h1>Inspiring sculptors:</h1>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <button onClick={handleClick}>
        Insert
      </button>
      <ul>
        {artists.map(artist => (
          <li key={artist.id}>{artist.name}</li>
        ))}
      </ul>
    </>
  );
}
```

Show more

### Making other changes to an array

There are some things you can’t do with the spread syntax and non-mutating methods like `map()` and `filter()` alone. For example, you may want to reverse or sort an array. The JavaScript `reverse()` and `sort()` methods are mutating the original array, so you can’t use them directly.

**However, you can copy the array first, and then make changes to it.**

For example:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

const initialList = [
  { id: 0, title: 'Big Bellies' },
  { id: 1, title: 'Lunar Landscape' },
  { id: 2, title: 'Terracotta Army' },
];

export default function List() {
  const [list, setList] = useState(initialList);

  function handleClick() {
    const nextList = [...list];
    nextList.reverse();
    setList(nextList);
  }

  return (
    <>
      <button onClick={handleClick}>
        Reverse
      </button>
      <ul>
        {list.map(artwork => (
          <li key={artwork.id}>{artwork.title}</li>
        ))}
      </ul>
    </>
  );
}
```

Show more

Here, you use the `[...list]` spread syntax to create a copy of the original array first. Now that you have a copy, you can use mutating methods like `nextList.reverse()` or `nextList.sort()`, or even assign individual items with `nextList[0] = "something"`.

However, **even if you copy an array, you can’t mutate existing items *inside* of it directly.** This is because copying is shallow—the new array will contain the same items as the original one. So if you modify an object inside the copied array, you are mutating the existing state. For example, code like this is a problem.

```
const nextList = [...list];

nextList[0].seen = true; // Problem: mutates list[0]

setList(nextList);
```

Although `nextList` and `list` are two different arrays, **`nextList[0]` and `list[0]` point to the same object.** So by changing `nextList[0].seen`, you are also changing `list[0].seen`. This is a state mutation, which you should avoid! You can solve this issue in a similar way to [updating nested JavaScript objects](https://react.dev/learn/updating-objects-in-state#updating-a-nested-object)—by copying individual items you want to change instead of mutating them. Here’s how.

## Updating objects inside arrays

Objects are not *really* located “inside” arrays. They might appear to be “inside” in code, but each object in an array is a separate value, to which the array “points”. This is why you need to be careful when changing nested fields like `list[0]`. Another person’s artwork list may point to the same element of the array!

**When updating nested state, you need to create copies from the point where you want to update, and all the way up to the top level.** Let’s see how this works.

In this example, two separate artwork lists have the same initial state. They are supposed to be isolated, but because of a mutation, their state is accidentally shared, and checking a box in one list affects the other list:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(
    initialList
  );

  function handleToggleMyList(artworkId, nextSeen) {
    const myNextList = [...myList];
    const artwork = myNextList.find(
      a => a.id === artworkId
    );
    artwork.seen = nextSeen;
    setMyList(myNextList);
  }

  function handleToggleYourList(artworkId, nextSeen) {
    const yourNextList = [...yourList];
    const artwork = yourNextList.find(
      a => a.id === artworkId
    );
    artwork.seen = nextSeen;
    setYourList(yourNextList);
  }

  return (
    <>
      <h1>Art Bucket List</h1>
      <h2>My list of art to see:</h2>
      <ItemList
        artworks={myList}
        onToggle={handleToggleMyList} />
      <h2>Your list of art to see:</h2>
      <ItemList
        artworks={yourList}
        onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map(artwork => (
        <li key={artwork.id}>
          <label>
            <input
              type="checkbox"
              checked={artwork.seen}
              onChange={e => {
                onToggle(
                  artwork.id,
                  e.target.checked
                );
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

Show more

The problem is in code like this:

```
const myNextList = [...myList];

const artwork = myNextList.find(a => a.id === artworkId);

artwork.seen = nextSeen; // Problem: mutates an existing item

setMyList(myNextList);
```

Although the `myNextList` array itself is new, the *items themselves* are the same as in the original `myList` array. So changing `artwork.seen` changes the *original* artwork item. That artwork item is also in `yourList`, which causes the bug. Bugs like this can be difficult to think about, but thankfully they disappear if you avoid mutating state.

**You can use `map` to substitute an old item with its updated version without mutation.**

```
setMyList(myList.map(artwork => {

if (artwork.id === artworkId) {

// Create a *new* object with changes

return { ...artwork, seen: nextSeen };

} else {

// No changes

return artwork;

}

}));
```

Here, `...` is the object spread syntax used to [create a copy of an object.](https://react.dev/learn/updating-objects-in-state#copying-objects-with-the-spread-syntax)

With this approach, none of the existing state items are being mutated, and the bug is fixed:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

let nextId = 3;
const initialList = [
  { id: 0, title: 'Big Bellies', seen: false },
  { id: 1, title: 'Lunar Landscape', seen: false },
  { id: 2, title: 'Terracotta Army', seen: true },
];

export default function BucketList() {
  const [myList, setMyList] = useState(initialList);
  const [yourList, setYourList] = useState(
    initialList
  );

  function handleToggleMyList(artworkId, nextSeen) {
    setMyList(myList.map(artwork => {
      if (artwork.id === artworkId) {
        // Create a *new* object with changes
        return { ...artwork, seen: nextSeen };
      } else {
        // No changes
        return artwork;
      }
    }));
  }

  function handleToggleYourList(artworkId, nextSeen) {
    setYourList(yourList.map(artwork => {
      if (artwork.id === artworkId) {
        // Create a *new* object with changes
        return { ...artwork, seen: nextSeen };
      } else {
        // No changes
        return artwork;
      }
    }));
  }

  return (
    <>
      <h1>Art Bucket List</h1>
      <h2>My list of art to see:</h2>
      <ItemList
        artworks={myList}
        onToggle={handleToggleMyList} />
      <h2>Your list of art to see:</h2>
      <ItemList
        artworks={yourList}
        onToggle={handleToggleYourList} />
    </>
  );
}

function ItemList({ artworks, onToggle }) {
  return (
    <ul>
      {artworks.map(artwork => (
        <li key={artwork.id}>
          <label>
            <input
              type="checkbox"
              checked={artwork.seen}
              onChange={e => {
                onToggle(
                  artwork.id,
                  e.target.checked
                );
              }}
            />
            {artwork.title}
          </label>
        </li>
      ))}
    </ul>
  );
}
```

Show more

In general, **you should only mutate objects that you have just created.** If you were inserting a *new* artwork, you could mutate it, but if you’re dealing with something that’s already in state, you need to make a copy.

### Write concise update logic with Immer

Updating nested arrays without mutation can get a little bit repetitive. [Just as with objects](https://react.dev/learn/updating-objects-in-state#write-concise-update-logic-with-immer):

* Generally, you shouldn’t need to update state more than a couple of levels deep. If your state objects are very deep, you might want to [restructure them differently](https://react.dev/learn/choosing-the-state-structure#avoid-deeply-nested-state) so that they are flat.
* If you don’t want to change your state structure, you might prefer to use [Immer](https://github.com/immerjs/use-immer), which lets you write using the convenient but mutating syntax and takes care of producing the copies for you.

Here is the Art Bucket List example rewritten with Immer:

package.jsonApp.js

package.json

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

Note how with Immer, **mutation like `artwork.seen = nextSeen` is now okay:**

```
updateMyTodos(draft => {

const artwork = draft.find(a => a.id === artworkId);

artwork.seen = nextSeen;

});
```

This is because you’re not mutating the *original* state, but you’re mutating a special `draft` object provided by Immer. Similarly, you can apply mutating methods like `push()` and `pop()` to the content of the `draft`.

Behind the scenes, Immer always constructs the next state from scratch according to the changes that you’ve done to the `draft`. This keeps your event handlers very concise without ever mutating state.

## Recap

* You can put arrays into state, but you can’t change them.
* Instead of mutating an array, create a *new* version of it, and update the state to it.
* You can use the `[...arr, newItem]` array spread syntax to create arrays with new items.
* You can use `filter()` and `map()` to create new arrays with filtered or transformed items.
* You can use Immer to keep your code concise.

## Try out some challenges

1. Update an item in the shopping cart 2. Remove an item from the shopping cart 3. Fix the mutations using non-mutative methods 4. Fix the mutations using Immer

#### Challenge 1 of 4: Update an item in the shopping cart

Fill in the `handleIncreaseClick` logic so that pressing ”+” increases the corresponding number:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

const initialProducts = [{
  id: 0,
  name: 'Baklava',
  count: 1,
}, {
  id: 1,
  name: 'Cheese',
  count: 5,
}, {
  id: 2,
  name: 'Spaghetti',
  count: 2,
}];

export default function ShoppingCart() {
  const [
    products,
    setProducts
  ] = useState(initialProducts)

  function handleIncreaseClick(productId) {

  }

  return (
    <ul>
      {products.map(product => (
        <li key={product.id}>
          {product.name}
          {' '}
          (<b>{product.count}</b>)
          <button onClick={() => {
            handleIncreaseClick(product.id);
          }}>
            +
          </button>
        </li>
      ))}
    </ul>
  );
}
```

Show more

Show solutionNext Challenge

[PreviousUpdating Objects in State](https://react.dev/learn/updating-objects-in-state)[NextManaging State](https://react.dev/learn/managing-state)

---

---


# Managing State – React

URL: https://react.dev/learn/managing-state

[Learn React](https://react.dev/learn)

# Managing State

Intermediate

As your application grows, it helps to be more intentional about how your state is organized and how the data flows between your components. Redundant or duplicate state is a common source of bugs. In this chapter, you’ll learn how to structure your state well, how to keep your state update logic maintainable, and how to share state between distant components.

### In this chapter

* [How to think about UI changes as state changes](https://react.dev/learn/reacting-to-input-with-state)
* [How to structure state well](https://react.dev/learn/choosing-the-state-structure)
* [How to “lift state up” to share it between components](https://react.dev/learn/sharing-state-between-components)
* [How to control whether the state gets preserved or reset](https://react.dev/learn/preserving-and-resetting-state)
* [How to consolidate complex state logic in a function](https://react.dev/learn/extracting-state-logic-into-a-reducer)
* [How to pass information without “prop drilling”](https://react.dev/learn/passing-data-deeply-with-context)
* [How to scale state management as your app grows](https://react.dev/learn/scaling-up-with-reducer-and-context)

## Reacting to input with state

With React, you won’t modify the UI from code directly. For example, you won’t write commands like “disable the button”, “enable the button”, “show the success message”, etc. Instead, you will describe the UI you want to see for the different visual states of your component (“initial state”, “typing state”, “success state”), and then trigger the state changes in response to user input. This is similar to how designers think about UI.

Here is a quiz form built using React. Note how it uses the `status` state variable to determine whether to enable or disable the submit button, and whether to show the success message instead.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [answer, setAnswer] = useState('');
  const [error, setError] = useState(null);
  const [status, setStatus] = useState('typing');

  if (status === 'success') {
    return <h1>That's right!</h1>
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('submitting');
    try {
      await submitForm(answer);
      setStatus('success');
    } catch (err) {
      setStatus('typing');
      setError(err);
    }
  }

  function handleTextareaChange(e) {
    setAnswer(e.target.value);
  }

  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form onSubmit={handleSubmit}>
        <textarea
          value={answer}
          onChange={handleTextareaChange}
          disabled={status === 'submitting'}
        />
        <br />
        <button disabled={
          answer.length === 0 ||
          status === 'submitting'
        }>
          Submit
        </button>
        {error !== null &&
          <p className="Error">
            {error.message}
          </p>
        }
      </form>
    </>
  );
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let shouldError = answer.toLowerCase() !== 'lima'
      if (shouldError) {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      } else {
        resolve();
      }
    }, 1500);
  });
}
```

Show more

## Ready to learn this topic?

Read **[Reacting to Input with State](https://react.dev/learn/reacting-to-input-with-state)** to learn how to approach interactions with a state-driven mindset.

[Read More](https://react.dev/learn/reacting-to-input-with-state)

---

## Choosing the state structure

Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. The most important principle is that state shouldn’t contain redundant or duplicated information. If there’s unnecessary state, it’s easy to forget to update it, and introduce bugs!

For example, this form has a **redundant** `fullName` state variable:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
    setFullName(e.target.value + ' ' + lastName);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
    setFullName(firstName + ' ' + e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name:{' '}
        <input
          value={firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:{' '}
        <input
          value={lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
```

Show more

You can remove it and simplify the code by calculating `fullName` while the component is rendering:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  const fullName = firstName + ' ' + lastName;

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name:{' '}
        <input
          value={firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:{' '}
        <input
          value={lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
```

Show more

This might seem like a small change, but many bugs in React apps are fixed this way.

## Ready to learn this topic?

Read **[Choosing the State Structure](https://react.dev/learn/choosing-the-state-structure)** to learn how to design the state shape to avoid bugs.

[Read More](https://react.dev/learn/choosing-the-state-structure)

---

## Sharing state between components

Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as “lifting state up”, and it’s one of the most common things you will do writing React code.

In this example, only one panel should be active at a time. To achieve this, instead of keeping the active state inside each individual panel, the parent component holds the state and specifies the props for its children.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Accordion() {
  const [activeIndex, setActiveIndex] = useState(0);
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel
        title="About"
        isActive={activeIndex === 0}
        onShow={() => setActiveIndex(0)}
      >
        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel
        title="Etymology"
        isActive={activeIndex === 1}
        onShow={() => setActiveIndex(1)}
      >
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for "apple" and is often translated as "full of apples". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang="la">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({
  title,
  children,
  isActive,
  onShow
}) {
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={onShow}>
          Show
        </button>
      )}
    </section>
  );
}
```

Show more

## Ready to learn this topic?

Read **[Sharing State Between Components](https://react.dev/learn/sharing-state-between-components)** to learn how to lift state up and keep components in sync.

[Read More](https://react.dev/learn/sharing-state-between-components)

---

## Preserving and resetting state

When you re-render a component, React needs to decide which parts of the tree to keep (and update), and which parts to discard or re-create from scratch. In most cases, React’s automatic behavior works well enough. By default, React preserves the parts of the tree that “match up” with the previously rendered component tree.

However, sometimes this is not what you want. In this chat app, typing a message and then switching the recipient does not reset the input. This can make the user accidentally send a message to the wrong person:

App.jsContactList.jsChat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat contact={to} />
    </div>
  )
}

const contacts = [
  { name: 'Taylor', email: 'taylor@mail.com' },
  { name: 'Alice', email: 'alice@mail.com' },
  { name: 'Bob', email: 'bob@mail.com' }
];
```

Show more

React lets you override the default behavior, and *force* a component to reset its state by passing it a different `key`, like `<Chat key={email} />`. This tells React that if the recipient is different, it should be considered a *different* `Chat` component that needs to be re-created from scratch with the new data (and UI like inputs). Now switching between the recipients resets the input field—even though you render the same component.

App.jsContactList.jsChat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat key={to.email} contact={to} />
    </div>
  )
}

const contacts = [
  { name: 'Taylor', email: 'taylor@mail.com' },
  { name: 'Alice', email: 'alice@mail.com' },
  { name: 'Bob', email: 'bob@mail.com' }
];
```

Show more

## Ready to learn this topic?

Read **[Preserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state)** to learn the lifetime of state and how to control it.

[Read More](https://react.dev/learn/preserving-and-resetting-state)

---

## Extracting state logic into a reducer

Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called “reducer”. Your event handlers become concise because they only specify the user “actions”. At the bottom of the file, the reducer function specifies how the state should update in response to each action!

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask
        onAddTask={handleAddTask}
      />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [...tasks, {
        id: action.id,
        text: action.text,
        done: false
      }];
    }
    case 'changed': {
      return tasks.map(t => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter(t => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Visit Kafka Museum', done: true },
  { id: 1, text: 'Watch a puppet show', done: false },
  { id: 2, text: 'Lennon Wall pic', done: false }
];
```

Show more

## Ready to learn this topic?

Read **[Extracting State Logic into a Reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer)** to learn how to consolidate logic in the reducer function.

[Read More](https://react.dev/learn/extracting-state-logic-into-a-reducer)

---

## Passing data deeply with context

Usually, you will pass information from a parent component to a child component via props. But passing props can become inconvenient if you need to pass some prop through many components, or if many components need the same information. Context lets the parent component make some information available to any component in the tree below it—no matter how deep it is—without passing it explicitly through props.

Here, the `Heading` component determines its heading level by “asking” the closest `Section` for its level. Each `Section` tracks its own level by asking the parent `Section` and adding one to it. Every `Section` provides information to all components below it without passing props—it does that through context.

App.jsSection.jsHeading.jsLevelContext.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section>
      <Heading>Title</Heading>
      <Section>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

Show more

## Ready to learn this topic?

Read **[Passing Data Deeply with Context](https://react.dev/learn/passing-data-deeply-with-context)** to learn about using context as an alternative to passing props.

[Read More](https://react.dev/learn/passing-data-deeply-with-context)

---

## Scaling up with reducer and context

Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen.

With this approach, a parent component with complex state manages it with a reducer. Other components anywhere deep in the tree can read its state via context. They can also dispatch actions to update that state.

App.jsTasksContext.jsAddTask.jsTaskList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import { TasksProvider } from './TasksContext.js';

export default function TaskApp() {
  return (
    <TasksProvider>
      <h1>Day off in Kyoto</h1>
      <AddTask />
      <TaskList />
    </TasksProvider>
  );
}
```

## Ready to learn this topic?

Read **[Scaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context)** to learn how state management scales in a growing app.

[Read More](https://react.dev/learn/scaling-up-with-reducer-and-context)

---

## What’s next?

Head over to [Reacting to Input with State](https://react.dev/learn/reacting-to-input-with-state) to start reading this chapter page by page!

Or, if you’re already familiar with these topics, why not read about [Escape Hatches](https://react.dev/learn/escape-hatches)?

[PreviousUpdating Arrays in State](https://react.dev/learn/updating-arrays-in-state)[NextReacting to Input with State](https://react.dev/learn/reacting-to-input-with-state)

---

---


# Reacting to Input with State – React

URL: https://react.dev/learn/reacting-to-input-with-state

[Learn React](https://react.dev/learn)

[Managing State](https://react.dev/learn/managing-state)

# Reacting to Input with State

React provides a declarative way to manipulate the UI. Instead of manipulating individual pieces of the UI directly, you describe the different states that your component can be in, and switch between them in response to the user input. This is similar to how designers think about the UI.

### You will learn

* How declarative UI programming differs from imperative UI programming
* How to enumerate the different visual states your component can be in
* How to trigger the changes between the different visual states from code

## How declarative UI compares to imperative

When you design UI interactions, you probably think about how the UI *changes* in response to user actions. Consider a form that lets the user submit an answer:

* When you type something into the form, the “Submit” button **becomes enabled.**
* When you press “Submit”, both the form and the button **become disabled,** and a spinner **appears.**
* If the network request succeeds, the form **gets hidden,** and the “Thank you” message **appears.**
* If the network request fails, an error message **appears,** and the form **becomes enabled** again.

In **imperative programming,** the above corresponds directly to how you implement interaction. You have to write the exact instructions to manipulate the UI depending on what just happened. Here’s another way to think about this: imagine riding next to someone in a car and telling them turn by turn where to go.

![In a car driven by an anxious-looking person representing JavaScript, a passenger orders the driver to execute a sequence of complicated turn by turn navigations.](https://react.dev/images/docs/illustrations/i_imperative-ui-programming.png)

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

They don’t know where you want to go, they just follow your commands. (And if you get the directions wrong, you end up in the wrong place!) It’s called *imperative* because you have to “command” each element, from the spinner to the button, telling the computer *how* to update the UI.

In this example of imperative UI programming, the form is built *without* React. It only uses the browser [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model):

index.jsindex.html

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
async function handleFormSubmit(e) {
  e.preventDefault();
  disable(textarea);
  disable(button);
  show(loadingMessage);
  hide(errorMessage);
  try {
    await submitForm(textarea.value);
    show(successMessage);
    hide(form);
  } catch (err) {
    show(errorMessage);
    errorMessage.textContent = err.message;
  } finally {
    hide(loadingMessage);
    enable(textarea);
    enable(button);
  }
}

function handleTextareaChange() {
  if (textarea.value.length === 0) {
    disable(button);
  } else {
    enable(button);
  }
}

function hide(el) {
  el.style.display = 'none';
}

function show(el) {
  el.style.display = '';
}

function enable(el) {
  el.disabled = false;
}

function disable(el) {
  el.disabled = true;
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (answer.toLowerCase() === 'istanbul') {
        resolve();
      } else {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      }
    }, 1500);
  });
}

let form = document.getElementById('form');
let textarea = document.getElementById('textarea');
let button = document.getElementById('button');
let loadingMessage = document.getElementById('loading');
let errorMessage = document.getElementById('error');
let successMessage = document.getElementById('success');
form.onsubmit = handleFormSubmit;
textarea.oninput = handleTextareaChange;
```

Show more

Manipulating the UI imperatively works well enough for isolated examples, but it gets exponentially more difficult to manage in more complex systems. Imagine updating a page full of different forms like this one. Adding a new UI element or a new interaction would require carefully checking all existing code to make sure you haven’t introduced a bug (for example, forgetting to show or hide something).

React was built to solve this problem.

In React, you don’t directly manipulate the UI—meaning you don’t enable, disable, show, or hide components directly. Instead, you **declare what you want to show,** and React figures out how to update the UI. Think of getting into a taxi and telling the driver where you want to go instead of telling them exactly where to turn. It’s the driver’s job to get you there, and they might even know some shortcuts you haven’t considered!

![In a car driven by React, a passenger asks to be taken to a specific place on the map. React figures out how to do that.](https://react.dev/images/docs/illustrations/i_declarative-ui-programming.png)

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

## Thinking about UI declaratively

You’ve seen how to implement a form imperatively above. To better understand how to think in React, you’ll walk through reimplementing this UI in React below:

1. **Identify** your component’s different visual states
2. **Determine** what triggers those state changes
3. **Represent** the state in memory using `useState`
4. **Remove** any non-essential state variables
5. **Connect** the event handlers to set the state

### Step 1: Identify your component’s different visual states

In computer science, you may hear about a [“state machine”](https://en.wikipedia.org/wiki/Finite-state_machine) being in one of several “states”. If you work with a designer, you may have seen mockups for different “visual states”. React stands at the intersection of design and computer science, so both of these ideas are sources of inspiration.

First, you need to visualize all the different “states” of the UI the user might see:

* **Empty**: Form has a disabled “Submit” button.
* **Typing**: Form has an enabled “Submit” button.
* **Submitting**: Form is completely disabled. Spinner is shown.
* **Success**: “Thank you” message is shown instead of a form.
* **Error**: Same as Typing state, but with an extra error message.

Just like a designer, you’ll want to “mock up” or create “mocks” for the different states before you add logic. For example, here is a mock for just the visual part of the form. This mock is controlled by a prop called `status` with a default value of `'empty'`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Form({
  status = 'empty'
}) {
  if (status === 'success') {
    return <h1>That's right!</h1>
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form>
        <textarea />
        <br />
        <button>
          Submit
        </button>
      </form>
    </>
  )
}
```

Show more

You could call that prop anything you like, the naming is not important. Try editing `status = 'empty'` to `status = 'success'` to see the success message appear. Mocking lets you quickly iterate on the UI before you wire up any logic. Here is a more fleshed out prototype of the same component, still “controlled” by the `status` prop:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Form({
  // Try 'submitting', 'error', 'success':
  status = 'empty'
}) {
  if (status === 'success') {
    return <h1>That's right!</h1>
  }
  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form>
        <textarea disabled={
          status === 'submitting'
        } />
        <br />
        <button disabled={
          status === 'empty' ||
          status === 'submitting'
        }>
          Submit
        </button>
        {status === 'error' &&
          <p className="Error">
            Good guess but a wrong answer. Try again!
          </p>
        }
      </form>
      </>
  );
}
```

Show more

##### Deep Dive

#### Displaying many visual states at once

Show Details

If a component has a lot of visual states, it can be convenient to show them all on one page:

App.jsForm.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Form from './Form.js';

let statuses = [
  'empty',
  'typing',
  'submitting',
  'success',
  'error',
];

export default function App() {
  return (
    <>
      {statuses.map(status => (
        <section key={status}>
          <h4>Form ({status}):</h4>
          <Form status={status} />
        </section>
      ))}
    </>
  );
}
```

Show more

Pages like this are often called “living styleguides” or “storybooks”.

### Step 2: Determine what triggers those state changes

You can trigger state updates in response to two kinds of inputs:

* **Human inputs,** like clicking a button, typing in a field, navigating a link.
* **Computer inputs,** like a network response arriving, a timeout completing, an image loading.

![A finger.](https://react.dev/images/docs/illustrations/i_inputs1.png)

Human inputs

![Ones and zeroes.](https://react.dev/images/docs/illustrations/i_inputs2.png)

Computer inputs

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

In both cases, **you must set [state variables](https://react.dev/learn/state-a-components-memory#anatomy-of-usestate) to update the UI.** For the form you’re developing, you will need to change state in response to a few different inputs:

* **Changing the text input** (human) should switch it from the *Empty* state to the *Typing* state or back, depending on whether the text box is empty or not.
* **Clicking the Submit button** (human) should switch it to the *Submitting* state.
* **Successful network response** (computer) should switch it to the *Success* state.
* **Failed network response** (computer) should switch it to the *Error* state with the matching error message.

### Note

Notice that human inputs often require [event handlers](https://react.dev/learn/responding-to-events)!

To help visualize this flow, try drawing each state on paper as a labeled circle, and each change between two states as an arrow. You can sketch out many flows this way and sort out bugs long before implementation.

![Flow chart moving left to right with 5 nodes. The first node labeled 'empty' has one edge labeled 'start typing' connected to a node labeled 'typing'. That node has one edge labeled 'press submit' connected to a node labeled 'submitting', which has two edges. The left edge is labeled 'network error' connecting to a node labeled 'error'. The right edge is labeled 'network success' connecting to a node labeled 'success'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fresponding_to_input_flow.dark.png&w=1920&q=75)

![Flow chart moving left to right with 5 nodes. The first node labeled 'empty' has one edge labeled 'start typing' connected to a node labeled 'typing'. That node has one edge labeled 'press submit' connected to a node labeled 'submitting', which has two edges. The left edge is labeled 'network error' connecting to a node labeled 'error'. The right edge is labeled 'network success' connecting to a node labeled 'success'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fresponding_to_input_flow.png&w=1920&q=75)

Form states

### Step 3: Represent the state in memory with `useState`

Next you’ll need to represent the visual states of your component in memory with [`useState`.](https://react.dev/reference/react/useState) Simplicity is key: each piece of state is a “moving piece”, and **you want as few “moving pieces” as possible.** More complexity leads to more bugs!

Start with the state that *absolutely must* be there. For example, you’ll need to store the `answer` for the input, and the `error` (if it exists) to store the last error:

```
const [answer, setAnswer] = useState('');

const [error, setError] = useState(null);
```

Then, you’ll need a state variable representing which one of the visual states that you want to display. There’s usually more than a single way to represent that in memory, so you’ll need to experiment with it.

If you struggle to think of the best way immediately, start by adding enough state that you’re *definitely* sure that all the possible visual states are covered:

```
const [isEmpty, setIsEmpty] = useState(true);

const [isTyping, setIsTyping] = useState(false);

const [isSubmitting, setIsSubmitting] = useState(false);

const [isSuccess, setIsSuccess] = useState(false);

const [isError, setIsError] = useState(false);
```

Your first idea likely won’t be the best, but that’s ok—refactoring state is a part of the process!

### Step 4: Remove any non-essential state variables

You want to avoid duplication in the state content so you’re only tracking what is essential. Spending a little time on refactoring your state structure will make your components easier to understand, reduce duplication, and avoid unintended meanings. Your goal is to **prevent the cases where the state in memory doesn’t represent any valid UI that you’d want a user to see.** (For example, you never want to show an error message and disable the input at the same time, or the user won’t be able to correct the error!)

Here are some questions you can ask about your state variables:

* **Does this state cause a paradox?** For example, `isTyping` and `isSubmitting` can’t both be `true`. A paradox usually means that the state is not constrained enough. There are four possible combinations of two booleans, but only three correspond to valid states. To remove the “impossible” state, you can combine these into a `status` that must be one of three values: `'typing'`, `'submitting'`, or `'success'`.
* **Is the same information available in another state variable already?** Another paradox: `isEmpty` and `isTyping` can’t be `true` at the same time. By making them separate state variables, you risk them going out of sync and causing bugs. Fortunately, you can remove `isEmpty` and instead check `answer.length === 0`.
* **Can you get the same information from the inverse of another state variable?** `isError` is not needed because you can check `error !== null` instead.

After this clean-up, you’re left with 3 (down from 7!) *essential* state variables:

```
const [answer, setAnswer] = useState('');

const [error, setError] = useState(null);

const [status, setStatus] = useState('typing'); // 'typing', 'submitting', or 'success'
```

You know they are essential, because you can’t remove any of them without breaking the functionality.

##### Deep Dive

#### Eliminating “impossible” states with a reducer

Show Details

These three variables are a good enough representation of this form’s state. However, there are still some intermediate states that don’t fully make sense. For example, a non-null `error` doesn’t make sense when `status` is `'success'`. To model the state more precisely, you can [extract it into a reducer.](https://react.dev/learn/extracting-state-logic-into-a-reducer) Reducers let you unify multiple state variables into a single object and consolidate all the related logic!

### Step 5: Connect the event handlers to set state

Lastly, create event handlers that update the state. Below is the final form, with all event handlers wired up:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [answer, setAnswer] = useState('');
  const [error, setError] = useState(null);
  const [status, setStatus] = useState('typing');

  if (status === 'success') {
    return <h1>That's right!</h1>
  }

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('submitting');
    try {
      await submitForm(answer);
      setStatus('success');
    } catch (err) {
      setStatus('typing');
      setError(err);
    }
  }

  function handleTextareaChange(e) {
    setAnswer(e.target.value);
  }

  return (
    <>
      <h2>City quiz</h2>
      <p>
        In which city is there a billboard that turns air into drinkable water?
      </p>
      <form onSubmit={handleSubmit}>
        <textarea
          value={answer}
          onChange={handleTextareaChange}
          disabled={status === 'submitting'}
        />
        <br />
        <button disabled={
          answer.length === 0 ||
          status === 'submitting'
        }>
          Submit
        </button>
        {error !== null &&
          <p className="Error">
            {error.message}
          </p>
        }
      </form>
    </>
  );
}

function submitForm(answer) {
  // Pretend it's hitting the network.
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      let shouldError = answer.toLowerCase() !== 'lima'
      if (shouldError) {
        reject(new Error('Good guess but a wrong answer. Try again!'));
      } else {
        resolve();
      }
    }, 1500);
  });
}
```

Show more

Although this code is longer than the original imperative example, it is much less fragile. Expressing all interactions as state changes lets you later introduce new visual states without breaking existing ones. It also lets you change what should be displayed in each state without changing the logic of the interaction itself.

## Recap

* Declarative programming means describing the UI for each visual state rather than micromanaging the UI (imperative).
* When developing a component:
  1. Identify all its visual states.
  2. Determine the human and computer triggers for state changes.
  3. Model the state with `useState`.
  4. Remove non-essential state to avoid bugs and paradoxes.
  5. Connect the event handlers to set state.

## Try out some challenges

1. Add and remove a CSS class 2. Profile editor 3. Refactor the imperative solution without React

#### Challenge 1 of 3: Add and remove a CSS class

Make it so that clicking on the picture *removes* the `background--active` CSS class from the outer `<div>`, but *adds* the `picture--active` class to the `<img>`. Clicking the background again should restore the original CSS classes.

Visually, you should expect that clicking on the picture removes the purple background and highlights the picture border. Clicking outside the picture highlights the background, but removes the picture border highlight.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Picture() {
  return (
    <div className="background background--active">
      <img
        className="picture"
        alt="Rainbow houses in Kampung Pelangi, Indonesia"
        src="https://i.imgur.com/5qwVYb1.jpeg"
      />
    </div>
  );
}
```

Show solutionNext Challenge

[PreviousManaging State](https://react.dev/learn/managing-state)[NextChoosing the State Structure](https://react.dev/learn/choosing-the-state-structure)

---

---


# Choosing the State Structure – React

URL: https://react.dev/learn/choosing-the-state-structure

[Learn React](https://react.dev/learn)

[Managing State](https://react.dev/learn/managing-state)

# Choosing the State Structure

Structuring state well can make a difference between a component that is pleasant to modify and debug, and one that is a constant source of bugs. Here are some tips you should consider when structuring state.

### You will learn

* When to use a single vs multiple state variables
* What to avoid when organizing state
* How to fix common issues with the state structure

## Principles for structuring state

When you write a component that holds some state, you’ll have to make choices about how many state variables to use and what the shape of their data should be. While it’s possible to write correct programs even with a suboptimal state structure, there are a few principles that can guide you to make better choices:

1. **Group related state.** If you always update two or more state variables at the same time, consider merging them into a single state variable.
2. **Avoid contradictions in state.** When the state is structured in a way that several pieces of state may contradict and “disagree” with each other, you leave room for mistakes. Try to avoid this.
3. **Avoid redundant state.** If you can calculate some information from the component’s props or its existing state variables during rendering, you should not put that information into that component’s state.
4. **Avoid duplication in state.** When the same data is duplicated between multiple state variables, or within nested objects, it is difficult to keep them in sync. Reduce duplication when you can.
5. **Avoid deeply nested state.** Deeply hierarchical state is not very convenient to update. When possible, prefer to structure state in a flat way.

The goal behind these principles is to *make state easy to update without introducing mistakes*. Removing redundant and duplicate data from state helps ensure that all its pieces stay in sync. This is similar to how a database engineer might want to [“normalize” the database structure](https://docs.microsoft.com/en-us/office/troubleshoot/access/database-normalization-description) to reduce the chance of bugs. To paraphrase Albert Einstein, **“Make your state as simple as it can be—but no simpler.”**

Now let’s see how these principles apply in action.

## Group related state

You might sometimes be unsure between using a single or multiple state variables.

Should you do this?

```
const [x, setX] = useState(0);

const [y, setY] = useState(0);
```

Or this?

```
const [position, setPosition] = useState({ x: 0, y: 0 });
```

Technically, you can use either of these approaches. But **if some two state variables always change together, it might be a good idea to unify them into a single state variable.** Then you won’t forget to always keep them in sync, like in this example where moving the cursor updates both coordinates of the red dot:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function MovingDot() {
  const [position, setPosition] = useState({
    x: 0,
    y: 0
  });
  return (
    <div
      onPointerMove={e => {
        setPosition({
          x: e.clientX,
          y: e.clientY
        });
      }}
      style={{
        position: 'relative',
        width: '100vw',
        height: '100vh',
      }}>
      <div style={{
        position: 'absolute',
        backgroundColor: 'red',
        borderRadius: '50%',
        transform: `translate(${position.x}px, ${position.y}px)`,
        left: -10,
        top: -10,
        width: 20,
        height: 20,
      }} />
    </div>
  )
}
```

Show more

Another case where you’ll group data into an object or an array is when you don’t know how many pieces of state you’ll need. For example, it’s helpful when you have a form where the user can add custom fields.

### Pitfall

If your state variable is an object, remember that [you can’t update only one field in it](https://react.dev/learn/updating-objects-in-state) without explicitly copying the other fields. For example, you can’t do `setPosition({ x: 100 })` in the above example because it would not have the `y` property at all! Instead, if you wanted to set `x` alone, you would either do `setPosition({ ...position, x: 100 })`, or split them into two state variables and do `setX(100)`.

## Avoid contradictions in state

Here is a hotel feedback form with `isSending` and `isSent` state variables:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [isSending, setIsSending] = useState(false);
  const [isSent, setIsSent] = useState(false);

  async function handleSubmit(e) {
    e.preventDefault();
    setIsSending(true);
    await sendMessage(text);
    setIsSending(false);
    setIsSent(true);
  }

  if (isSent) {
    return <h1>Thanks for feedback!</h1>
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <br />
      <button
        disabled={isSending}
        type="submit"
      >
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  });
}
```

Show more

While this code works, it leaves the door open for “impossible” states. For example, if you forget to call `setIsSent` and `setIsSending` together, you may end up in a situation where both `isSending` and `isSent` are `true` at the same time. The more complex your component is, the harder it is to understand what happened.

**Since `isSending` and `isSent` should never be `true` at the same time, it is better to replace them with one `status` state variable that may take one of *three* valid states:** `'typing'` (initial), `'sending'`, and `'sent'`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function FeedbackForm() {
  const [text, setText] = useState('');
  const [status, setStatus] = useState('typing');

  async function handleSubmit(e) {
    e.preventDefault();
    setStatus('sending');
    await sendMessage(text);
    setStatus('sent');
  }

  const isSending = status === 'sending';
  const isSent = status === 'sent';

  if (isSent) {
    return <h1>Thanks for feedback!</h1>
  }

  return (
    <form onSubmit={handleSubmit}>
      <p>How was your stay at The Prancing Pony?</p>
      <textarea
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <br />
      <button
        disabled={isSending}
        type="submit"
      >
        Send
      </button>
      {isSending && <p>Sending...</p>}
    </form>
  );
}

// Pretend to send a message.
function sendMessage(text) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  });
}
```

Show more

You can still declare some constants for readability:

```
const isSending = status === 'sending';

const isSent = status === 'sent';
```

But they’re not state variables, so you don’t need to worry about them getting out of sync with each other.

## Avoid redundant state

If you can calculate some information from the component’s props or its existing state variables during rendering, you **should not** put that information into that component’s state.

For example, take this form. It works, but can you find any redundant state in it?

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [fullName, setFullName] = useState('');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
    setFullName(e.target.value + ' ' + lastName);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
    setFullName(firstName + ' ' + e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name:{' '}
        <input
          value={firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:{' '}
        <input
          value={lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
```

Show more

This form has three state variables: `firstName`, `lastName`, and `fullName`. However, `fullName` is redundant. **You can always calculate `fullName` from `firstName` and `lastName` during render, so remove it from state.**

This is how you can do it:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  const fullName = firstName + ' ' + lastName;

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <h2>Let’s check you in</h2>
      <label>
        First name:{' '}
        <input
          value={firstName}
          onChange={handleFirstNameChange}
        />
      </label>
      <label>
        Last name:{' '}
        <input
          value={lastName}
          onChange={handleLastNameChange}
        />
      </label>
      <p>
        Your ticket will be issued to: <b>{fullName}</b>
      </p>
    </>
  );
}
```

Show more

Here, `fullName` is *not* a state variable. Instead, it’s calculated during render:

```
const fullName = firstName + ' ' + lastName;
```

As a result, the change handlers don’t need to do anything special to update it. When you call `setFirstName` or `setLastName`, you trigger a re-render, and then the next `fullName` will be calculated from the fresh data.

##### Deep Dive

#### Don’t mirror props in state

Show Details

A common example of redundant state is code like this:

```
function Message({ messageColor }) {

const [color, setColor] = useState(messageColor);
```

Here, a `color` state variable is initialized to the `messageColor` prop. The problem is that **if the parent component passes a different value of `messageColor` later (for example, `'red'` instead of `'blue'`), the `color` *state variable* would not be updated!** The state is only initialized during the first render.

This is why “mirroring” some prop in a state variable can lead to confusion. Instead, use the `messageColor` prop directly in your code. If you want to give it a shorter name, use a constant:

```
function Message({ messageColor }) {

const color = messageColor;
```

This way it won’t get out of sync with the prop passed from the parent component.

”Mirroring” props into state only makes sense when you *want* to ignore all updates for a specific prop. By convention, start the prop name with `initial` or `default` to clarify that its new values are ignored:

```
function Message({ initialColor }) {

// The `color` state variable holds the *first* value of `initialColor`.

// Further changes to the `initialColor` prop are ignored.

const [color, setColor] = useState(initialColor);
```

## Avoid duplication in state

This menu list component lets you choose a single travel snack out of several:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(
    items[0]
  );

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map(item => (
          <li key={item.id}>
            {item.title}
            {' '}
            <button onClick={() => {
              setSelectedItem(item);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

Show more

Currently, it stores the selected item as an object in the `selectedItem` state variable. However, this is not great: **the contents of the `selectedItem` is the same object as one of the items inside the `items` list.** This means that the information about the item itself is duplicated in two places.

Why is this a problem? Let’s make each item editable:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedItem, setSelectedItem] = useState(
    items[0]
  );

  function handleItemChange(id, e) {
    setItems(items.map(item => {
      if (item.id === id) {
        return {
          ...item,
          title: e.target.value,
        };
      } else {
        return item;
      }
    }));
  }

  return (
    <>
      <h2>What's your travel snack?</h2> 
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={e => {
                handleItemChange(item.id, e)
              }}
            />
            {' '}
            <button onClick={() => {
              setSelectedItem(item);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

Show more

Notice how if you first click “Choose” on an item and *then* edit it, **the input updates but the label at the bottom does not reflect the edits.** This is because you have duplicated state, and you forgot to update `selectedItem`.

Although you could update `selectedItem` too, an easier fix is to remove duplication. In this example, instead of a `selectedItem` object (which creates a duplication with objects inside `items`), you hold the `selectedId` in state, and *then* get the `selectedItem` by searching the `items` array for an item with that ID:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

const initialItems = [
  { title: 'pretzels', id: 0 },
  { title: 'crispy seaweed', id: 1 },
  { title: 'granola bar', id: 2 },
];

export default function Menu() {
  const [items, setItems] = useState(initialItems);
  const [selectedId, setSelectedId] = useState(0);

  const selectedItem = items.find(item =>
    item.id === selectedId
  );

  function handleItemChange(id, e) {
    setItems(items.map(item => {
      if (item.id === id) {
        return {
          ...item,
          title: e.target.value,
        };
      } else {
        return item;
      }
    }));
  }

  return (
    <>
      <h2>What's your travel snack?</h2>
      <ul>
        {items.map((item, index) => (
          <li key={item.id}>
            <input
              value={item.title}
              onChange={e => {
                handleItemChange(item.id, e)
              }}
            />
            {' '}
            <button onClick={() => {
              setSelectedId(item.id);
            }}>Choose</button>
          </li>
        ))}
      </ul>
      <p>You picked {selectedItem.title}.</p>
    </>
  );
}
```

Show more

The state used to be duplicated like this:

* `items = [{ id: 0, title: 'pretzels'}, ...]`
* `selectedItem = {id: 0, title: 'pretzels'}`

But after the change it’s like this:

* `items = [{ id: 0, title: 'pretzels'}, ...]`
* `selectedId = 0`

The duplication is gone, and you only keep the essential state!

Now if you edit the *selected* item, the message below will update immediately. This is because `setItems` triggers a re-render, and `items.find(...)` would find the item with the updated title. You didn’t need to hold *the selected item* in state, because only the *selected ID* is essential. The rest could be calculated during render.

## Avoid deeply nested state

Imagine a travel plan consisting of planets, continents, and countries. You might be tempted to structure its state using nested objects and arrays, like in this example:

App.jsplaces.js

places.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export const initialTravelPlan = {
  id: 0,
  title: '(Root)',
  childPlaces: [{
    id: 1,
    title: 'Earth',
    childPlaces: [{
      id: 2,
      title: 'Africa',
      childPlaces: [{
        id: 3,
        title: 'Botswana',
        childPlaces: []
      }, {
        id: 4,
        title: 'Egypt',
        childPlaces: []
      }, {
        id: 5,
        title: 'Kenya',
        childPlaces: []
      }, {
        id: 6,
        title: 'Madagascar',
        childPlaces: []
      }, {
        id: 7,
        title: 'Morocco',
        childPlaces: []
      }, {
        id: 8,
        title: 'Nigeria',
        childPlaces: []
      }, {
        id: 9,
        title: 'South Africa',
        childPlaces: []
      }]
    }, {
      id: 10,
      title: 'Americas',
      childPlaces: [{
        id: 11,
        title: 'Argentina',
        childPlaces: []
      }, {
        id: 12,
        title: 'Brazil',
        childPlaces: []
      }, {
        id: 13,
        title: 'Barbados',
        childPlaces: []
      }, {
        id: 14,
        title: 'Canada',
        childPlaces: []
      }, {
        id: 15,
        title: 'Jamaica',
        childPlaces: []
      }, {
        id: 16,
        title: 'Mexico',
        childPlaces: []
      }, {
        id: 17,
        title: 'Trinidad and Tobago',
        childPlaces: []
      }, {
        id: 18,
        title: 'Venezuela',
        childPlaces: []
      }]
    }, {
      id: 19,
      title: 'Asia',
      childPlaces: [{
        id: 20,
        title: 'China',
        childPlaces: []
      }, {
        id: 21,
        title: 'India',
        childPlaces: []
      }, {
        id: 22,
        title: 'Singapore',
        childPlaces: []
      }, {
        id: 23,
        title: 'South Korea',
        childPlaces: []
      }, {
        id: 24,
        title: 'Thailand',
        childPlaces: []
      }, {
        id: 25,
        title: 'Vietnam',
        childPlaces: []
      }]
    }, {
      id: 26,
      title: 'Europe',
      childPlaces: [{
        id: 27,
        title: 'Croatia',
        childPlaces: [],
      }, {
        id: 28,
        title: 'France',
        childPlaces: [],
      }, {
        id: 29,
        title: 'Germany',
        childPlaces: [],
      }, {
        id: 30,
        title: 'Italy',
        childPlaces: [],
      }, {
        id: 31,
        title: 'Portugal',
        childPlaces: [],
      }, {
        id: 32,
        title: 'Spain',
        childPlaces: [],
      }, {
        id: 33,
        title: 'Turkey',
        childPlaces: [],
      }]
    }, {
      id: 34,
      title: 'Oceania',
      childPlaces: [{
        id: 35,
        title: 'Australia',
        childPlaces: [],
      }, {
        id: 36,
        title: 'Bora Bora (French Polynesia)',
        childPlaces: [],
      }, {
        id: 37,
        title: 'Easter Island (Chile)',
        childPlaces: [],
      }, {
        id: 38,
        title: 'Fiji',
        childPlaces: [],
      }, {
        id: 39,
        title: 'Hawaii (the USA)',
        childPlaces: [],
      }, {
        id: 40,
        title: 'New Zealand',
        childPlaces: [],
      }, {
        id: 41,
        title: 'Vanuatu',
        childPlaces: [],
      }]
    }]
  }, {
    id: 42,
    title: 'Moon',
    childPlaces: [{
      id: 43,
      title: 'Rheita',
      childPlaces: []
    }, {
      id: 44,
      title: 'Piccolomini',
      childPlaces: []
    }, {
      id: 45,
      title: 'Tycho',
      childPlaces: []
    }]
  }, {
    id: 46,
    title: 'Mars',
    childPlaces: [{
      id: 47,
      title: 'Corn Town',
      childPlaces: []
    }, {
      id: 48,
      title: 'Green Hill',
      childPlaces: []      
    }]
  }]
};
```

Show more

Now let’s say you want to add a button to delete a place you’ve already visited. How would you go about it? [Updating nested state](https://react.dev/learn/updating-objects-in-state#updating-a-nested-object) involves making copies of objects all the way up from the part that changed. Deleting a deeply nested place would involve copying its entire parent place chain. Such code can be very verbose.

**If the state is too nested to update easily, consider making it “flat”.** Here is one way you can restructure this data. Instead of a tree-like structure where each `place` has an array of *its child places*, you can have each place hold an array of *its child place IDs*. Then store a mapping from each place ID to the corresponding place.

This data restructuring might remind you of seeing a database table:

App.jsplaces.js

places.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export const initialTravelPlan = {
  0: {
    id: 0,
    title: '(Root)',
    childIds: [1, 42, 46],
  },
  1: {
    id: 1,
    title: 'Earth',
    childIds: [2, 10, 19, 26, 34]
  },
  2: {
    id: 2,
    title: 'Africa',
    childIds: [3, 4, 5, 6 , 7, 8, 9]
  }, 
  3: {
    id: 3,
    title: 'Botswana',
    childIds: []
  },
  4: {
    id: 4,
    title: 'Egypt',
    childIds: []
  },
  5: {
    id: 5,
    title: 'Kenya',
    childIds: []
  },
  6: {
    id: 6,
    title: 'Madagascar',
    childIds: []
  }, 
  7: {
    id: 7,
    title: 'Morocco',
    childIds: []
  },
  8: {
    id: 8,
    title: 'Nigeria',
    childIds: []
  },
  9: {
    id: 9,
    title: 'South Africa',
    childIds: []
  },
  10: {
    id: 10,
    title: 'Americas',
    childIds: [11, 12, 13, 14, 15, 16, 17, 18],   
  },
  11: {
    id: 11,
    title: 'Argentina',
    childIds: []
  },
  12: {
    id: 12,
    title: 'Brazil',
    childIds: []
  },
  13: {
    id: 13,
    title: 'Barbados',
    childIds: []
  }, 
  14: {
    id: 14,
    title: 'Canada',
    childIds: []
  },
  15: {
    id: 15,
    title: 'Jamaica',
    childIds: []
  },
  16: {
    id: 16,
    title: 'Mexico',
    childIds: []
  },
  17: {
    id: 17,
    title: 'Trinidad and Tobago',
    childIds: []
  },
  18: {
    id: 18,
    title: 'Venezuela',
    childIds: []
  },
  19: {
    id: 19,
    title: 'Asia',
    childIds: [20, 21, 22, 23, 24, 25],   
  },
  20: {
    id: 20,
    title: 'China',
    childIds: []
  },
  21: {
    id: 21,
    title: 'India',
    childIds: []
  },
  22: {
    id: 22,
    title: 'Singapore',
    childIds: []
  },
  23: {
    id: 23,
    title: 'South Korea',
    childIds: []
  },
  24: {
    id: 24,
    title: 'Thailand',
    childIds: []
  },
  25: {
    id: 25,
    title: 'Vietnam',
    childIds: []
  },
  26: {
    id: 26,
    title: 'Europe',
    childIds: [27, 28, 29, 30, 31, 32, 33],   
  },
  27: {
    id: 27,
    title: 'Croatia',
    childIds: []
  },
  28: {
    id: 28,
    title: 'France',
    childIds: []
  },
  29: {
    id: 29,
    title: 'Germany',
    childIds: []
  },
  30: {
    id: 30,
    title: 'Italy',
    childIds: []
  },
  31: {
    id: 31,
    title: 'Portugal',
    childIds: []
  },
  32: {
    id: 32,
    title: 'Spain',
    childIds: []
  },
  33: {
    id: 33,
    title: 'Turkey',
    childIds: []
  },
  34: {
    id: 34,
    title: 'Oceania',
    childIds: [35, 36, 37, 38, 39, 40, 41],   
  },
  35: {
    id: 35,
    title: 'Australia',
    childIds: []
  },
  36: {
    id: 36,
    title: 'Bora Bora (French Polynesia)',
    childIds: []
  },
  37: {
    id: 37,
    title: 'Easter Island (Chile)',
    childIds: []
  },
  38: {
    id: 38,
    title: 'Fiji',
    childIds: []
  },
  39: {
    id: 40,
    title: 'Hawaii (the USA)',
    childIds: []
  },
  40: {
    id: 40,
    title: 'New Zealand',
    childIds: []
  },
  41: {
    id: 41,
    title: 'Vanuatu',
    childIds: []
  },
  42: {
    id: 42,
    title: 'Moon',
    childIds: [43, 44, 45]
  },
  43: {
    id: 43,
    title: 'Rheita',
    childIds: []
  },
  44: {
    id: 44,
    title: 'Piccolomini',
    childIds: []
  },
  45: {
    id: 45,
    title: 'Tycho',
    childIds: []
  },
  46: {
    id: 46,
    title: 'Mars',
    childIds: [47, 48]
  },
  47: {
    id: 47,
    title: 'Corn Town',
    childIds: []
  },
  48: {
    id: 48,
    title: 'Green Hill',
    childIds: []
  }
};
```

Show more

**Now that the state is “flat” (also known as “normalized”), updating nested items becomes easier.**

In order to remove a place now, you only need to update two levels of state:

* The updated version of its *parent* place should exclude the removed ID from its `childIds` array.
* The updated version of the root “table” object should include the updated version of the parent place.

Here is an example of how you could go about it:

App.jsplaces.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { initialTravelPlan } from './places.js';

export default function TravelPlan() {
  const [plan, setPlan] = useState(initialTravelPlan);

  function handleComplete(parentId, childId) {
    const parent = plan[parentId];
    // Create a new version of the parent place
    // that doesn't include this child ID.
    const nextParent = {
      ...parent,
      childIds: parent.childIds
        .filter(id => id !== childId)
    };
    // Update the root state object...
    setPlan({
      ...plan,
      // ...so that it has the updated parent.
      [parentId]: nextParent
    });
  }

  const root = plan[0];
  const planetIds = root.childIds;
  return (
    <>
      <h2>Places to visit</h2>
      <ol>
        {planetIds.map(id => (
          <PlaceTree
            key={id}
            id={id}
            parentId={0}
            placesById={plan}
            onComplete={handleComplete}
          />
        ))}
      </ol>
    </>
  );
}

function PlaceTree({ id, parentId, placesById, onComplete }) {
  const place = placesById[id];
  const childIds = place.childIds;
  return (
    <li>
      {place.title}
      <button onClick={() => {
        onComplete(parentId, id);
      }}>
        Complete
      </button>
      {childIds.length > 0 &&
        <ol>
          {childIds.map(childId => (
            <PlaceTree
              key={childId}
              id={childId}
              parentId={id}
              placesById={placesById}
              onComplete={onComplete}
            />
          ))}
        </ol>
      }
    </li>
  );
}
```

Show more

You can nest state as much as you like, but making it “flat” can solve numerous problems. It makes state easier to update, and it helps ensure you don’t have duplication in different parts of a nested object.

##### Deep Dive

#### Improving memory usage

Show Details

Ideally, you would also remove the deleted items (and their children!) from the “table” object to improve memory usage. This version does that. It also [uses Immer](https://react.dev/learn/updating-objects-in-state#write-concise-update-logic-with-immer) to make the update logic more concise.

package.jsonApp.jsplaces.js

package.json

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

Sometimes, you can also reduce state nesting by moving some of the nested state into the child components. This works well for ephemeral UI state that doesn’t need to be stored, like whether an item is hovered.

## Recap

* If two state variables always update together, consider merging them into one.
* Choose your state variables carefully to avoid creating “impossible” states.
* Structure your state in a way that reduces the chances that you’ll make a mistake updating it.
* Avoid redundant and duplicate state so that you don’t need to keep it in sync.
* Don’t put props *into* state unless you specifically want to prevent updates.
* For UI patterns like selection, keep ID or index in state instead of the object itself.
* If updating deeply nested state is complicated, try flattening it.

## Try out some challenges

1. Fix a component that’s not updating 2. Fix a broken packing list 3. Fix the disappearing selection 4. Implement multiple selection

#### Challenge 1 of 4: Fix a component that’s not updating

This `Clock` component receives two props: `color` and `time`. When you select a different color in the select box, the `Clock` component receives a different `color` prop from its parent component. However, for some reason, the displayed color doesn’t update. Why? Fix the problem.

Clock.js

Clock.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Clock(props) {
  const [color, setColor] = useState(props.color);
  return (
    <h1 style={{ color: color }}>
      {props.time}
    </h1>
  );
}
```

Show solutionNext Challenge

[PreviousReacting to Input with State](https://react.dev/learn/reacting-to-input-with-state)[NextSharing State Between Components](https://react.dev/learn/sharing-state-between-components)

---

---


# Sharing State Between Components – React

URL: https://react.dev/learn/sharing-state-between-components

[Learn React](https://react.dev/learn)

[Managing State](https://react.dev/learn/managing-state)

# Sharing State Between Components

Sometimes, you want the state of two components to always change together. To do it, remove state from both of them, move it to their closest common parent, and then pass it down to them via props. This is known as *lifting state up,* and it’s one of the most common things you will do writing React code.

### You will learn

* How to share state between components by lifting it up
* What are controlled and uncontrolled components

## Lifting state up by example

In this example, a parent `Accordion` component renders two separate `Panel`s:

* `Accordion`
  + `Panel`
  + `Panel`

Each `Panel` component has a boolean `isActive` state that determines whether its content is visible.

Press the Show button for both panels:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Panel({ title, children }) {
  const [isActive, setIsActive] = useState(false);
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={() => setIsActive(true)}>
          Show
        </button>
      )}
    </section>
  );
}

export default function Accordion() {
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel title="About">
        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel title="Etymology">
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for "apple" and is often translated as "full of apples". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang="la">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}
```

Show more

Notice how pressing one panel’s button does not affect the other panel—they are independent.

![Diagram showing a tree of three components, one parent labeled Accordion and two children labeled Panel. Both Panel components contain isActive with value false.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_child.dark.png&w=1080&q=75)

![Diagram showing a tree of three components, one parent labeled Accordion and two children labeled Panel. Both Panel components contain isActive with value false.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_child.png&w=1080&q=75)

Initially, each `Panel`’s `isActive` state is `false`, so they both appear collapsed

![The same diagram as the previous, with the isActive of the first child Panel component highlighted indicating a click with the isActive value set to true. The second Panel component still contains value false.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_child_clicked.dark.png&w=1080&q=75)

![The same diagram as the previous, with the isActive of the first child Panel component highlighted indicating a click with the isActive value set to true. The second Panel component still contains value false.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_child_clicked.png&w=1080&q=75)

Clicking either `Panel`’s button will only update that `Panel`’s `isActive` state alone

**But now let’s say you want to change it so that only one panel is expanded at any given time.** With that design, expanding the second panel should collapse the first one. How would you do that?

To coordinate these two panels, you need to “lift their state up” to a parent component in three steps:

1. **Remove** state from the child components.
2. **Pass** hardcoded data from the common parent.
3. **Add** state to the common parent and pass it down together with the event handlers.

This will allow the `Accordion` component to coordinate both `Panel`s and only expand one at a time.

### Step 1: Remove state from the child components

You will give control of the `Panel`’s `isActive` to its parent component. This means that the parent component will pass `isActive` to `Panel` as a prop instead. Start by **removing this line** from the `Panel` component:

```
const [isActive, setIsActive] = useState(false);
```

And instead, add `isActive` to the `Panel`’s list of props:

```
function Panel({ title, children, isActive }) {
```

Now the `Panel`’s parent component can *control* `isActive` by [passing it down as a prop.](https://react.dev/learn/passing-props-to-a-component) Conversely, the `Panel` component now has *no control* over the value of `isActive`—it’s now up to the parent component!

### Step 2: Pass hardcoded data from the common parent

To lift state up, you must locate the closest common parent component of *both* of the child components that you want to coordinate:

* `Accordion` *(closest common parent)*
  + `Panel`
  + `Panel`

In this example, it’s the `Accordion` component. Since it’s above both panels and can control their props, it will become the “source of truth” for which panel is currently active. Make the `Accordion` component pass a hardcoded value of `isActive` (for example, `true`) to both panels:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Accordion() {
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel title="About" isActive={true}>
        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel title="Etymology" isActive={true}>
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for "apple" and is often translated as "full of apples". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang="la">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({ title, children, isActive }) {
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={() => setIsActive(true)}>
          Show
        </button>
      )}
    </section>
  );
}
```

Show more

Try editing the hardcoded `isActive` values in the `Accordion` component and see the result on the screen.

### Step 3: Add state to the common parent

Lifting state up often changes the nature of what you’re storing as state.

In this case, only one panel should be active at a time. This means that the `Accordion` common parent component needs to keep track of *which* panel is the active one. Instead of a `boolean` value, it could use a number as the index of the active `Panel` for the state variable:

```
const [activeIndex, setActiveIndex] = useState(0);
```

When the `activeIndex` is `0`, the first panel is active, and when it’s `1`, it’s the second one.

Clicking the “Show” button in either `Panel` needs to change the active index in `Accordion`. A `Panel` can’t set the `activeIndex` state directly because it’s defined inside the `Accordion`. The `Accordion` component needs to *explicitly allow* the `Panel` component to change its state by [passing an event handler down as a prop](https://react.dev/learn/responding-to-events#passing-event-handlers-as-props):

```
<>

<Panel

isActive={activeIndex === 0}

onShow={() => setActiveIndex(0)}

>

...

</Panel>

<Panel

isActive={activeIndex === 1}

onShow={() => setActiveIndex(1)}

>

...

</Panel>

</>
```

The `<button>` inside the `Panel` will now use the `onShow` prop as its click event handler:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Accordion() {
  const [activeIndex, setActiveIndex] = useState(0);
  return (
    <>
      <h2>Almaty, Kazakhstan</h2>
      <Panel
        title="About"
        isActive={activeIndex === 0}
        onShow={() => setActiveIndex(0)}
      >
        With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city.
      </Panel>
      <Panel
        title="Etymology"
        isActive={activeIndex === 1}
        onShow={() => setActiveIndex(1)}
      >
        The name comes from <span lang="kk-KZ">алма</span>, the Kazakh word for "apple" and is often translated as "full of apples". In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild <i lang="la">Malus sieversii</i> is considered a likely candidate for the ancestor of the modern domestic apple.
      </Panel>
    </>
  );
}

function Panel({
  title,
  children,
  isActive,
  onShow
}) {
  return (
    <section className="panel">
      <h3>{title}</h3>
      {isActive ? (
        <p>{children}</p>
      ) : (
        <button onClick={onShow}>
          Show
        </button>
      )}
    </section>
  );
}
```

Show more

This completes lifting state up! Moving state into the common parent component allowed you to coordinate the two panels. Using the active index instead of two “is shown” flags ensured that only one panel is active at a given time. And passing down the event handler to the child allowed the child to change the parent’s state.

![Diagram showing a tree of three components, one parent labeled Accordion and two children labeled Panel. Accordion contains an activeIndex value of zero which turns into isActive value of true passed to the first Panel, and isActive value of false passed to the second Panel.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_parent.dark.png&w=1080&q=75)

![Diagram showing a tree of three components, one parent labeled Accordion and two children labeled Panel. Accordion contains an activeIndex value of zero which turns into isActive value of true passed to the first Panel, and isActive value of false passed to the second Panel.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_parent.png&w=1080&q=75)

Initially, `Accordion`’s `activeIndex` is `0`, so the first `Panel` receives `isActive = true`

![The same diagram as the previous, with the activeIndex value of the parent Accordion component highlighted indicating a click with the value changed to one. The flow to both of the children Panel components is also highlighted, and the isActive value passed to each child is set to the opposite: false for the first Panel and true for the second one.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_parent_clicked.dark.png&w=1080&q=75)

![The same diagram as the previous, with the activeIndex value of the parent Accordion component highlighted indicating a click with the value changed to one. The flow to both of the children Panel components is also highlighted, and the isActive value passed to each child is set to the opposite: false for the first Panel and true for the second one.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_parent_clicked.png&w=1080&q=75)

When `Accordion`’s `activeIndex` state changes to `1`, the second `Panel` receives `isActive = true` instead

##### Deep Dive

#### Controlled and uncontrolled components

Show Details

It is common to call a component with some local state “uncontrolled”. For example, the original `Panel` component with an `isActive` state variable is uncontrolled because its parent cannot influence whether the panel is active or not.

In contrast, you might say a component is “controlled” when the important information in it is driven by props rather than its own local state. This lets the parent component fully specify its behavior. The final `Panel` component with the `isActive` prop is controlled by the `Accordion` component.

Uncontrolled components are easier to use within their parents because they require less configuration. But they’re less flexible when you want to coordinate them together. Controlled components are maximally flexible, but they require the parent components to fully configure them with props.

In practice, “controlled” and “uncontrolled” aren’t strict technical terms—each component usually has some mix of both local state and props. However, this is a useful way to talk about how components are designed and what capabilities they offer.

When writing a component, consider which information in it should be controlled (via props), and which information should be uncontrolled (via state). But you can always change your mind and refactor later.

## A single source of truth for each state

In a React application, many components will have their own state. Some state may “live” close to the leaf components (components at the bottom of the tree) like inputs. Other state may “live” closer to the top of the app. For example, even client-side routing libraries are usually implemented by storing the current route in the React state, and passing it down by props!

**For each unique piece of state, you will choose the component that “owns” it.** This principle is also known as having a [“single source of truth”.](https://en.wikipedia.org/wiki/Single_source_of_truth) It doesn’t mean that all state lives in one place—but that for *each* piece of state, there is a *specific* component that holds that piece of information. Instead of duplicating shared state between components, *lift it up* to their common shared parent, and *pass it down* to the children that need it.

Your app will change as you work on it. It is common that you will move state down or back up while you’re still figuring out where each piece of the state “lives”. This is all part of the process!

To see what this feels like in practice with a few more components, read [Thinking in React.](https://react.dev/learn/thinking-in-react)

## Recap

* When you want to coordinate two components, move their state to their common parent.
* Then pass the information down through props from their common parent.
* Finally, pass the event handlers down so that the children can change the parent’s state.
* It’s useful to consider components as “controlled” (driven by props) or “uncontrolled” (driven by state).

## Try out some challenges

1. Synced inputs 2. Filtering a list

#### Challenge 1 of 2: Synced inputs

These two inputs are independent. Make them stay in sync: editing one input should update the other input with the same text, and vice versa.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function SyncedInputs() {
  return (
    <>
      <Input label="First input" />
      <Input label="Second input" />
    </>
  );
}

function Input({ label }) {
  const [text, setText] = useState('');

  function handleChange(e) {
    setText(e.target.value);
  }

  return (
    <label>
      {label}
      {' '}
      <input
        value={text}
        onChange={handleChange}
      />
    </label>
  );
}
```

Show more

Show hint Show solution

Next Challenge

[PreviousChoosing the State Structure](https://react.dev/learn/choosing-the-state-structure)[NextPreserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state)

---

---


# Preserving and Resetting State – React

URL: https://react.dev/learn/preserving-and-resetting-state

[Learn React](https://react.dev/learn)

[Managing State](https://react.dev/learn/managing-state)

# Preserving and Resetting State

State is isolated between components. React keeps track of which state belongs to which component based on their place in the UI tree. You can control when to preserve state and when to reset it between re-renders.

### You will learn

* When React chooses to preserve or reset the state
* How to force React to reset component’s state
* How keys and types affect whether the state is preserved

## State is tied to a position in the render tree

React builds [render trees](https://react.dev/learn/understanding-your-ui-as-a-tree#the-render-tree) for the component structure in your UI.

When you give a component state, you might think the state “lives” inside the component. But the state is actually held inside React. React associates each piece of state it’s holding with the correct component by where that component sits in the render tree.

Here, there is only one `<Counter />` JSX tag, but it’s rendered at two different positions:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function App() {
  const counter = <Counter />;
  return (
    <div>
      {counter}
      {counter}
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

Here’s how these look as a tree:

![Diagram of a tree of React components. The root node is labeled 'div' and has two children. Each of the children are labeled 'Counter' and both contain a state bubble labeled 'count' with value 0.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_tree.dark.png&w=828&q=75)

![Diagram of a tree of React components. The root node is labeled 'div' and has two children. Each of the children are labeled 'Counter' and both contain a state bubble labeled 'count' with value 0.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_tree.png&w=828&q=75)

React tree

**These are two separate counters because each is rendered at its own position in the tree.** You don’t usually have to think about these positions to use React, but it can be useful to understand how it works.

In React, each component on the screen has fully isolated state. For example, if you render two `Counter` components side by side, each of them will get its own, independent, `score` and `hover` states.

Try clicking both counters and notice they don’t affect each other:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function App() {
  return (
    <div>
      <Counter />
      <Counter />
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

As you can see, when one counter is updated, only the state for that component is updated:

![Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is labeled 'Counter' and contains a state bubble labeled 'count' with value 1. The state bubble of the right child is highlighted in yellow to indicate its value has updated.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_increment.dark.png&w=1080&q=75)

![Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is labeled 'Counter' and contains a state bubble labeled 'count' with value 1. The state bubble of the right child is highlighted in yellow to indicate its value has updated.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_increment.png&w=1080&q=75)

Updating state

React will keep the state around for as long as you render the same component at the same position in the tree. To see this, increment both counters, then remove the second component by unchecking “Render the second counter” checkbox, and then add it back by ticking it again:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function App() {
  const [showB, setShowB] = useState(true);
  return (
    <div>
      <Counter />
      {showB && <Counter />} 
      <label>
        <input
          type="checkbox"
          checked={showB}
          onChange={e => {
            setShowB(e.target.checked)
          }}
        />
        Render the second counter
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

Notice how the moment you stop rendering the second counter, its state disappears completely. That’s because when React removes a component, it destroys its state.

![Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is missing, and in its place is a yellow 'poof' image, highlighting the component being deleted from the tree.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_remove_component.dark.png&w=1080&q=75)

![Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is missing, and in its place is a yellow 'poof' image, highlighting the component being deleted from the tree.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_remove_component.png&w=1080&q=75)

Deleting a component

When you tick “Render the second counter”, a second `Counter` and its state are initialized from scratch (`score = 0`) and added to the DOM.

![Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The entire right child node is highlighted in yellow, indicating that it was just added to the tree.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_add_component.dark.png&w=1080&q=75)

![Diagram of a tree of React components. The root node is labeled 'div' and has two children. The left child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The entire right child node is highlighted in yellow, indicating that it was just added to the tree.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_add_component.png&w=1080&q=75)

Adding a component

**React preserves a component’s state for as long as it’s being rendered at its position in the UI tree.** If it gets removed, or a different component gets rendered at the same position, React discards its state.

## Same component at the same position preserves state

In this example, there are two different `<Counter />` tags:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? (
        <Counter isFancy={true} /> 
      ) : (
        <Counter isFancy={false} /> 
      )}
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={e => {
            setIsFancy(e.target.checked)
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

When you tick or clear the checkbox, the counter state does not get reset. Whether `isFancy` is `true` or `false`, you always have a `<Counter />` as the first child of the `div` returned from the root `App` component:

![Diagram with two sections separated by an arrow transitioning between them. Each section contains a layout of components with a parent labeled 'App' containing a state bubble labeled isFancy. This component has one child labeled 'div', which leads to a prop bubble containing isFancy (highlighted in purple) passed down to the only child. The last child is labeled 'Counter' and contains a state bubble with label 'count' and value 3 in both diagrams. In the left section of the diagram, nothing is highlighted and the isFancy parent state value is false. In the right section of the diagram, the isFancy parent state value has changed to true and it is highlighted in yellow, and so is the props bubble below, which has also changed its isFancy value to true.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_same_component.dark.png&w=1200&q=75)

![Diagram with two sections separated by an arrow transitioning between them. Each section contains a layout of components with a parent labeled 'App' containing a state bubble labeled isFancy. This component has one child labeled 'div', which leads to a prop bubble containing isFancy (highlighted in purple) passed down to the only child. The last child is labeled 'Counter' and contains a state bubble with label 'count' and value 3 in both diagrams. In the left section of the diagram, nothing is highlighted and the isFancy parent state value is false. In the right section of the diagram, the isFancy parent state value has changed to true and it is highlighted in yellow, and so is the props bubble below, which has also changed its isFancy value to true.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_same_component.png&w=1200&q=75)

Updating the `App` state does not reset the `Counter` because `Counter` stays in the same position

It’s the same component at the same position, so from React’s perspective, it’s the same counter.

### Pitfall

Remember that **it’s the position in the UI tree—not in the JSX markup—that matters to React!** This component has two `return` clauses with different `<Counter />` JSX tags inside and outside the `if`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  if (isFancy) {
    return (
      <div>
        <Counter isFancy={true} />
        <label>
          <input
            type="checkbox"
            checked={isFancy}
            onChange={e => {
              setIsFancy(e.target.checked)
            }}
          />
          Use fancy styling
        </label>
      </div>
    );
  }
  return (
    <div>
      <Counter isFancy={false} />
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={e => {
            setIsFancy(e.target.checked)
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

You might expect the state to reset when you tick checkbox, but it doesn’t! This is because **both of these `<Counter />` tags are rendered at the same position.** React doesn’t know where you place the conditions in your function. All it “sees” is the tree you return.

In both cases, the `App` component returns a `<div>` with `<Counter />` as a first child. To React, these two counters have the same “address”: the first child of the first child of the root. This is how React matches them up between the previous and next renders, regardless of how you structure your logic.

## Different components at the same position reset state

In this example, ticking the checkbox will replace `<Counter>` with a `<p>`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function App() {
  const [isPaused, setIsPaused] = useState(false);
  return (
    <div>
      {isPaused ? (
        <p>See you later!</p> 
      ) : (
        <Counter /> 
      )}
      <label>
        <input
          type="checkbox"
          checked={isPaused}
          onChange={e => {
            setIsPaused(e.target.checked)
          }}
        />
        Take a break
      </label>
    </div>
  );
}

function Counter() {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

Here, you switch between *different* component types at the same position. Initially, the first child of the `<div>` contained a `Counter`. But when you swapped in a `p`, React removed the `Counter` from the UI tree and destroyed its state.

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child component has now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'p', highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_pt1.dark.png&w=1920&q=75)

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child component has now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'p', highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_pt1.png&w=1920&q=75)

When `Counter` changes to `p`, the `Counter` is deleted and the `p` is added

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'p'. The middle section has the same 'div' parent, but the child component has now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_pt2.dark.png&w=1920&q=75)

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'p'. The middle section has the same 'div' parent, but the child component has now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_pt2.png&w=1920&q=75)

When switching back, the `p` is deleted and the `Counter` is added

Also, **when you render a different component in the same position, it resets the state of its entire subtree.** To see how this works, increment the counter and then tick the checkbox:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function App() {
  const [isFancy, setIsFancy] = useState(false);
  return (
    <div>
      {isFancy ? (
        <div>
          <Counter isFancy={true} /> 
        </div>
      ) : (
        <section>
          <Counter isFancy={false} />
        </section>
      )}
      <label>
        <input
          type="checkbox"
          checked={isFancy}
          onChange={e => {
            setIsFancy(e.target.checked)
          }}
        />
        Use fancy styling
      </label>
    </div>
  );
}

function Counter({ isFancy }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }
  if (isFancy) {
    className += ' fancy';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

The counter state gets reset when you click the checkbox. Although you render a `Counter`, the first child of the `div` changes from a `section` to a `div`. When the child `section` was removed from the DOM, the whole tree below it (including the `Counter` and its state) was destroyed as well.

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'section', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'div', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.dark.png&w=1920&q=75)

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'section', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'div', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.png&w=1920&q=75)

When `section` changes to `div`, the `section` is deleted and the new `div` is added

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'div', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 0. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'section', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt2.dark.png&w=1920&q=75)

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'div', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 0. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'section', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt2.png&w=1920&q=75)

When switching back, the `div` is deleted and the new `section` is added

As a rule of thumb, **if you want to preserve the state between re-renders, the structure of your tree needs to “match up”** from one render to another. If the structure is different, the state gets destroyed because React destroys state when it removes a component from the tree.

### Pitfall

This is why you should not nest component function definitions.

Here, the `MyTextField` component function is defined *inside* `MyComponent`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function MyComponent() {
  const [counter, setCounter] = useState(0);

  function MyTextField() {
    const [text, setText] = useState('');

    return (
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
    );
  }

  return (
    <>
      <MyTextField />
      <button onClick={() => {
        setCounter(counter + 1)
      }}>Clicked {counter} times</button>
    </>
  );
}
```

Show more

Every time you click the button, the input state disappears! This is because a *different* `MyTextField` function is created for every render of `MyComponent`. You’re rendering a *different* component in the same position, so React resets all state below. This leads to bugs and performance problems. To avoid this problem, **always declare component functions at the top level, and don’t nest their definitions.**

## Resetting state at the same position

By default, React preserves state of a component while it stays at the same position. Usually, this is exactly what you want, so it makes sense as the default behavior. But sometimes, you may want to reset a component’s state. Consider this app that lets two players keep track of their scores during each turn:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter person="Taylor" />
      ) : (
        <Counter person="Sarah" />
      )}
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{person}'s score: {score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

Currently, when you change the player, the score is preserved. The two `Counter`s appear in the same position, so React sees them as *the same* `Counter` whose `person` prop has changed.

But conceptually, in this app they should be two separate counters. They might appear in the same place in the UI, but one is a counter for Taylor, and another is a counter for Sarah.

There are two ways to reset state when switching between them:

1. Render components in different positions
2. Give each component an explicit identity with `key`

### Option 1: Rendering a component in different positions

If you want these two `Counter`s to be independent, you can render them in two different positions:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA &&
        <Counter person="Taylor" />
      }
      {!isPlayerA &&
        <Counter person="Sarah" />
      }
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{person}'s score: {score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

* Initially, `isPlayerA` is `true`. So the first position contains `Counter` state, and the second one is empty.
* When you click the “Next player” button the first position clears but the second one now contains a `Counter`.

![Diagram with a tree of React components. The parent is labeled 'Scoreboard' with a state bubble labeled isPlayerA with value 'true'. The only child, arranged to the left, is labeled Counter with a state bubble labeled 'count' and value 0. All of the left child is highlighted in yellow, indicating it was added.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_position_p1.dark.png&w=1080&q=75)

![Diagram with a tree of React components. The parent is labeled 'Scoreboard' with a state bubble labeled isPlayerA with value 'true'. The only child, arranged to the left, is labeled Counter with a state bubble labeled 'count' and value 0. All of the left child is highlighted in yellow, indicating it was added.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_position_p1.png&w=1080&q=75)

Initial state

![Diagram with a tree of React components. The parent is labeled 'Scoreboard' with a state bubble labeled isPlayerA with value 'false'. The state bubble is highlighted in yellow, indicating that it has changed. The left child is replaced with a yellow 'poof' image indicating that it has been deleted and there is a new child on the right, highlighted in yellow indicating that it was added. The new child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_position_p2.dark.png&w=1080&q=75)

![Diagram with a tree of React components. The parent is labeled 'Scoreboard' with a state bubble labeled isPlayerA with value 'false'. The state bubble is highlighted in yellow, indicating that it has changed. The left child is replaced with a yellow 'poof' image indicating that it has been deleted and there is a new child on the right, highlighted in yellow indicating that it was added. The new child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_position_p2.png&w=1080&q=75)

Clicking “next”

![Diagram with a tree of React components. The parent is labeled 'Scoreboard' with a state bubble labeled isPlayerA with value 'true'. The state bubble is highlighted in yellow, indicating that it has changed. There is a new child on the left, highlighted in yellow indicating that it was added. The new child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is replaced with a yellow 'poof' image indicating that it has been deleted.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_position_p3.dark.png&w=1080&q=75)

![Diagram with a tree of React components. The parent is labeled 'Scoreboard' with a state bubble labeled isPlayerA with value 'true'. The state bubble is highlighted in yellow, indicating that it has changed. There is a new child on the left, highlighted in yellow indicating that it was added. The new child is labeled 'Counter' and contains a state bubble labeled 'count' with value 0. The right child is replaced with a yellow 'poof' image indicating that it has been deleted.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_position_p3.png&w=1080&q=75)

Clicking “next” again

Each `Counter`’s state gets destroyed each time it’s removed from the DOM. This is why they reset every time you click the button.

This solution is convenient when you only have a few independent components rendered in the same place. In this example, you only have two, so it’s not a hassle to render both separately in the JSX.

### Option 2: Resetting state with a key

There is also another, more generic, way to reset a component’s state.

You might have seen `key`s when [rendering lists.](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) Keys aren’t just for lists! You can use keys to make React distinguish between any components. By default, React uses order within the parent (“first counter”, “second counter”) to discern between components. But keys let you tell React that this is not just a *first* counter, or a *second* counter, but a specific counter—for example, *Taylor’s* counter. This way, React will know *Taylor’s* counter wherever it appears in the tree!

In this example, the two `<Counter />`s don’t share state even though they appear in the same place in JSX:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Scoreboard() {
  const [isPlayerA, setIsPlayerA] = useState(true);
  return (
    <div>
      {isPlayerA ? (
        <Counter key="Taylor" person="Taylor" />
      ) : (
        <Counter key="Sarah" person="Sarah" />
      )}
      <button onClick={() => {
        setIsPlayerA(!isPlayerA);
      }}>
        Next player!
      </button>
    </div>
  );
}

function Counter({ person }) {
  const [score, setScore] = useState(0);
  const [hover, setHover] = useState(false);

  let className = 'counter';
  if (hover) {
    className += ' hover';
  }

  return (
    <div
      className={className}
      onPointerEnter={() => setHover(true)}
      onPointerLeave={() => setHover(false)}
    >
      <h1>{person}'s score: {score}</h1>
      <button onClick={() => setScore(score + 1)}>
        Add one
      </button>
    </div>
  );
}
```

Show more

Switching between Taylor and Sarah does not preserve the state. This is because **you gave them different `key`s:**

```
{isPlayerA ? (

<Counter key="Taylor" person="Taylor" />

) : (

<Counter key="Sarah" person="Sarah" />

)}
```

Specifying a `key` tells React to use the `key` itself as part of the position, instead of their order within the parent. This is why, even though you render them in the same place in JSX, React sees them as two different counters, and so they will never share state. Every time a counter appears on the screen, its state is created. Every time it is removed, its state is destroyed. Toggling between them resets their state over and over.

### Note

Remember that keys are not globally unique. They only specify the position *within the parent*.

### Resetting a form with a key

Resetting state with a key is particularly useful when dealing with forms.

In this chat app, the `<Chat>` component contains the text input state:

App.jsContactList.jsChat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat contact={to} />
    </div>
  )
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];
```

Show more

Try entering something into the input, and then press “Alice” or “Bob” to choose a different recipient. You will notice that the input state is preserved because the `<Chat>` is rendered at the same position in the tree.

**In many apps, this may be the desired behavior, but not in a chat app!** You don’t want to let the user send a message they already typed to a wrong person due to an accidental click. To fix it, add a `key`:

```
<Chat key={to.id} contact={to} />
```

This ensures that when you select a different recipient, the `Chat` component will be recreated from scratch, including any state in the tree below it. React will also re-create the DOM elements instead of reusing them.

Now switching the recipient always clears the text field:

App.jsContactList.jsChat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';

export default function Messenger() {
  const [to, setTo] = useState(contacts[0]);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedContact={to}
        onSelect={contact => setTo(contact)}
      />
      <Chat key={to.id} contact={to} />
    </div>
  )
}

const contacts = [
  { id: 0, name: 'Taylor', email: 'taylor@mail.com' },
  { id: 1, name: 'Alice', email: 'alice@mail.com' },
  { id: 2, name: 'Bob', email: 'bob@mail.com' }
];
```

Show more

##### Deep Dive

#### Preserving state for removed components

Show Details

In a real chat app, you’d probably want to recover the input state when the user selects the previous recipient again. There are a few ways to keep the state “alive” for a component that’s no longer visible:

* You could render *all* chats instead of just the current one, but hide all the others with CSS. The chats would not get removed from the tree, so their local state would be preserved. This solution works great for simple UIs. But it can get very slow if the hidden trees are large and contain a lot of DOM nodes.
* You could [lift the state up](https://react.dev/learn/sharing-state-between-components) and hold the pending message for each recipient in the parent component. This way, when the child components get removed, it doesn’t matter, because it’s the parent that keeps the important information. This is the most common solution.
* You might also use a different source in addition to React state. For example, you probably want a message draft to persist even if the user accidentally closes the page. To implement this, you could have the `Chat` component initialize its state by reading from the [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage), and save the drafts there too.

No matter which strategy you pick, a chat *with Alice* is conceptually distinct from a chat *with Bob*, so it makes sense to give a `key` to the `<Chat>` tree based on the current recipient.

## Recap

* React keeps state for as long as the same component is rendered at the same position.
* State is not kept in JSX tags. It’s associated with the tree position in which you put that JSX.
* You can force a subtree to reset its state by giving it a different key.
* Don’t nest component definitions, or you’ll reset state by accident.

## Try out some challenges

1. Fix disappearing input text 2. Swap two form fields 3. Reset a detail form 4. Clear an image while it’s loading 5. Fix misplaced state in the list

#### Challenge 1 of 5: Fix disappearing input text

This example shows a message when you press the button. However, pressing the button also accidentally resets the input. Why does this happen? Fix it so that pressing the button does not reset the input text.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function App() {
  const [showHint, setShowHint] = useState(false);
  if (showHint) {
    return (
      <div>
        <p><i>Hint: Your favorite city?</i></p>
        <Form />
        <button onClick={() => {
          setShowHint(false);
        }}>Hide hint</button>
      </div>
    );
  }
  return (
    <div>
      <Form />
      <button onClick={() => {
        setShowHint(true);
      }}>Show hint</button>
    </div>
  );
}

function Form() {
  const [text, setText] = useState('');
  return (
    <textarea
      value={text}
      onChange={e => setText(e.target.value)}
    />
  );
}
```

Show more

Show solutionNext Challenge

[PreviousSharing State Between Components](https://react.dev/learn/sharing-state-between-components)[NextExtracting State Logic into a Reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer)

---

---


# Extracting State Logic into a Reducer – React

URL: https://react.dev/learn/extracting-state-logic-into-a-reducer

[Learn React](https://react.dev/learn)

[Managing State](https://react.dev/learn/managing-state)

# Extracting State Logic into a Reducer

Components with many state updates spread across many event handlers can get overwhelming. For these cases, you can consolidate all the state update logic outside your component in a single function, called a *reducer.*

### You will learn

* What a reducer function is
* How to refactor `useState` to `useReducer`
* When to use a reducer
* How to write one well

## Consolidate state logic with a reducer

As your components grow in complexity, it can get harder to see at a glance all the different ways in which a component’s state gets updated. For example, the `TaskApp` component below holds an array of `tasks` in state and uses three different event handlers to add, remove, and edit tasks:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, setTasks] = useState(initialTasks);

  function handleAddTask(text) {
    setTasks([
      ...tasks,
      {
        id: nextId++,
        text: text,
        done: false,
      },
    ]);
  }

  function handleChangeTask(task) {
    setTasks(
      tasks.map((t) => {
        if (t.id === task.id) {
          return task;
        } else {
          return t;
        }
      })
    );
  }

  function handleDeleteTask(taskId) {
    setTasks(tasks.filter((t) => t.id !== taskId));
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

let nextId = 3;
const initialTasks = [
  {id: 0, text: 'Visit Kafka Museum', done: true},
  {id: 1, text: 'Watch a puppet show', done: false},
  {id: 2, text: 'Lennon Wall pic', done: false},
];
```

Show more

Each of its event handlers calls `setTasks` in order to update the state. As this component grows, so does the amount of state logic sprinkled throughout it. To reduce this complexity and keep all your logic in one easy-to-access place, you can move that state logic into a single function outside your component, **called a “reducer”.**

Reducers are a different way to handle state. You can migrate from `useState` to `useReducer` in three steps:

1. **Move** from setting state to dispatching actions.
2. **Write** a reducer function.
3. **Use** the reducer from your component.

### Step 1: Move from setting state to dispatching actions

Your event handlers currently specify *what to do* by setting state:

```
function handleAddTask(text) {

setTasks([

...tasks,

{

id: nextId++,

text: text,

done: false,

},

]);

}

function handleChangeTask(task) {

setTasks(

tasks.map((t) => {

if (t.id === task.id) {

return task;

} else {

return t;

}

})

);

}

function handleDeleteTask(taskId) {

setTasks(tasks.filter((t) => t.id !== taskId));

}
```

Remove all the state setting logic. What you are left with are three event handlers:

* `handleAddTask(text)` is called when the user presses “Add”.
* `handleChangeTask(task)` is called when the user toggles a task or presses “Save”.
* `handleDeleteTask(taskId)` is called when the user presses “Delete”.

Managing state with reducers is slightly different from directly setting state. Instead of telling React “what to do” by setting state, you specify “what the user just did” by dispatching “actions” from your event handlers. (The state update logic will live elsewhere!) So instead of “setting `tasks`” via an event handler, you’re dispatching an “added/changed/deleted a task” action. This is more descriptive of the user’s intent.

```
function handleAddTask(text) {

dispatch({

type: 'added',

id: nextId++,

text: text,

});

}

function handleChangeTask(task) {

dispatch({

type: 'changed',

task: task,

});

}

function handleDeleteTask(taskId) {

dispatch({

type: 'deleted',

id: taskId,

});

}
```

The object you pass to `dispatch` is called an “action”:

```
function handleDeleteTask(taskId) {

dispatch(

// "action" object:

{

type: 'deleted',

id: taskId,

}

);

}
```

It is a regular JavaScript object. You decide what to put in it, but generally it should contain the minimal information about *what happened*. (You will add the `dispatch` function itself in a later step.)

### Note

An action object can have any shape.

By convention, it is common to give it a string `type` that describes what happened, and pass any additional information in other fields. The `type` is specific to a component, so in this example either `'added'` or `'added_task'` would be fine. Choose a name that says what happened!

```
dispatch({

// specific to component

type: 'what_happened',

// other fields go here

});
```

### Step 2: Write a reducer function

A reducer function is where you will put your state logic. It takes two arguments, the current state and the action object, and it returns the next state:

```
function yourReducer(state, action) {

// return next state for React to set

}
```

React will set the state to what you return from the reducer.

To move your state setting logic from your event handlers to a reducer function in this example, you will:

1. Declare the current state (`tasks`) as the first argument.
2. Declare the `action` object as the second argument.
3. Return the *next* state from the reducer (which React will set the state to).

Here is all the state setting logic migrated to a reducer function:

```
function tasksReducer(tasks, action) {

if (action.type === 'added') {

return [

...tasks,

{

id: action.id,

text: action.text,

done: false,

},

];

} else if (action.type === 'changed') {

return tasks.map((t) => {

if (t.id === action.task.id) {

return action.task;

} else {

return t;

}

});

} else if (action.type === 'deleted') {

return tasks.filter((t) => t.id !== action.id);

} else {

throw Error('Unknown action: ' + action.type);

}

}
```

Because the reducer function takes state (`tasks`) as an argument, you can **declare it outside of your component.** This decreases the indentation level and can make your code easier to read.

### Note

The code above uses if/else statements, but it’s a convention to use [switch statements](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/switch) inside reducers. The result is the same, but it can be easier to read switch statements at a glance.

We’ll be using them throughout the rest of this documentation like so:

```
function tasksReducer(tasks, action) {

switch (action.type) {

case 'added': {

return [

...tasks,

{

id: action.id,

text: action.text,

done: false,

},

];

}

case 'changed': {

return tasks.map((t) => {

if (t.id === action.task.id) {

return action.task;

} else {

return t;

}

});

}

case 'deleted': {

return tasks.filter((t) => t.id !== action.id);

}

default: {

throw Error('Unknown action: ' + action.type);

}

}

}
```

We recommend wrapping each `case` block into the `{` and `}` curly braces so that variables declared inside of different `case`s don’t clash with each other. Also, a `case` should usually end with a `return`. If you forget to `return`, the code will “fall through” to the next `case`, which can lead to mistakes!

If you’re not yet comfortable with switch statements, using if/else is completely fine.

##### Deep Dive

#### Why are reducers called this way?

Show Details

Although reducers can “reduce” the amount of code inside your component, they are actually named after the [`reduce()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) operation that you can perform on arrays.

The `reduce()` operation lets you take an array and “accumulate” a single value out of many:

```
const arr = [1, 2, 3, 4, 5];

const sum = arr.reduce(

(result, number) => result + number

); // 1 + 2 + 3 + 4 + 5
```

The function you pass to `reduce` is known as a “reducer”. It takes the *result so far* and the *current item,* then it returns the *next result.* React reducers are an example of the same idea: they take the *state so far* and the *action*, and return the *next state.* In this way, they accumulate actions over time into state.

You could even use the `reduce()` method with an `initialState` and an array of `actions` to calculate the final state by passing your reducer function to it:

index.jsindex.htmltasksReducer.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import tasksReducer from './tasksReducer.js';

let initialState = [];
let actions = [
  {type: 'added', id: 1, text: 'Visit Kafka Museum'},
  {type: 'added', id: 2, text: 'Watch a puppet show'},
  {type: 'deleted', id: 1},
  {type: 'added', id: 3, text: 'Lennon Wall pic'},
];

let finalState = actions.reduce(tasksReducer, initialState);

const output = document.getElementById('output');
output.textContent = JSON.stringify(finalState, null, 2);
```

You probably won’t need to do this yourself, but this is similar to what React does!

### Step 3: Use the reducer from your component

Finally, you need to hook up the `tasksReducer` to your component. Import the `useReducer` Hook from React:

```
import { useReducer } from 'react';
```

Then you can replace `useState`:

```
const [tasks, setTasks] = useState(initialTasks);
```

with `useReducer` like so:

```
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

The `useReducer` Hook is similar to `useState`—you must pass it an initial state and it returns a stateful value and a way to set state (in this case, the dispatch function). But it’s a little different.

The `useReducer` Hook takes two arguments:

1. A reducer function
2. An initial state

And it returns:

1. A stateful value
2. A dispatch function (to “dispatch” user actions to the reducer)

Now it’s fully wired up! Here, the reducer is declared at the bottom of the component file:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId,
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  {id: 0, text: 'Visit Kafka Museum', done: true},
  {id: 1, text: 'Watch a puppet show', done: false},
  {id: 2, text: 'Lennon Wall pic', done: false},
];
```

Show more

If you want, you can even move the reducer to a different file:

App.jstasksReducer.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import tasksReducer from './tasksReducer.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task,
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId,
    });
  }

  return (
    <>
      <h1>Prague itinerary</h1>
      <AddTask onAddTask={handleAddTask} />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

let nextId = 3;
const initialTasks = [
  {id: 0, text: 'Visit Kafka Museum', done: true},
  {id: 1, text: 'Watch a puppet show', done: false},
  {id: 2, text: 'Lennon Wall pic', done: false},
];
```

Show more

Component logic can be easier to read when you separate concerns like this. Now the event handlers only specify *what happened* by dispatching actions, and the reducer function determines *how the state updates* in response to them.

## Comparing `useState` and `useReducer`

Reducers are not without downsides! Here’s a few ways you can compare them:

* **Code size:** Generally, with `useState` you have to write less code upfront. With `useReducer`, you have to write both a reducer function *and* dispatch actions. However, `useReducer` can help cut down on the code if many event handlers modify state in a similar way.
* **Readability:** `useState` is very easy to read when the state updates are simple. When they get more complex, they can bloat your component’s code and make it difficult to scan. In this case, `useReducer` lets you cleanly separate the *how* of update logic from the *what happened* of event handlers.
* **Debugging:** When you have a bug with `useState`, it can be difficult to tell *where* the state was set incorrectly, and *why*. With `useReducer`, you can add a console log into your reducer to see every state update, and *why* it happened (due to which `action`). If each `action` is correct, you’ll know that the mistake is in the reducer logic itself. However, you have to step through more code than with `useState`.
* **Testing:** A reducer is a pure function that doesn’t depend on your component. This means that you can export and test it separately in isolation. While generally it’s best to test components in a more realistic environment, for complex state update logic it can be useful to assert that your reducer returns a particular state for a particular initial state and action.
* **Personal preference:** Some people like reducers, others don’t. That’s okay. It’s a matter of preference. You can always convert between `useState` and `useReducer` back and forth: they are equivalent!

We recommend using a reducer if you often encounter bugs due to incorrect state updates in some component, and want to introduce more structure to its code. You don’t have to use reducers for everything: feel free to mix and match! You can even `useState` and `useReducer` in the same component.

## Writing reducers well

Keep these two tips in mind when writing reducers:

* **Reducers must be pure.** Similar to [state updater functions](https://react.dev/learn/queueing-a-series-of-state-updates), reducers run during rendering! (Actions are queued until the next render.) This means that reducers [must be pure](https://react.dev/learn/keeping-components-pure)—same inputs always result in the same output. They should not send requests, schedule timeouts, or perform any side effects (operations that impact things outside the component). They should update [objects](https://react.dev/learn/updating-objects-in-state) and [arrays](https://react.dev/learn/updating-arrays-in-state) without mutations.
* **Each action describes a single user interaction, even if that leads to multiple changes in the data.** For example, if a user presses “Reset” on a form with five fields managed by a reducer, it makes more sense to dispatch one `reset_form` action rather than five separate `set_field` actions. If you log every action in a reducer, that log should be clear enough for you to reconstruct what interactions or responses happened in what order. This helps with debugging!

## Writing concise reducers with Immer

Just like with [updating objects](https://react.dev/learn/updating-objects-in-state#write-concise-update-logic-with-immer) and [arrays](https://react.dev/learn/updating-arrays-in-state#write-concise-update-logic-with-immer) in regular state, you can use the Immer library to make reducers more concise. Here, [`useImmerReducer`](https://github.com/immerjs/use-immer#useimmerreducer) lets you mutate the state with `push` or `arr[i] =` assignment:

package.jsonApp.js

package.json

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
{
  "dependencies": {
    "immer": "1.7.3",
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "use-immer": "0.5.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

Reducers must be pure, so they shouldn’t mutate state. But Immer provides you with a special `draft` object which is safe to mutate. Under the hood, Immer will create a copy of your state with the changes you made to the `draft`. This is why reducers managed by `useImmerReducer` can mutate their first argument and don’t need to return state.

## Recap

* To convert from `useState` to `useReducer`:
  1. Dispatch actions from event handlers.
  2. Write a reducer function that returns the next state for a given state and action.
  3. Replace `useState` with `useReducer`.
* Reducers require you to write a bit more code, but they help with debugging and testing.
* Reducers must be pure.
* Each action describes a single user interaction.
* Use Immer if you want to write reducers in a mutating style.

## Try out some challenges

1. Dispatch actions from event handlers 2. Clear the input on sending a message 3. Restore input values when switching between tabs 4. Implement `useReducer` from scratch

#### Challenge 1 of 4: Dispatch actions from event handlers

Currently, the event handlers in `ContactList.js` and `Chat.js` have `// TODO` comments. This is why typing into the input doesn’t work, and clicking on the buttons doesn’t change the selected recipient.

Replace these two `// TODO`s with the code to `dispatch` the corresponding actions. To see the expected shape and the type of the actions, check the reducer in `messengerReducer.js`. The reducer is already written so you won’t need to change it. You only need to dispatch the actions in `ContactList.js` and `Chat.js`.

App.jsmessengerReducer.jsContactList.jsChat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useReducer } from 'react';
import Chat from './Chat.js';
import ContactList from './ContactList.js';
import { initialState, messengerReducer } from './messengerReducer';

export default function Messenger() {
  const [state, dispatch] = useReducer(messengerReducer, initialState);
  const message = state.message;
  const contact = contacts.find((c) => c.id === state.selectedId);
  return (
    <div>
      <ContactList
        contacts={contacts}
        selectedId={state.selectedId}
        dispatch={dispatch}
      />
      <Chat
        key={contact.id}
        message={message}
        contact={contact}
        dispatch={dispatch}
      />
    </div>
  );
}

const contacts = [
  {id: 0, name: 'Taylor', email: 'taylor@mail.com'},
  {id: 1, name: 'Alice', email: 'alice@mail.com'},
  {id: 2, name: 'Bob', email: 'bob@mail.com'},
];
```

Show more

Show hint Show solution

Next Challenge

[PreviousPreserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state)[NextPassing Data Deeply with Context](https://react.dev/learn/passing-data-deeply-with-context)

---

---


# Passing Data Deeply with Context – React

URL: https://react.dev/learn/passing-data-deeply-with-context

[Learn React](https://react.dev/learn)

[Managing State](https://react.dev/learn/managing-state)

# Passing Data Deeply with Context

Usually, you will pass information from a parent component to a child component via props. But passing props can become verbose and inconvenient if you have to pass them through many components in the middle, or if many components in your app need the same information. *Context* lets the parent component make some information available to any component in the tree below it—no matter how deep—without passing it explicitly through props.

### You will learn

* What “prop drilling” is
* How to replace repetitive prop passing with context
* Common use cases for context
* Common alternatives to context

## The problem with passing props

[Passing props](https://react.dev/learn/passing-props-to-a-component) is a great way to explicitly pipe data through your UI tree to the components that use it.

But passing props can become verbose and inconvenient when you need to pass some prop deeply through the tree, or if many components need the same prop. The nearest common ancestor could be far removed from the components that need data, and [lifting state up](https://react.dev/learn/sharing-state-between-components) that high can lead to a situation called “prop drilling”.

Lifting state up

![Diagram with a tree of three components. The parent contains a bubble representing a value highlighted in purple. The value flows down to each of the two children, both highlighted in purple.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_lifting_state.dark.png&w=1920&q=75)

![Diagram with a tree of three components. The parent contains a bubble representing a value highlighted in purple. The value flows down to each of the two children, both highlighted in purple.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_lifting_state.png&w=1920&q=75)

Prop drilling

![Diagram with a tree of ten nodes, each node with two children or less. The root node contains a bubble representing a value highlighted in purple. The value flows down through the two children, each of which pass the value but do not contain it. The left child passes the value down to two children which are both highlighted purple. The right child of the root passes the value through to one of its two children - the right one, which is highlighted purple. That child passed the value through its single child, which passes it down to both of its two children, which are highlighted purple.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_prop_drilling.dark.png&w=1920&q=75)

![Diagram with a tree of ten nodes, each node with two children or less. The root node contains a bubble representing a value highlighted in purple. The value flows down through the two children, each of which pass the value but do not contain it. The left child passes the value down to two children which are both highlighted purple. The right child of the root passes the value through to one of its two children - the right one, which is highlighted purple. That child passed the value through its single child, which passes it down to both of its two children, which are highlighted purple.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_prop_drilling.png&w=1920&q=75)

Wouldn’t it be great if there were a way to “teleport” data to the components in the tree that need it without passing props? With React’s context feature, there is!

## Context: an alternative to passing props

Context lets a parent component provide data to the entire tree below it. There are many uses for context. Here is one example. Consider this `Heading` component that accepts a `level` for its size:

App.jsSection.jsHeading.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section>
      <Heading level={1}>Title</Heading>
      <Heading level={2}>Heading</Heading>
      <Heading level={3}>Sub-heading</Heading>
      <Heading level={4}>Sub-sub-heading</Heading>
      <Heading level={5}>Sub-sub-sub-heading</Heading>
      <Heading level={6}>Sub-sub-sub-sub-heading</Heading>
    </Section>
  );
}
```

Let’s say you want multiple headings within the same `Section` to always have the same size:

App.jsSection.jsHeading.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section>
      <Heading level={1}>Title</Heading>
      <Section>
        <Heading level={2}>Heading</Heading>
        <Heading level={2}>Heading</Heading>
        <Heading level={2}>Heading</Heading>
        <Section>
          <Heading level={3}>Sub-heading</Heading>
          <Heading level={3}>Sub-heading</Heading>
          <Heading level={3}>Sub-heading</Heading>
          <Section>
            <Heading level={4}>Sub-sub-heading</Heading>
            <Heading level={4}>Sub-sub-heading</Heading>
            <Heading level={4}>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

Show more

Currently, you pass the `level` prop to each `<Heading>` separately:

```
<Section>

<Heading level={3}>About</Heading>

<Heading level={3}>Photos</Heading>

<Heading level={3}>Videos</Heading>

</Section>
```

It would be nice if you could pass the `level` prop to the `<Section>` component instead and remove it from the `<Heading>`. This way you could enforce that all headings in the same section have the same size:

```
<Section level={3}>

<Heading>About</Heading>

<Heading>Photos</Heading>

<Heading>Videos</Heading>

</Section>
```

But how can the `<Heading>` component know the level of its closest `<Section>`? **That would require some way for a child to “ask” for data from somewhere above in the tree.**

You can’t do it with props alone. This is where context comes into play. You will do it in three steps:

1. **Create** a context. (You can call it `LevelContext`, since it’s for the heading level.)
2. **Use** that context from the component that needs the data. (`Heading` will use `LevelContext`.)
3. **Provide** that context from the component that specifies the data. (`Section` will provide `LevelContext`.)

Context lets a parent—even a distant one!—provide some data to the entire tree inside of it.

Using context in close children

![Diagram with a tree of three components. The parent contains a bubble representing a value highlighted in orange which projects down to the two children, each highlighted in orange.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_context_close.dark.png&w=1920&q=75)

![Diagram with a tree of three components. The parent contains a bubble representing a value highlighted in orange which projects down to the two children, each highlighted in orange.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_context_close.png&w=1920&q=75)

Using context in distant children

![Diagram with a tree of ten nodes, each node with two children or less. The root parent node contains a bubble representing a value highlighted in orange. The value projects down directly to four leaves and one intermediate component in the tree, which are all highlighted in orange. None of the other intermediate components are highlighted.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_context_far.dark.png&w=1920&q=75)

![Diagram with a tree of ten nodes, each node with two children or less. The root parent node contains a bubble representing a value highlighted in orange. The value projects down directly to four leaves and one intermediate component in the tree, which are all highlighted in orange. None of the other intermediate components are highlighted.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_context_far.png&w=1920&q=75)

### Step 1: Create the context

First, you need to create the context. You’ll need to **export it from a file** so that your components can use it:

App.jsSection.jsHeading.jsLevelContext.js

LevelContext.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext } from 'react';

export const LevelContext = createContext(1);
```

The only argument to `createContext` is the *default* value. Here, `1` refers to the biggest heading level, but you could pass any kind of value (even an object). You will see the significance of the default value in the next step.

### Step 2: Use the context

Import the `useContext` Hook from React and your context:

```
import { useContext } from 'react';

import { LevelContext } from './LevelContext.js';
```

Currently, the `Heading` component reads `level` from props:

```
export default function Heading({ level, children }) {

// ...

}
```

Instead, remove the `level` prop and read the value from the context you just imported, `LevelContext`:

```
export default function Heading({ children }) {

const level = useContext(LevelContext);

// ...

}
```

`useContext` is a Hook. Just like `useState` and `useReducer`, you can only call a Hook immediately inside a React component (not inside loops or conditions). **`useContext` tells React that the `Heading` component wants to read the `LevelContext`.**

Now that the `Heading` component doesn’t have a `level` prop, you don’t need to pass the level prop to `Heading` in your JSX like this anymore:

```
<Section>

<Heading level={4}>Sub-sub-heading</Heading>

<Heading level={4}>Sub-sub-heading</Heading>

<Heading level={4}>Sub-sub-heading</Heading>

</Section>
```

Update the JSX so that it’s the `Section` that receives it instead:

```
<Section level={4}>

<Heading>Sub-sub-heading</Heading>

<Heading>Sub-sub-heading</Heading>

<Heading>Sub-sub-heading</Heading>

</Section>
```

As a reminder, this is the markup that you were trying to get working:

App.jsSection.jsHeading.jsLevelContext.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section level={1}>
      <Heading>Title</Heading>
      <Section level={2}>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section level={3}>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section level={4}>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

Show more

Notice this example doesn’t quite work, yet! All the headings have the same size because **even though you’re *using* the context, you have not *provided* it yet.** React doesn’t know where to get it!

If you don’t provide the context, React will use the default value you’ve specified in the previous step. In this example, you specified `1` as the argument to `createContext`, so `useContext(LevelContext)` returns `1`, setting all those headings to `<h1>`. Let’s fix this problem by having each `Section` provide its own context.

### Step 3: Provide the context

The `Section` component currently renders its children:

```
export default function Section({ children }) {

return (

<section className="section">

{children}

</section>

);

}
```

**Wrap them with a context provider** to provide the `LevelContext` to them:

```
import { LevelContext } from './LevelContext.js';

export default function Section({ level, children }) {

return (

<section className="section">

<LevelContext value={level}>

{children}

</LevelContext>

</section>

);

}
```

This tells React: “if any component inside this `<Section>` asks for `LevelContext`, give them this `level`.” The component will use the value of the nearest `<LevelContext>` in the UI tree above it.

App.jsSection.jsHeading.jsLevelContext.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section level={1}>
      <Heading>Title</Heading>
      <Section level={2}>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section level={3}>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section level={4}>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

Show more

It’s the same result as the original code, but you did not need to pass the `level` prop to each `Heading` component! Instead, it “figures out” its heading level by asking the closest `Section` above:

1. You pass a `level` prop to the `<Section>`.
2. `Section` wraps its children into `<LevelContext value={level}>`.
3. `Heading` asks the closest value of `LevelContext` above with `useContext(LevelContext)`.

## Using and providing context from the same component

Currently, you still have to specify each section’s `level` manually:

```
export default function Page() {

return (

<Section level={1}>

...

<Section level={2}>

...

<Section level={3}>

...
```

Since context lets you read information from a component above, each `Section` could read the `level` from the `Section` above, and pass `level + 1` down automatically. Here is how you could do it:

```
import { useContext } from 'react';

import { LevelContext } from './LevelContext.js';

export default function Section({ children }) {

const level = useContext(LevelContext);

return (

<section className="section">

<LevelContext value={level + 1}>

{children}

</LevelContext>

</section>

);

}
```

With this change, you don’t need to pass the `level` prop *either* to the `<Section>` or to the `<Heading>`:

App.jsSection.jsHeading.jsLevelContext.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Heading from './Heading.js';
import Section from './Section.js';

export default function Page() {
  return (
    <Section>
      <Heading>Title</Heading>
      <Section>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Heading>Heading</Heading>
        <Section>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Heading>Sub-heading</Heading>
          <Section>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
            <Heading>Sub-sub-heading</Heading>
          </Section>
        </Section>
      </Section>
    </Section>
  );
}
```

Show more

Now both `Heading` and `Section` read the `LevelContext` to figure out how “deep” they are. And the `Section` wraps its children into the `LevelContext` to specify that anything inside of it is at a “deeper” level.

### Note

This example uses heading levels because they show visually how nested components can override context. But context is useful for many other use cases too. You can pass down any information needed by the entire subtree: the current color theme, the currently logged in user, and so on.

## Context passes through intermediate components

You can insert as many components as you like between the component that provides context and the one that uses it. This includes both built-in components like `<div>` and components you might build yourself.

In this example, the same `Post` component (with a dashed border) is rendered at two different nesting levels. Notice that the `<Heading>` inside of it gets its level automatically from the closest `<Section>`:

App.jsSection.jsHeading.jsLevelContext.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Heading from './Heading.js';
import Section from './Section.js';

export default function ProfilePage() {
  return (
    <Section>
      <Heading>My Profile</Heading>
      <Post
        title="Hello traveller!"
        body="Read about my adventures."
      />
      <AllPosts />
    </Section>
  );
}

function AllPosts() {
  return (
    <Section>
      <Heading>Posts</Heading>
      <RecentPosts />
    </Section>
  );
}

function RecentPosts() {
  return (
    <Section>
      <Heading>Recent Posts</Heading>
      <Post
        title="Flavors of Lisbon"
        body="...those pastéis de nata!"
      />
      <Post
        title="Buenos Aires in the rhythm of tango"
        body="I loved it!"
      />
    </Section>
  );
}

function Post({ title, body }) {
  return (
    <Section isFancy={true}>
      <Heading>
        {title}
      </Heading>
      <p><i>{body}</i></p>
    </Section>
  );
}
```

Show more

You didn’t do anything special for this to work. A `Section` specifies the context for the tree inside it, so you can insert a `<Heading>` anywhere, and it will have the correct size. Try it in the sandbox above!

**Context lets you write components that “adapt to their surroundings” and display themselves differently depending on *where* (or, in other words, *in which context*) they are being rendered.**

How context works might remind you of [CSS property inheritance.](https://developer.mozilla.org/en-US/docs/Web/CSS/inheritance) In CSS, you can specify `color: blue` for a `<div>`, and any DOM node inside of it, no matter how deep, will inherit that color unless some other DOM node in the middle overrides it with `color: green`. Similarly, in React, the only way to override some context coming from above is to wrap children into a context provider with a different value.

In CSS, different properties like `color` and `background-color` don’t override each other. You can set all `<div>`’s `color` to red without impacting `background-color`. Similarly, **different React contexts don’t override each other.** Each context that you make with `createContext()` is completely separate from other ones, and ties together components using and providing *that particular* context. One component may use or provide many different contexts without a problem.

## Before you use context

Context is very tempting to use! However, this also means it’s too easy to overuse it. **Just because you need to pass some props several levels deep doesn’t mean you should put that information into context.**

Here’s a few alternatives you should consider before using context:

1. **Start by [passing props.](https://react.dev/learn/passing-props-to-a-component)** If your components are not trivial, it’s not unusual to pass a dozen props down through a dozen components. It may feel like a slog, but it makes it very clear which components use which data! The person maintaining your code will be glad you’ve made the data flow explicit with props.
2. **Extract components and [pass JSX as `children`](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) to them.** If you pass some data through many layers of intermediate components that don’t use that data (and only pass it further down), this often means that you forgot to extract some components along the way. For example, maybe you pass data props like `posts` to visual components that don’t use them directly, like `<Layout posts={posts} />`. Instead, make `Layout` take `children` as a prop, and render `<Layout><Posts posts={posts} /></Layout>`. This reduces the number of layers between the component specifying the data and the one that needs it.

If neither of these approaches works well for you, consider context.

## Use cases for context

* **Theming:** If your app lets the user change its appearance (e.g. dark mode), you can put a context provider at the top of your app, and use that context in components that need to adjust their visual look.
* **Current account:** Many components might need to know the currently logged in user. Putting it in context makes it convenient to read it anywhere in the tree. Some apps also let you operate multiple accounts at the same time (e.g. to leave a comment as a different user). In those cases, it can be convenient to wrap a part of the UI into a nested provider with a different current account value.
* **Routing:** Most routing solutions use context internally to hold the current route. This is how every link “knows” whether it’s active or not. If you build your own router, you might want to do it too.
* **Managing state:** As your app grows, you might end up with a lot of state closer to the top of your app. Many distant components below may want to change it. It is common to [use a reducer together with context](https://react.dev/learn/scaling-up-with-reducer-and-context) to manage complex state and pass it down to distant components without too much hassle.

Context is not limited to static values. If you pass a different value on the next render, React will update all the components reading it below! This is why context is often used in combination with state.

In general, if some information is needed by distant components in different parts of the tree, it’s a good indication that context will help you.

## Recap

* Context lets a component provide some information to the entire tree below it.
* To pass context:
  1. Create and export it with `export const MyContext = createContext(defaultValue)`.
  2. Pass it to the `useContext(MyContext)` Hook to read it in any child component, no matter how deep.
  3. Wrap children into `<MyContext value={...}>` to provide it from a parent.
* Context passes through any components in the middle.
* Context lets you write components that “adapt to their surroundings”.
* Before you use context, try passing props or passing JSX as `children`.

## Try out some challenges

#### Challenge 1 of 1: Replace prop drilling with context

In this example, toggling the checkbox changes the `imageSize` prop passed to each `<PlaceImage>`. The checkbox state is held in the top-level `App` component, but each `<PlaceImage>` needs to be aware of it.

Currently, `App` passes `imageSize` to `List`, which passes it to each `Place`, which passes it to the `PlaceImage`. Remove the `imageSize` prop, and instead pass it from the `App` component directly to `PlaceImage`.

You can declare context in `Context.js`.

App.jsContext.jsdata.jsutils.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { places } from './data.js';
import { getImageUrl } from './utils.js';

export default function App() {
  const [isLarge, setIsLarge] = useState(false);
  const imageSize = isLarge ? 150 : 100;
  return (
    <>
      <label>
        <input
          type="checkbox"
          checked={isLarge}
          onChange={e => {
            setIsLarge(e.target.checked);
          }}
        />
        Use large images
      </label>
      <hr />
      <List imageSize={imageSize} />
    </>
  )
}

function List({ imageSize }) {
  const listItems = places.map(place =>
    <li key={place.id}>
      <Place
        place={place}
        imageSize={imageSize}
      />
    </li>
  );
  return <ul>{listItems}</ul>;
}

function Place({ place, imageSize }) {
  return (
    <>
      <PlaceImage
        place={place}
        imageSize={imageSize}
      />
      <p>
        <b>{place.name}</b>
        {': ' + place.description}
      </p>
    </>
  );
}

function PlaceImage({ place, imageSize }) {
  return (
    <img
      src={getImageUrl(place)}
      alt={place.name}
      width={imageSize}
      height={imageSize}
    />
  );
}
```

Show more

Show solution

[PreviousExtracting State Logic into a Reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer)[NextScaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context)

---

---


# Scaling Up with Reducer and Context – React

URL: https://react.dev/learn/scaling-up-with-reducer-and-context

[Learn React](https://react.dev/learn)

[Managing State](https://react.dev/learn/managing-state)

# Scaling Up with Reducer and Context

Reducers let you consolidate a component’s state update logic. Context lets you pass information deep down to other components. You can combine reducers and context together to manage state of a complex screen.

### You will learn

* How to combine a reducer with context
* How to avoid passing state and dispatch through props
* How to keep context and state logic in a separate file

## Combining a reducer with context

In this example from [the introduction to reducers](https://react.dev/learn/extracting-state-logic-into-a-reducer), the state is managed by a reducer. The reducer function contains all of the state update logic and is declared at the bottom of this file:

App.jsAddTask.jsTaskList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId
    });
  }

  return (
    <>
      <h1>Day off in Kyoto</h1>
      <AddTask
        onAddTask={handleAddTask}
      />
      <TaskList
        tasks={tasks}
        onChangeTask={handleChangeTask}
        onDeleteTask={handleDeleteTask}
      />
    </>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [...tasks, {
        id: action.id,
        text: action.text,
        done: false
      }];
    }
    case 'changed': {
      return tasks.map(t => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter(t => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Philosopher’s Path', done: true },
  { id: 1, text: 'Visit the temple', done: false },
  { id: 2, text: 'Drink matcha', done: false }
];
```

Show more

A reducer helps keep the event handlers short and concise. However, as your app grows, you might run into another difficulty. **Currently, the `tasks` state and the `dispatch` function are only available in the top-level `TaskApp` component.** To let other components read the list of tasks or change it, you have to explicitly [pass down](https://react.dev/learn/passing-props-to-a-component) the current state and the event handlers that change it as props.

For example, `TaskApp` passes a list of tasks and the event handlers to `TaskList`:

```
<TaskList

tasks={tasks}

onChangeTask={handleChangeTask}

onDeleteTask={handleDeleteTask}

/>
```

And `TaskList` passes the event handlers to `Task`:

```
<Task

task={task}

onChange={onChangeTask}

onDelete={onDeleteTask}

/>
```

In a small example like this, this works well, but if you have tens or hundreds of components in the middle, passing down all state and functions can be quite frustrating!

This is why, as an alternative to passing them through props, you might want to put both the `tasks` state and the `dispatch` function [into context.](https://react.dev/learn/passing-data-deeply-with-context) **This way, any component below `TaskApp` in the tree can read the tasks and dispatch actions without the repetitive “prop drilling”.**

Here is how you can combine a reducer with context:

1. **Create** the context.
2. **Put** state and dispatch into context.
3. **Use** context anywhere in the tree.

### Step 1: Create the context

The `useReducer` Hook returns the current `tasks` and the `dispatch` function that lets you update them:

```
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

To pass them down the tree, you will [create](https://react.dev/learn/passing-data-deeply-with-context#step-2-use-the-context) two separate contexts:

* `TasksContext` provides the current list of tasks.
* `TasksDispatchContext` provides the function that lets components dispatch actions.

Export them from a separate file so that you can later import them from other files:

App.jsTasksContext.jsAddTask.jsTaskList.js

TasksContext.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext } from 'react';

export const TasksContext = createContext(null);
export const TasksDispatchContext = createContext(null);
```

Here, you’re passing `null` as the default value to both contexts. The actual values will be provided by the `TaskApp` component.

### Step 2: Put state and dispatch into context

Now you can import both contexts in your `TaskApp` component. Take the `tasks` and `dispatch` returned by `useReducer()` and [provide them](https://react.dev/learn/passing-data-deeply-with-context#step-3-provide-the-context) to the entire tree below:

```
import { TasksContext, TasksDispatchContext } from './TasksContext.js';

export default function TaskApp() {

const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

// ...

return (

<TasksContext value={tasks}>

<TasksDispatchContext value={dispatch}>

...

</TasksDispatchContext>

</TasksContext>

);

}
```

For now, you pass the information both via props and in context:

App.jsTasksContext.jsAddTask.jsTaskList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useReducer } from 'react';
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import { TasksContext, TasksDispatchContext } from './TasksContext.js';

export default function TaskApp() {
  const [tasks, dispatch] = useReducer(
    tasksReducer,
    initialTasks
  );

  function handleAddTask(text) {
    dispatch({
      type: 'added',
      id: nextId++,
      text: text,
    });
  }

  function handleChangeTask(task) {
    dispatch({
      type: 'changed',
      task: task
    });
  }

  function handleDeleteTask(taskId) {
    dispatch({
      type: 'deleted',
      id: taskId
    });
  }

  return (
    <TasksContext value={tasks}>
      <TasksDispatchContext value={dispatch}>
        <h1>Day off in Kyoto</h1>
        <AddTask
          onAddTask={handleAddTask}
        />
        <TaskList
          tasks={tasks}
          onChangeTask={handleChangeTask}
          onDeleteTask={handleDeleteTask}
        />
      </TasksDispatchContext>
    </TasksContext>
  );
}

function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [...tasks, {
        id: action.id,
        text: action.text,
        done: false
      }];
    }
    case 'changed': {
      return tasks.map(t => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter(t => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}

let nextId = 3;
const initialTasks = [
  { id: 0, text: 'Philosopher’s Path', done: true },
  { id: 1, text: 'Visit the temple', done: false },
  { id: 2, text: 'Drink matcha', done: false }
];
```

Show more

In the next step, you will remove prop passing.

### Step 3: Use context anywhere in the tree

Now you don’t need to pass the list of tasks or the event handlers down the tree:

```
<TasksContext value={tasks}>

<TasksDispatchContext value={dispatch}>

<h1>Day off in Kyoto</h1>

<AddTask />

<TaskList />

</TasksDispatchContext>

</TasksContext>
```

Instead, any component that needs the task list can read it from the `TasksContext`:

```
export default function TaskList() {

const tasks = useContext(TasksContext);

// ...
```

To update the task list, any component can read the `dispatch` function from context and call it:

```
export default function AddTask() {

const [text, setText] = useState('');

const dispatch = useContext(TasksDispatchContext);

// ...

return (

// ...

<button onClick={() => {

setText('');

dispatch({

type: 'added',

id: nextId++,

text: text,

});

}}>Add</button>

// ...
```

**The `TaskApp` component does not pass any event handlers down, and the `TaskList` does not pass any event handlers to the `Task` component either.** Each component reads the context that it needs:

App.jsTasksContext.jsAddTask.jsTaskList.js

TaskList.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useContext } from 'react';
import { TasksContext, TasksDispatchContext } from './TasksContext.js';

export default function TaskList() {
  const tasks = useContext(TasksContext);
  return (
    <ul>
      {tasks.map(task => (
        <li key={task.id}>
          <Task task={task} />
        </li>
      ))}
    </ul>
  );
}

function Task({ task }) {
  const [isEditing, setIsEditing] = useState(false);
  const dispatch = useContext(TasksDispatchContext);
  let taskContent;
  if (isEditing) {
    taskContent = (
      <>
        <input
          value={task.text}
          onChange={e => {
            dispatch({
              type: 'changed',
              task: {
                ...task,
                text: e.target.value
              }
            });
          }} />
        <button onClick={() => setIsEditing(false)}>
          Save
        </button>
      </>
    );
  } else {
    taskContent = (
      <>
        {task.text}
        <button onClick={() => setIsEditing(true)}>
          Edit
        </button>
      </>
    );
  }
  return (
    <label>
      <input
        type="checkbox"
        checked={task.done}
        onChange={e => {
          dispatch({
            type: 'changed',
            task: {
              ...task,
              done: e.target.checked
            }
          });
        }}
      />
      {taskContent}
      <button onClick={() => {
        dispatch({
          type: 'deleted',
          id: task.id
        });
      }}>
        Delete
      </button>
    </label>
  );
}
```

Show more

**The state still “lives” in the top-level `TaskApp` component, managed with `useReducer`.** But its `tasks` and `dispatch` are now available to every component below in the tree by importing and using these contexts.

## Moving all wiring into a single file

You don’t have to do this, but you could further declutter the components by moving both reducer and context into a single file. Currently, `TasksContext.js` contains only two context declarations:

```
import { createContext } from 'react';

export const TasksContext = createContext(null);

export const TasksDispatchContext = createContext(null);
```

This file is about to get crowded! You’ll move the reducer into that same file. Then you’ll declare a new `TasksProvider` component in the same file. This component will tie all the pieces together:

1. It will manage the state with a reducer.
2. It will provide both contexts to components below.
3. It will [take `children` as a prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) so you can pass JSX to it.

```
export function TasksProvider({ children }) {

const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);

return (

<TasksContext value={tasks}>

<TasksDispatchContext value={dispatch}>

{children}

</TasksDispatchContext>

</TasksContext>

);

}
```

**This removes all the complexity and wiring from your `TaskApp` component:**

App.jsTasksContext.jsAddTask.jsTaskList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import AddTask from './AddTask.js';
import TaskList from './TaskList.js';
import { TasksProvider } from './TasksContext.js';

export default function TaskApp() {
  return (
    <TasksProvider>
      <h1>Day off in Kyoto</h1>
      <AddTask />
      <TaskList />
    </TasksProvider>
  );
}
```

You can also export functions that *use* the context from `TasksContext.js`:

```
export function useTasks() {

return useContext(TasksContext);

}

export function useTasksDispatch() {

return useContext(TasksDispatchContext);

}
```

When a component needs to read context, it can do it through these functions:

```
const tasks = useTasks();

const dispatch = useTasksDispatch();
```

This doesn’t change the behavior in any way, but it lets you later split these contexts further or add some logic to these functions. **Now all of the context and reducer wiring is in `TasksContext.js`. This keeps the components clean and uncluttered, focused on what they display rather than where they get the data:**

App.jsTasksContext.jsAddTask.jsTaskList.js

TaskList.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { useTasks, useTasksDispatch } from './TasksContext.js';

export default function TaskList() {
  const tasks = useTasks();
  return (
    <ul>
      {tasks.map(task => (
        <li key={task.id}>
          <Task task={task} />
        </li>
      ))}
    </ul>
  );
}

function Task({ task }) {
  const [isEditing, setIsEditing] = useState(false);
  const dispatch = useTasksDispatch();
  let taskContent;
  if (isEditing) {
    taskContent = (
      <>
        <input
          value={task.text}
          onChange={e => {
            dispatch({
              type: 'changed',
              task: {
                ...task,
                text: e.target.value
              }
            });
          }} />
        <button onClick={() => setIsEditing(false)}>
          Save
        </button>
      </>
    );
  } else {
    taskContent = (
      <>
        {task.text}
        <button onClick={() => setIsEditing(true)}>
          Edit
        </button>
      </>
    );
  }
  return (
    <label>
      <input
        type="checkbox"
        checked={task.done}
        onChange={e => {
          dispatch({
            type: 'changed',
            task: {
              ...task,
              done: e.target.checked
            }
          });
        }}
      />
      {taskContent}
      <button onClick={() => {
        dispatch({
          type: 'deleted',
          id: task.id
        });
      }}>
        Delete
      </button>
    </label>
  );
}
```

Show more

You can think of `TasksProvider` as a part of the screen that knows how to deal with tasks, `useTasks` as a way to read them, and `useTasksDispatch` as a way to update them from any component below in the tree.

### Note

Functions like `useTasks` and `useTasksDispatch` are called *[Custom Hooks.](https://react.dev/learn/reusing-logic-with-custom-hooks)* Your function is considered a custom Hook if its name starts with `use`. This lets you use other Hooks, like `useContext`, inside it.

As your app grows, you may have many context-reducer pairs like this. This is a powerful way to scale your app and [lift state up](https://react.dev/learn/sharing-state-between-components) without too much work whenever you want to access the data deep in the tree.

## Recap

* You can combine reducer with context to let any component read and update state above it.
* To provide state and the dispatch function to components below:
  1. Create two contexts (for state and for dispatch functions).
  2. Provide both contexts from the component that uses the reducer.
  3. Use either context from components that need to read them.
* You can further declutter the components by moving all wiring into one file.
  + You can export a component like `TasksProvider` that provides context.
  + You can also export custom Hooks like `useTasks` and `useTasksDispatch` to read it.
* You can have many context-reducer pairs like this in your app.

[PreviousPassing Data Deeply with Context](https://react.dev/learn/passing-data-deeply-with-context)[NextEscape Hatches](https://react.dev/learn/escape-hatches)

---

---


# Escape Hatches – React

URL: https://react.dev/learn/escape-hatches

[Learn React](https://react.dev/learn)

# Escape Hatches

Advanced

Some of your components may need to control and synchronize with systems outside of React. For example, you might need to focus an input using the browser API, play and pause a video player implemented without React, or connect and listen to messages from a remote server. In this chapter, you’ll learn the escape hatches that let you “step outside” React and connect to external systems. Most of your application logic and data flow should not rely on these features.

### In this chapter

* [How to “remember” information without re-rendering](https://react.dev/learn/referencing-values-with-refs)
* [How to access DOM elements managed by React](https://react.dev/learn/manipulating-the-dom-with-refs)
* [How to synchronize components with external systems](https://react.dev/learn/synchronizing-with-effects)
* [How to remove unnecessary Effects from your components](https://react.dev/learn/you-might-not-need-an-effect)
* [How an Effect’s lifecycle is different from a component’s](https://react.dev/learn/lifecycle-of-reactive-effects)
* [How to prevent some values from re-triggering Effects](https://react.dev/learn/separating-events-from-effects)
* [How to make your Effect re-run less often](https://react.dev/learn/removing-effect-dependencies)
* [How to share logic between components](https://react.dev/learn/reusing-logic-with-custom-hooks)

## Referencing values with refs

When you want a component to “remember” some information, but you don’t want that information to [trigger new renders](https://react.dev/learn/render-and-commit), you can use a *ref*:

```
const ref = useRef(0);
```

Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not! You can access the current value of that ref through the `ref.current` property.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('You clicked ' + ref.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}
```

Show more

A ref is like a secret pocket of your component that React doesn’t track. For example, you can use refs to store [timeout IDs](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#return_value), [DOM elements](https://developer.mozilla.org/en-US/docs/Web/API/Element), and other objects that don’t impact the component’s rendering output.

## Ready to learn this topic?

Read **[Referencing Values with Refs](https://react.dev/learn/referencing-values-with-refs)** to learn how to use refs to remember information.

[Read More](https://react.dev/learn/referencing-values-with-refs)

---

## Manipulating the DOM with refs

React automatically updates the DOM to match your render output, so your components won’t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a ref to the DOM node. For example, clicking the button will focus the input using a ref:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

Show more

## Ready to learn this topic?

Read **[Manipulating the DOM with Refs](https://react.dev/learn/manipulating-the-dom-with-refs)** to learn how to access DOM elements managed by React.

[Read More](https://react.dev/learn/manipulating-the-dom-with-refs)

---

## Synchronizing with Effects

Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. Unlike event handlers, which let you handle particular events, *Effects* let you run some code after rendering. Use them to synchronize your component with a system outside of React.

Press Play/Pause a few times and see how the video player stays synchronized to the `isPlaying` prop value:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]);

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

Show more

Many Effects also “clean up” after themselves. For example, an Effect that sets up a connection to a chat server should return a *cleanup function* that tells React how to disconnect your component from that server:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

In development, React will immediately run and clean up your Effect one extra time. This is why you see `"✅ Connecting..."` printed twice. This ensures that you don’t forget to implement the cleanup function.

## Ready to learn this topic?

Read **[Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects)** to learn how to synchronize components with external systems.

[Read More](https://react.dev/learn/synchronizing-with-effects)

---

## You Might Not Need An Effect

Effects are an escape hatch from the React paradigm. They let you “step outside” of React and synchronize your components with some external system. If there is no external system involved (for example, if you want to update a component’s state when some props or state change), you shouldn’t need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.

There are two common cases in which you don’t need Effects:

* **You don’t need Effects to transform data for rendering.**
* **You don’t need Effects to handle user events.**

For example, you don’t need an Effect to adjust some state based on other state:

```
function Form() {

const [firstName, setFirstName] = useState('Taylor');

const [lastName, setLastName] = useState('Swift');

// 🔴 Avoid: redundant state and unnecessary Effect

const [fullName, setFullName] = useState('');

useEffect(() => {

setFullName(firstName + ' ' + lastName);

}, [firstName, lastName]);

// ...

}
```

Instead, calculate as much as you can while rendering:

```
function Form() {

const [firstName, setFirstName] = useState('Taylor');

const [lastName, setLastName] = useState('Swift');

// ✅ Good: calculated during rendering

const fullName = firstName + ' ' + lastName;

// ...

}
```

However, you *do* need Effects to synchronize with external systems.

## Ready to learn this topic?

Read **[You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)** to learn how to remove unnecessary Effects.

[Read More](https://react.dev/learn/you-might-not-need-an-effect)

---

## Lifecycle of reactive effects

Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time.

This Effect depends on the value of the `roomId` prop. Props are *reactive values,* which means they can change on a re-render. Notice that the Effect *re-synchronizes* (and re-connects to the server) if `roomId` changes:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. If you forget to specify `roomId` in the list of dependencies in the above example, the linter will find that bug automatically.

## Ready to learn this topic?

Read **[Lifecycle of Reactive Events](https://react.dev/learn/lifecycle-of-reactive-effects)** to learn how an Effect’s lifecycle is different from a component’s.

[Read More](https://react.dev/learn/lifecycle-of-reactive-effects)

---

## Separating events from Effects

Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if any of the values they read, like props or state, are different than during last render. Sometimes, you want a mix of both behaviors: an Effect that re-runs in response to some values but not others.

All code inside Effects is *reactive.* It will run again if some reactive value it reads has changed due to a re-render. For example, this Effect will re-connect to the chat if either `roomId` or `theme` have changed:

App.jschat.jsnotifications.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'} 
      />
    </>
  );
}
```

Show more

This is not ideal. You want to re-connect to the chat only if the `roomId` has changed. Switching the `theme` shouldn’t re-connect to the chat! Move the code reading `theme` out of your Effect into an *Effect Event*:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'} 
      />
    </>
  );
}
```

Show more

Code inside Effect Events isn’t reactive, so changing the `theme` no longer makes your Effect re-connect.

## Ready to learn this topic?

Read **[Separating Events from Effects](https://react.dev/learn/separating-events-from-effects)** to learn how to prevent some values from re-triggering Effects.

[Read More](https://react.dev/learn/separating-events-from-effects)

---

## Removing Effect dependencies

When you write an Effect, the linter will verify that you’ve included every reactive value (like props and state) that the Effect reads in the list of your Effect’s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. The way you remove them depends on the case.

For example, this Effect depends on the `options` object which gets re-created every time you edit the input:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  const options = {
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

You don’t want the chat to re-connect every time you start typing a message in that chat. To fix this problem, move creation of the `options` object inside the Effect so that the Effect only depends on the `roomId` string:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

Notice that you didn’t start by editing the dependency list to remove the `options` dependency. That would be wrong. Instead, you changed the surrounding code so that the dependency became *unnecessary.* Think of the dependency list as a list of all the reactive values used by your Effect’s code. You don’t intentionally choose what to put on that list. The list describes your code. To change the dependency list, change the code.

## Ready to learn this topic?

Read **[Removing Effect Dependencies](https://react.dev/learn/removing-effect-dependencies)** to learn how to make your Effect re-run less often.

[Read More](https://react.dev/learn/removing-effect-dependencies)

---

## Reusing logic with custom Hooks

React comes with built-in Hooks like `useState`, `useContext`, and `useEffect`. Sometimes, you’ll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. To do this, you can create your own Hooks for your application’s needs.

In this example, the `usePointerPosition` custom Hook tracks the cursor position, while `useDelayedValue` custom Hook returns a value that’s “lagging behind” the value you passed by a certain number of milliseconds. Move the cursor over the sandbox preview area to see a moving trail of dots following the cursor:

App.jsusePointerPosition.jsuseDelayedValue.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { usePointerPosition } from './usePointerPosition.js';
import { useDelayedValue } from './useDelayedValue.js';

export default function Canvas() {
  const pos1 = usePointerPosition();
  const pos2 = useDelayedValue(pos1, 100);
  const pos3 = useDelayedValue(pos2, 200);
  const pos4 = useDelayedValue(pos3, 100);
  const pos5 = useDelayedValue(pos4, 50);
  return (
    <>
      <Dot position={pos1} opacity={1} />
      <Dot position={pos2} opacity={0.8} />
      <Dot position={pos3} opacity={0.6} />
      <Dot position={pos4} opacity={0.4} />
      <Dot position={pos5} opacity={0.2} />
    </>
  );
}

function Dot({ position, opacity }) {
  return (
    <div style={{
      position: 'absolute',
      backgroundColor: 'pink',
      borderRadius: '50%',
      opacity,
      transform: `translate(${position.x}px, ${position.y}px)`,
      pointerEvents: 'none',
      left: -20,
      top: -20,
      width: 40,
      height: 40,
    }} />
  );
}
```

Show more

You can create custom Hooks, compose them together, pass data between them, and reuse them between components. As your app grows, you will write fewer Effects by hand because you’ll be able to reuse custom Hooks you already wrote. There are also many excellent custom Hooks maintained by the React community.

## Ready to learn this topic?

Read **[Reusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)** to learn how to share logic between components.

[Read More](https://react.dev/learn/reusing-logic-with-custom-hooks)

---

## What’s next?

Head over to [Referencing Values with Refs](https://react.dev/learn/referencing-values-with-refs) to start reading this chapter page by page!

[PreviousScaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context)[NextReferencing Values with Refs](https://react.dev/learn/referencing-values-with-refs)

---

---


# Referencing Values with Refs – React

URL: https://react.dev/learn/referencing-values-with-refs

[Learn React](https://react.dev/learn)

[Escape Hatches](https://react.dev/learn/escape-hatches)

# Referencing Values with Refs

When you want a component to “remember” some information, but you don’t want that information to [trigger new renders](https://react.dev/learn/render-and-commit), you can use a *ref*.

### You will learn

* How to add a ref to your component
* How to update a ref’s value
* How refs are different from state
* How to use refs safely

## Adding a ref to your component

You can add a ref to your component by importing the `useRef` Hook from React:

```
import { useRef } from 'react';
```

Inside your component, call the `useRef` Hook and pass the initial value that you want to reference as the only argument. For example, here is a ref to the value `0`:

```
const ref = useRef(0);
```

`useRef` returns an object like this:

```
{

current: 0 // The value you passed to useRef

}
```

![An arrow with 'current' written on it stuffed into a pocket with 'ref' written on it.](https://react.dev/images/docs/illustrations/i_ref.png)

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

You can access the current value of that ref through the `ref.current` property. This value is intentionally mutable, meaning you can both read and write to it. It’s like a secret pocket of your component that React doesn’t track. (This is what makes it an “escape hatch” from React’s one-way data flow—more on that below!)

Here, a button will increment `ref.current` on every click:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('You clicked ' + ref.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}
```

Show more

The ref points to a number, but, like [state](https://react.dev/learn/state-a-components-memory), you could point to anything: a string, an object, or even a function. Unlike state, ref is a plain JavaScript object with the `current` property that you can read and modify.

Note that **the component doesn’t re-render with every increment.** Like state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not!

## Example: building a stopwatch

You can combine refs and state in a single component. For example, let’s make a stopwatch that the user can start or stop by pressing a button. In order to display how much time has passed since the user pressed “Start”, you will need to keep track of when the Start button was pressed and what the current time is. **This information is used for rendering, so you’ll keep it in state:**

```
const [startTime, setStartTime] = useState(null);

const [now, setNow] = useState(null);
```

When the user presses “Start”, you’ll use [`setInterval`](https://developer.mozilla.org/docs/Web/API/setInterval) in order to update the time every 10 milliseconds:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);

  function handleStart() {
    // Start counting.
    setStartTime(Date.now());
    setNow(Date.now());

    setInterval(() => {
      // Update the current time every 10ms.
      setNow(Date.now());
    }, 10);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>
        Start
      </button>
    </>
  );
}
```

Show more

When the “Stop” button is pressed, you need to cancel the existing interval so that it stops updating the `now` state variable. You can do this by calling [`clearInterval`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval), but you need to give it the interval ID that was previously returned by the `setInterval` call when the user pressed Start. You need to keep the interval ID somewhere. **Since the interval ID is not used for rendering, you can keep it in a ref:**

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef } from 'react';

export default function Stopwatch() {
  const [startTime, setStartTime] = useState(null);
  const [now, setNow] = useState(null);
  const intervalRef = useRef(null);

  function handleStart() {
    setStartTime(Date.now());
    setNow(Date.now());

    clearInterval(intervalRef.current);
    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 10);
  }

  function handleStop() {
    clearInterval(intervalRef.current);
  }

  let secondsPassed = 0;
  if (startTime != null && now != null) {
    secondsPassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {secondsPassed.toFixed(3)}</h1>
      <button onClick={handleStart}>
        Start
      </button>
      <button onClick={handleStop}>
        Stop
      </button>
    </>
  );
}
```

Show more

When a piece of information is used for rendering, keep it in state. When a piece of information is only needed by event handlers and changing it doesn’t require a re-render, using a ref may be more efficient.

## Differences between refs and state

Perhaps you’re thinking refs seem less “strict” than state—you can mutate them instead of always having to use a state setting function, for instance. But in most cases, you’ll want to use state. Refs are an “escape hatch” you won’t need often. Here’s how state and refs compare:

| refs | state |
| --- | --- |
| `useRef(initialValue)` returns `{ current: initialValue }` | `useState(initialValue)` returns the current value of a state variable and a state setter function ( `[value, setValue]`) |
| Doesn’t trigger re-render when you change it. | Triggers re-render when you change it. |
| Mutable—you can modify and update `current`’s value outside of the rendering process. | ”Immutable”—you must use the state setting function to modify state variables to queue a re-render. |
| You shouldn’t read (or write) the `current` value during rendering. | You can read state at any time. However, each render has its own [snapshot](https://react.dev/learn/state-as-a-snapshot) of state which does not change. |

Here is a counter button that’s implemented with state:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      You clicked {count} times
    </button>
  );
}
```

Because the `count` value is displayed, it makes sense to use a state value for it. When the counter’s value is set with `setCount()`, React re-renders the component and the screen updates to reflect the new count.

If you tried to implement this with a ref, React would never re-render the component, so you’d never see the count change! See how clicking this button **does not update its text**:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function Counter() {
  let countRef = useRef(0);

  function handleClick() {
    // This doesn't re-render the component!
    countRef.current = countRef.current + 1;
  }

  return (
    <button onClick={handleClick}>
      You clicked {countRef.current} times
    </button>
  );
}
```

Show more

This is why reading `ref.current` during render leads to unreliable code. If you need that, use state instead.

##### Deep Dive

#### How does useRef work inside?

Show Details

Although both `useState` and `useRef` are provided by React, in principle `useRef` could be implemented *on top of* `useState`. You can imagine that inside of React, `useRef` is implemented like this:

```
// Inside of React

function useRef(initialValue) {

const [ref, unused] = useState({ current: initialValue });

return ref;

}
```

During the first render, `useRef` returns `{ current: initialValue }`. This object is stored by React, so during the next render the same object will be returned. Note how the state setter is unused in this example. It is unnecessary because `useRef` always needs to return the same object!

React provides a built-in version of `useRef` because it is common enough in practice. But you can think of it as a regular state variable without a setter. If you’re familiar with object-oriented programming, refs might remind you of instance fields—but instead of `this.something` you write `somethingRef.current`.

## When to use refs

Typically, you will use a ref when your component needs to “step outside” React and communicate with external APIs—often a browser API that won’t impact the appearance of the component. Here are a few of these rare situations:

* Storing [timeout IDs](https://developer.mozilla.org/docs/Web/API/setTimeout)
* Storing and manipulating [DOM elements](https://developer.mozilla.org/docs/Web/API/Element), which we cover on [the next page](https://react.dev/learn/manipulating-the-dom-with-refs)
* Storing other objects that aren’t necessary to calculate the JSX.

If your component needs to store some value, but it doesn’t impact the rendering logic, choose refs.

## Best practices for refs

Following these principles will make your components more predictable:

* **Treat refs as an escape hatch.** Refs are useful when you work with external systems or browser APIs. If much of your application logic and data flow relies on refs, you might want to rethink your approach.
* **Don’t read or write `ref.current` during rendering.** If some information is needed during rendering, use [state](https://react.dev/learn/state-a-components-memory) instead. Since React doesn’t know when `ref.current` changes, even reading it while rendering makes your component’s behavior difficult to predict. (The only exception to this is code like `if (!ref.current) ref.current = new Thing()` which only sets the ref once during the first render.)

Limitations of React state don’t apply to refs. For example, state acts like a [snapshot for every render](https://react.dev/learn/state-as-a-snapshot) and [doesn’t update synchronously.](https://react.dev/learn/queueing-a-series-of-state-updates) But when you mutate the current value of a ref, it changes immediately:

```
ref.current = 5;

console.log(ref.current); // 5
```

This is because **the ref itself is a regular JavaScript object,** and so it behaves like one.

You also don’t need to worry about [avoiding mutation](https://react.dev/learn/updating-objects-in-state) when you work with a ref. As long as the object you’re mutating isn’t used for rendering, React doesn’t care what you do with the ref or its contents.

## Refs and the DOM

You can point a ref to any value. However, the most common use case for a ref is to access a DOM element. For example, this is handy if you want to focus an input programmatically. When you pass a ref to a `ref` attribute in JSX, like `<div ref={myRef}>`, React will put the corresponding DOM element into `myRef.current`. Once the element is removed from the DOM, React will update `myRef.current` to be `null`. You can read more about this in [Manipulating the DOM with Refs.](https://react.dev/learn/manipulating-the-dom-with-refs)

## Recap

* Refs are an escape hatch to hold onto values that aren’t used for rendering. You won’t need them often.
* A ref is a plain JavaScript object with a single property called `current`, which you can read or set.
* You can ask React to give you a ref by calling the `useRef` Hook.
* Like state, refs let you retain information between re-renders of a component.
* Unlike state, setting the ref’s `current` value does not trigger a re-render.
* Don’t read or write `ref.current` during rendering. This makes your component hard to predict.

## Try out some challenges

1. Fix a broken chat input 2. Fix a component failing to re-render 3. Fix debouncing 4. Read the latest state

#### Challenge 1 of 4: Fix a broken chat input

Type a message and click “Send”. You will notice there is a three second delay before you see the “Sent!” alert. During this delay, you can see an “Undo” button. Click it. This “Undo” button is supposed to stop the “Sent!” message from appearing. It does this by calling [`clearTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout) for the timeout ID saved during `handleSend`. However, even after “Undo” is clicked, the “Sent!” message still appears. Find why it doesn’t work, and fix it.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Chat() {
  const [text, setText] = useState('');
  const [isSending, setIsSending] = useState(false);
  let timeoutID = null;

  function handleSend() {
    setIsSending(true);
    timeoutID = setTimeout(() => {
      alert('Sent!');
      setIsSending(false);
    }, 3000);
  }

  function handleUndo() {
    setIsSending(false);
    clearTimeout(timeoutID);
  }

  return (
    <>
      <input
        disabled={isSending}
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <button
        disabled={isSending}
        onClick={handleSend}>
        {isSending ? 'Sending...' : 'Send'}
      </button>
      {isSending &&
        <button onClick={handleUndo}>
          Undo
        </button>
      }
    </>
  );
}
```

Show more

Show hint Show solution

Next Challenge

[PreviousEscape Hatches](https://react.dev/learn/escape-hatches)[NextManipulating the DOM with Refs](https://react.dev/learn/manipulating-the-dom-with-refs)

---

---


# Manipulating the DOM with Refs – React

URL: https://react.dev/learn/manipulating-the-dom-with-refs

[Learn React](https://react.dev/learn)

[Escape Hatches](https://react.dev/learn/escape-hatches)

# Manipulating the DOM with Refs

React automatically updates the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction) to match your render output, so your components won’t often need to manipulate it. However, sometimes you might need access to the DOM elements managed by React—for example, to focus a node, scroll to it, or measure its size and position. There is no built-in way to do those things in React, so you will need a *ref* to the DOM node.

### You will learn

* How to access a DOM node managed by React with the `ref` attribute
* How the `ref` JSX attribute relates to the `useRef` Hook
* How to access another component’s DOM node
* In which cases it’s safe to modify the DOM managed by React

## Getting a ref to the node

To access a DOM node managed by React, first, import the `useRef` Hook:

```
import { useRef } from 'react';
```

Then, use it to declare a ref inside your component:

```
const myRef = useRef(null);
```

Finally, pass your ref as the `ref` attribute to the JSX tag for which you want to get the DOM node:

```
<div ref={myRef}>
```

The `useRef` Hook returns an object with a single property called `current`. Initially, `myRef.current` will be `null`. When React creates a DOM node for this `<div>`, React will put a reference to this node into `myRef.current`. You can then access this DOM node from your [event handlers](https://react.dev/learn/responding-to-events) and use the built-in [browser APIs](https://developer.mozilla.org/docs/Web/API/Element) defined on it.

```
// You can use any browser APIs, for example:

myRef.current.scrollIntoView();
```

### Example: Focusing a text input

In this example, clicking the button will focus the input:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

Show more

To implement this:

1. Declare `inputRef` with the `useRef` Hook.
2. Pass it as `<input ref={inputRef}>`. This tells React to **put this `<input>`’s DOM node into `inputRef.current`.**
3. In the `handleClick` function, read the input DOM node from `inputRef.current` and call [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) on it with `inputRef.current.focus()`.
4. Pass the `handleClick` event handler to `<button>` with `onClick`.

While DOM manipulation is the most common use case for refs, the `useRef` Hook can be used for storing other things outside React, like timer IDs. Similarly to state, refs remain between renders. Refs are like state variables that don’t trigger re-renders when you set them. Read about refs in [Referencing Values with Refs.](https://react.dev/learn/referencing-values-with-refs)

### Example: Scrolling to an element

You can have more than a single ref in a component. In this example, there is a carousel of three images. Each button centers an image by calling the browser [`scrollIntoView()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) method on the corresponding DOM node:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function CatFriends() {
  const firstCatRef = useRef(null);
  const secondCatRef = useRef(null);
  const thirdCatRef = useRef(null);

  function handleScrollToFirstCat() {
    firstCatRef.current.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  function handleScrollToSecondCat() {
    secondCatRef.current.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  function handleScrollToThirdCat() {
    thirdCatRef.current.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest',
      inline: 'center'
    });
  }

  return (
    <>
      <nav>
        <button onClick={handleScrollToFirstCat}>
          Neo
        </button>
        <button onClick={handleScrollToSecondCat}>
          Millie
        </button>
        <button onClick={handleScrollToThirdCat}>
          Bella
        </button>
      </nav>
      <div>
        <ul>
          <li>
            <img
              src="https://placecats.com/neo/300/200"
              alt="Neo"
              ref={firstCatRef}
            />
          </li>
          <li>
            <img
              src="https://placecats.com/millie/200/200"
              alt="Millie"
              ref={secondCatRef}
            />
          </li>
          <li>
            <img
              src="https://placecats.com/bella/199/200"
              alt="Bella"
              ref={thirdCatRef}
            />
          </li>
        </ul>
      </div>
    </>
  );
}
```

Show more

##### Deep Dive

#### How to manage a list of refs using a ref callback

Show Details

In the above examples, there is a predefined number of refs. However, sometimes you might need a ref to each item in the list, and you don’t know how many you will have. Something like this **wouldn’t work**:

```
<ul>

{items.map((item) => {

// Doesn't work!

const ref = useRef(null);

return <li ref={ref} />;

})}

</ul>
```

This is because **Hooks must only be called at the top-level of your component.** You can’t call `useRef` in a loop, in a condition, or inside a `map()` call.

One possible way around this is to get a single ref to their parent element, and then use DOM manipulation methods like [`querySelectorAll`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll) to “find” the individual child nodes from it. However, this is brittle and can break if your DOM structure changes.

Another solution is to **pass a function to the `ref` attribute.** This is called a [`ref` callback.](https://react.dev/reference/react-dom/components/common#ref-callback) React will call your ref callback with the DOM node when it’s time to set the ref, and call the cleanup function returned from the callback when it’s time to clear it. This lets you maintain your own array or a [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map), and access any ref by its index or some kind of ID.

This example shows how you can use this approach to scroll to an arbitrary node in a long list:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useState } from "react";

export default function CatFriends() {
  const itemsRef = useRef(null);
  const [catList, setCatList] = useState(setupCatList);

  function scrollToCat(cat) {
    const map = getMap();
    const node = map.get(cat);
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  function getMap() {
    if (!itemsRef.current) {
      // Initialize the Map on first usage.
      itemsRef.current = new Map();
    }
    return itemsRef.current;
  }

  return (
    <>
      <nav>
        <button onClick={() => scrollToCat(catList[0])}>Neo</button>
        <button onClick={() => scrollToCat(catList[5])}>Millie</button>
        <button onClick={() => scrollToCat(catList[8])}>Bella</button>
      </nav>
      <div>
        <ul>
          {catList.map((cat) => (
            <li
              key={cat.id}
              ref={(node) => {
                const map = getMap();
                map.set(cat, node);

                return () => {
                  map.delete(cat);
                };
              }}
            >
              <img src={cat.imageUrl} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

function setupCatList() {
  const catCount = 10;
  const catList = new Array(catCount)
  for (let i = 0; i < catCount; i++) {
    let imageUrl = '';
    if (i < 5) {
      imageUrl = "https://placecats.com/neo/320/240";
    } else if (i < 8) {
      imageUrl = "https://placecats.com/millie/320/240";
    } else {
      imageUrl = "https://placecats.com/bella/320/240";
    }
    catList[i] = {
      id: i,
      imageUrl,
    };
  }
  return catList;
}
```

Show more

In this example, `itemsRef` doesn’t hold a single DOM node. Instead, it holds a [Map](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Map) from item ID to a DOM node. ([Refs can hold any values!](https://react.dev/learn/referencing-values-with-refs)) The [`ref` callback](https://react.dev/reference/react-dom/components/common#ref-callback) on every list item takes care to update the Map:

```
<li

key={cat.id}

ref={node => {

const map = getMap();

// Add to the Map

map.set(cat, node);

return () => {

// Remove from the Map

map.delete(cat);

};

}}

>
```

This lets you read individual DOM nodes from the Map later.

### Note

When Strict Mode is enabled, ref callbacks will run twice in development.

Read more about [how this helps find bugs](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-re-running-ref-callbacks-in-development) in callback refs.

## Accessing another component’s DOM nodes

### Pitfall

Refs are an escape hatch. Manually manipulating *another* component’s DOM nodes can make your code fragile.

You can pass refs from parent component to child components [just like any other prop](https://react.dev/learn/passing-props-to-a-component).

```
import { useRef } from 'react';

function MyInput({ ref }) {

return <input ref={ref} />;

}

function MyForm() {

const inputRef = useRef(null);

return <MyInput ref={inputRef} />

}
```

In the above example, a ref is created in the parent component, `MyForm`, and is passed to the child component, `MyInput`. `MyInput` then passes the ref to `<input>`. Because `<input>` is a [built-in component](https://react.dev/reference/react-dom/components/common) React sets the `.current` property of the ref to the `<input>` DOM element.

The `inputRef` created in `MyForm` now points to the `<input>` DOM element returned by `MyInput`. A click handler created in `MyForm` can access `inputRef` and call `focus()` to set the focus on `<input>`.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

function MyInput({ ref }) {
  return <input ref={ref} />;
}

export default function MyForm() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

Show more

##### Deep Dive

#### Exposing a subset of the API with an imperative handle

Show Details

In the above example, the ref passed to `MyInput` is passed on to the original DOM input element. This lets the parent component call `focus()` on it. However, this also lets the parent component do something else—for example, change its CSS styles. In uncommon cases, you may want to restrict the exposed functionality. You can do that with [`useImperativeHandle`](https://react.dev/reference/react/useImperativeHandle):

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useImperativeHandle } from "react";

function MyInput({ ref }) {
  const realInputRef = useRef(null);
  useImperativeHandle(ref, () => ({
    // Only expose focus and nothing else
    focus() {
      realInputRef.current.focus();
    },
  }));
  return <input ref={realInputRef} />;
};

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <MyInput ref={inputRef} />
      <button onClick={handleClick}>Focus the input</button>
    </>
  );
}
```

Show more

Here, `realInputRef` inside `MyInput` holds the actual input DOM node. However, [`useImperativeHandle`](https://react.dev/reference/react/useImperativeHandle) instructs React to provide your own special object as the value of a ref to the parent component. So `inputRef.current` inside the `Form` component will only have the `focus` method. In this case, the ref “handle” is not the DOM node, but the custom object you create inside [`useImperativeHandle`](https://react.dev/reference/react/useImperativeHandle) call.

## When React attaches the refs

In React, every update is split in [two phases](https://react.dev/learn/render-and-commit#step-3-react-commits-changes-to-the-dom):

* During **render,** React calls your components to figure out what should be on the screen.
* During **commit,** React applies changes to the DOM.

In general, you [don’t want](https://react.dev/learn/referencing-values-with-refs#best-practices-for-refs) to access refs during rendering. That goes for refs holding DOM nodes as well. During the first render, the DOM nodes have not yet been created, so `ref.current` will be `null`. And during the rendering of updates, the DOM nodes haven’t been updated yet. So it’s too early to read them.

React sets `ref.current` during the commit. Before updating the DOM, React sets the affected `ref.current` values to `null`. After updating the DOM, React immediately sets them to the corresponding DOM nodes.

**Usually, you will access refs from event handlers.** If you want to do something with a ref, but there is no particular event to do it in, you might need an Effect. We will discuss Effects on the next pages.

##### Deep Dive

#### Flushing state updates synchronously with flushSync

Show Details

Consider code like this, which adds a new todo and scrolls the screen down to the last child of the list. Notice how, for some reason, it always scrolls to the todo that was *just before* the last added one:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef } from 'react';

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState('');
  const [todos, setTodos] = useState(
    initialTodos
  );

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    setText('');
    setTodos([ ...todos, newTodo]);
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>
        Add
      </button>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: 'Todo #' + (i + 1)
  });
}
```

Show more

The issue is with these two lines:

```
setTodos([ ...todos, newTodo]);

listRef.current.lastChild.scrollIntoView();
```

In React, [state updates are queued.](https://react.dev/learn/queueing-a-series-of-state-updates) Usually, this is what you want. However, here it causes a problem because `setTodos` does not immediately update the DOM. So the time you scroll the list to its last element, the todo has not yet been added. This is why scrolling always “lags behind” by one item.

To fix this issue, you can force React to update (“flush”) the DOM synchronously. To do this, import `flushSync` from `react-dom` and **wrap the state update** into a `flushSync` call:

```
flushSync(() => {

setTodos([ ...todos, newTodo]);

});

listRef.current.lastChild.scrollIntoView();
```

This will instruct React to update the DOM synchronously right after the code wrapped in `flushSync` executes. As a result, the last todo will already be in the DOM by the time you try to scroll to it:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef } from 'react';
import { flushSync } from 'react-dom';

export default function TodoList() {
  const listRef = useRef(null);
  const [text, setText] = useState('');
  const [todos, setTodos] = useState(
    initialTodos
  );

  function handleAdd() {
    const newTodo = { id: nextId++, text: text };
    flushSync(() => {
      setText('');
      setTodos([ ...todos, newTodo]);
    });
    listRef.current.lastChild.scrollIntoView({
      behavior: 'smooth',
      block: 'nearest'
    });
  }

  return (
    <>
      <button onClick={handleAdd}>
        Add
      </button>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <ul ref={listRef}>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}

let nextId = 0;
let initialTodos = [];
for (let i = 0; i < 20; i++) {
  initialTodos.push({
    id: nextId++,
    text: 'Todo #' + (i + 1)
  });
}
```

Show more

## Best practices for DOM manipulation with refs

Refs are an escape hatch. You should only use them when you have to “step outside React”. Common examples of this include managing focus, scroll position, or calling browser APIs that React does not expose.

If you stick to non-destructive actions like focusing and scrolling, you shouldn’t encounter any problems. However, if you try to **modify** the DOM manually, you can risk conflicting with the changes React is making.

To illustrate this problem, this example includes a welcome message and two buttons. The first button toggles its presence using [conditional rendering](https://react.dev/learn/conditional-rendering) and [state](https://react.dev/learn/state-a-components-memory), as you would usually do in React. The second button uses the [`remove()` DOM API](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove) to forcefully remove it from the DOM outside of React’s control.

Try pressing “Toggle with setState” a few times. The message should disappear and appear again. Then press “Remove from the DOM”. This will forcefully remove it. Finally, press “Toggle with setState”:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef } from 'react';

export default function Counter() {
  const [show, setShow] = useState(true);
  const ref = useRef(null);

  return (
    <div>
      <button
        onClick={() => {
          setShow(!show);
        }}>
        Toggle with setState
      </button>
      <button
        onClick={() => {
          ref.current.remove();
        }}>
        Remove from the DOM
      </button>
      {show && <p ref={ref}>Hello world</p>}
    </div>
  );
}
```

Show more

After you’ve manually removed the DOM element, trying to use `setState` to show it again will lead to a crash. This is because you’ve changed the DOM, and React doesn’t know how to continue managing it correctly.

**Avoid changing DOM nodes managed by React.** Modifying, adding children to, or removing children from elements that are managed by React can lead to inconsistent visual results or crashes like above.

However, this doesn’t mean that you can’t do it at all. It requires caution. **You can safely modify parts of the DOM that React has *no reason* to update.** For example, if some `<div>` is always empty in the JSX, React won’t have a reason to touch its children list. Therefore, it is safe to manually add or remove elements there.

## Recap

* Refs are a generic concept, but most often you’ll use them to hold DOM elements.
* You instruct React to put a DOM node into `myRef.current` by passing `<div ref={myRef}>`.
* Usually, you will use refs for non-destructive actions like focusing, scrolling, or measuring DOM elements.
* A component doesn’t expose its DOM nodes by default. You can opt into exposing a DOM node by using the `ref` prop.
* Avoid changing DOM nodes managed by React.
* If you do modify DOM nodes managed by React, modify parts that React has no reason to update.

## Try out some challenges

1. Play and pause the video 2. Focus the search field 3. Scrolling an image carousel 4. Focus the search field with separate components

#### Challenge 1 of 4: Play and pause the video

In this example, the button toggles a state variable to switch between a playing and a paused state. However, in order to actually play or pause the video, toggling state is not enough. You also need to call [`play()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play) and [`pause()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause) on the DOM element for the `<video>`. Add a ref to it, and make the button work.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef } from 'react';

export default function VideoPlayer() {
  const [isPlaying, setIsPlaying] = useState(false);

  function handleClick() {
    const nextIsPlaying = !isPlaying;
    setIsPlaying(nextIsPlaying);
  }

  return (
    <>
      <button onClick={handleClick}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <video width="250">
        <source
          src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
          type="video/mp4"
        />
      </video>
    </>
  )
}
```

Show more

For an extra challenge, keep the “Play” button in sync with whether the video is playing even if the user right-clicks the video and plays it using the built-in browser media controls. You might want to listen to `onPlay` and `onPause` on the video to do that.

Show solutionNext Challenge

[PreviousReferencing Values with Refs](https://react.dev/learn/referencing-values-with-refs)[NextSynchronizing with Effects](https://react.dev/learn/synchronizing-with-effects)

---

---


# Synchronizing with Effects – React

URL: https://react.dev/learn/synchronizing-with-effects

[Learn React](https://react.dev/learn)

[Escape Hatches](https://react.dev/learn/escape-hatches)

# Synchronizing with Effects

Some components need to synchronize with external systems. For example, you might want to control a non-React component based on the React state, set up a server connection, or send an analytics log when a component appears on the screen. *Effects* let you run some code after rendering so that you can synchronize your component with some system outside of React.

### You will learn

* What Effects are
* How Effects are different from events
* How to declare an Effect in your component
* How to skip re-running an Effect unnecessarily
* Why Effects run twice in development and how to fix them

## What are Effects and how are they different from events?

Before getting to Effects, you need to be familiar with two types of logic inside React components:

* **Rendering code** (introduced in [Describing the UI](https://react.dev/learn/describing-the-ui)) lives at the top level of your component. This is where you take the props and state, transform them, and return the JSX you want to see on the screen. [Rendering code must be pure.](https://react.dev/learn/keeping-components-pure) Like a math formula, it should only *calculate* the result, but not do anything else.
* **Event handlers** (introduced in [Adding Interactivity](https://react.dev/learn/adding-interactivity)) are nested functions inside your components that *do* things rather than just calculate them. An event handler might update an input field, submit an HTTP POST request to buy a product, or navigate the user to another screen. Event handlers contain [“side effects”](https://en.wikipedia.org/wiki/Side_effect_(computer_science)) (they change the program’s state) caused by a specific user action (for example, a button click or typing).

Sometimes this isn’t enough. Consider a `ChatRoom` component that must connect to the chat server whenever it’s visible on the screen. Connecting to a server is not a pure calculation (it’s a side effect) so it can’t happen during rendering. However, there is no single particular event like a click that causes `ChatRoom` to be displayed.

***Effects* let you specify side effects that are caused by rendering itself, rather than by a particular event.** Sending a message in the chat is an *event* because it is directly caused by the user clicking a specific button. However, setting up a server connection is an *Effect* because it should happen no matter which interaction caused the component to appear. Effects run at the end of a [commit](https://react.dev/learn/render-and-commit) after the screen updates. This is a good time to synchronize the React components with some external system (like network or a third-party library).

### Note

Here and later in this text, capitalized “Effect” refers to the React-specific definition above, i.e. a side effect caused by rendering. To refer to the broader programming concept, we’ll say “side effect”.

## You might not need an Effect

**Don’t rush to add Effects to your components.** Keep in mind that Effects are typically used to “step out” of your React code and synchronize with some *external* system. This includes browser APIs, third-party widgets, network, and so on. If your Effect only adjusts some state based on other state, [you might not need an Effect.](https://react.dev/learn/you-might-not-need-an-effect)

## How to write an Effect

To write an Effect, follow these three steps:

1. **Declare an Effect.** By default, your Effect will run after every [commit](https://react.dev/learn/render-and-commit).
2. **Specify the Effect dependencies.** Most Effects should only re-run *when needed* rather than after every render. For example, a fade-in animation should only trigger when a component appears. Connecting and disconnecting to a chat room should only happen when the component appears and disappears, or when the chat room changes. You will learn how to control this by specifying *dependencies.*
3. **Add cleanup if needed.** Some Effects need to specify how to stop, undo, or clean up whatever they were doing. For example, “connect” needs “disconnect”, “subscribe” needs “unsubscribe”, and “fetch” needs either “cancel” or “ignore”. You will learn how to do this by returning a *cleanup function*.

Let’s look at each of these steps in detail.

### Step 1: Declare an Effect

To declare an Effect in your component, import the [`useEffect` Hook](https://react.dev/reference/react/useEffect) from React:

```
import { useEffect } from 'react';
```

Then, call it at the top level of your component and put some code inside your Effect:

```
function MyComponent() {

useEffect(() => {

// Code here will run after *every* render

});

return <div />;

}
```

Every time your component renders, React will update the screen *and then* run the code inside `useEffect`. In other words, **`useEffect` “delays” a piece of code from running until that render is reflected on the screen.**

Let’s see how you can use an Effect to synchronize with an external system. Consider a `<VideoPlayer>` React component. It would be nice to control whether it’s playing or paused by passing an `isPlaying` prop to it:

```
<VideoPlayer isPlaying={isPlaying} />;
```

Your custom `VideoPlayer` component renders the built-in browser [`<video>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video) tag:

```
function VideoPlayer({ src, isPlaying }) {

// TODO: do something with isPlaying

return <video src={src} />;

}
```

However, the browser `<video>` tag does not have an `isPlaying` prop. The only way to control it is to manually call the [`play()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play) and [`pause()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause) methods on the DOM element. **You need to synchronize the value of `isPlaying` prop, which tells whether the video *should* currently be playing, with calls like `play()` and `pause()`.**

We’ll need to first [get a ref](https://react.dev/learn/manipulating-the-dom-with-refs) to the `<video>` DOM node.

You might be tempted to try to call `play()` or `pause()` during rendering, but that isn’t correct:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play();  // Calling these while rendering isn't allowed.
  } else {
    ref.current.pause(); // Also, this crashes.
  }

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

Show more

The reason this code isn’t correct is that it tries to do something with the DOM node during rendering. In React, [rendering should be a pure calculation](https://react.dev/learn/keeping-components-pure) of JSX and should not contain side effects like modifying the DOM.

Moreover, when `VideoPlayer` is called for the first time, its DOM does not exist yet! There isn’t a DOM node yet to call `play()` or `pause()` on, because React doesn’t know what DOM to create until you return the JSX.

The solution here is to **wrap the side effect with `useEffect` to move it out of the rendering calculation:**

```
import { useEffect, useRef } from 'react';

function VideoPlayer({ src, isPlaying }) {

const ref = useRef(null);

useEffect(() => {

if (isPlaying) {

ref.current.play();

} else {

ref.current.pause();

}

});

return <video ref={ref} src={src} loop playsInline />;

}
```

By wrapping the DOM update in an Effect, you let React update the screen first. Then your Effect runs.

When your `VideoPlayer` component renders (either the first time or if it re-renders), a few things will happen. First, React will update the screen, ensuring the `<video>` tag is in the DOM with the right props. Then React will run your Effect. Finally, your Effect will call `play()` or `pause()` depending on the value of `isPlaying`.

Press Play/Pause multiple times and see how the video player stays synchronized to the `isPlaying` value:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  return (
    <>
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

Show more

In this example, the “external system” you synchronized to React state was the browser media API. You can use a similar approach to wrap legacy non-React code (like jQuery plugins) into declarative React components.

Note that controlling a video player is much more complex in practice. Calling `play()` may fail, the user might play or pause using the built-in browser controls, and so on. This example is very simplified and incomplete.

### Pitfall

By default, Effects run after *every* render. This is why code like this will **produce an infinite loop:**

```
const [count, setCount] = useState(0);

useEffect(() => {

setCount(count + 1);

});
```

Effects run as a *result* of rendering. Setting state *triggers* rendering. Setting state immediately in an Effect is like plugging a power outlet into itself. The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.

Effects should usually synchronize your components with an *external* system. If there’s no external system and you only want to adjust some state based on other state, [you might not need an Effect.](https://react.dev/learn/you-might-not-need-an-effect)

### Step 2: Specify the Effect dependencies

By default, Effects run after *every* render. Often, this is **not what you want:**

* Sometimes, it’s slow. Synchronizing with an external system is not always instant, so you might want to skip doing it unless it’s necessary. For example, you don’t want to reconnect to the chat server on every keystroke.
* Sometimes, it’s wrong. For example, you don’t want to trigger a component fade-in animation on every keystroke. The animation should only play once when the component appears for the first time.

To demonstrate the issue, here is the previous example with a few `console.log` calls and a text input that updates the parent component’s state. Notice how typing causes the Effect to re-run:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  });

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

Show more

You can tell React to **skip unnecessarily re-running the Effect** by specifying an array of *dependencies* as the second argument to the `useEffect` call. Start by adding an empty `[]` array to the above example on line 14:

```
useEffect(() => {

// ...

}, []);
```

You should see an error saying `React Hook useEffect has a missing dependency: 'isPlaying'`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, []); // This causes an error

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

Show more

The problem is that the code inside of your Effect *depends on* the `isPlaying` prop to decide what to do, but this dependency was not explicitly declared. To fix this issue, add `isPlaying` to the dependency array:

```
useEffect(() => {

if (isPlaying) { // It's used here...

// ...

} else {

// ...

}

}, [isPlaying]); // ...so it must be declared here!
```

Now all dependencies are declared, so there is no error. Specifying `[isPlaying]` as the dependency array tells React that it should skip re-running your Effect if `isPlaying` is the same as it was during the previous render. With this change, typing into the input doesn’t cause the Effect to re-run, but pressing Play/Pause does:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useRef, useEffect } from 'react';

function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  useEffect(() => {
    if (isPlaying) {
      console.log('Calling video.play()');
      ref.current.play();
    } else {
      console.log('Calling video.pause()');
      ref.current.pause();
    }
  }, [isPlaying]);

  return <video ref={ref} src={src} loop playsInline />;
}

export default function App() {
  const [isPlaying, setIsPlaying] = useState(false);
  const [text, setText] = useState('');
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={() => setIsPlaying(!isPlaying)}>
        {isPlaying ? 'Pause' : 'Play'}
      </button>
      <VideoPlayer
        isPlaying={isPlaying}
        src="https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4"
      />
    </>
  );
}
```

Show more

The dependency array can contain multiple dependencies. React will only skip re-running the Effect if *all* of the dependencies you specify have exactly the same values as they had during the previous render. React compares the dependency values using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. See the [`useEffect` reference](https://react.dev/reference/react/useEffect#reference) for details.

**Notice that you can’t “choose” your dependencies.** You will get a lint error if the dependencies you specified don’t match what React expects based on the code inside your Effect. This helps catch many bugs in your code. If you don’t want some code to re-run, [*edit the Effect code itself* to not “need” that dependency.](https://react.dev/learn/lifecycle-of-reactive-effects#what-to-do-when-you-dont-want-to-re-synchronize)

### Pitfall

The behaviors without the dependency array and with an *empty* `[]` dependency array are different:

```
useEffect(() => {

// This runs after every render

});

useEffect(() => {

// This runs only on mount (when the component appears)

}, []);

useEffect(() => {

// This runs on mount *and also* if either a or b have changed since the last render

}, [a, b]);
```

We’ll take a close look at what “mount” means in the next step.

##### Deep Dive

#### Why was the ref omitted from the dependency array?

Show Details

This Effect uses *both* `ref` and `isPlaying`, but only `isPlaying` is declared as a dependency:

```
function VideoPlayer({ src, isPlaying }) {

const ref = useRef(null);

useEffect(() => {

if (isPlaying) {

ref.current.play();

} else {

ref.current.pause();

}

}, [isPlaying]);
```

This is because the `ref` object has a *stable identity:* React guarantees [you’ll always get the same object](https://react.dev/reference/react/useRef#returns) from the same `useRef` call on every render. It never changes, so it will never by itself cause the Effect to re-run. Therefore, it does not matter whether you include it or not. Including it is fine too:

```
function VideoPlayer({ src, isPlaying }) {

const ref = useRef(null);

useEffect(() => {

if (isPlaying) {

ref.current.play();

} else {

ref.current.pause();

}

}, [isPlaying, ref]);
```

The [`set` functions](https://react.dev/reference/react/useState#setstate) returned by `useState` also have stable identity, so you will often see them omitted from the dependencies too. If the linter lets you omit a dependency without errors, it is safe to do.

Omitting always-stable dependencies only works when the linter can “see” that the object is stable. For example, if `ref` was passed from a parent component, you would have to specify it in the dependency array. However, this is good because you can’t know whether the parent component always passes the same ref, or passes one of several refs conditionally. So your Effect *would* depend on which ref is passed.

### Step 3: Add cleanup if needed

Consider a different example. You’re writing a `ChatRoom` component that needs to connect to the chat server when it appears. You are given a `createConnection()` API that returns an object with `connect()` and `disconnect()` methods. How do you keep the component connected while it is displayed to the user?

Start by writing the Effect logic:

```
useEffect(() => {

const connection = createConnection();

connection.connect();

});
```

It would be slow to connect to the chat after every re-render, so you add the dependency array:

```
useEffect(() => {

const connection = createConnection();

connection.connect();

}, []);
```

**The code inside the Effect does not use any props or state, so your dependency array is `[]` (empty). This tells React to only run this code when the component “mounts”, i.e. appears on the screen for the first time.**

Let’s try running this code:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

This Effect only runs on mount, so you might expect `"✅ Connecting..."` to be printed once in the console. **However, if you check the console, `"✅ Connecting..."` gets printed twice. Why does it happen?**

Imagine the `ChatRoom` component is a part of a larger app with many different screens. The user starts their journey on the `ChatRoom` page. The component mounts and calls `connection.connect()`. Then imagine the user navigates to another screen—for example, to the Settings page. The `ChatRoom` component unmounts. Finally, the user clicks Back and `ChatRoom` mounts again. This would set up a second connection—but the first connection was never destroyed! As the user navigates across the app, the connections would keep piling up.

Bugs like this are easy to miss without extensive manual testing. To help you spot them quickly, in development React remounts every component once immediately after its initial mount.

Seeing the `"✅ Connecting..."` log twice helps you notice the real issue: your code doesn’t close the connection when the component unmounts.

To fix the issue, return a *cleanup function* from your Effect:

```
useEffect(() => {

const connection = createConnection();

connection.connect();

return () => {

connection.disconnect();

};

}, []);
```

React will call your cleanup function each time before the Effect runs again, and one final time when the component unmounts (gets removed). Let’s see what happens when the cleanup function is implemented:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the chat!</h1>;
}
```

Now you get three console logs in development:

1. `"✅ Connecting..."`
2. `"❌ Disconnected."`
3. `"✅ Connecting..."`

**This is the correct behavior in development.** By remounting your component, React verifies that navigating away and back would not break your code. Disconnecting and then connecting again is exactly what should happen! When you implement the cleanup well, there should be no user-visible difference between running the Effect once vs running it, cleaning it up, and running it again. There’s an extra connect/disconnect call pair because React is probing your code for bugs in development. This is normal—don’t try to make it go away!

**In production, you would only see `"✅ Connecting..."` printed once.** Remounting components only happens in development to help you find Effects that need cleanup. You can turn off [Strict Mode](https://react.dev/reference/react/StrictMode) to opt out of the development behavior, but we recommend keeping it on. This lets you find many bugs like the one above.

## How to handle the Effect firing twice in development?

React intentionally remounts your components in development to find bugs like in the last example. **The right question isn’t “how to run an Effect once”, but “how to fix my Effect so that it works after remounting”.**

Usually, the answer is to implement the cleanup function. The cleanup function should stop or undo whatever the Effect was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the Effect running once (as in production) and a *setup → cleanup → setup* sequence (as you’d see in development).

Most of the Effects you’ll write will fit into one of the common patterns below.

### Pitfall

#### Don’t use refs to prevent Effects from firing

A common pitfall for preventing Effects firing twice in development is to use a `ref` to prevent the Effect from running more than once. For example, you could “fix” the above bug with a `useRef`:

```
const connectionRef = useRef(null);

useEffect(() => {

// 🚩 This wont fix the bug!!!

if (!connectionRef.current) {

connectionRef.current = createConnection();

connectionRef.current.connect();

}

}, []);
```

This makes it so you only see `"✅ Connecting..."` once in development, but it doesn’t fix the bug.

When the user navigates away, the connection still isn’t closed and when they navigate back, a new connection is created. As the user navigates across the app, the connections would keep piling up, the same as it would before the “fix”.

To fix the bug, it is not enough to just make the Effect run once. The effect needs to work after re-mounting, which means the connection needs to be cleaned up like in the solution above.

See the examples below for how to handle common patterns.

### Controlling non-React widgets

Sometimes you need to add UI widgets that aren’t written in React. For example, let’s say you’re adding a map component to your page. It has a `setZoomLevel()` method, and you’d like to keep the zoom level in sync with a `zoomLevel` state variable in your React code. Your Effect would look similar to this:

```
useEffect(() => {

const map = mapRef.current;

map.setZoomLevel(zoomLevel);

}, [zoomLevel]);
```

Note that there is no cleanup needed in this case. In development, React will call the Effect twice, but this is not a problem because calling `setZoomLevel` twice with the same value does not do anything. It may be slightly slower, but this doesn’t matter because it won’t remount needlessly in production.

Some APIs may not allow you to call them twice in a row. For example, the [`showModal`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal) method of the built-in [`<dialog>`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement) element throws if you call it twice. Implement the cleanup function and make it close the dialog:

```
useEffect(() => {

const dialog = dialogRef.current;

dialog.showModal();

return () => dialog.close();

}, []);
```

In development, your Effect will call `showModal()`, then immediately `close()`, and then `showModal()` again. This has the same user-visible behavior as calling `showModal()` once, as you would see in production.

### Subscribing to events

If your Effect subscribes to something, the cleanup function should unsubscribe:

```
useEffect(() => {

function handleScroll(e) {

console.log(window.scrollX, window.scrollY);

}

window.addEventListener('scroll', handleScroll);

return () => window.removeEventListener('scroll', handleScroll);

}, []);
```

In development, your Effect will call `addEventListener()`, then immediately `removeEventListener()`, and then `addEventListener()` again with the same handler. So there would be only one active subscription at a time. This has the same user-visible behavior as calling `addEventListener()` once, as in production.

### Triggering animations

If your Effect animates something in, the cleanup function should reset the animation to the initial values:

```
useEffect(() => {

const node = ref.current;

node.style.opacity = 1; // Trigger the animation

return () => {

node.style.opacity = 0; // Reset to the initial value

};

}, []);
```

In development, opacity will be set to `1`, then to `0`, and then to `1` again. This should have the same user-visible behavior as setting it to `1` directly, which is what would happen in production. If you use a third-party animation library with support for tweening, your cleanup function should reset the timeline to its initial state.

### Fetching data

If your Effect fetches something, the cleanup function should either [abort the fetch](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) or ignore its result:

```
useEffect(() => {

let ignore = false;

async function startFetching() {

const json = await fetchTodos(userId);

if (!ignore) {

setTodos(json);

}

}

startFetching();

return () => {

ignore = true;

};

}, [userId]);
```

You can’t “undo” a network request that already happened, but your cleanup function should ensure that the fetch that’s *not relevant anymore* does not keep affecting your application. If the `userId` changes from `'Alice'` to `'Bob'`, cleanup ensures that the `'Alice'` response is ignored even if it arrives after `'Bob'`.

**In development, you will see two fetches in the Network tab.** There is nothing wrong with that. With the approach above, the first Effect will immediately get cleaned up so its copy of the `ignore` variable will be set to `true`. So even though there is an extra request, it won’t affect the state thanks to the `if (!ignore)` check.

**In production, there will only be one request.** If the second request in development is bothering you, the best approach is to use a solution that deduplicates requests and caches their responses between components:

```
function TodoList() {

const todos = useSomeDataLibrary(`/api/user/${userId}/todos`);

// ...
```

This will not only improve the development experience, but also make your application feel faster. For example, the user pressing the Back button won’t have to wait for some data to load again because it will be cached. You can either build such a cache yourself or use one of the many alternatives to manual fetching in Effects.

##### Deep Dive

#### What are good alternatives to data fetching in Effects?

Show Details

Writing `fetch` calls inside Effects is a [popular way to fetch data](https://www.robinwieruch.de/react-hooks-fetch-data/), especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:

* **Effects don’t run on the server.** This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.
* **Fetching directly in Effects makes it easy to create “network waterfalls”.** You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.
* **Fetching directly in Effects usually means you don’t preload or cache data.** For example, if the component unmounts and then mounts again, it would have to fetch the data again.
* **It’s not very ergonomic.** There’s quite a bit of boilerplate code involved when writing `fetch` calls in a way that doesn’t suffer from bugs like [race conditions.](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect)

This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:

* **If you use a [framework](https://react.dev/learn/creating-a-react-app#full-stack-frameworks), use its built-in data fetching mechanism.** Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.
* **Otherwise, consider using or building a client-side cache.** Popular open source solutions include [TanStack Query](https://tanstack.com/query/latest), [useSWR](https://swr.vercel.app/), and [React Router 6.4+.](https://beta.reactrouter.com/en/main/start/overview) You can build your own solution too, in which case you would use Effects under the hood, but add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).

You can continue fetching data directly in Effects if neither of these approaches suit you.

### Sending analytics

Consider this code that sends an analytics event on the page visit:

```
useEffect(() => {

logVisit(url); // Sends a POST request

}, [url]);
```

In development, `logVisit` will be called twice for every URL, so you might be tempted to try to fix that. **We recommend keeping this code as is.** Like with earlier examples, there is no *user-visible* behavior difference between running it once and running it twice. From a practical point of view, `logVisit` should not do anything in development because you don’t want the logs from the development machines to skew the production metrics. Your component remounts every time you save its file, so it logs extra visits in development anyway.

**In production, there will be no duplicate visit logs.**

To debug the analytics events you’re sending, you can deploy your app to a staging environment (which runs in production mode) or temporarily opt out of [Strict Mode](https://react.dev/reference/react/StrictMode) and its development-only remounting checks. You may also send analytics from the route change event handlers instead of Effects. For more precise analytics, [intersection observers](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) can help track which components are in the viewport and how long they remain visible.

### Not an Effect: Initializing the application

Some logic should only run once when the application starts. You can put it outside your components:

```
if (typeof window !== 'undefined') { // Check if we're running in the browser.

checkAuthToken();

loadDataFromLocalStorage();

}

function App() {

// ...

}
```

This guarantees that such logic only runs once after the browser loads the page.

### Not an Effect: Buying a product

Sometimes, even if you write a cleanup function, there’s no way to prevent user-visible consequences of running the Effect twice. For example, maybe your Effect sends a POST request like buying a product:

```
useEffect(() => {

// 🔴 Wrong: This Effect fires twice in development, exposing a problem in the code.

fetch('/api/buy', { method: 'POST' });

}, []);
```

You wouldn’t want to buy the product twice. However, this is also why you shouldn’t put this logic in an Effect. What if the user goes to another page and then presses Back? Your Effect would run again. You don’t want to buy the product when the user *visits* a page; you want to buy it when the user *clicks* the Buy button.

Buying is not caused by rendering; it’s caused by a specific interaction. It should run only when the user presses the button. **Delete the Effect and move your `/api/buy` request into the Buy button event handler:**

```
function handleClick() {

// ✅ Buying is an event because it is caused by a particular interaction.

fetch('/api/buy', { method: 'POST' });

}
```

**This illustrates that if remounting breaks the logic of your application, this usually uncovers existing bugs.** From a user’s perspective, visiting a page shouldn’t be different from visiting it, clicking a link, then pressing Back to view the page again. React verifies that your components abide by this principle by remounting them once in development.

## Putting it all together

This playground can help you “get a feel” for how Effects work in practice.

This example uses [`setTimeout`](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout) to schedule a console log with the input text to appear three seconds after the Effect runs. The cleanup function cancels the pending timeout. Start by pressing “Mount the component”:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

function Playground() {
  const [text, setText] = useState('a');

  useEffect(() => {
    function onTimeout() {
      console.log('⏰ ' + text);
    }

    console.log('🔵 Schedule "' + text + '" log');
    const timeoutId = setTimeout(onTimeout, 3000);

    return () => {
      console.log('🟡 Cancel "' + text + '" log');
      clearTimeout(timeoutId);
    };
  }, [text]);

  return (
    <>
      <label>
        What to log:{' '}
        <input
          value={text}
          onChange={e => setText(e.target.value)}
        />
      </label>
      <h1>{text}</h1>
    </>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Unmount' : 'Mount'} the component
      </button>
      {show && <hr />}
      {show && <Playground />}
    </>
  );
}
```

Show more

You will see three logs at first: `Schedule "a" log`, `Cancel "a" log`, and `Schedule "a" log` again. Three second later there will also be a log saying `a`. As you learned earlier, the extra schedule/cancel pair is because React remounts the component once in development to verify that you’ve implemented cleanup well.

Now edit the input to say `abc`. If you do it fast enough, you’ll see `Schedule "ab" log` immediately followed by `Cancel "ab" log` and `Schedule "abc" log`. **React always cleans up the previous render’s Effect before the next render’s Effect.** This is why even if you type into the input fast, there is at most one timeout scheduled at a time. Edit the input a few times and watch the console to get a feel for how Effects get cleaned up.

Type something into the input and then immediately press “Unmount the component”. Notice how unmounting cleans up the last render’s Effect. Here, it clears the last timeout before it has a chance to fire.

Finally, edit the component above and comment out the cleanup function so that the timeouts don’t get cancelled. Try typing `abcde` fast. What do you expect to happen in three seconds? Will `console.log(text)` inside the timeout print the *latest* `text` and produce five `abcde` logs? Give it a try to check your intuition!

Three seconds later, you should see a sequence of logs (`a`, `ab`, `abc`, `abcd`, and `abcde`) rather than five `abcde` logs. **Each Effect “captures” the `text` value from its corresponding render.** It doesn’t matter that the `text` state changed: an Effect from the render with `text = 'ab'` will always see `'ab'`. In other words, Effects from each render are isolated from each other. If you’re curious how this works, you can read about [closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures).

##### Deep Dive

#### Each render has its own Effects

Show Details

You can think of `useEffect` as “attaching” a piece of behavior to the render output. Consider this Effect:

```
export default function ChatRoom({ roomId }) {

useEffect(() => {

const connection = createConnection(roomId);

connection.connect();

return () => connection.disconnect();

}, [roomId]);

return <h1>Welcome to {roomId}!</h1>;

}
```

Let’s see what exactly happens as the user navigates around the app.

#### Initial render

The user visits `<ChatRoom roomId="general" />`. Let’s [mentally substitute](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time) `roomId` with `'general'`:

```
// JSX for the first render (roomId = "general")

return <h1>Welcome to general!</h1>;
```

**The Effect is *also* a part of the rendering output.** The first render’s Effect becomes:

```
// Effect for the first render (roomId = "general")

() => {

const connection = createConnection('general');

connection.connect();

return () => connection.disconnect();

},

// Dependencies for the first render (roomId = "general")

['general']
```

React runs this Effect, which connects to the `'general'` chat room.

#### Re-render with same dependencies

Let’s say `<ChatRoom roomId="general" />` re-renders. The JSX output is the same:

```
// JSX for the second render (roomId = "general")

return <h1>Welcome to general!</h1>;
```

React sees that the rendering output has not changed, so it doesn’t update the DOM.

The Effect from the second render looks like this:

```
// Effect for the second render (roomId = "general")

() => {

const connection = createConnection('general');

connection.connect();

return () => connection.disconnect();

},

// Dependencies for the second render (roomId = "general")

['general']
```

React compares `['general']` from the second render with `['general']` from the first render. **Because all dependencies are the same, React *ignores* the Effect from the second render.** It never gets called.

#### Re-render with different dependencies

Then, the user visits `<ChatRoom roomId="travel" />`. This time, the component returns different JSX:

```
// JSX for the third render (roomId = "travel")

return <h1>Welcome to travel!</h1>;
```

React updates the DOM to change `"Welcome to general"` into `"Welcome to travel"`.

The Effect from the third render looks like this:

```
// Effect for the third render (roomId = "travel")

() => {

const connection = createConnection('travel');

connection.connect();

return () => connection.disconnect();

},

// Dependencies for the third render (roomId = "travel")

['travel']
```

React compares `['travel']` from the third render with `['general']` from the second render. One dependency is different: `Object.is('travel', 'general')` is `false`. The Effect can’t be skipped.

**Before React can apply the Effect from the third render, it needs to clean up the last Effect that *did* run.** The second render’s Effect was skipped, so React needs to clean up the first render’s Effect. If you scroll up to the first render, you’ll see that its cleanup calls `disconnect()` on the connection that was created with `createConnection('general')`. This disconnects the app from the `'general'` chat room.

After that, React runs the third render’s Effect. It connects to the `'travel'` chat room.

#### Unmount

Finally, let’s say the user navigates away, and the `ChatRoom` component unmounts. React runs the last Effect’s cleanup function. The last Effect was from the third render. The third render’s cleanup destroys the `createConnection('travel')` connection. So the app disconnects from the `'travel'` room.

#### Development-only behaviors

When [Strict Mode](https://react.dev/reference/react/StrictMode) is on, React remounts every component once after mount (state and DOM are preserved). This [helps you find Effects that need cleanup](https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) and exposes bugs like race conditions early. Additionally, React will remount the Effects whenever you save a file in development. Both of these behaviors are development-only.

## Recap

* Unlike events, Effects are caused by rendering itself rather than a particular interaction.
* Effects let you synchronize a component with some external system (third-party API, network, etc).
* By default, Effects run after every render (including the initial one).
* React will skip the Effect if all of its dependencies have the same values as during the last render.
* You can’t “choose” your dependencies. They are determined by the code inside the Effect.
* Empty dependency array (`[]`) corresponds to the component “mounting”, i.e. being added to the screen.
* In Strict Mode, React mounts components twice (in development only!) to stress-test your Effects.
* If your Effect breaks because of remounting, you need to implement a cleanup function.
* React will call your cleanup function before the Effect runs next time, and during the unmount.

## Try out some challenges

1. Focus a field on mount 2. Focus a field conditionally 3. Fix an interval that fires twice 4. Fix fetching inside an Effect

#### Challenge 1 of 4: Focus a field on mount

In this example, the form renders a `<MyInput />` component.

Use the input’s [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) method to make `MyInput` automatically focus when it appears on the screen. There is already a commented out implementation, but it doesn’t quite work. Figure out why it doesn’t work, and fix it. (If you’re familiar with the `autoFocus` attribute, pretend that it does not exist: we are reimplementing the same functionality from scratch.)

MyInput.js

MyInput.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useEffect, useRef } from 'react';

export default function MyInput({ value, onChange }) {
  const ref = useRef(null);

  // TODO: This doesn't quite work. Fix it.
  // ref.current.focus()

  return (
    <input
      ref={ref}
      value={value}
      onChange={onChange}
    />
  );
}
```

Show more

To verify that your solution works, press “Show form” and verify that the input receives focus (becomes highlighted and the cursor is placed inside). Press “Hide form” and “Show form” again. Verify the input is highlighted again.

`MyInput` should only focus *on mount* rather than after every render. To verify that the behavior is right, press “Show form” and then repeatedly press the “Make it uppercase” checkbox. Clicking the checkbox should *not* focus the input above it.

Show solutionNext Challenge

[PreviousManipulating the DOM with Refs](https://react.dev/learn/manipulating-the-dom-with-refs)[NextYou Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)

---

---


# You Might Not Need an Effect – React

URL: https://react.dev/learn/you-might-not-need-an-effect

[Learn React](https://react.dev/learn)

[Escape Hatches](https://react.dev/learn/escape-hatches)

# You Might Not Need an Effect

Effects are an escape hatch from the React paradigm. They let you “step outside” of React and synchronize your components with some external system like a non-React widget, network, or the browser DOM. If there is no external system involved (for example, if you want to update a component’s state when some props or state change), you shouldn’t need an Effect. Removing unnecessary Effects will make your code easier to follow, faster to run, and less error-prone.

### You will learn

* Why and how to remove unnecessary Effects from your components
* How to cache expensive computations without Effects
* How to reset and adjust component state without Effects
* How to share logic between event handlers
* Which logic should be moved to event handlers
* How to notify parent components about changes

## How to remove unnecessary Effects

There are two common cases in which you don’t need Effects:

* **You don’t need Effects to transform data for rendering.** For example, let’s say you want to filter a list before displaying it. You might feel tempted to write an Effect that updates a state variable when the list changes. However, this is inefficient. When you update the state, React will first call your component functions to calculate what should be on the screen. Then React will [“commit”](https://react.dev/learn/render-and-commit) these changes to the DOM, updating the screen. Then React will run your Effects. If your Effect *also* immediately updates the state, this restarts the whole process from scratch! To avoid the unnecessary render passes, transform all the data at the top level of your components. That code will automatically re-run whenever your props or state change.
* **You don’t need Effects to handle user events.** For example, let’s say you want to send an `/api/buy` POST request and show a notification when the user buys a product. In the Buy button click event handler, you know exactly what happened. By the time an Effect runs, you don’t know *what* the user did (for example, which button was clicked). This is why you’ll usually handle user events in the corresponding event handlers.

You *do* need Effects to [synchronize](https://react.dev/learn/synchronizing-with-effects#what-are-effects-and-how-are-they-different-from-events) with external systems. For example, you can write an Effect that keeps a jQuery widget synchronized with the React state. You can also fetch data with Effects: for example, you can synchronize the search results with the current search query. Keep in mind that modern [frameworks](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) provide more efficient built-in data fetching mechanisms than writing Effects directly in your components.

To help you gain the right intuition, let’s look at some common concrete examples!

### Updating state based on props or state

Suppose you have a component with two state variables: `firstName` and `lastName`. You want to calculate a `fullName` from them by concatenating them. Moreover, you’d like `fullName` to update whenever `firstName` or `lastName` change. Your first instinct might be to add a `fullName` state variable and update it in an Effect:

```
function Form() {

const [firstName, setFirstName] = useState('Taylor');

const [lastName, setLastName] = useState('Swift');

// 🔴 Avoid: redundant state and unnecessary Effect

const [fullName, setFullName] = useState('');

useEffect(() => {

setFullName(firstName + ' ' + lastName);

}, [firstName, lastName]);

// ...

}
```

This is more complicated than necessary. It is inefficient too: it does an entire render pass with a stale value for `fullName`, then immediately re-renders with the updated value. Remove the state variable and the Effect:

```
function Form() {

const [firstName, setFirstName] = useState('Taylor');

const [lastName, setLastName] = useState('Swift');

// ✅ Good: calculated during rendering

const fullName = firstName + ' ' + lastName;

// ...

}
```

**When something can be calculated from the existing props or state, [don’t put it in state.](https://react.dev/learn/choosing-the-state-structure#avoid-redundant-state) Instead, calculate it during rendering.** This makes your code faster (you avoid the extra “cascading” updates), simpler (you remove some code), and less error-prone (you avoid bugs caused by different state variables getting out of sync with each other). If this approach feels new to you, [Thinking in React](https://react.dev/learn/thinking-in-react#step-3-find-the-minimal-but-complete-representation-of-ui-state) explains what should go into state.

### Caching expensive calculations

This component computes `visibleTodos` by taking the `todos` it receives by props and filtering them according to the `filter` prop. You might feel tempted to store the result in state and update it from an Effect:

```
function TodoList({ todos, filter }) {

const [newTodo, setNewTodo] = useState('');

// 🔴 Avoid: redundant state and unnecessary Effect

const [visibleTodos, setVisibleTodos] = useState([]);

useEffect(() => {

setVisibleTodos(getFilteredTodos(todos, filter));

}, [todos, filter]);

// ...

}
```

Like in the earlier example, this is both unnecessary and inefficient. First, remove the state and the Effect:

```
function TodoList({ todos, filter }) {

const [newTodo, setNewTodo] = useState('');

// ✅ This is fine if getFilteredTodos() is not slow.

const visibleTodos = getFilteredTodos(todos, filter);

// ...

}
```

Usually, this code is fine! But maybe `getFilteredTodos()` is slow or you have a lot of `todos`. In that case you don’t want to recalculate `getFilteredTodos()` if some unrelated state variable like `newTodo` has changed.

You can cache (or [“memoize”](https://en.wikipedia.org/wiki/Memoization)) an expensive calculation by wrapping it in a [`useMemo`](https://react.dev/reference/react/useMemo) Hook:

### Note

[React Compiler](https://react.dev/learn/react-compiler) can automatically memoize expensive calculations for you, eliminating the need for manual `useMemo` in many cases.

```
import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {

const [newTodo, setNewTodo] = useState('');

const visibleTodos = useMemo(() => {

// ✅ Does not re-run unless todos or filter change

return getFilteredTodos(todos, filter);

}, [todos, filter]);

// ...

}
```

Or, written as a single line:

```
import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {

const [newTodo, setNewTodo] = useState('');

// ✅ Does not re-run getFilteredTodos() unless todos or filter change

const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);

// ...

}
```

**This tells React that you don’t want the inner function to re-run unless either `todos` or `filter` have changed.** React will remember the return value of `getFilteredTodos()` during the initial render. During the next renders, it will check if `todos` or `filter` are different. If they’re the same as last time, `useMemo` will return the last result it has stored. But if they are different, React will call the inner function again (and store its result).

The function you wrap in [`useMemo`](https://react.dev/reference/react/useMemo) runs during rendering, so this only works for [pure calculations.](https://react.dev/learn/keeping-components-pure)

##### Deep Dive

#### How to tell if a calculation is expensive?

Show Details

In general, unless you’re creating or looping over thousands of objects, it’s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:

```
console.time('filter array');

const visibleTodos = getFilteredTodos(todos, filter);

console.timeEnd('filter array');
```

Perform the interaction you’re measuring (for example, typing into the input). You will then see logs like `filter array: 0.15ms` in your console. If the overall logged time adds up to a significant amount (say, `1ms` or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in `useMemo` to verify whether the total logged time has decreased for that interaction or not:

```
console.time('filter array');

const visibleTodos = useMemo(() => {

return getFilteredTodos(todos, filter); // Skipped if todos and filter haven't changed

}, [todos, filter]);

console.timeEnd('filter array');
```

`useMemo` won’t make the *first* render faster. It only helps you skip unnecessary work on updates.

Keep in mind that your machine is probably faster than your users’ so it’s a good idea to test the performance with an artificial slowdown. For example, Chrome offers a [CPU Throttling](https://developer.chrome.com/blog/new-in-devtools-61/#throttling) option for this.

Also note that measuring performance in development will not give you the most accurate results. (For example, when [Strict Mode](https://react.dev/reference/react/StrictMode) is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.

### Resetting all state when a prop changes

This `ProfilePage` component receives a `userId` prop. The page contains a comment input, and you use a `comment` state variable to hold its value. One day, you notice a problem: when you navigate from one profile to another, the `comment` state does not get reset. As a result, it’s easy to accidentally post a comment on a wrong user’s profile. To fix the issue, you want to clear out the `comment` state variable whenever the `userId` changes:

```
export default function ProfilePage({ userId }) {

const [comment, setComment] = useState('');

// 🔴 Avoid: Resetting state on prop change in an Effect

useEffect(() => {

setComment('');

}, [userId]);

// ...

}
```

This is inefficient because `ProfilePage` and its children will first render with the stale value, and then render again. It is also complicated because you’d need to do this in *every* component that has some state inside `ProfilePage`. For example, if the comment UI is nested, you’d want to clear out nested comment state too.

Instead, you can tell React that each user’s profile is conceptually a *different* profile by giving it an explicit key. Split your component in two and pass a `key` attribute from the outer component to the inner one:

```
export default function ProfilePage({ userId }) {

return (

<Profile

userId={userId}

key={userId}

/>

);

}

function Profile({ userId }) {

// ✅ This and any other state below will reset on key change automatically

const [comment, setComment] = useState('');

// ...

}
```

Normally, React preserves the state when the same component is rendered in the same spot. **By passing `userId` as a `key` to the `Profile` component, you’re asking React to treat two `Profile` components with different `userId` as two different components that should not share any state.** Whenever the key (which you’ve set to `userId`) changes, React will recreate the DOM and [reset the state](https://react.dev/learn/preserving-and-resetting-state#option-2-resetting-state-with-a-key) of the `Profile` component and all of its children. Now the `comment` field will clear out automatically when navigating between profiles.

Note that in this example, only the outer `ProfilePage` component is exported and visible to other files in the project. Components rendering `ProfilePage` don’t need to pass the key to it: they pass `userId` as a regular prop. The fact `ProfilePage` passes it as a `key` to the inner `Profile` component is an implementation detail.

### Adjusting some state when a prop changes

Sometimes, you might want to reset or adjust a part of the state on a prop change, but not all of it.

This `List` component receives a list of `items` as a prop, and maintains the selected item in the `selection` state variable. You want to reset the `selection` to `null` whenever the `items` prop receives a different array:

```
function List({ items }) {

const [isReverse, setIsReverse] = useState(false);

const [selection, setSelection] = useState(null);

// 🔴 Avoid: Adjusting state on prop change in an Effect

useEffect(() => {

setSelection(null);

}, [items]);

// ...

}
```

This, too, is not ideal. Every time the `items` change, the `List` and its child components will render with a stale `selection` value at first. Then React will update the DOM and run the Effects. Finally, the `setSelection(null)` call will cause another re-render of the `List` and its child components, restarting this whole process again.

Start by deleting the Effect. Instead, adjust the state directly during rendering:

```
function List({ items }) {

const [isReverse, setIsReverse] = useState(false);

const [selection, setSelection] = useState(null);

// Better: Adjust the state while rendering

const [prevItems, setPrevItems] = useState(items);

if (items !== prevItems) {

setPrevItems(items);

setSelection(null);

}

// ...

}
```

[Storing information from previous renders](https://react.dev/reference/react/useState#storing-information-from-previous-renders) like this can be hard to understand, but it’s better than updating the same state in an Effect. In the above example, `setSelection` is called directly during a render. React will re-render the `List` *immediately* after it exits with a `return` statement. React has not rendered the `List` children or updated the DOM yet, so this lets the `List` children skip rendering the stale `selection` value.

When you update a component during rendering, React throws away the returned JSX and immediately retries rendering. To avoid very slow cascading retries, React only lets you update the *same* component’s state during a render. If you update another component’s state during a render, you’ll see an error. A condition like `items !== prevItems` is necessary to avoid loops. You may adjust state like this, but any other side effects (like changing the DOM or setting timeouts) should stay in event handlers or Effects to [keep components pure.](https://react.dev/learn/keeping-components-pure)

**Although this pattern is more efficient than an Effect, most components shouldn’t need it either.** No matter how you do it, adjusting state based on props or other state makes your data flow more difficult to understand and debug. Always check whether you can [reset all state with a key](https://react.dev/learn/you-might-not-need-an-effect#resetting-all-state-when-a-prop-changes) or [calculate everything during rendering](https://react.dev/learn/you-might-not-need-an-effect#updating-state-based-on-props-or-state) instead. For example, instead of storing (and resetting) the selected *item*, you can store the selected *item ID:*

```
function List({ items }) {

const [isReverse, setIsReverse] = useState(false);

const [selectedId, setSelectedId] = useState(null);

// ✅ Best: Calculate everything during rendering

const selection = items.find(item => item.id === selectedId) ?? null;

// ...

}
```

Now there is no need to “adjust” the state at all. If the item with the selected ID is in the list, it remains selected. If it’s not, the `selection` calculated during rendering will be `null` because no matching item was found. This behavior is different, but arguably better because most changes to `items` preserve the selection.

### Sharing logic between event handlers

Let’s say you have a product page with two buttons (Buy and Checkout) that both let you buy that product. You want to show a notification whenever the user puts the product in the cart. Calling `showNotification()` in both buttons’ click handlers feels repetitive so you might be tempted to place this logic in an Effect:

```
function ProductPage({ product, addToCart }) {

// 🔴 Avoid: Event-specific logic inside an Effect

useEffect(() => {

if (product.isInCart) {

showNotification(`Added ${product.name} to the shopping cart!`);

}

}, [product]);

function handleBuyClick() {

addToCart(product);

}

function handleCheckoutClick() {

addToCart(product);

navigateTo('/checkout');

}

// ...

}
```

This Effect is unnecessary. It will also most likely cause bugs. For example, let’s say that your app “remembers” the shopping cart between the page reloads. If you add a product to the cart once and refresh the page, the notification will appear again. It will keep appearing every time you refresh that product’s page. This is because `product.isInCart` will already be `true` on the page load, so the Effect above will call `showNotification()`.

**When you’re not sure whether some code should be in an Effect or in an event handler, ask yourself *why* this code needs to run. Use Effects only for code that should run *because* the component was displayed to the user.** In this example, the notification should appear because the user *pressed the button*, not because the page was displayed! Delete the Effect and put the shared logic into a function called from both event handlers:

```
function ProductPage({ product, addToCart }) {

// ✅ Good: Event-specific logic is called from event handlers

function buyProduct() {

addToCart(product);

showNotification(`Added ${product.name} to the shopping cart!`);

}

function handleBuyClick() {

buyProduct();

}

function handleCheckoutClick() {

buyProduct();

navigateTo('/checkout');

}

// ...

}
```

This both removes the unnecessary Effect and fixes the bug.

### Sending a POST request

This `Form` component sends two kinds of POST requests. It sends an analytics event when it mounts. When you fill in the form and click the Submit button, it will send a POST request to the `/api/register` endpoint:

```
function Form() {

const [firstName, setFirstName] = useState('');

const [lastName, setLastName] = useState('');

// ✅ Good: This logic should run because the component was displayed

useEffect(() => {

post('/analytics/event', { eventName: 'visit_form' });

}, []);

// 🔴 Avoid: Event-specific logic inside an Effect

const [jsonToSubmit, setJsonToSubmit] = useState(null);

useEffect(() => {

if (jsonToSubmit !== null) {

post('/api/register', jsonToSubmit);

}

}, [jsonToSubmit]);

function handleSubmit(e) {

e.preventDefault();

setJsonToSubmit({ firstName, lastName });

}

// ...

}
```

Let’s apply the same criteria as in the example before.

The analytics POST request should remain in an Effect. This is because the *reason* to send the analytics event is that the form was displayed. (It would fire twice in development, but [see here](https://react.dev/learn/synchronizing-with-effects#sending-analytics) for how to deal with that.)

However, the `/api/register` POST request is not caused by the form being *displayed*. You only want to send the request at one specific moment in time: when the user presses the button. It should only ever happen *on that particular interaction*. Delete the second Effect and move that POST request into the event handler:

```
function Form() {

const [firstName, setFirstName] = useState('');

const [lastName, setLastName] = useState('');

// ✅ Good: This logic runs because the component was displayed

useEffect(() => {

post('/analytics/event', { eventName: 'visit_form' });

}, []);

function handleSubmit(e) {

e.preventDefault();

// ✅ Good: Event-specific logic is in the event handler

post('/api/register', { firstName, lastName });

}

// ...

}
```

When you choose whether to put some logic into an event handler or an Effect, the main question you need to answer is *what kind of logic* it is from the user’s perspective. If this logic is caused by a particular interaction, keep it in the event handler. If it’s caused by the user *seeing* the component on the screen, keep it in the Effect.

### Chains of computations

Sometimes you might feel tempted to chain Effects that each adjust a piece of state based on other state:

```
function Game() {

const [card, setCard] = useState(null);

const [goldCardCount, setGoldCardCount] = useState(0);

const [round, setRound] = useState(1);

const [isGameOver, setIsGameOver] = useState(false);

// 🔴 Avoid: Chains of Effects that adjust the state solely to trigger each other

useEffect(() => {

if (card !== null && card.gold) {

setGoldCardCount(c => c + 1);

}

}, [card]);

useEffect(() => {

if (goldCardCount > 3) {

setRound(r => r + 1)

setGoldCardCount(0);

}

}, [goldCardCount]);

useEffect(() => {

if (round > 5) {

setIsGameOver(true);

}

}, [round]);

useEffect(() => {

alert('Good game!');

}, [isGameOver]);

function handlePlaceCard(nextCard) {

if (isGameOver) {

throw Error('Game already ended.');

} else {

setCard(nextCard);

}

}

// ...
```

There are two problems with this code.

The first problem is that it is very inefficient: the component (and its children) have to re-render between each `set` call in the chain. In the example above, in the worst case (`setCard` → render → `setGoldCardCount` → render → `setRound` → render → `setIsGameOver` → render) there are three unnecessary re-renders of the tree below.

The second problem is that even if it weren’t slow, as your code evolves, you will run into cases where the “chain” you wrote doesn’t fit the new requirements. Imagine you are adding a way to step through the history of the game moves. You’d do it by updating each state variable to a value from the past. However, setting the `card` state to a value from the past would trigger the Effect chain again and change the data you’re showing. Such code is often rigid and fragile.

In this case, it’s better to calculate what you can during rendering, and adjust the state in the event handler:

```
function Game() {

const [card, setCard] = useState(null);

const [goldCardCount, setGoldCardCount] = useState(0);

const [round, setRound] = useState(1);

// ✅ Calculate what you can during rendering

const isGameOver = round > 5;

function handlePlaceCard(nextCard) {

if (isGameOver) {

throw Error('Game already ended.');

}

// ✅ Calculate all the next state in the event handler

setCard(nextCard);

if (nextCard.gold) {

if (goldCardCount < 3) {

setGoldCardCount(goldCardCount + 1);

} else {

setGoldCardCount(0);

setRound(round + 1);

if (round === 5) {

alert('Good game!');

}

}

}

}

// ...
```

This is a lot more efficient. Also, if you implement a way to view game history, now you will be able to set each state variable to a move from the past without triggering the Effect chain that adjusts every other value. If you need to reuse logic between several event handlers, you can [extract a function](https://react.dev/learn/you-might-not-need-an-effect#sharing-logic-between-event-handlers) and call it from those handlers.

Remember that inside event handlers, [state behaves like a snapshot.](https://react.dev/learn/state-as-a-snapshot) For example, even after you call `setRound(round + 1)`, the `round` variable will reflect the value at the time the user clicked the button. If you need to use the next value for calculations, define it manually like `const nextRound = round + 1`.

In some cases, you *can’t* calculate the next state directly in the event handler. For example, imagine a form with multiple dropdowns where the options of the next dropdown depend on the selected value of the previous dropdown. Then, a chain of Effects is appropriate because you are synchronizing with network.

### Initializing the application

Some logic should only run once when the app loads.

You might be tempted to place it in an Effect in the top-level component:

```
function App() {

// 🔴 Avoid: Effects with logic that should only ever run once

useEffect(() => {

loadDataFromLocalStorage();

checkAuthToken();

}, []);

// ...

}
```

However, you’ll quickly discover that it [runs twice in development.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development) This can cause issues—for example, maybe it invalidates the authentication token because the function wasn’t designed to be called twice. In general, your components should be resilient to being remounted. This includes your top-level `App` component.

Although it may not ever get remounted in practice in production, following the same constraints in all components makes it easier to move and reuse code. If some logic must run *once per app load* rather than *once per component mount*, add a top-level variable to track whether it has already executed:

```
let didInit = false;

function App() {

useEffect(() => {

if (!didInit) {

didInit = true;

// ✅ Only runs once per app load

loadDataFromLocalStorage();

checkAuthToken();

}

}, []);

// ...

}
```

You can also run it during module initialization and before the app renders:

```
if (typeof window !== 'undefined') { // Check if we're running in the browser.

// ✅ Only runs once per app load

checkAuthToken();

loadDataFromLocalStorage();

}

function App() {

// ...

}
```

Code at the top level runs once when your component is imported—even if it doesn’t end up being rendered. To avoid slowdown or surprising behavior when importing arbitrary components, don’t overuse this pattern. Keep app-wide initialization logic to root component modules like `App.js` or in your application’s entry point.

### Notifying parent components about state changes

Let’s say you’re writing a `Toggle` component with an internal `isOn` state which can be either `true` or `false`. There are a few different ways to toggle it (by clicking or dragging). You want to notify the parent component whenever the `Toggle` internal state changes, so you expose an `onChange` event and call it from an Effect:

```
function Toggle({ onChange }) {

const [isOn, setIsOn] = useState(false);

// 🔴 Avoid: The onChange handler runs too late

useEffect(() => {

onChange(isOn);

}, [isOn, onChange])

function handleClick() {

setIsOn(!isOn);

}

function handleDragEnd(e) {

if (isCloserToRightEdge(e)) {

setIsOn(true);

} else {

setIsOn(false);

}

}

// ...

}
```

Like earlier, this is not ideal. The `Toggle` updates its state first, and React updates the screen. Then React runs the Effect, which calls the `onChange` function passed from a parent component. Now the parent component will update its own state, starting another render pass. It would be better to do everything in a single pass.

Delete the Effect and instead update the state of *both* components within the same event handler:

```
function Toggle({ onChange }) {

const [isOn, setIsOn] = useState(false);

function updateToggle(nextIsOn) {

// ✅ Good: Perform all updates during the event that caused them

setIsOn(nextIsOn);

onChange(nextIsOn);

}

function handleClick() {

updateToggle(!isOn);

}

function handleDragEnd(e) {

if (isCloserToRightEdge(e)) {

updateToggle(true);

} else {

updateToggle(false);

}

}

// ...

}
```

With this approach, both the `Toggle` component and its parent component update their state during the event. React [batches updates](https://react.dev/learn/queueing-a-series-of-state-updates) from different components together, so there will only be one render pass.

You might also be able to remove the state altogether, and instead receive `isOn` from the parent component:

```
// ✅ Also good: the component is fully controlled by its parent

function Toggle({ isOn, onChange }) {

function handleClick() {

onChange(!isOn);

}

function handleDragEnd(e) {

if (isCloserToRightEdge(e)) {

onChange(true);

} else {

onChange(false);

}

}

// ...

}
```

[“Lifting state up”](https://react.dev/learn/sharing-state-between-components) lets the parent component fully control the `Toggle` by toggling the parent’s own state. This means the parent component will have to contain more logic, but there will be less state overall to worry about. Whenever you try to keep two different state variables synchronized, try lifting state up instead!

### Passing data to the parent

This `Child` component fetches some data and then passes it to the `Parent` component in an Effect:

```
function Parent() {

const [data, setData] = useState(null);

// ...

return <Child onFetched={setData} />;

}

function Child({ onFetched }) {

const data = useSomeAPI();

// 🔴 Avoid: Passing data to the parent in an Effect

useEffect(() => {

if (data) {

onFetched(data);

}

}, [onFetched, data]);

// ...

}
```

In React, data flows from the parent components to their children. When you see something wrong on the screen, you can trace where the information comes from by going up the component chain until you find which component passes the wrong prop or has the wrong state. When child components update the state of their parent components in Effects, the data flow becomes very difficult to trace. Since both the child and the parent need the same data, let the parent component fetch that data, and *pass it down* to the child instead:

```
function Parent() {

const data = useSomeAPI();

// ...

// ✅ Good: Passing data down to the child

return <Child data={data} />;

}

function Child({ data }) {

// ...

}
```

This is simpler and keeps the data flow predictable: the data flows down from the parent to the child.

### Subscribing to an external store

Sometimes, your components may need to subscribe to some data outside of the React state. This data could be from a third-party library or a built-in browser API. Since this data can change without React’s knowledge, you need to manually subscribe your components to it. This is often done with an Effect, for example:

```
function useOnlineStatus() {

// Not ideal: Manual store subscription in an Effect

const [isOnline, setIsOnline] = useState(true);

useEffect(() => {

function updateState() {

setIsOnline(navigator.onLine);

}

updateState();

window.addEventListener('online', updateState);

window.addEventListener('offline', updateState);

return () => {

window.removeEventListener('online', updateState);

window.removeEventListener('offline', updateState);

};

}, []);

return isOnline;

}

function ChatIndicator() {

const isOnline = useOnlineStatus();

// ...

}
```

Here, the component subscribes to an external data store (in this case, the browser `navigator.onLine` API). Since this API does not exist on the server (so it can’t be used for the initial HTML), initially the state is set to `true`. Whenever the value of that data store changes in the browser, the component updates its state.

Although it’s common to use Effects for this, React has a purpose-built Hook for subscribing to an external store that is preferred instead. Delete the Effect and replace it with a call to [`useSyncExternalStore`](https://react.dev/reference/react/useSyncExternalStore):

```
function subscribe(callback) {

window.addEventListener('online', callback);

window.addEventListener('offline', callback);

return () => {

window.removeEventListener('online', callback);

window.removeEventListener('offline', callback);

};

}

function useOnlineStatus() {

// ✅ Good: Subscribing to an external store with a built-in Hook

return useSyncExternalStore(

subscribe, // React won't resubscribe for as long as you pass the same function

() => navigator.onLine, // How to get the value on the client

() => true // How to get the value on the server

);

}

function ChatIndicator() {

const isOnline = useOnlineStatus();

// ...

}
```

This approach is less error-prone than manually syncing mutable data to React state with an Effect. Typically, you’ll write a custom Hook like `useOnlineStatus()` above so that you don’t need to repeat this code in the individual components. [Read more about subscribing to external stores from React components.](https://react.dev/reference/react/useSyncExternalStore)

### Fetching data

Many apps use Effects to kick off data fetching. It is quite common to write a data fetching Effect like this:

```
function SearchResults({ query }) {

const [results, setResults] = useState([]);

const [page, setPage] = useState(1);

useEffect(() => {

// 🔴 Avoid: Fetching without cleanup logic

fetchResults(query, page).then(json => {

setResults(json);

});

}, [query, page]);

function handleNextPageClick() {

setPage(page + 1);

}

// ...

}
```

You *don’t* need to move this fetch to an event handler.

This might seem like a contradiction with the earlier examples where you needed to put the logic into the event handlers! However, consider that it’s not *the typing event* that’s the main reason to fetch. Search inputs are often prepopulated from the URL, and the user might navigate Back and Forward without touching the input.

It doesn’t matter where `page` and `query` come from. While this component is visible, you want to keep `results` [synchronized](https://react.dev/learn/synchronizing-with-effects) with data from the network for the current `page` and `query`. This is why it’s an Effect.

However, the code above has a bug. Imagine you type `"hello"` fast. Then the `query` will change from `"h"`, to `"he"`, `"hel"`, `"hell"`, and `"hello"`. This will kick off separate fetches, but there is no guarantee about which order the responses will arrive in. For example, the `"hell"` response may arrive *after* the `"hello"` response. Since it will call `setResults()` last, you will be displaying the wrong search results. This is called a [“race condition”](https://en.wikipedia.org/wiki/Race_condition): two different requests “raced” against each other and came in a different order than you expected.

**To fix the race condition, you need to [add a cleanup function](https://react.dev/learn/synchronizing-with-effects#fetching-data) to ignore stale responses:**

```
function SearchResults({ query }) {

const [results, setResults] = useState([]);

const [page, setPage] = useState(1);

useEffect(() => {

let ignore = false;

fetchResults(query, page).then(json => {

if (!ignore) {

setResults(json);

}

});

return () => {

ignore = true;

};

}, [query, page]);

function handleNextPageClick() {

setPage(page + 1);

}

// ...

}
```

This ensures that when your Effect fetches data, all responses except the last requested one will be ignored.

Handling race conditions is not the only difficulty with implementing data fetching. You might also want to think about caching responses (so that the user can click Back and see the previous screen instantly), how to fetch data on the server (so that the initial server-rendered HTML contains the fetched content instead of a spinner), and how to avoid network waterfalls (so that a child can fetch data without waiting for every parent).

**These issues apply to any UI library, not just React. Solving them is not trivial, which is why modern [frameworks](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) provide more efficient built-in data fetching mechanisms than fetching data in Effects.**

If you don’t use a framework (and don’t want to build your own) but would like to make data fetching from Effects more ergonomic, consider extracting your fetching logic into a custom Hook like in this example:

```
function SearchResults({ query }) {

const [page, setPage] = useState(1);

const params = new URLSearchParams({ query, page });

const results = useData(`/api/search?${params}`);

function handleNextPageClick() {

setPage(page + 1);

}

// ...

}

function useData(url) {

const [data, setData] = useState(null);

useEffect(() => {

let ignore = false;

fetch(url)

.then(response => response.json())

.then(json => {

if (!ignore) {

setData(json);

}

});

return () => {

ignore = true;

};

}, [url]);

return data;

}
```

You’ll likely also want to add some logic for error handling and to track whether the content is loading. You can build a Hook like this yourself or use one of the many solutions already available in the React ecosystem. **Although this alone won’t be as efficient as using a framework’s built-in data fetching mechanism, moving the data fetching logic into a custom Hook will make it easier to adopt an efficient data fetching strategy later.**

In general, whenever you have to resort to writing Effects, keep an eye out for when you can extract a piece of functionality into a custom Hook with a more declarative and purpose-built API like `useData` above. The fewer raw `useEffect` calls you have in your components, the easier you will find to maintain your application.

## Recap

* If you can calculate something during render, you don’t need an Effect.
* To cache expensive calculations, add `useMemo` instead of `useEffect`.
* To reset the state of an entire component tree, pass a different `key` to it.
* To reset a particular bit of state in response to a prop change, set it during rendering.
* Code that runs because a component was *displayed* should be in Effects, the rest should be in events.
* If you need to update the state of several components, it’s better to do it during a single event.
* Whenever you try to synchronize state variables in different components, consider lifting state up.
* You can fetch data with Effects, but you need to implement cleanup to avoid race conditions.

## Try out some challenges

1. Transform data without Effects 2. Cache a calculation without Effects 3. Reset state without Effects 4. Submit a form without Effects

#### Challenge 1 of 4: Transform data without Effects

The `TodoList` below displays a list of todos. When the “Show only active todos” checkbox is ticked, completed todos are not displayed in the list. Regardless of which todos are visible, the footer displays the count of todos that are not yet completed.

Simplify this component by removing all the unnecessary state and Effects.

App.jstodos.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { initialTodos, createTodo } from './todos.js';

export default function TodoList() {
  const [todos, setTodos] = useState(initialTodos);
  const [showActive, setShowActive] = useState(false);
  const [activeTodos, setActiveTodos] = useState([]);
  const [visibleTodos, setVisibleTodos] = useState([]);
  const [footer, setFooter] = useState(null);

  useEffect(() => {
    setActiveTodos(todos.filter(todo => !todo.completed));
  }, [todos]);

  useEffect(() => {
    setVisibleTodos(showActive ? activeTodos : todos);
  }, [showActive, todos, activeTodos]);

  useEffect(() => {
    setFooter(
      <footer>
        {activeTodos.length} todos left
      </footer>
    );
  }, [activeTodos]);

  return (
    <>
      <label>
        <input
          type="checkbox"
          checked={showActive}
          onChange={e => setShowActive(e.target.checked)}
        />
        Show only active todos
      </label>
      <NewTodo onAdd={newTodo => setTodos([...todos, newTodo])} />
      <ul>
        {visibleTodos.map(todo => (
          <li key={todo.id}>
            {todo.completed ? <s>{todo.text}</s> : todo.text}
          </li>
        ))}
      </ul>
      {footer}
    </>
  );
}

function NewTodo({ onAdd }) {
  const [text, setText] = useState('');

  function handleAddClick() {
    setText('');
    onAdd(createTodo(text));
  }

  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <button onClick={handleAddClick}>
        Add
      </button>
    </>
  );
}
```

Show more

Show hint Show solution

Next Challenge

[PreviousSynchronizing with Effects](https://react.dev/learn/synchronizing-with-effects)[NextLifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)

---

---


# Lifecycle of Reactive Effects – React

URL: https://react.dev/learn/lifecycle-of-reactive-effects

[Learn React](https://react.dev/learn)

[Escape Hatches](https://react.dev/learn/escape-hatches)

# Lifecycle of Reactive Effects

Effects have a different lifecycle from components. Components may mount, update, or unmount. An Effect can only do two things: to start synchronizing something, and later to stop synchronizing it. This cycle can happen multiple times if your Effect depends on props and state that change over time. React provides a linter rule to check that you’ve specified your Effect’s dependencies correctly. This keeps your Effect synchronized to the latest props and state.

### You will learn

* How an Effect’s lifecycle is different from a component’s lifecycle
* How to think about each individual Effect in isolation
* When your Effect needs to re-synchronize, and why
* How your Effect’s dependencies are determined
* What it means for a value to be reactive
* What an empty dependency array means
* How React verifies your dependencies are correct with a linter
* What to do when you disagree with the linter

## The lifecycle of an Effect

Every React component goes through the same lifecycle:

* A component *mounts* when it’s added to the screen.
* A component *updates* when it receives new props or state, usually in response to an interaction.
* A component *unmounts* when it’s removed from the screen.

**It’s a good way to think about components, but *not* about Effects.** Instead, try to think about each Effect independently from your component’s lifecycle. An Effect describes how to [synchronize an external system](https://react.dev/learn/synchronizing-with-effects) to the current props and state. As your code changes, synchronization will need to happen more or less often.

To illustrate this point, consider this Effect connecting your component to a chat server:

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, [roomId]);

// ...

}
```

Your Effect’s body specifies how to **start synchronizing:**

```
// ...

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

// ...
```

The cleanup function returned by your Effect specifies how to **stop synchronizing:**

```
// ...

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

// ...
```

Intuitively, you might think that React would **start synchronizing** when your component mounts and **stop synchronizing** when your component unmounts. However, this is not the end of the story! Sometimes, it may also be necessary to **start and stop synchronizing multiple times** while the component remains mounted.

Let’s look at *why* this is necessary, *when* it happens, and *how* you can control this behavior.

### Note

Some Effects don’t return a cleanup function at all. [More often than not,](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development) you’ll want to return one—but if you don’t, React will behave as if you returned an empty cleanup function.

### Why synchronization may need to happen more than once

Imagine this `ChatRoom` component receives a `roomId` prop that the user picks in a dropdown. Let’s say that initially the user picks the `"general"` room as the `roomId`. Your app displays the `"general"` chat room:

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId /* "general" */ }) {

// ...

return <h1>Welcome to the {roomId} room!</h1>;

}
```

After the UI is displayed, React will run your Effect to **start synchronizing.** It connects to the `"general"` room:

```
function ChatRoom({ roomId /* "general" */ }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId); // Connects to the "general" room

connection.connect();

return () => {

connection.disconnect(); // Disconnects from the "general" room

};

}, [roomId]);

// ...
```

So far, so good.

Later, the user picks a different room in the dropdown (for example, `"travel"`). First, React will update the UI:

```
function ChatRoom({ roomId /* "travel" */ }) {

// ...

return <h1>Welcome to the {roomId} room!</h1>;

}
```

Think about what should happen next. The user sees that `"travel"` is the selected chat room in the UI. However, the Effect that ran the last time is still connected to the `"general"` room. **The `roomId` prop has changed, so what your Effect did back then (connecting to the `"general"` room) no longer matches the UI.**

At this point, you want React to do two things:

1. Stop synchronizing with the old `roomId` (disconnect from the `"general"` room)
2. Start synchronizing with the new `roomId` (connect to the `"travel"` room)

**Luckily, you’ve already taught React how to do both of these things!** Your Effect’s body specifies how to start synchronizing, and your cleanup function specifies how to stop synchronizing. All that React needs to do now is to call them in the correct order and with the correct props and state. Let’s see how exactly that happens.

### How React re-synchronizes your Effect

Recall that your `ChatRoom` component has received a new value for its `roomId` prop. It used to be `"general"`, and now it is `"travel"`. React needs to re-synchronize your Effect to re-connect you to a different room.

To **stop synchronizing,** React will call the cleanup function that your Effect returned after connecting to the `"general"` room. Since `roomId` was `"general"`, the cleanup function disconnects from the `"general"` room:

```
function ChatRoom({ roomId /* "general" */ }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId); // Connects to the "general" room

connection.connect();

return () => {

connection.disconnect(); // Disconnects from the "general" room

};

// ...
```

Then React will run the Effect that you’ve provided during this render. This time, `roomId` is `"travel"` so it will **start synchronizing** to the `"travel"` chat room (until its cleanup function is eventually called too):

```
function ChatRoom({ roomId /* "travel" */ }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId); // Connects to the "travel" room

connection.connect();

// ...
```

Thanks to this, you’re now connected to the same room that the user chose in the UI. Disaster averted!

Every time after your component re-renders with a different `roomId`, your Effect will re-synchronize. For example, let’s say the user changes `roomId` from `"travel"` to `"music"`. React will again **stop synchronizing** your Effect by calling its cleanup function (disconnecting you from the `"travel"` room). Then it will **start synchronizing** again by running its body with the new `roomId` prop (connecting you to the `"music"` room).

Finally, when the user goes to a different screen, `ChatRoom` unmounts. Now there is no need to stay connected at all. React will **stop synchronizing** your Effect one last time and disconnect you from the `"music"` chat room.

### Thinking from the Effect’s perspective

Let’s recap everything that’s happened from the `ChatRoom` component’s perspective:

1. `ChatRoom` mounted with `roomId` set to `"general"`
2. `ChatRoom` updated with `roomId` set to `"travel"`
3. `ChatRoom` updated with `roomId` set to `"music"`
4. `ChatRoom` unmounted

During each of these points in the component’s lifecycle, your Effect did different things:

1. Your Effect connected to the `"general"` room
2. Your Effect disconnected from the `"general"` room and connected to the `"travel"` room
3. Your Effect disconnected from the `"travel"` room and connected to the `"music"` room
4. Your Effect disconnected from the `"music"` room

Now let’s think about what happened from the perspective of the Effect itself:

```
useEffect(() => {

// Your Effect connected to the room specified with roomId...

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

// ...until it disconnected

connection.disconnect();

};

}, [roomId]);
```

This code’s structure might inspire you to see what happened as a sequence of non-overlapping time periods:

1. Your Effect connected to the `"general"` room (until it disconnected)
2. Your Effect connected to the `"travel"` room (until it disconnected)
3. Your Effect connected to the `"music"` room (until it disconnected)

Previously, you were thinking from the component’s perspective. When you looked from the component’s perspective, it was tempting to think of Effects as “callbacks” or “lifecycle events” that fire at a specific time like “after a render” or “before unmount”. This way of thinking gets complicated very fast, so it’s best to avoid.

**Instead, always focus on a single start/stop cycle at a time. It shouldn’t matter whether a component is mounting, updating, or unmounting. All you need to do is to describe how to start synchronization and how to stop it. If you do it well, your Effect will be resilient to being started and stopped as many times as it’s needed.**

This might remind you how you don’t think whether a component is mounting or updating when you write the rendering logic that creates JSX. You describe what should be on the screen, and React [figures out the rest.](https://react.dev/learn/reacting-to-input-with-state)

### How React verifies that your Effect can re-synchronize

Here is a live example that you can play with. Press “Open chat” to mount the `ChatRoom` component:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}
```

Show more

Notice that when the component mounts for the first time, you see three logs:

1. `✅ Connecting to "general" room at https://localhost:1234...` *(development-only)*
2. `❌ Disconnected from "general" room at https://localhost:1234.` *(development-only)*
3. `✅ Connecting to "general" room at https://localhost:1234...`

The first two logs are development-only. In development, React always remounts each component once.

**React verifies that your Effect can re-synchronize by forcing it to do that immediately in development.** This might remind you of opening a door and closing it an extra time to check if the door lock works. React starts and stops your Effect one extra time in development to check [you’ve implemented its cleanup well.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)

The main reason your Effect will re-synchronize in practice is if some data it uses has changed. In the sandbox above, change the selected chat room. Notice how, when the `roomId` changes, your Effect re-synchronizes.

However, there are also more unusual cases in which re-synchronization is necessary. For example, try editing the `serverUrl` in the sandbox above while the chat is open. Notice how the Effect re-synchronizes in response to your edits to the code. In the future, React may add more features that rely on re-synchronization.

### How React knows that it needs to re-synchronize the Effect

You might be wondering how React knew that your Effect needed to re-synchronize after `roomId` changes. It’s because *you told React* that its code depends on `roomId` by including it in the [list of dependencies:](https://react.dev/learn/synchronizing-with-effects#step-2-specify-the-effect-dependencies)

```
function ChatRoom({ roomId }) { // The roomId prop may change over time

useEffect(() => {

const connection = createConnection(serverUrl, roomId); // This Effect reads roomId

connection.connect();

return () => {

connection.disconnect();

};

}, [roomId]); // So you tell React that this Effect "depends on" roomId

// ...
```

Here’s how this works:

1. You knew `roomId` is a prop, which means it can change over time.
2. You knew that your Effect reads `roomId` (so its logic depends on a value that may change later).
3. This is why you specified it as your Effect’s dependency (so that it re-synchronizes when `roomId` changes).

Every time after your component re-renders, React will look at the array of dependencies that you have passed. If any of the values in the array is different from the value at the same spot that you passed during the previous render, React will re-synchronize your Effect.

For example, if you passed `["general"]` during the initial render, and later you passed `["travel"]` during the next render, React will compare `"general"` and `"travel"`. These are different values (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), so React will re-synchronize your Effect. On the other hand, if your component re-renders but `roomId` has not changed, your Effect will remain connected to the same room.

### Each Effect represents a separate synchronization process

Resist adding unrelated logic to your Effect only because this logic needs to run at the same time as an Effect you already wrote. For example, let’s say you want to send an analytics event when the user visits the room. You already have an Effect that depends on `roomId`, so you might feel tempted to add the analytics call there:

```
function ChatRoom({ roomId }) {

useEffect(() => {

logVisit(roomId);

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, [roomId]);

// ...

}
```

But imagine you later add another dependency to this Effect that needs to re-establish the connection. If this Effect re-synchronizes, it will also call `logVisit(roomId)` for the same room, which you did not intend. Logging the visit **is a separate process** from connecting. Write them as two separate Effects:

```
function ChatRoom({ roomId }) {

useEffect(() => {

logVisit(roomId);

}, [roomId]);

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

// ...

}, [roomId]);

// ...

}
```

**Each Effect in your code should represent a separate and independent synchronization process.**

In the above example, deleting one Effect wouldn’t break the other Effect’s logic. This is a good indication that they synchronize different things, and so it made sense to split them up. On the other hand, if you split up a cohesive piece of logic into separate Effects, the code may look “cleaner” but will be [more difficult to maintain.](https://react.dev/learn/you-might-not-need-an-effect#chains-of-computations) This is why you should think whether the processes are same or separate, not whether the code looks cleaner.

## Effects “react” to reactive values

Your Effect reads two variables (`serverUrl` and `roomId`), but you only specified `roomId` as a dependency:

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, [roomId]);

// ...

}
```

Why doesn’t `serverUrl` need to be a dependency?

This is because the `serverUrl` never changes due to a re-render. It’s always the same no matter how many times the component re-renders and why. Since `serverUrl` never changes, it wouldn’t make sense to specify it as a dependency. After all, dependencies only do something when they change over time!

On the other hand, `roomId` may be different on a re-render. **Props, state, and other values declared inside the component are *reactive* because they’re calculated during rendering and participate in the React data flow.**

If `serverUrl` was a state variable, it would be reactive. Reactive values must be included in dependencies:

```
function ChatRoom({ roomId }) { // Props change over time

const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // State may change over time

useEffect(() => {

const connection = createConnection(serverUrl, roomId); // Your Effect reads props and state

connection.connect();

return () => {

connection.disconnect();

};

}, [roomId, serverUrl]); // So you tell React that this Effect "depends on" on props and state

// ...

}
```

By including `serverUrl` as a dependency, you ensure that the Effect re-synchronizes after it changes.

Try changing the selected chat room or edit the server URL in this sandbox:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

Whenever you change a reactive value like `roomId` or `serverUrl`, the Effect re-connects to the chat server.

### What an Effect with empty dependencies means

What happens if you move both `serverUrl` and `roomId` outside the component?

```
const serverUrl = 'https://localhost:1234';

const roomId = 'general';

function ChatRoom() {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, []); // ✅ All dependencies declared

// ...

}
```

Now your Effect’s code does not use *any* reactive values, so its dependencies can be empty (`[]`).

Thinking from the component’s perspective, the empty `[]` dependency array means this Effect connects to the chat room only when the component mounts, and disconnects only when the component unmounts. (Keep in mind that React would still [re-synchronize it an extra time](https://react.dev/learn/lifecycle-of-reactive-effects#how-react-verifies-that-your-effect-can-re-synchronize) in development to stress-test your logic.)

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';
const roomId = 'general';

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom />}
    </>
  );
}
```

Show more

However, if you [think from the Effect’s perspective,](https://react.dev/learn/lifecycle-of-reactive-effects#thinking-from-the-effects-perspective) you don’t need to think about mounting and unmounting at all. What’s important is you’ve specified what your Effect does to start and stop synchronizing. Today, it has no reactive dependencies. But if you ever want the user to change `roomId` or `serverUrl` over time (and they would become reactive), your Effect’s code won’t change. You will only need to add them to the dependencies.

### All variables declared in the component body are reactive

Props and state aren’t the only reactive values. Values that you calculate from them are also reactive. If the props or state change, your component will re-render, and the values calculated from them will also change. This is why all variables from the component body used by the Effect should be in the Effect dependency list.

Let’s say that the user can pick a chat server in the dropdown, but they can also configure a default server in settings. Suppose you’ve already put the settings state in a [context](https://react.dev/learn/scaling-up-with-reducer-and-context) so you read the `settings` from that context. Now you calculate the `serverUrl` based on the selected server from props and the default server:

```
function ChatRoom({ roomId, selectedServerUrl }) { // roomId is reactive

const settings = useContext(SettingsContext); // settings is reactive

const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl is reactive

useEffect(() => {

const connection = createConnection(serverUrl, roomId); // Your Effect reads roomId and serverUrl

connection.connect();

return () => {

connection.disconnect();

};

}, [roomId, serverUrl]); // So it needs to re-synchronize when either of them changes!

// ...

}
```

In this example, `serverUrl` is not a prop or a state variable. It’s a regular variable that you calculate during rendering. But it’s calculated during rendering, so it can change due to a re-render. This is why it’s reactive.

**All values inside the component (including props, state, and variables in your component’s body) are reactive. Any reactive value can change on a re-render, so you need to include reactive values as Effect’s dependencies.**

In other words, Effects “react” to all values from the component body.

##### Deep Dive

#### Can global or mutable values be dependencies?

Show Details

Mutable values (including global variables) aren’t reactive.

**A mutable value like [`location.pathname`](https://developer.mozilla.org/en-US/docs/Web/API/Location/pathname) can’t be a dependency.** It’s mutable, so it can change at any time completely outside of the React rendering data flow. Changing it wouldn’t trigger a re-render of your component. Therefore, even if you specified it in the dependencies, React *wouldn’t know* to re-synchronize the Effect when it changes. This also breaks the rules of React because reading mutable data during rendering (which is when you calculate the dependencies) breaks [purity of rendering.](https://react.dev/learn/keeping-components-pure) Instead, you should read and subscribe to an external mutable value with [`useSyncExternalStore`.](https://react.dev/learn/you-might-not-need-an-effect#subscribing-to-an-external-store)

**A mutable value like [`ref.current`](https://react.dev/reference/react/useRef#reference) or things you read from it also can’t be a dependency.** The ref object returned by `useRef` itself can be a dependency, but its `current` property is intentionally mutable. It lets you [keep track of something without triggering a re-render.](https://react.dev/learn/referencing-values-with-refs) But since changing it doesn’t trigger a re-render, it’s not a reactive value, and React won’t know to re-run your Effect when it changes.

As you’ll learn below on this page, a linter will check for these issues automatically.

### React verifies that you specified every reactive value as a dependency

If your linter is [configured for React,](https://react.dev/learn/editor-setup#linting) it will check that every reactive value used by your Effect’s code is declared as its dependency. For example, this is a lint error because both `roomId` and `serverUrl` are reactive:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) { // roomId is reactive
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // <-- Something's wrong here!

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

This may look like a React error, but really React is pointing out a bug in your code. Both `roomId` and `serverUrl` may change over time, but you’re forgetting to re-synchronize your Effect when they change. You will remain connected to the initial `roomId` and `serverUrl` even after the user picks different values in the UI.

To fix the bug, follow the linter’s suggestion to specify `roomId` and `serverUrl` as dependencies of your Effect:

```
function ChatRoom({ roomId }) { // roomId is reactive

const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, [serverUrl, roomId]); // ✅ All dependencies declared

// ...

}
```

Try this fix in the sandbox above. Verify that the linter error is gone, and the chat re-connects when needed.

### Note

In some cases, React *knows* that a value never changes even though it’s declared inside the component. For example, the [`set` function](https://react.dev/reference/react/useState#setstate) returned from `useState` and the ref object returned by [`useRef`](https://react.dev/reference/react/useRef) are *stable*—they are guaranteed to not change on a re-render. Stable values aren’t reactive, so you may omit them from the list. Including them is allowed: they won’t change, so it doesn’t matter.

### What to do when you don’t want to re-synchronize

In the previous example, you’ve fixed the lint error by listing `roomId` and `serverUrl` as dependencies.

**However, you could instead “prove” to the linter that these values aren’t reactive values,** i.e. that they *can’t* change as a result of a re-render. For example, if `serverUrl` and `roomId` don’t depend on rendering and always have the same values, you can move them outside the component. Now they don’t need to be dependencies:

```
const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive

const roomId = 'general'; // roomId is not reactive

function ChatRoom() {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, []); // ✅ All dependencies declared

// ...

}
```

You can also move them *inside the Effect.* They aren’t calculated during rendering, so they’re not reactive:

```
function ChatRoom() {

useEffect(() => {

const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive

const roomId = 'general'; // roomId is not reactive

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, []); // ✅ All dependencies declared

// ...

}
```

**Effects are reactive blocks of code.** They re-synchronize when the values you read inside of them change. Unlike event handlers, which only run once per interaction, Effects run whenever synchronization is necessary.

**You can’t “choose” your dependencies.** Your dependencies must include every [reactive value](https://react.dev/learn/lifecycle-of-reactive-effects#all-variables-declared-in-the-component-body-are-reactive) you read in the Effect. The linter enforces this. Sometimes this may lead to problems like infinite loops and to your Effect re-synchronizing too often. Don’t fix these problems by suppressing the linter! Here’s what to try instead:

* **Check that your Effect represents an independent synchronization process.** If your Effect doesn’t synchronize anything, [it might be unnecessary.](https://react.dev/learn/you-might-not-need-an-effect) If it synchronizes several independent things, [split it up.](https://react.dev/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process)
* **If you want to read the latest value of props or state without “reacting” to it and re-synchronizing the Effect,** you can split your Effect into a reactive part (which you’ll keep in the Effect) and a non-reactive part (which you’ll extract into something called an *Effect Event*). [Read about separating Events from Effects.](https://react.dev/learn/separating-events-from-effects)
* **Avoid relying on objects and functions as dependencies.** If you create objects and functions during rendering and then read them from an Effect, they will be different on every render. This will cause your Effect to re-synchronize every time. [Read more about removing unnecessary dependencies from Effects.](https://react.dev/learn/removing-effect-dependencies)

### Pitfall

The linter is your friend, but its powers are limited. The linter only knows when the dependencies are *wrong*. It doesn’t know *the best* way to solve each case. If the linter suggests a dependency, but adding it causes a loop, it doesn’t mean the linter should be ignored. You need to change the code inside (or outside) the Effect so that that value isn’t reactive and doesn’t *need* to be a dependency.

If you have an existing codebase, you might have some Effects that suppress the linter like this:

```
useEffect(() => {

// ...

// 🔴 Avoid suppressing the linter like this:

// eslint-ignore-next-line react-hooks/exhaustive-deps

}, []);
```

On the [next](https://react.dev/learn/separating-events-from-effects) [pages](https://react.dev/learn/removing-effect-dependencies), you’ll learn how to fix this code without breaking the rules. It’s always worth fixing!

## Recap

* Components can mount, update, and unmount.
* Each Effect has a separate lifecycle from the surrounding component.
* Each Effect describes a separate synchronization process that can *start* and *stop*.
* When you write and read Effects, think from each individual Effect’s perspective (how to start and stop synchronization) rather than from the component’s perspective (how it mounts, updates, or unmounts).
* Values declared inside the component body are “reactive”.
* Reactive values should re-synchronize the Effect because they can change over time.
* The linter verifies that all reactive values used inside the Effect are specified as dependencies.
* All errors flagged by the linter are legitimate. There’s always a way to fix the code to not break the rules.

## Try out some challenges

1. Fix reconnecting on every keystroke 2. Switch synchronization on and off 3. Investigate a stale value bug 4. Fix a connection switch 5. Populate a chain of select boxes

#### Challenge 1 of 5: Fix reconnecting on every keystroke

In this example, the `ChatRoom` component connects to the chat room when the component mounts, disconnects when it unmounts, and reconnects when you select a different chat room. This behavior is correct, so you need to keep it working.

However, there is a problem. Whenever you type into the message box input at the bottom, `ChatRoom` *also* reconnects to the chat. (You can notice this by clearing the console and typing into the input.) Fix the issue so that this doesn’t happen.

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  });

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input
        value={message}
        onChange={e => setMessage(e.target.value)}
      />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

Show hint Show solution

Next Challenge

[PreviousYou Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)[NextSeparating Events from Effects](https://react.dev/learn/separating-events-from-effects)

---

---


# Separating Events from Effects – React

URL: https://react.dev/learn/separating-events-from-effects

[Learn React](https://react.dev/learn)

[Escape Hatches](https://react.dev/learn/escape-hatches)

# Separating Events from Effects

Event handlers only re-run when you perform the same interaction again. Unlike event handlers, Effects re-synchronize if some value they read, like a prop or a state variable, is different from what it was during the last render. Sometimes, you also want a mix of both behaviors: an Effect that re-runs in response to some values but not others. This page will teach you how to do that.

### You will learn

* How to choose between an event handler and an Effect
* Why Effects are reactive, and event handlers are not
* What to do when you want a part of your Effect’s code to not be reactive
* What Effect Events are, and how to extract them from your Effects
* How to read the latest props and state from Effects using Effect Events

## Choosing between event handlers and Effects

First, let’s recap the difference between event handlers and Effects.

Imagine you’re implementing a chat room component. Your requirements look like this:

1. Your component should automatically connect to the selected chat room.
2. When you click the “Send” button, it should send a message to the chat.

Let’s say you’ve already implemented the code for them, but you’re not sure where to put it. Should you use event handlers or Effects? Every time you need to answer this question, consider [*why* the code needs to run.](https://react.dev/learn/synchronizing-with-effects#what-are-effects-and-how-are-they-different-from-events)

### Event handlers run in response to specific interactions

From the user’s perspective, sending a message should happen *because* the particular “Send” button was clicked. The user will get rather upset if you send their message at any other time or for any other reason. This is why sending a message should be an event handler. Event handlers let you handle specific interactions:

```
function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

// ...

function handleSendClick() {

sendMessage(message);

}

// ...

return (

<>

<input value={message} onChange={e => setMessage(e.target.value)} />

<button onClick={handleSendClick}>Send</button>

</>

);

}
```

With an event handler, you can be sure that `sendMessage(message)` will *only* run if the user presses the button.

### Effects run whenever synchronization is needed

Recall that you also need to keep the component connected to the chat room. Where does that code go?

The *reason* to run this code is not some particular interaction. It doesn’t matter why or how the user navigated to the chat room screen. Now that they’re looking at it and could interact with it, the component needs to stay connected to the selected chat server. Even if the chat room component was the initial screen of your app, and the user has not performed any interactions at all, you would *still* need to connect. This is why it’s an Effect:

```
function ChatRoom({ roomId }) {

// ...

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, [roomId]);

// ...

}
```

With this code, you can be sure that there is always an active connection to the currently selected chat server, *regardless* of the specific interactions performed by the user. Whether the user has only opened your app, selected a different room, or navigated to another screen and back, your Effect ensures that the component will *remain synchronized* with the currently selected room, and will [re-connect whenever it’s necessary.](https://react.dev/learn/lifecycle-of-reactive-effects#why-synchronization-may-need-to-happen-more-than-once)

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  function handleSendClick() {
    sendMessage(message);
  }

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Send</button>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}
```

Show more

## Reactive values and reactive logic

Intuitively, you could say that event handlers are always triggered “manually”, for example by clicking a button. Effects, on the other hand, are “automatic”: they run and re-run as often as it’s needed to stay synchronized.

There is a more precise way to think about this.

Props, state, and variables declared inside your component’s body are called reactive values. In this example, `serverUrl` is not a reactive value, but `roomId` and `message` are. They participate in the rendering data flow:

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

// ...

}
```

Reactive values like these can change due to a re-render. For example, the user may edit the `message` or choose a different `roomId` in a dropdown. Event handlers and Effects respond to changes differently:

* **Logic inside event handlers is *not reactive.*** It will not run again unless the user performs the same interaction (e.g. a click) again. Event handlers can read reactive values without “reacting” to their changes.
* **Logic inside Effects is *reactive.*** If your Effect reads a reactive value, [you have to specify it as a dependency.](https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) Then, if a re-render causes that value to change, React will re-run your Effect’s logic with the new value.

Let’s revisit the previous example to illustrate this difference.

### Logic inside event handlers is not reactive

Take a look at this line of code. Should this logic be reactive or not?

```
// ...

sendMessage(message);

// ...
```

From the user’s perspective, **a change to the `message` does *not* mean that they want to send a message.** It only means that the user is typing. In other words, the logic that sends a message should not be reactive. It should not run again only because the reactive value has changed. That’s why it belongs in the event handler:

```
function handleSendClick() {

sendMessage(message);

}
```

Event handlers aren’t reactive, so `sendMessage(message)` will only run when the user clicks the Send button.

### Logic inside Effects is reactive

Now let’s return to these lines:

```
// ...

const connection = createConnection(serverUrl, roomId);

connection.connect();

// ...
```

From the user’s perspective, **a change to the `roomId` *does* mean that they want to connect to a different room.** In other words, the logic for connecting to the room should be reactive. You *want* these lines of code to “keep up” with the reactive value, and to run again if that value is different. That’s why it belongs in an Effect:

```
useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect()

};

}, [roomId]);
```

Effects are reactive, so `createConnection(serverUrl, roomId)` and `connection.connect()` will run for every distinct value of `roomId`. Your Effect keeps the chat connection synchronized to the currently selected room.

## Extracting non-reactive logic out of Effects

Things get more tricky when you want to mix reactive logic with non-reactive logic.

For example, imagine that you want to show a notification when the user connects to the chat. You read the current theme (dark or light) from the props so that you can show the notification in the correct color:

```
function ChatRoom({ roomId, theme }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.on('connected', () => {

showNotification('Connected!', theme);

});

connection.connect();

// ...
```

However, `theme` is a reactive value (it can change as a result of re-rendering), and [every reactive value read by an Effect must be declared as its dependency.](https://react.dev/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency) Now you have to specify `theme` as a dependency of your Effect:

```
function ChatRoom({ roomId, theme }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.on('connected', () => {

showNotification('Connected!', theme);

});

connection.connect();

return () => {

connection.disconnect()

};

}, [roomId, theme]); // ✅ All dependencies declared

// ...
```

Play with this example and see if you can spot the problem with this user experience:

App.jschat.jsnotifications.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

Show more

When the `roomId` changes, the chat re-connects as you would expect. But since `theme` is also a dependency, the chat *also* re-connects every time you switch between the dark and the light theme. That’s not great!

In other words, you *don’t* want this line to be reactive, even though it is inside an Effect (which is reactive):

```
// ...

showNotification('Connected!', theme);

// ...
```

You need a way to separate this non-reactive logic from the reactive Effect around it.

### Declaring an Effect Event

Use a special Hook called [`useEffectEvent`](https://react.dev/reference/react/useEffectEvent) to extract this non-reactive logic out of your Effect:

```
import { useEffect, useEffectEvent } from 'react';

function ChatRoom({ roomId, theme }) {

const onConnected = useEffectEvent(() => {

showNotification('Connected!', theme);

});

// ...
```

Here, `onConnected` is called an *Effect Event.* It’s a part of your Effect logic, but it behaves a lot more like an event handler. The logic inside it is not reactive, and it always “sees” the latest values of your props and state.

Now you can call the `onConnected` Effect Event from inside your Effect:

```
function ChatRoom({ roomId, theme }) {

const onConnected = useEffectEvent(() => {

showNotification('Connected!', theme);

});

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.on('connected', () => {

onConnected();

});

connection.connect();

return () => connection.disconnect();

}, [roomId]); // ✅ All dependencies declared

// ...
```

This solves the problem. Note that you had to *remove* `theme` from the list of your Effect’s dependencies, because it’s no longer used in the Effect. You also don’t need to *add* `onConnected` to it, because **Effect Events are not reactive and must be omitted from dependencies.**

Verify that the new behavior works as you would expect:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { useEffectEvent } from 'react';
import { createConnection, sendMessage } from './chat.js';
import { showNotification } from './notifications.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return <h1>Welcome to the {roomId} room!</h1>
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [isDark, setIsDark] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <label>
        <input
          type="checkbox"
          checked={isDark}
          onChange={e => setIsDark(e.target.checked)}
        />
        Use dark theme
      </label>
      <hr />
      <ChatRoom
        roomId={roomId}
        theme={isDark ? 'dark' : 'light'}
      />
    </>
  );
}
```

Show more

You can think of Effect Events as being very similar to event handlers. The main difference is that event handlers run in response to a user interactions, whereas Effect Events are triggered by you from Effects. Effect Events let you “break the chain” between the reactivity of Effects and code that should not be reactive.

### Reading latest props and state with Effect Events

Effect Events let you fix many patterns where you might be tempted to suppress the dependency linter.

For example, say you have an Effect to log the page visits:

```
function Page() {

useEffect(() => {

logVisit();

}, []);

// ...

}
```

Later, you add multiple routes to your site. Now your `Page` component receives a `url` prop with the current path. You want to pass the `url` as a part of your `logVisit` call, but the dependency linter complains:

```
function Page({ url }) {

useEffect(() => {

logVisit(url);

}, []); // 🔴 React Hook useEffect has a missing dependency: 'url'

// ...

}
```

Think about what you want the code to do. You *want* to log a separate visit for different URLs since each URL represents a different page. In other words, this `logVisit` call *should* be reactive with respect to the `url`. This is why, in this case, it makes sense to follow the dependency linter, and add `url` as a dependency:

```
function Page({ url }) {

useEffect(() => {

logVisit(url);

}, [url]); // ✅ All dependencies declared

// ...

}
```

Now let’s say you want to include the number of items in the shopping cart together with every page visit:

```
function Page({ url }) {

const { items } = useContext(ShoppingCartContext);

const numberOfItems = items.length;

useEffect(() => {

logVisit(url, numberOfItems);

}, [url]); // 🔴 React Hook useEffect has a missing dependency: 'numberOfItems'

// ...

}
```

You used `numberOfItems` inside the Effect, so the linter asks you to add it as a dependency. However, you *don’t* want the `logVisit` call to be reactive with respect to `numberOfItems`. If the user puts something into the shopping cart, and the `numberOfItems` changes, this *does not mean* that the user visited the page again. In other words, *visiting the page* is, in some sense, an “event”. It happens at a precise moment in time.

Split the code in two parts:

```
function Page({ url }) {

const { items } = useContext(ShoppingCartContext);

const numberOfItems = items.length;

const onVisit = useEffectEvent(visitedUrl => {

logVisit(visitedUrl, numberOfItems);

});

useEffect(() => {

onVisit(url);

}, [url]); // ✅ All dependencies declared

// ...

}
```

Here, `onVisit` is an Effect Event. The code inside it isn’t reactive. This is why you can use `numberOfItems` (or any other reactive value!) without worrying that it will cause the surrounding code to re-execute on changes.

On the other hand, the Effect itself remains reactive. Code inside the Effect uses the `url` prop, so the Effect will re-run after every re-render with a different `url`. This, in turn, will call the `onVisit` Effect Event.

As a result, you will call `logVisit` for every change to the `url`, and always read the latest `numberOfItems`. However, if `numberOfItems` changes on its own, this will not cause any of the code to re-run.

### Note

You might be wondering if you could call `onVisit()` with no arguments, and read the `url` inside it:

```
const onVisit = useEffectEvent(() => {

logVisit(url, numberOfItems);

});

useEffect(() => {

onVisit();

}, [url]);
```

This would work, but it’s better to pass this `url` to the Effect Event explicitly. **By passing `url` as an argument to your Effect Event, you are saying that visiting a page with a different `url` constitutes a separate “event” from the user’s perspective.** The `visitedUrl` is a *part* of the “event” that happened:

```
const onVisit = useEffectEvent(visitedUrl => {

logVisit(visitedUrl, numberOfItems);

});

useEffect(() => {

onVisit(url);

}, [url]);
```

Since your Effect Event explicitly “asks” for the `visitedUrl`, now you can’t accidentally remove `url` from the Effect’s dependencies. If you remove the `url` dependency (causing distinct page visits to be counted as one), the linter will warn you about it. You want `onVisit` to be reactive with regards to the `url`, so instead of reading the `url` inside (where it wouldn’t be reactive), you pass it *from* your Effect.

This becomes especially important if there is some asynchronous logic inside the Effect:

```
const onVisit = useEffectEvent(visitedUrl => {

logVisit(visitedUrl, numberOfItems);

});

useEffect(() => {

setTimeout(() => {

onVisit(url);

}, 5000); // Delay logging visits

}, [url]);
```

Here, `url` inside `onVisit` corresponds to the *latest* `url` (which could have already changed), but `visitedUrl` corresponds to the `url` that originally caused this Effect (and this `onVisit` call) to run.

##### Deep Dive

#### Is it okay to suppress the dependency linter instead?

Show Details

In the existing codebases, you may sometimes see the lint rule suppressed like this:

```
function Page({ url }) {

const { items } = useContext(ShoppingCartContext);

const numberOfItems = items.length;

useEffect(() => {

logVisit(url, numberOfItems);

// 🔴 Avoid suppressing the linter like this:

// eslint-disable-next-line react-hooks/exhaustive-deps

}, [url]);

// ...

}
```

We recommend **never suppressing the linter**.

The first downside of suppressing the rule is that React will no longer warn you when your Effect needs to “react” to a new reactive dependency you’ve introduced to your code. In the earlier example, you added `url` to the dependencies *because* React reminded you to do it. You will no longer get such reminders for any future edits to that Effect if you disable the linter. This leads to bugs.

Here is an example of a confusing bug caused by suppressing the linter. In this example, the `handleMove` function is supposed to read the current `canMove` state variable value in order to decide whether the dot should follow the cursor. However, `canMove` is always `true` inside `handleMove`.

Can you see why?

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener('pointermove', handleMove);
    return () => window.removeEventListener('pointermove', handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

Show more

The problem with this code is in suppressing the dependency linter. If you remove the suppression, you’ll see that this Effect should depend on the `handleMove` function. This makes sense: `handleMove` is declared inside the component body, which makes it a reactive value. Every reactive value must be specified as a dependency, or it can potentially get stale over time!

The author of the original code has “lied” to React by saying that the Effect does not depend (`[]`) on any reactive values. This is why React did not re-synchronize the Effect after `canMove` has changed (and `handleMove` with it). Because React did not re-synchronize the Effect, the `handleMove` attached as a listener is the `handleMove` function created during the initial render. During the initial render, `canMove` was `true`, which is why `handleMove` from the initial render will forever see that value.

**If you never suppress the linter, you will never see problems with stale values.**

With `useEffectEvent`, there is no need to “lie” to the linter, and the code works as you would expect:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { useEffectEvent } from 'react';

export default function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  const onMove = useEffectEvent(e => {
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  });

  useEffect(() => {
    window.addEventListener('pointermove', onMove);
    return () => window.removeEventListener('pointermove', onMove);
  }, []);

  return (
    <>
      <label>
        <input type="checkbox"
          checked={canMove}
          onChange={e => setCanMove(e.target.checked)}
        />
        The dot is allowed to move
      </label>
      <hr />
      <div style={{
        position: 'absolute',
        backgroundColor: 'pink',
        borderRadius: '50%',
        opacity: 0.6,
        transform: `translate(${position.x}px, ${position.y}px)`,
        pointerEvents: 'none',
        left: -20,
        top: -20,
        width: 40,
        height: 40,
      }} />
    </>
  );
}
```

Show more

This doesn’t mean that `useEffectEvent` is *always* the correct solution. You should only apply it to the lines of code that you don’t want to be reactive. In the above sandbox, you didn’t want the Effect’s code to be reactive with regards to `canMove`. That’s why it made sense to extract an Effect Event.

Read [Removing Effect Dependencies](https://react.dev/learn/removing-effect-dependencies) for other correct alternatives to suppressing the linter.

### Limitations of Effect Events

Effect Events are very limited in how you can use them:

* **Only call them from inside Effects.**
* **Never pass them to other components or Hooks.**

For example, don’t declare and pass an Effect Event like this:

```
function Timer() {

const [count, setCount] = useState(0);

const onTick = useEffectEvent(() => {

setCount(count + 1);

});

useTimer(onTick, 1000); // 🔴 Avoid: Passing Effect Events

return <h1>{count}</h1>

}

function useTimer(callback, delay) {

useEffect(() => {

const id = setInterval(() => {

callback();

}, delay);

return () => {

clearInterval(id);

};

}, [delay, callback]); // Need to specify "callback" in dependencies

}
```

Instead, always declare Effect Events directly next to the Effects that use them:

```
function Timer() {

const [count, setCount] = useState(0);

useTimer(() => {

setCount(count + 1);

}, 1000);

return <h1>{count}</h1>

}

function useTimer(callback, delay) {

const onTick = useEffectEvent(() => {

callback();

});

useEffect(() => {

const id = setInterval(() => {

onTick(); // ✅ Good: Only called locally inside an Effect

}, delay);

return () => {

clearInterval(id);

};

}, [delay]); // No need to specify "onTick" (an Effect Event) as a dependency

}
```

Effect Events are non-reactive “pieces” of your Effect code. They should be next to the Effect using them.

## Recap

* Event handlers run in response to specific interactions.
* Effects run whenever synchronization is needed.
* Logic inside event handlers is not reactive.
* Logic inside Effects is reactive.
* You can move non-reactive logic from Effects into Effect Events.
* Only call Effect Events from inside Effects.
* Don’t pass Effect Events to other components or Hooks.

## Try out some challenges

1. Fix a variable that doesn’t update 2. Fix a freezing counter 3. Fix a non-adjustable delay 4. Fix a delayed notification

#### Challenge 1 of 4: Fix a variable that doesn’t update

This `Timer` component keeps a `count` state variable which increases every second. The value by which it’s increasing is stored in the `increment` state variable. You can control the `increment` variable with the plus and minus buttons.

However, no matter how many times you click the plus button, the counter is still incremented by one every second. What’s wrong with this code? Why is `increment` always equal to `1` inside the Effect’s code? Find the mistake and fix it.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + increment);
    }, 1000);
    return () => {
      clearInterval(id);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Every second, increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>–</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```

Show more

Show hint Show solution

Next Challenge

[PreviousLifecycle of Reactive Effects](https://react.dev/learn/lifecycle-of-reactive-effects)[NextRemoving Effect Dependencies](https://react.dev/learn/removing-effect-dependencies)

---

---


# Removing Effect Dependencies – React

URL: https://react.dev/learn/removing-effect-dependencies

[Learn React](https://react.dev/learn)

[Escape Hatches](https://react.dev/learn/escape-hatches)

# Removing Effect Dependencies

When you write an Effect, the linter will verify that you’ve included every reactive value (like props and state) that the Effect reads in the list of your Effect’s dependencies. This ensures that your Effect remains synchronized with the latest props and state of your component. Unnecessary dependencies may cause your Effect to run too often, or even create an infinite loop. Follow this guide to review and remove unnecessary dependencies from your Effects.

### You will learn

* How to fix infinite Effect dependency loops
* What to do when you want to remove a dependency
* How to read a value from your Effect without “reacting” to it
* How and why to avoid object and function dependencies
* Why suppressing the dependency linter is dangerous, and what to do instead

## Dependencies should match the code

When you write an Effect, you first specify how to [start and stop](https://react.dev/learn/lifecycle-of-reactive-effects#the-lifecycle-of-an-effect) whatever you want your Effect to be doing:

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => connection.disconnect();

// ...

}
```

Then, if you leave the Effect dependencies empty (`[]`), the linter will suggest the correct dependencies:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // <-- Fix the mistake here!
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

Fill them in according to what the linter says:

```
function ChatRoom({ roomId }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => connection.disconnect();

}, [roomId]); // ✅ All dependencies declared

// ...

}
```

[Effects “react” to reactive values.](https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) Since `roomId` is a reactive value (it can change due to a re-render), the linter verifies that you’ve specified it as a dependency. If `roomId` receives a different value, React will re-synchronize your Effect. This ensures that the chat stays connected to the selected room and “reacts” to the dropdown:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);
  return <h1>Welcome to the {roomId} room!</h1>;
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

### To remove a dependency, prove that it’s not a dependency

Notice that you can’t “choose” the dependencies of your Effect. Every reactive value used by your Effect’s code must be declared in your dependency list. The dependency list is determined by the surrounding code:

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) { // This is a reactive value

useEffect(() => {

const connection = createConnection(serverUrl, roomId); // This Effect reads that reactive value

connection.connect();

return () => connection.disconnect();

}, [roomId]); // ✅ So you must specify that reactive value as a dependency of your Effect

// ...

}
```

[Reactive values](https://react.dev/learn/lifecycle-of-reactive-effects#all-variables-declared-in-the-component-body-are-reactive) include props and all variables and functions declared directly inside of your component. Since `roomId` is a reactive value, you can’t remove it from the dependency list. The linter wouldn’t allow it:

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => connection.disconnect();

}, []); // 🔴 React Hook useEffect has a missing dependency: 'roomId'

// ...

}
```

And the linter would be right! Since `roomId` may change over time, this would introduce a bug in your code.

**To remove a dependency, “prove” to the linter that it *doesn’t need* to be a dependency.** For example, you can move `roomId` out of your component to prove that it’s not reactive and won’t change on re-renders:

```
const serverUrl = 'https://localhost:1234';

const roomId = 'music'; // Not a reactive value anymore

function ChatRoom() {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => connection.disconnect();

}, []); // ✅ All dependencies declared

// ...

}
```

Now that `roomId` is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';
const roomId = 'music';

export default function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []);
  return <h1>Welcome to the {roomId} room!</h1>;
}
```

This is why you could now specify an [empty (`[]`) dependency list.](https://react.dev/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means) Your Effect *really doesn’t* depend on any reactive value anymore, so it *really doesn’t* need to re-run when any of the component’s props or state change.

### To change the dependencies, change the code

You might have noticed a pattern in your workflow:

1. First, you **change the code** of your Effect or how your reactive values are declared.
2. Then, you follow the linter and adjust the dependencies to **match the code you have changed.**
3. If you’re not happy with the list of dependencies, you **go back to the first step** (and change the code again).

The last part is important. **If you want to change the dependencies, change the surrounding code first.** You can think of the dependency list as [a list of all the reactive values used by your Effect’s code.](https://react.dev/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency) You don’t *choose* what to put on that list. The list *describes* your code. To change the dependency list, change the code.

This might feel like solving an equation. You might start with a goal (for example, to remove a dependency), and you need to “find” the code matching that goal. Not everyone finds solving equations fun, and the same thing could be said about writing Effects! Luckily, there is a list of common recipes that you can try below.

### Pitfall

If you have an existing codebase, you might have some Effects that suppress the linter like this:

```
useEffect(() => {

// ...

// 🔴 Avoid suppressing the linter like this:

// eslint-ignore-next-line react-hooks/exhaustive-deps

}, []);
```

**When dependencies don’t match the code, there is a very high risk of introducing bugs.** By suppressing the linter, you “lie” to React about the values your Effect depends on.

Instead, use the techniques below.

##### Deep Dive

#### Why is suppressing the dependency linter so dangerous?

Show Details

Suppressing the linter leads to very unintuitive bugs that are hard to find and fix. Here’s one example:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  function onTick() {
	setCount(count + increment);
  }

  useEffect(() => {
    const id = setInterval(onTick, 1000);
    return () => clearInterval(id);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <h1>
        Counter: {count}
        <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>
        Every second, increment by:
        <button disabled={increment === 0} onClick={() => {
          setIncrement(i => i - 1);
        }}>–</button>
        <b>{increment}</b>
        <button onClick={() => {
          setIncrement(i => i + 1);
        }}>+</button>
      </p>
    </>
  );
}
```

Show more

Let’s say that you wanted to run the Effect “only on mount”. You’ve read that [empty (`[]`) dependencies](https://react.dev/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means) do that, so you’ve decided to ignore the linter, and forcefully specified `[]` as the dependencies.

This counter was supposed to increment every second by the amount configurable with the two buttons. However, since you “lied” to React that this Effect doesn’t depend on anything, React forever keeps using the `onTick` function from the initial render. [During that render,](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time) `count` was `0` and `increment` was `1`. This is why `onTick` from that render always calls `setCount(0 + 1)` every second, and you always see `1`. Bugs like this are harder to fix when they’re spread across multiple components.

There’s always a better solution than ignoring the linter! To fix this code, you need to add `onTick` to the dependency list. (To ensure the interval is only setup once, [make `onTick` an Effect Event.](https://react.dev/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events))

**We recommend treating the dependency lint error as a compilation error. If you don’t suppress it, you will never see bugs like this.** The rest of this page documents the alternatives for this and other cases.

## Removing unnecessary dependencies

Every time you adjust the Effect’s dependencies to reflect the code, look at the dependency list. Does it make sense for the Effect to re-run when any of these dependencies change? Sometimes, the answer is “no”:

* You might want to re-execute *different parts* of your Effect under different conditions.
* You might want to only read the *latest value* of some dependency instead of “reacting” to its changes.
* A dependency may change too often *unintentionally* because it’s an object or a function.

To find the right solution, you’ll need to answer a few questions about your Effect. Let’s walk through them.

### Should this code move to an event handler?

The first thing you should think about is whether this code should be an Effect at all.

Imagine a form. On submit, you set the `submitted` state variable to `true`. You need to send a POST request and show a notification. You’ve put this logic inside an Effect that “reacts” to `submitted` being `true`:

```
function Form() {

const [submitted, setSubmitted] = useState(false);

useEffect(() => {

if (submitted) {

// 🔴 Avoid: Event-specific logic inside an Effect

post('/api/register');

showNotification('Successfully registered!');

}

}, [submitted]);

function handleSubmit() {

setSubmitted(true);

}

// ...

}
```

Later, you want to style the notification message according to the current theme, so you read the current theme. Since `theme` is declared in the component body, it is a reactive value, so you add it as a dependency:

```
function Form() {

const [submitted, setSubmitted] = useState(false);

const theme = useContext(ThemeContext);

useEffect(() => {

if (submitted) {

// 🔴 Avoid: Event-specific logic inside an Effect

post('/api/register');

showNotification('Successfully registered!', theme);

}

}, [submitted, theme]); // ✅ All dependencies declared

function handleSubmit() {

setSubmitted(true);

}

// ...

}
```

By doing this, you’ve introduced a bug. Imagine you submit the form first and then switch between Dark and Light themes. The `theme` will change, the Effect will re-run, and so it will display the same notification again!

**The problem here is that this shouldn’t be an Effect in the first place.** You want to send this POST request and show the notification in response to *submitting the form,* which is a particular interaction. To run some code in response to particular interaction, put that logic directly into the corresponding event handler:

```
function Form() {

const theme = useContext(ThemeContext);

function handleSubmit() {

// ✅ Good: Event-specific logic is called from event handlers

post('/api/register');

showNotification('Successfully registered!', theme);

}

// ...

}
```

Now that the code is in an event handler, it’s not reactive—so it will only run when the user submits the form. Read more about [choosing between event handlers and Effects](https://react.dev/learn/separating-events-from-effects#reactive-values-and-reactive-logic) and [how to delete unnecessary Effects.](https://react.dev/learn/you-might-not-need-an-effect)

### Is your Effect doing several unrelated things?

The next question you should ask yourself is whether your Effect is doing several unrelated things.

Imagine you’re creating a shipping form where the user needs to choose their city and area. You fetch the list of `cities` from the server according to the selected `country` to show them in a dropdown:

```
function ShippingForm({ country }) {

const [cities, setCities] = useState(null);

const [city, setCity] = useState(null);

useEffect(() => {

let ignore = false;

fetch(`/api/cities?country=${country}`)

.then(response => response.json())

.then(json => {

if (!ignore) {

setCities(json);

}

});

return () => {

ignore = true;

};

}, [country]); // ✅ All dependencies declared

// ...
```

This is a good example of [fetching data in an Effect.](https://react.dev/learn/you-might-not-need-an-effect#fetching-data) You are synchronizing the `cities` state with the network according to the `country` prop. You can’t do this in an event handler because you need to fetch as soon as `ShippingForm` is displayed and whenever the `country` changes (no matter which interaction causes it).

Now let’s say you’re adding a second select box for city areas, which should fetch the `areas` for the currently selected `city`. You might start by adding a second `fetch` call for the list of areas inside the same Effect:

```
function ShippingForm({ country }) {

const [cities, setCities] = useState(null);

const [city, setCity] = useState(null);

const [areas, setAreas] = useState(null);

useEffect(() => {

let ignore = false;

fetch(`/api/cities?country=${country}`)

.then(response => response.json())

.then(json => {

if (!ignore) {

setCities(json);

}

});

// 🔴 Avoid: A single Effect synchronizes two independent processes

if (city) {

fetch(`/api/areas?city=${city}`)

.then(response => response.json())

.then(json => {

if (!ignore) {

setAreas(json);

}

});

}

return () => {

ignore = true;

};

}, [country, city]); // ✅ All dependencies declared

// ...
```

However, since the Effect now uses the `city` state variable, you’ve had to add `city` to the list of dependencies. That, in turn, introduced a problem: when the user selects a different city, the Effect will re-run and call `fetchCities(country)`. As a result, you will be unnecessarily refetching the list of cities many times.

**The problem with this code is that you’re synchronizing two different unrelated things:**

1. You want to synchronize the `cities` state to the network based on the `country` prop.
2. You want to synchronize the `areas` state to the network based on the `city` state.

Split the logic into two Effects, each of which reacts to the prop that it needs to synchronize with:

```
function ShippingForm({ country }) {

const [cities, setCities] = useState(null);

useEffect(() => {

let ignore = false;

fetch(`/api/cities?country=${country}`)

.then(response => response.json())

.then(json => {

if (!ignore) {

setCities(json);

}

});

return () => {

ignore = true;

};

}, [country]); // ✅ All dependencies declared

const [city, setCity] = useState(null);

const [areas, setAreas] = useState(null);

useEffect(() => {

if (city) {

let ignore = false;

fetch(`/api/areas?city=${city}`)

.then(response => response.json())

.then(json => {

if (!ignore) {

setAreas(json);

}

});

return () => {

ignore = true;

};

}

}, [city]); // ✅ All dependencies declared

// ...
```

Now the first Effect only re-runs if the `country` changes, while the second Effect re-runs when the `city` changes. You’ve separated them by purpose: two different things are synchronized by two separate Effects. Two separate Effects have two separate dependency lists, so they won’t trigger each other unintentionally.

The final code is longer than the original, but splitting these Effects is still correct. [Each Effect should represent an independent synchronization process.](https://react.dev/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process) In this example, deleting one Effect doesn’t break the other Effect’s logic. This means they *synchronize different things,* and it’s good to split them up. If you’re concerned about duplication, you can improve this code by [extracting repetitive logic into a custom Hook.](https://react.dev/learn/reusing-logic-with-custom-hooks#when-to-use-custom-hooks)

### Are you reading some state to calculate the next state?

This Effect updates the `messages` state variable with a newly created array every time a new message arrives:

```
function ChatRoom({ roomId }) {

const [messages, setMessages] = useState([]);

useEffect(() => {

const connection = createConnection();

connection.connect();

connection.on('message', (receivedMessage) => {

setMessages([...messages, receivedMessage]);

});

// ...
```

It uses the `messages` variable to [create a new array](https://react.dev/learn/updating-arrays-in-state) starting with all the existing messages and adds the new message at the end. However, since `messages` is a reactive value read by an Effect, it must be a dependency:

```
function ChatRoom({ roomId }) {

const [messages, setMessages] = useState([]);

useEffect(() => {

const connection = createConnection();

connection.connect();

connection.on('message', (receivedMessage) => {

setMessages([...messages, receivedMessage]);

});

return () => connection.disconnect();

}, [roomId, messages]); // ✅ All dependencies declared

// ...
```

And making `messages` a dependency introduces a problem.

Every time you receive a message, `setMessages()` causes the component to re-render with a new `messages` array that includes the received message. However, since this Effect now depends on `messages`, this will *also* re-synchronize the Effect. So every new message will make the chat re-connect. The user would not like that!

To fix the issue, don’t read `messages` inside the Effect. Instead, pass an [updater function](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state) to `setMessages`:

```
function ChatRoom({ roomId }) {

const [messages, setMessages] = useState([]);

useEffect(() => {

const connection = createConnection();

connection.connect();

connection.on('message', (receivedMessage) => {

setMessages(msgs => [...msgs, receivedMessage]);

});

return () => connection.disconnect();

}, [roomId]); // ✅ All dependencies declared

// ...
```

**Notice how your Effect does not read the `messages` variable at all now.** You only need to pass an updater function like `msgs => [...msgs, receivedMessage]`. React [puts your updater function in a queue](https://react.dev/learn/queueing-a-series-of-state-updates) and will provide the `msgs` argument to it during the next render. This is why the Effect itself doesn’t need to depend on `messages` anymore. As a result of this fix, receiving a chat message will no longer make the chat re-connect.

### Do you want to read a value without “reacting” to its changes?

Suppose that you want to play a sound when the user receives a new message unless `isMuted` is `true`:

```
function ChatRoom({ roomId }) {

const [messages, setMessages] = useState([]);

const [isMuted, setIsMuted] = useState(false);

useEffect(() => {

const connection = createConnection();

connection.connect();

connection.on('message', (receivedMessage) => {

setMessages(msgs => [...msgs, receivedMessage]);

if (!isMuted) {

playSound();

}

});

// ...
```

Since your Effect now uses `isMuted` in its code, you have to add it to the dependencies:

```
function ChatRoom({ roomId }) {

const [messages, setMessages] = useState([]);

const [isMuted, setIsMuted] = useState(false);

useEffect(() => {

const connection = createConnection();

connection.connect();

connection.on('message', (receivedMessage) => {

setMessages(msgs => [...msgs, receivedMessage]);

if (!isMuted) {

playSound();

}

});

return () => connection.disconnect();

}, [roomId, isMuted]); // ✅ All dependencies declared

// ...
```

The problem is that every time `isMuted` changes (for example, when the user presses the “Muted” toggle), the Effect will re-synchronize, and reconnect to the chat. This is not the desired user experience! (In this example, even disabling the linter would not work—if you do that, `isMuted` would get “stuck” with its old value.)

To solve this problem, you need to extract the logic that shouldn’t be reactive out of the Effect. You don’t want this Effect to “react” to the changes in `isMuted`. [Move this non-reactive piece of logic into an Effect Event:](https://react.dev/learn/separating-events-from-effects#declaring-an-effect-event)

```
import { useState, useEffect, useEffectEvent } from 'react';

function ChatRoom({ roomId }) {

const [messages, setMessages] = useState([]);

const [isMuted, setIsMuted] = useState(false);

const onMessage = useEffectEvent(receivedMessage => {

setMessages(msgs => [...msgs, receivedMessage]);

if (!isMuted) {

playSound();

}

});

useEffect(() => {

const connection = createConnection();

connection.connect();

connection.on('message', (receivedMessage) => {

onMessage(receivedMessage);

});

return () => connection.disconnect();

}, [roomId]); // ✅ All dependencies declared

// ...
```

Effect Events let you split an Effect into reactive parts (which should “react” to reactive values like `roomId` and their changes) and non-reactive parts (which only read their latest values, like `onMessage` reads `isMuted`). **Now that you read `isMuted` inside an Effect Event, it doesn’t need to be a dependency of your Effect.** As a result, the chat won’t re-connect when you toggle the “Muted” setting on and off, solving the original issue!

#### Wrapping an event handler from the props

You might run into a similar problem when your component receives an event handler as a prop:

```
function ChatRoom({ roomId, onReceiveMessage }) {

const [messages, setMessages] = useState([]);

useEffect(() => {

const connection = createConnection();

connection.connect();

connection.on('message', (receivedMessage) => {

onReceiveMessage(receivedMessage);

});

return () => connection.disconnect();

}, [roomId, onReceiveMessage]); // ✅ All dependencies declared

// ...
```

Suppose that the parent component passes a *different* `onReceiveMessage` function on every render:

```
<ChatRoom

roomId={roomId}

onReceiveMessage={receivedMessage => {

// ...

}}

/>
```

Since `onReceiveMessage` is a dependency, it would cause the Effect to re-synchronize after every parent re-render. This would make it re-connect to the chat. To solve this, wrap the call in an Effect Event:

```
function ChatRoom({ roomId, onReceiveMessage }) {

const [messages, setMessages] = useState([]);

const onMessage = useEffectEvent(receivedMessage => {

onReceiveMessage(receivedMessage);

});

useEffect(() => {

const connection = createConnection();

connection.connect();

connection.on('message', (receivedMessage) => {

onMessage(receivedMessage);

});

return () => connection.disconnect();

}, [roomId]); // ✅ All dependencies declared

// ...
```

Effect Events aren’t reactive, so you don’t need to specify them as dependencies. As a result, the chat will no longer re-connect even if the parent component passes a function that’s different on every re-render.

#### Separating reactive and non-reactive code

In this example, you want to log a visit every time `roomId` changes. You want to include the current `notificationCount` with every log, but you *don’t* want a change to `notificationCount` to trigger a log event.

The solution is again to split out the non-reactive code into an Effect Event:

```
function Chat({ roomId, notificationCount }) {

const onVisit = useEffectEvent(visitedRoomId => {

logVisit(visitedRoomId, notificationCount);

});

useEffect(() => {

onVisit(roomId);

}, [roomId]); // ✅ All dependencies declared

// ...

}
```

You want your logic to be reactive with regards to `roomId`, so you read `roomId` inside of your Effect. However, you don’t want a change to `notificationCount` to log an extra visit, so you read `notificationCount` inside of the Effect Event. [Learn more about reading the latest props and state from Effects using Effect Events.](https://react.dev/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events)

### Does some reactive value change unintentionally?

Sometimes, you *do* want your Effect to “react” to a certain value, but that value changes more often than you’d like—and might not reflect any actual change from the user’s perspective. For example, let’s say that you create an `options` object in the body of your component, and then read that object from inside of your Effect:

```
function ChatRoom({ roomId }) {

// ...

const options = {

serverUrl: serverUrl,

roomId: roomId

};

useEffect(() => {

const connection = createConnection(options);

connection.connect();

// ...
```

This object is declared in the component body, so it’s a [reactive value.](https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) When you read a reactive value like this inside an Effect, you declare it as a dependency. This ensures your Effect “reacts” to its changes:

```
// ...

useEffect(() => {

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [options]); // ✅ All dependencies declared

// ...
```

It is important to declare it as a dependency! This ensures, for example, that if the `roomId` changes, your Effect will re-connect to the chat with the new `options`. However, there is also a problem with the code above. To see it, try typing into the input in the sandbox below, and watch what happens in the console:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // Temporarily disable the linter to demonstrate the problem
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const options = {
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

In the sandbox above, the input only updates the `message` state variable. From the user’s perspective, this should not affect the chat connection. However, every time you update the `message`, your component re-renders. When your component re-renders, the code inside of it runs again from scratch.

A new `options` object is created from scratch on every re-render of the `ChatRoom` component. React sees that the `options` object is a *different object* from the `options` object created during the last render. This is why it re-synchronizes your Effect (which depends on `options`), and the chat re-connects as you type.

**This problem only affects objects and functions. In JavaScript, each newly created object and function is considered distinct from all the others. It doesn’t matter that the contents inside of them may be the same!**

```
// During the first render

const options1 = { serverUrl: 'https://localhost:1234', roomId: 'music' };

// During the next render

const options2 = { serverUrl: 'https://localhost:1234', roomId: 'music' };

// These are two different objects!

console.log(Object.is(options1, options2)); // false
```

**Object and function dependencies can make your Effect re-synchronize more often than you need.**

This is why, whenever possible, you should try to avoid objects and functions as your Effect’s dependencies. Instead, try moving them outside the component, inside the Effect, or extracting primitive values out of them.

#### Move static objects and functions outside your component

If the object does not depend on any props and state, you can move that object outside your component:

```
const options = {

serverUrl: 'https://localhost:1234',

roomId: 'music'

};

function ChatRoom() {

const [message, setMessage] = useState('');

useEffect(() => {

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, []); // ✅ All dependencies declared

// ...
```

This way, you *prove* to the linter that it’s not reactive. It can’t change as a result of a re-render, so it doesn’t need to be a dependency. Now re-rendering `ChatRoom` won’t cause your Effect to re-synchronize.

This works for functions too:

```
function createOptions() {

return {

serverUrl: 'https://localhost:1234',

roomId: 'music'

};

}

function ChatRoom() {

const [message, setMessage] = useState('');

useEffect(() => {

const options = createOptions();

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, []); // ✅ All dependencies declared

// ...
```

Since `createOptions` is declared outside your component, it’s not a reactive value. This is why it doesn’t need to be specified in your Effect’s dependencies, and why it won’t ever cause your Effect to re-synchronize.

#### Move dynamic objects and functions inside your Effect

If your object depends on some reactive value that may change as a result of a re-render, like a `roomId` prop, you can’t pull it *outside* your component. You can, however, move its creation *inside* of your Effect’s code:

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

useEffect(() => {

const options = {

serverUrl: serverUrl,

roomId: roomId

};

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [roomId]); // ✅ All dependencies declared

// ...
```

Now that `options` is declared inside of your Effect, it is no longer a dependency of your Effect. Instead, the only reactive value used by your Effect is `roomId`. Since `roomId` is not an object or function, you can be sure that it won’t be *unintentionally* different. In JavaScript, numbers and strings are compared by their content:

```
// During the first render

const roomId1 = 'music';

// During the next render

const roomId2 = 'music';

// These two strings are the same!

console.log(Object.is(roomId1, roomId2)); // true
```

Thanks to this fix, the chat no longer re-connects if you edit the input:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

However, it *does* re-connect when you change the `roomId` dropdown, as you would expect.

This works for functions, too:

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

useEffect(() => {

function createOptions() {

return {

serverUrl: serverUrl,

roomId: roomId

};

}

const options = createOptions();

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [roomId]); // ✅ All dependencies declared

// ...
```

You can write your own functions to group pieces of logic inside your Effect. As long as you also declare them *inside* your Effect, they’re not reactive values, and so they don’t need to be dependencies of your Effect.

#### Read primitive values from objects

Sometimes, you may receive an object from props:

```
function ChatRoom({ options }) {

const [message, setMessage] = useState('');

useEffect(() => {

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [options]); // ✅ All dependencies declared

// ...
```

The risk here is that the parent component will create the object during rendering:

```
<ChatRoom

roomId={roomId}

options={{

serverUrl: serverUrl,

roomId: roomId

}}

/>
```

This would cause your Effect to re-connect every time the parent component re-renders. To fix this, read information from the object *outside* the Effect, and avoid having object and function dependencies:

```
function ChatRoom({ options }) {

const [message, setMessage] = useState('');

const { roomId, serverUrl } = options;

useEffect(() => {

const connection = createConnection({

roomId: roomId,

serverUrl: serverUrl

});

connection.connect();

return () => connection.disconnect();

}, [roomId, serverUrl]); // ✅ All dependencies declared

// ...
```

The logic gets a little repetitive (you read some values from an object outside an Effect, and then create an object with the same values inside the Effect). But it makes it very explicit what information your Effect *actually* depends on. If an object is re-created unintentionally by the parent component, the chat would not re-connect. However, if `options.roomId` or `options.serverUrl` really are different, the chat would re-connect.

#### Calculate primitive values from functions

The same approach can work for functions. For example, suppose the parent component passes a function:

```
<ChatRoom

roomId={roomId}

getOptions={() => {

return {

serverUrl: serverUrl,

roomId: roomId

};

}}

/>
```

To avoid making it a dependency (and causing it to re-connect on re-renders), call it outside the Effect. This gives you the `roomId` and `serverUrl` values that aren’t objects, and that you can read from inside your Effect:

```
function ChatRoom({ getOptions }) {

const [message, setMessage] = useState('');

const { roomId, serverUrl } = getOptions();

useEffect(() => {

const connection = createConnection({

roomId: roomId,

serverUrl: serverUrl

});

connection.connect();

return () => connection.disconnect();

}, [roomId, serverUrl]); // ✅ All dependencies declared

// ...
```

This only works for [pure](https://react.dev/learn/keeping-components-pure) functions because they are safe to call during rendering. If your function is an event handler, but you don’t want its changes to re-synchronize your Effect, [wrap it into an Effect Event instead.](https://react.dev/learn/removing-effect-dependencies#do-you-want-to-read-a-value-without-reacting-to-its-changes)

## Recap

* Dependencies should always match the code.
* When you’re not happy with your dependencies, what you need to edit is the code.
* Suppressing the linter leads to very confusing bugs, and you should always avoid it.
* To remove a dependency, you need to “prove” to the linter that it’s not necessary.
* If some code should run in response to a specific interaction, move that code to an event handler.
* If different parts of your Effect should re-run for different reasons, split it into several Effects.
* If you want to update some state based on the previous state, pass an updater function.
* If you want to read the latest value without “reacting” it, extract an Effect Event from your Effect.
* In JavaScript, objects and functions are considered different if they were created at different times.
* Try to avoid object and function dependencies. Move them outside the component or inside the Effect.

## Try out some challenges

1. Fix a resetting interval 2. Fix a retriggering animation 3. Fix a reconnecting chat 4. Fix a reconnecting chat, again

#### Challenge 1 of 4: Fix a resetting interval

This Effect sets up an interval that ticks every second. You’ve noticed something strange happening: it seems like the interval gets destroyed and re-created every time it ticks. Fix the code so that the interval doesn’t get constantly re-created.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

export default function Timer() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('✅ Creating an interval');
    const id = setInterval(() => {
      console.log('⏰ Interval tick');
      setCount(count + 1);
    }, 1000);
    return () => {
      console.log('❌ Clearing an interval');
      clearInterval(id);
    };
  }, [count]);

  return <h1>Counter: {count}</h1>
}
```

Show more

Show hint Show solution

Next Challenge

[PreviousSeparating Events from Effects](https://react.dev/learn/separating-events-from-effects)[NextReusing Logic with Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks)

---

---


# Reusing Logic with Custom Hooks – React

URL: https://react.dev/learn/reusing-logic-with-custom-hooks

[Learn React](https://react.dev/learn)

[Escape Hatches](https://react.dev/learn/escape-hatches)

# Reusing Logic with Custom Hooks

React comes with several built-in Hooks like `useState`, `useContext`, and `useEffect`. Sometimes, you’ll wish that there was a Hook for some more specific purpose: for example, to fetch data, to keep track of whether the user is online, or to connect to a chat room. You might not find these Hooks in React, but you can create your own Hooks for your application’s needs.

### You will learn

* What custom Hooks are, and how to write your own
* How to reuse logic between components
* How to name and structure your custom Hooks
* When and why to extract custom Hooks

## Custom Hooks: Sharing logic between components

Imagine you’re developing an app that heavily relies on the network (as most apps do). You want to warn the user if their network connection has accidentally gone off while they were using your app. How would you go about it? It seems like you’ll need two things in your component:

1. A piece of state that tracks whether the network is online.
2. An Effect that subscribes to the global [`online`](https://developer.mozilla.org/en-US/docs/Web/API/Window/online_event) and [`offline`](https://developer.mozilla.org/en-US/docs/Web/API/Window/offline_event) events, and updates that state.

This will keep your component [synchronized](https://react.dev/learn/synchronizing-with-effects) with the network status. You might start with something like this:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

export default function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}
```

Show more

Try turning your network on and off, and notice how this `StatusBar` updates in response to your actions.

Now imagine you *also* want to use the same logic in a different component. You want to implement a Save button that will become disabled and show “Reconnecting…” instead of “Save” while the network is off.

To start, you can copy and paste the `isOnline` state and the Effect into `SaveButton`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

export default function SaveButton() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  function handleSaveClick() {
    console.log('✅ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}
```

Show more

Verify that, if you turn off the network, the button will change its appearance.

These two components work fine, but the duplication in logic between them is unfortunate. It seems like even though they have different *visual appearance,* you want to reuse the logic between them.

### Extracting your own custom Hook from a component

Imagine for a moment that, similar to [`useState`](https://react.dev/reference/react/useState) and [`useEffect`](https://react.dev/reference/react/useEffect), there was a built-in `useOnlineStatus` Hook. Then both of these components could be simplified and you could remove the duplication between them:

```
function StatusBar() {

const isOnline = useOnlineStatus();

return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;

}

function SaveButton() {

const isOnline = useOnlineStatus();

function handleSaveClick() {

console.log('✅ Progress saved');

}

return (

<button disabled={!isOnline} onClick={handleSaveClick}>

{isOnline ? 'Save progress' : 'Reconnecting...'}

</button>

);

}
```

Although there is no such built-in Hook, you can write it yourself. Declare a function called `useOnlineStatus` and move all the duplicated code into it from the components you wrote earlier:

```
function useOnlineStatus() {

const [isOnline, setIsOnline] = useState(true);

useEffect(() => {

function handleOnline() {

setIsOnline(true);

}

function handleOffline() {

setIsOnline(false);

}

window.addEventListener('online', handleOnline);

window.addEventListener('offline', handleOffline);

return () => {

window.removeEventListener('online', handleOnline);

window.removeEventListener('offline', handleOffline);

};

}, []);

return isOnline;

}
```

At the end of the function, return `isOnline`. This lets your components read that value:

App.jsuseOnlineStatus.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useOnlineStatus } from './useOnlineStatus.js';

function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('✅ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}

export default function App() {
  return (
    <>
      <SaveButton />
      <StatusBar />
    </>
  );
}
```

Show more

Verify that switching the network on and off updates both components.

Now your components don’t have as much repetitive logic. **More importantly, the code inside them describes *what they want to do* (use the online status!) rather than *how to do it* (by subscribing to the browser events).**

When you extract logic into custom Hooks, you can hide the gnarly details of how you deal with some external system or a browser API. The code of your components expresses your intent, not the implementation.

### Hook names always start with `use`

React applications are built from components. Components are built from Hooks, whether built-in or custom. You’ll likely often use custom Hooks created by others, but occasionally you might write one yourself!

You must follow these naming conventions:

1. **React component names must start with a capital letter,** like `StatusBar` and `SaveButton`. React components also need to return something that React knows how to display, like a piece of JSX.
2. **Hook names must start with `use` followed by a capital letter,** like [`useState`](https://react.dev/reference/react/useState) (built-in) or `useOnlineStatus` (custom, like earlier on the page). Hooks may return arbitrary values.

This convention guarantees that you can always look at a component and know where its state, Effects, and other React features might “hide”. For example, if you see a `getColor()` function call inside your component, you can be sure that it can’t possibly contain React state inside because its name doesn’t start with `use`. However, a function call like `useOnlineStatus()` will most likely contain calls to other Hooks inside!

### Note

If your linter is [configured for React,](https://react.dev/learn/editor-setup#linting) it will enforce this naming convention. Scroll up to the sandbox above and rename `useOnlineStatus` to `getOnlineStatus`. Notice that the linter won’t allow you to call `useState` or `useEffect` inside of it anymore. Only Hooks and components can call other Hooks!

##### Deep Dive

#### Should all functions called during rendering start with the use prefix?

Show Details

No. Functions that don’t *call* Hooks don’t need to *be* Hooks.

If your function doesn’t call any Hooks, avoid the `use` prefix. Instead, write it as a regular function *without* the `use` prefix. For example, `useSorted` below doesn’t call Hooks, so call it `getSorted` instead:

```
// 🔴 Avoid: A Hook that doesn't use Hooks

function useSorted(items) {

return items.slice().sort();

}

// ✅ Good: A regular function that doesn't use Hooks

function getSorted(items) {

return items.slice().sort();

}
```

This ensures that your code can call this regular function anywhere, including conditions:

```
function List({ items, shouldSort }) {

let displayedItems = items;

if (shouldSort) {

// ✅ It's ok to call getSorted() conditionally because it's not a Hook

displayedItems = getSorted(items);

}

// ...

}
```

You should give `use` prefix to a function (and thus make it a Hook) if it uses at least one Hook inside of it:

```
// ✅ Good: A Hook that uses other Hooks

function useAuth() {

return useContext(Auth);

}
```

Technically, this isn’t enforced by React. In principle, you could make a Hook that doesn’t call other Hooks. This is often confusing and limiting so it’s best to avoid that pattern. However, there may be rare cases where it is helpful. For example, maybe your function doesn’t use any Hooks right now, but you plan to add some Hook calls to it in the future. Then it makes sense to name it with the `use` prefix:

```
// ✅ Good: A Hook that will likely use some other Hooks later

function useAuth() {

// TODO: Replace with this line when authentication is implemented:

// return useContext(Auth);

return TEST_USER;

}
```

Then components won’t be able to call it conditionally. This will become important when you actually add Hook calls inside. If you don’t plan to use Hooks inside it (now or later), don’t make it a Hook.

### Custom Hooks let you share stateful logic, not state itself

In the earlier example, when you turned the network on and off, both components updated together. However, it’s wrong to think that a single `isOnline` state variable is shared between them. Look at this code:

```
function StatusBar() {

const isOnline = useOnlineStatus();

// ...

}

function SaveButton() {

const isOnline = useOnlineStatus();

// ...

}
```

It works the same way as before you extracted the duplication:

```
function StatusBar() {

const [isOnline, setIsOnline] = useState(true);

useEffect(() => {

// ...

}, []);

// ...

}

function SaveButton() {

const [isOnline, setIsOnline] = useState(true);

useEffect(() => {

// ...

}, []);

// ...

}
```

These are two completely independent state variables and Effects! They happened to have the same value at the same time because you synchronized them with the same external value (whether the network is on).

To better illustrate this, we’ll need a different example. Consider this `Form` component:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('Mary');
  const [lastName, setLastName] = useState('Poppins');

  function handleFirstNameChange(e) {
    setFirstName(e.target.value);
  }

  function handleLastNameChange(e) {
    setLastName(e.target.value);
  }

  return (
    <>
      <label>
        First name:
        <input value={firstName} onChange={handleFirstNameChange} />
      </label>
      <label>
        Last name:
        <input value={lastName} onChange={handleLastNameChange} />
      </label>
      <p><b>Good morning, {firstName} {lastName}.</b></p>
    </>
  );
}
```

Show more

There’s some repetitive logic for each form field:

1. There’s a piece of state (`firstName` and `lastName`).
2. There’s a change handler (`handleFirstNameChange` and `handleLastNameChange`).
3. There’s a piece of JSX that specifies the `value` and `onChange` attributes for that input.

You can extract the repetitive logic into this `useFormInput` custom Hook:

App.jsuseFormInput.js

useFormInput.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export function useFormInput(initialValue) {
  const [value, setValue] = useState(initialValue);

  function handleChange(e) {
    setValue(e.target.value);
  }

  const inputProps = {
    value: value,
    onChange: handleChange
  };

  return inputProps;
}
```

Show more

Notice that it only declares *one* state variable called `value`.

However, the `Form` component calls `useFormInput` *two times:*

```
function Form() {

const firstNameProps = useFormInput('Mary');

const lastNameProps = useFormInput('Poppins');

// ...
```

This is why it works like declaring two separate state variables!

**Custom Hooks let you share *stateful logic* but not *state itself.* Each call to a Hook is completely independent from every other call to the same Hook.** This is why the two sandboxes above are completely equivalent. If you’d like, scroll back up and compare them. The behavior before and after extracting a custom Hook is identical.

When you need to share the state itself between multiple components, [lift it up and pass it down](https://react.dev/learn/sharing-state-between-components) instead.

## Passing reactive values between Hooks

The code inside your custom Hooks will re-run during every re-render of your component. This is why, like components, custom Hooks [need to be pure.](https://react.dev/learn/keeping-components-pure) Think of custom Hooks’ code as part of your component’s body!

Because custom Hooks re-render together with your component, they always receive the latest props and state. To see what this means, consider this chat room example. Change the server URL or the chat room:

App.jsChatRoom.jschat.jsnotifications.js

ChatRoom.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';
import { showNotification } from './notifications.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.on('message', (msg) => {
      showNotification('New message: ' + msg);
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:
        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}
```

Show more

When you change `serverUrl` or `roomId`, the Effect [“reacts” to your changes](https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) and re-synchronizes. You can tell by the console messages that the chat re-connects every time that you change your Effect’s dependencies.

Now move the Effect’s code into a custom Hook:

```
export function useChatRoom({ serverUrl, roomId }) {

useEffect(() => {

const options = {

serverUrl: serverUrl,

roomId: roomId

};

const connection = createConnection(options);

connection.connect();

connection.on('message', (msg) => {

showNotification('New message: ' + msg);

});

return () => connection.disconnect();

}, [roomId, serverUrl]);

}
```

This lets your `ChatRoom` component call your custom Hook without worrying about how it works inside:

```
export default function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

useChatRoom({

roomId: roomId,

serverUrl: serverUrl

});

return (

<>

<label>

Server URL:

<input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />

</label>

<h1>Welcome to the {roomId} room!</h1>

</>

);

}
```

This looks much simpler! (But it does the same thing.)

Notice that the logic *still responds* to prop and state changes. Try editing the server URL or the selected room:

App.jsChatRoom.jsuseChatRoom.jschat.jsnotifications.js

ChatRoom.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { useChatRoom } from './useChatRoom.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl
  });

  return (
    <>
      <label>
        Server URL:
        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}
```

Show more

Notice how you’re taking the return value of one Hook:

```
export default function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

useChatRoom({

roomId: roomId,

serverUrl: serverUrl

});

// ...
```

and passing it as an input to another Hook:

```
export default function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

useChatRoom({

roomId: roomId,

serverUrl: serverUrl

});

// ...
```

Every time your `ChatRoom` component re-renders, it passes the latest `roomId` and `serverUrl` to your Hook. This is why your Effect re-connects to the chat whenever their values are different after a re-render. (If you ever worked with audio or video processing software, chaining Hooks like this might remind you of chaining visual or audio effects. It’s as if the output of `useState` “feeds into” the input of the `useChatRoom`.)

### Passing event handlers to custom Hooks

As you start using `useChatRoom` in more components, you might want to let components customize its behavior. For example, currently, the logic for what to do when a message arrives is hardcoded inside the Hook:

```
export function useChatRoom({ serverUrl, roomId }) {

useEffect(() => {

const options = {

serverUrl: serverUrl,

roomId: roomId

};

const connection = createConnection(options);

connection.connect();

connection.on('message', (msg) => {

showNotification('New message: ' + msg);

});

return () => connection.disconnect();

}, [roomId, serverUrl]);

}
```

Let’s say you want to move this logic back to your component:

```
export default function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

useChatRoom({

roomId: roomId,

serverUrl: serverUrl,

onReceiveMessage(msg) {

showNotification('New message: ' + msg);

}

});

// ...
```

To make this work, change your custom Hook to take `onReceiveMessage` as one of its named options:

```
export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {

useEffect(() => {

const options = {

serverUrl: serverUrl,

roomId: roomId

};

const connection = createConnection(options);

connection.connect();

connection.on('message', (msg) => {

onReceiveMessage(msg);

});

return () => connection.disconnect();

}, [roomId, serverUrl, onReceiveMessage]); // ✅ All dependencies declared

}
```

This will work, but there’s one more improvement you can do when your custom Hook accepts event handlers.

Adding a dependency on `onReceiveMessage` is not ideal because it will cause the chat to re-connect every time the component re-renders. [Wrap this event handler into an Effect Event to remove it from the dependencies:](https://react.dev/learn/removing-effect-dependencies#wrapping-an-event-handler-from-the-props)

```
import { useEffect, useEffectEvent } from 'react';

// ...

export function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {

const onMessage = useEffectEvent(onReceiveMessage);

useEffect(() => {

const options = {

serverUrl: serverUrl,

roomId: roomId

};

const connection = createConnection(options);

connection.connect();

connection.on('message', (msg) => {

onMessage(msg);

});

return () => connection.disconnect();

}, [roomId, serverUrl]); // ✅ All dependencies declared

}
```

Now the chat won’t re-connect every time that the `ChatRoom` component re-renders. Here is a fully working demo of passing an event handler to a custom Hook that you can play with:

App.jsChatRoom.jsuseChatRoom.jschat.jsnotifications.js

ChatRoom.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { useChatRoom } from './useChatRoom.js';
import { showNotification } from './notifications.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl,
    onReceiveMessage(msg) {
      showNotification('New message: ' + msg);
    }
  });

  return (
    <>
      <label>
        Server URL:
        <input value={serverUrl} onChange={e => setServerUrl(e.target.value)} />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}
```

Show more

Notice how you no longer need to know *how* `useChatRoom` works in order to use it. You could add it to any other component, pass any other options, and it would work the same way. That’s the power of custom Hooks.

## When to use custom Hooks

You don’t need to extract a custom Hook for every little duplicated bit of code. Some duplication is fine. For example, extracting a `useFormInput` Hook to wrap a single `useState` call like earlier is probably unnecessary.

However, whenever you write an Effect, consider whether it would be clearer to also wrap it in a custom Hook. [You shouldn’t need Effects very often,](https://react.dev/learn/you-might-not-need-an-effect) so if you’re writing one, it means that you need to “step outside React” to synchronize with some external system or to do something that React doesn’t have a built-in API for. Wrapping it into a custom Hook lets you precisely communicate your intent and how the data flows through it.

For example, consider a `ShippingForm` component that displays two dropdowns: one shows the list of cities, and another shows the list of areas in the selected city. You might start with some code that looks like this:

```
function ShippingForm({ country }) {

const [cities, setCities] = useState(null);

// This Effect fetches cities for a country

useEffect(() => {

let ignore = false;

fetch(`/api/cities?country=${country}`)

.then(response => response.json())

.then(json => {

if (!ignore) {

setCities(json);

}

});

return () => {

ignore = true;

};

}, [country]);

const [city, setCity] = useState(null);

const [areas, setAreas] = useState(null);

// This Effect fetches areas for the selected city

useEffect(() => {

if (city) {

let ignore = false;

fetch(`/api/areas?city=${city}`)

.then(response => response.json())

.then(json => {

if (!ignore) {

setAreas(json);

}

});

return () => {

ignore = true;

};

}

}, [city]);

// ...
```

Although this code is quite repetitive, [it’s correct to keep these Effects separate from each other.](https://react.dev/learn/removing-effect-dependencies#is-your-effect-doing-several-unrelated-things) They synchronize two different things, so you shouldn’t merge them into one Effect. Instead, you can simplify the `ShippingForm` component above by extracting the common logic between them into your own `useData` Hook:

```
function useData(url) {

const [data, setData] = useState(null);

useEffect(() => {

if (url) {

let ignore = false;

fetch(url)

.then(response => response.json())

.then(json => {

if (!ignore) {

setData(json);

}

});

return () => {

ignore = true;

};

}

}, [url]);

return data;

}
```

Now you can replace both Effects in the `ShippingForm` components with calls to `useData`:

```
function ShippingForm({ country }) {

const cities = useData(`/api/cities?country=${country}`);

const [city, setCity] = useState(null);

const areas = useData(city ? `/api/areas?city=${city}` : null);

// ...
```

Extracting a custom Hook makes the data flow explicit. You feed the `url` in and you get the `data` out. By “hiding” your Effect inside `useData`, you also prevent someone working on the `ShippingForm` component from adding [unnecessary dependencies](https://react.dev/learn/removing-effect-dependencies) to it. With time, most of your app’s Effects will be in custom Hooks.

##### Deep Dive

#### Keep your custom Hooks focused on concrete high-level use cases

Show Details

Start by choosing your custom Hook’s name. If you struggle to pick a clear name, it might mean that your Effect is too coupled to the rest of your component’s logic, and is not yet ready to be extracted.

Ideally, your custom Hook’s name should be clear enough that even a person who doesn’t write code often could have a good guess about what your custom Hook does, what it takes, and what it returns:

* ✅ `useData(url)`
* ✅ `useImpressionLog(eventName, extraData)`
* ✅ `useChatRoom(options)`

When you synchronize with an external system, your custom Hook name may be more technical and use jargon specific to that system. It’s good as long as it would be clear to a person familiar with that system:

* ✅ `useMediaQuery(query)`
* ✅ `useSocket(url)`
* ✅ `useIntersectionObserver(ref, options)`

**Keep custom Hooks focused on concrete high-level use cases.** Avoid creating and using custom “lifecycle” Hooks that act as alternatives and convenience wrappers for the `useEffect` API itself:

* 🔴 `useMount(fn)`
* 🔴 `useEffectOnce(fn)`
* 🔴 `useUpdateEffect(fn)`

For example, this `useMount` Hook tries to ensure some code only runs “on mount”:

```
function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

// 🔴 Avoid: using custom "lifecycle" Hooks

useMount(() => {

const connection = createConnection({ roomId, serverUrl });

connection.connect();

post('/analytics/event', { eventName: 'visit_chat' });

});

// ...

}

// 🔴 Avoid: creating custom "lifecycle" Hooks

function useMount(fn) {

useEffect(() => {

fn();

}, []); // 🔴 React Hook useEffect has a missing dependency: 'fn'

}
```

**Custom “lifecycle” Hooks like `useMount` don’t fit well into the React paradigm.** For example, this code example has a mistake (it doesn’t “react” to `roomId` or `serverUrl` changes), but the linter won’t warn you about it because the linter only checks direct `useEffect` calls. It won’t know about your Hook.

If you’re writing an Effect, start by using the React API directly:

```
function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

// ✅ Good: two raw Effects separated by purpose

useEffect(() => {

const connection = createConnection({ serverUrl, roomId });

connection.connect();

return () => connection.disconnect();

}, [serverUrl, roomId]);

useEffect(() => {

post('/analytics/event', { eventName: 'visit_chat', roomId });

}, [roomId]);

// ...

}
```

Then, you can (but don’t have to) extract custom Hooks for different high-level use cases:

```
function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

// ✅ Great: custom Hooks named after their purpose

useChatRoom({ serverUrl, roomId });

useImpressionLog('visit_chat', { roomId });

// ...

}
```

**A good custom Hook makes the calling code more declarative by constraining what it does.** For example, `useChatRoom(options)` can only connect to the chat room, while `useImpressionLog(eventName, extraData)` can only send an impression log to the analytics. If your custom Hook API doesn’t constrain the use cases and is very abstract, in the long run it’s likely to introduce more problems than it solves.

### Custom Hooks help you migrate to better patterns

Effects are an [“escape hatch”](https://react.dev/learn/escape-hatches): you use them when you need to “step outside React” and when there is no better built-in solution for your use case. With time, the React team’s goal is to reduce the number of the Effects in your app to the minimum by providing more specific solutions to more specific problems. Wrapping your Effects in custom Hooks makes it easier to upgrade your code when these solutions become available.

Let’s return to this example:

App.jsuseOnlineStatus.js

useOnlineStatus.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

export function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    function handleOnline() {
      setIsOnline(true);
    }
    function handleOffline() {
      setIsOnline(false);
    }
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return isOnline;
}
```

Show more

In the above example, `useOnlineStatus` is implemented with a pair of [`useState`](https://react.dev/reference/react/useState) and [`useEffect`.](https://react.dev/reference/react/useEffect) However, this isn’t the best possible solution. There is a number of edge cases it doesn’t consider. For example, it assumes that when the component mounts, `isOnline` is already `true`, but this may be wrong if the network already went offline. You can use the browser [`navigator.onLine`](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/onLine) API to check for that, but using it directly would not work on the server for generating the initial HTML. In short, this code could be improved.

React includes a dedicated API called [`useSyncExternalStore`](https://react.dev/reference/react/useSyncExternalStore) which takes care of all of these problems for you. Here is your `useOnlineStatus` Hook, rewritten to take advantage of this new API:

App.jsuseOnlineStatus.js

useOnlineStatus.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useSyncExternalStore } from 'react';

function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}

export function useOnlineStatus() {
  return useSyncExternalStore(
    subscribe,
    () => navigator.onLine, // How to get the value on the client
    () => true // How to get the value on the server
  );
}
```

Show more

Notice how **you didn’t need to change any of the components** to make this migration:

```
function StatusBar() {

const isOnline = useOnlineStatus();

// ...

}

function SaveButton() {

const isOnline = useOnlineStatus();

// ...

}
```

This is another reason for why wrapping Effects in custom Hooks is often beneficial:

1. You make the data flow to and from your Effects very explicit.
2. You let your components focus on the intent rather than on the exact implementation of your Effects.
3. When React adds new features, you can remove those Effects without changing any of your components.

Similar to a [design system,](https://uxdesign.cc/everything-you-need-to-know-about-design-systems-54b109851969) you might find it helpful to start extracting common idioms from your app’s components into custom Hooks. This will keep your components’ code focused on the intent, and let you avoid writing raw Effects very often. Many excellent custom Hooks are maintained by the React community.

##### Deep Dive

#### Will React provide any built-in solution for data fetching?

Show Details

Today, with the [`use`](https://react.dev/reference/react/use#streaming-data-from-server-to-client) API, data can be read in render by passing a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) to `use`:

```
import { use, Suspense } from "react";

function Message({ messagePromise }) {

const messageContent = use(messagePromise);

return <p>Here is the message: {messageContent}</p>;

}

export function MessageContainer({ messagePromise }) {

return (

<Suspense fallback={<p>⌛Downloading message...</p>}>

<Message messagePromise={messagePromise} />

</Suspense>

);

}
```

We’re still working out the details, but we expect that in the future, you’ll write data fetching like this:

```
import { use } from 'react';

function ShippingForm({ country }) {

const cities = use(fetch(`/api/cities?country=${country}`));

const [city, setCity] = useState(null);

const areas = city ? use(fetch(`/api/areas?city=${city}`)) : null;

// ...
```

If you use custom Hooks like `useData` above in your app, it will require fewer changes to migrate to the eventually recommended approach than if you write raw Effects in every component manually. However, the old approach will still work fine, so if you feel happy writing raw Effects, you can continue to do that.

### There is more than one way to do it

Let’s say you want to implement a fade-in animation *from scratch* using the browser [`requestAnimationFrame`](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) API. You might start with an Effect that sets up an animation loop. During each frame of the animation, you could change the opacity of the DOM node you [hold in a ref](https://react.dev/learn/manipulating-the-dom-with-refs) until it reaches `1`. Your code might start like this:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect, useRef } from 'react';

function Welcome() {
  const ref = useRef(null);

  useEffect(() => {
    const duration = 1000;
    const node = ref.current;

    let startTime = performance.now();
    let frameId = null;

    function onFrame(now) {
      const timePassed = now - startTime;
      const progress = Math.min(timePassed / duration, 1);
      onProgress(progress);
      if (progress < 1) {
        // We still have more frames to paint
        frameId = requestAnimationFrame(onFrame);
      }
    }

    function onProgress(progress) {
      node.style.opacity = progress;
    }

    function start() {
      onProgress(0);
      startTime = performance.now();
      frameId = requestAnimationFrame(onFrame);
    }

    function stop() {
      cancelAnimationFrame(frameId);
      startTime = null;
      frameId = null;
    }

    start();
    return () => stop();
  }, []);

  return (
    <h1 className="welcome" ref={ref}>
      Welcome
    </h1>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Remove' : 'Show'}
      </button>
      <hr />
      {show && <Welcome />}
    </>
  );
}
```

Show more

To make the component more readable, you might extract the logic into a `useFadeIn` custom Hook:

App.jsuseFadeIn.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect, useRef } from 'react';
import { useFadeIn } from './useFadeIn.js';

function Welcome() {
  const ref = useRef(null);

  useFadeIn(ref, 1000);

  return (
    <h1 className="welcome" ref={ref}>
      Welcome
    </h1>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  return (
    <>
      <button onClick={() => setShow(!show)}>
        {show ? 'Remove' : 'Show'}
      </button>
      <hr />
      {show && <Welcome />}
    </>
  );
}
```

Show more

You could keep the `useFadeIn` code as is, but you could also refactor it more. For example, you could extract the logic for setting up the animation loop out of `useFadeIn` into a custom `useAnimationLoop` Hook:

App.jsuseFadeIn.js

useFadeIn.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { useEffectEvent } from 'react';

export function useFadeIn(ref, duration) {
  const [isRunning, setIsRunning] = useState(true);

  useAnimationLoop(isRunning, (timePassed) => {
    const progress = Math.min(timePassed / duration, 1);
    ref.current.style.opacity = progress;
    if (progress === 1) {
      setIsRunning(false);
    }
  });
}

function useAnimationLoop(isRunning, drawFrame) {
  const onFrame = useEffectEvent(drawFrame);

  useEffect(() => {
    if (!isRunning) {
      return;
    }

    const startTime = performance.now();
    let frameId = null;

    function tick(now) {
      const timePassed = now - startTime;
      onFrame(timePassed);
      frameId = requestAnimationFrame(tick);
    }

    tick();
    return () => cancelAnimationFrame(frameId);
  }, [isRunning]);
}
```

Show more

However, you didn’t *have to* do that. As with regular functions, ultimately you decide where to draw the boundaries between different parts of your code. You could also take a very different approach. Instead of keeping the logic in the Effect, you could move most of the imperative logic inside a JavaScript [class:](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)

App.jsuseFadeIn.jsanimation.js

useFadeIn.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { FadeInAnimation } from './animation.js';

export function useFadeIn(ref, duration) {
  useEffect(() => {
    const animation = new FadeInAnimation(ref.current);
    animation.start(duration);
    return () => {
      animation.stop();
    };
  }, [ref, duration]);
}
```

Effects let you connect React to external systems. The more coordination between Effects is needed (for example, to chain multiple animations), the more it makes sense to extract that logic out of Effects and Hooks *completely* like in the sandbox above. Then, the code you extracted *becomes* the “external system”. This lets your Effects stay simple because they only need to send messages to the system you’ve moved outside React.

The examples above assume that the fade-in logic needs to be written in JavaScript. However, this particular fade-in animation is both simpler and much more efficient to implement with a plain [CSS Animation:](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations)

App.jswelcome.css

welcome.css

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
.welcome {
  color: white;
  padding: 50px;
  text-align: center;
  font-size: 50px;
  background-image: radial-gradient(circle, rgba(63,94,251,1) 0%, rgba(252,70,107,1) 100%);

  animation: fadeIn 1000ms;
}

@keyframes fadeIn {
  0% { opacity: 0; }
  100% { opacity: 1; }
}
```

Sometimes, you don’t even need a Hook!

## Recap

* Custom Hooks let you share logic between components.
* Custom Hooks must be named starting with `use` followed by a capital letter.
* Custom Hooks only share stateful logic, not state itself.
* You can pass reactive values from one Hook to another, and they stay up-to-date.
* All Hooks re-run every time your component re-renders.
* The code of your custom Hooks should be pure, like your component’s code.
* Wrap event handlers received by custom Hooks into Effect Events.
* Don’t create custom Hooks like `useMount`. Keep their purpose specific.
* It’s up to you how and where to choose the boundaries of your code.

## Try out some challenges

1. Extract a `useCounter` Hook 2. Make the counter delay configurable 3. Extract `useInterval` out of `useCounter` 4. Fix a resetting interval 5. Implement a staggering movement

#### Challenge 1 of 5: Extract a `useCounter` Hook

This component uses a state variable and an Effect to display a number that increments every second. Extract this logic into a custom Hook called `useCounter`. Your goal is to make the `Counter` component implementation look exactly like this:

```
export default function Counter() {

const count = useCounter();

return <h1>Seconds passed: {count}</h1>;

}
```

You’ll need to write your custom Hook in `useCounter.js` and import it into the `App.js` file.

App.jsuseCounter.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    const id = setInterval(() => {
      setCount(c => c + 1);
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return <h1>Seconds passed: {count}</h1>;
}
```

Show solutionNext Challenge

[PreviousRemoving Effect Dependencies](https://react.dev/learn/removing-effect-dependencies)

---

---


# useState – React

URL: https://react.dev/reference/react/useState

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useState

`useState` is a React Hook that lets you add a [state variable](https://react.dev/learn/state-a-components-memory) to your component.

```
const [state, setState] = useState(initialState)
```

* [Reference](https://react.dev/reference/react/useState#reference) 
  + [`useState(initialState)`](https://react.dev/reference/react/useState#usestate)
  + [`set` functions, like `setSomething(nextState)`](https://react.dev/reference/react/useState#setstate)
* [Usage](https://react.dev/reference/react/useState#usage) 
  + [Adding state to a component](https://react.dev/reference/react/useState#adding-state-to-a-component)
  + [Updating state based on the previous state](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state)
  + [Updating objects and arrays in state](https://react.dev/reference/react/useState#updating-objects-and-arrays-in-state)
  + [Avoiding recreating the initial state](https://react.dev/reference/react/useState#avoiding-recreating-the-initial-state)
  + [Resetting state with a key](https://react.dev/reference/react/useState#resetting-state-with-a-key)
  + [Storing information from previous renders](https://react.dev/reference/react/useState#storing-information-from-previous-renders)
* [Troubleshooting](https://react.dev/reference/react/useState#troubleshooting) 
  + [I’ve updated the state, but logging gives me the old value](https://react.dev/reference/react/useState#ive-updated-the-state-but-logging-gives-me-the-old-value)
  + [I’ve updated the state, but the screen doesn’t update](https://react.dev/reference/react/useState#ive-updated-the-state-but-the-screen-doesnt-update)
  + [I’m getting an error: “Too many re-renders”](https://react.dev/reference/react/useState#im-getting-an-error-too-many-re-renders)
  + [My initializer or updater function runs twice](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice)
  + [I’m trying to set state to a function, but it gets called instead](https://react.dev/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead)

---

## Reference

### `useState(initialState)`

Call `useState` at the top level of your component to declare a [state variable.](https://react.dev/learn/state-a-components-memory)

```
import { useState } from 'react';

function MyComponent() {

const [age, setAge] = useState(28);

const [name, setName] = useState('Taylor');

const [todos, setTodos] = useState(() => createTodos());

// ...
```

The convention is to name state variables like `[something, setSomething]` using [array destructuring.](https://javascript.info/destructuring-assignment)

[See more examples below.](https://react.dev/reference/react/useState#usage)

#### Parameters

* `initialState`: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.
  + If you pass a function as `initialState`, it will be treated as an *initializer function*. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. [See an example below.](https://react.dev/reference/react/useState#avoiding-recreating-the-initial-state)

#### Returns

`useState` returns an array with exactly two values:

1. The current state. During the first render, it will match the `initialState` you have passed.
2. The [`set` function](https://react.dev/reference/react/useState#setstate) that lets you update the state to a different value and trigger a re-render.

#### Caveats

* `useState` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
* In Strict Mode, React will **call your initializer function twice** in order to [help you find accidental impurities.](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.

---

### `set` functions, like `setSomething(nextState)`

The `set` function returned by `useState` lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:

```
const [name, setName] = useState('Edward');

function handleClick() {

setName('Taylor');

setAge(a => a + 1);

// ...
```

#### Parameters

* `nextState`: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.
  + If you pass a function as `nextState`, it will be treated as an *updater function*. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. [See an example below.](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state)

#### Returns

`set` functions do not have a return value.

#### Caveats

* The `set` function **only updates the state variable for the *next* render**. If you read the state variable after calling the `set` function, [you will still get the old value](https://react.dev/reference/react/useState#ive-updated-the-state-but-logging-gives-me-the-old-value) that was on the screen before your call.
* If the new value you provide is identical to the current `state`, as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison, React will **skip re-rendering the component and its children.** This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code.
* React [batches state updates.](https://react.dev/learn/queueing-a-series-of-state-updates) It updates the screen **after all the event handlers have run** and have called their `set` functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use [`flushSync`.](https://react.dev/reference/react-dom/flushSync)
* The `set` function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. [Learn more about removing Effect dependencies.](https://react.dev/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect)
* Calling the `set` function *during rendering* is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to **store information from the previous renders**. [See an example below.](https://react.dev/reference/react/useState#storing-information-from-previous-renders)
* In Strict Mode, React will **call your updater function twice** in order to [help you find accidental impurities.](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored.

---

## Usage

### Adding state to a component

Call `useState` at the top level of your component to declare one or more [state variables.](https://react.dev/learn/state-a-components-memory)

```
import { useState } from 'react';

function MyComponent() {

const [age, setAge] = useState(42);

const [name, setName] = useState('Taylor');

// ...
```

The convention is to name state variables like `[something, setSomething]` using [array destructuring.](https://javascript.info/destructuring-assignment)

`useState` returns an array with exactly two items:

1. The current state of this state variable, initially set to the initial state you provided.
2. The `set` function that lets you change it to any other value in response to interaction.

To update what’s on the screen, call the `set` function with some next state:

```
function handleClick() {

setName('Robin');

}
```

React will store the next state, render your component again with the new values, and update the UI.

### Pitfall

Calling the `set` function [**does not** change the current state in the already executing code](https://react.dev/reference/react/useState#ive-updated-the-state-but-logging-gives-me-the-old-value):

```
function handleClick() {

setName('Robin');

console.log(name); // Still "Taylor"!

}
```

It only affects what `useState` will return starting from the *next* render.

#### Basic useState examples

1. Counter (number) 2. Text field (string) 3. Checkbox (boolean) 4. Form (two variables)

#### Example 1 of 4: Counter (number)

In this example, the `count` state variable holds a number. Clicking the button increments it.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      You pressed me {count} times
    </button>
  );
}
```

Next Example

---

### Updating state based on the previous state

Suppose the `age` is `42`. This handler calls `setAge(age + 1)` three times:

```
function handleClick() {

setAge(age + 1); // setAge(42 + 1)

setAge(age + 1); // setAge(42 + 1)

setAge(age + 1); // setAge(42 + 1)

}
```

However, after one click, `age` will only be `43` rather than `45`! This is because calling the `set` function [does not update](https://react.dev/learn/state-as-a-snapshot) the `age` state variable in the already running code. So each `setAge(age + 1)` call becomes `setAge(43)`.

To solve this problem, **you may pass an *updater function*** to `setAge` instead of the next state:

```
function handleClick() {

setAge(a => a + 1); // setAge(42 => 43)

setAge(a => a + 1); // setAge(43 => 44)

setAge(a => a + 1); // setAge(44 => 45)

}
```

Here, `a => a + 1` is your updater function. It takes the pending state and calculates the next state from it.

React puts your updater functions in a [queue.](https://react.dev/learn/queueing-a-series-of-state-updates) Then, during the next render, it will call them in the same order:

1. `a => a + 1` will receive `42` as the pending state and return `43` as the next state.
2. `a => a + 1` will receive `43` as the pending state and return `44` as the next state.
3. `a => a + 1` will receive `44` as the pending state and return `45` as the next state.

There are no other queued updates, so React will store `45` as the current state in the end.

By convention, it’s common to name the pending state argument for the first letter of the state variable name, like `a` for `age`. However, you may also call it like `prevAge` or something else that you find clearer.

React may [call your updaters twice](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice) in development to verify that they are [pure.](https://react.dev/learn/keeping-components-pure)

##### Deep Dive

#### Is using an updater always preferred?

Show Details

You might hear a recommendation to always write code like `setAge(a => a + 1)` if the state you’re setting is calculated from the previous state. There is no harm in it, but it is also not always necessary.

In most cases, there is no difference between these two approaches. React always makes sure that for intentional user actions, like clicks, the `age` state variable would be updated before the next click. This means there is no risk of a click handler seeing a “stale” `age` at the beginning of the event handler.

However, if you do multiple updates within the same event, updaters can be helpful. They’re also helpful if accessing the state variable itself is inconvenient (you might run into this when optimizing re-renders).

If you prefer consistency over slightly more verbose syntax, it’s reasonable to always write an updater if the state you’re setting is calculated from the previous state. If it’s calculated from the previous state of some *other* state variable, you might want to combine them into one object and [use a reducer.](https://react.dev/learn/extracting-state-logic-into-a-reducer)

#### The difference between passing an updater and passing the next state directly

1. Passing the updater function 2. Passing the next state directly

#### Example 1 of 2: Passing the updater function

This example passes the updater function, so the “+3” button works.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [age, setAge] = useState(42);

  function increment() {
    setAge(a => a + 1);
  }

  return (
    <>
      <h1>Your age: {age}</h1>
      <button onClick={() => {
        increment();
        increment();
        increment();
      }}>+3</button>
      <button onClick={() => {
        increment();
      }}>+1</button>
    </>
  );
}
```

Show more

Next Example

---

### Updating objects and arrays in state

You can put objects and arrays into state. In React, state is considered read-only, so **you should *replace* it rather than *mutate* your existing objects**. For example, if you have a `form` object in state, don’t mutate it:

```
// 🚩 Don't mutate an object in state like this:

form.firstName = 'Taylor';
```

Instead, replace the whole object by creating a new one:

```
// ✅ Replace state with a new object

setForm({

...form,

firstName: 'Taylor'

});
```

Read [updating objects in state](https://react.dev/learn/updating-objects-in-state) and [updating arrays in state](https://react.dev/learn/updating-arrays-in-state) to learn more.

#### Examples of objects and arrays in state

1. Form (object) 2. Form (nested object) 3. List (array) 4. Writing concise update logic with Immer

#### Example 1 of 4: Form (object)

In this example, the `form` state variable holds an object. Each input has a change handler that calls `setForm` with the next state of the entire form. The `{ ...form }` spread syntax ensures that the state object is replaced rather than mutated.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [form, setForm] = useState({
    firstName: 'Barbara',
    lastName: 'Hepworth',
    email: 'bhepworth@sculpture.com',
  });

  return (
    <>
      <label>
        First name:
        <input
          value={form.firstName}
          onChange={e => {
            setForm({
              ...form,
              firstName: e.target.value
            });
          }}
        />
      </label>
      <label>
        Last name:
        <input
          value={form.lastName}
          onChange={e => {
            setForm({
              ...form,
              lastName: e.target.value
            });
          }}
        />
      </label>
      <label>
        Email:
        <input
          value={form.email}
          onChange={e => {
            setForm({
              ...form,
              email: e.target.value
            });
          }}
        />
      </label>
      <p>
        {form.firstName}{' '}
        {form.lastName}{' '}
        ({form.email})
      </p>
    </>
  );
}
```

Show more

Next Example

---

### Avoiding recreating the initial state

React saves the initial state once and ignores it on the next renders.

```
function TodoList() {

const [todos, setTodos] = useState(createInitialTodos());

// ...
```

Although the result of `createInitialTodos()` is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.

To solve this, you may **pass it as an *initializer* function** to `useState` instead:

```
function TodoList() {

const [todos, setTodos] = useState(createInitialTodos);

// ...
```

Notice that you’re passing `createInitialTodos`, which is the *function itself*, and not `createInitialTodos()`, which is the result of calling it. If you pass a function to `useState`, React will only call it during initialization.

React may [call your initializers twice](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice) in development to verify that they are [pure.](https://react.dev/learn/keeping-components-pure)

#### The difference between passing an initializer and passing the initial state directly

1. Passing the initializer function 2. Passing the initial state directly

#### Example 1 of 2: Passing the initializer function

This example passes the initializer function, so the `createInitialTodos` function only runs during initialization. It does not run when component re-renders, such as when you type into the input.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function createInitialTodos() {
  const initialTodos = [];
  for (let i = 0; i < 50; i++) {
    initialTodos.push({
      id: i,
      text: 'Item ' + (i + 1)
    });
  }
  return initialTodos;
}

export default function TodoList() {
  const [todos, setTodos] = useState(createInitialTodos);
  const [text, setText] = useState('');

  return (
    <>
      <input
        value={text}
        onChange={e => setText(e.target.value)}
      />
      <button onClick={() => {
        setText('');
        setTodos([{
          id: todos.length,
          text: text
        }, ...todos]);
      }}>Add</button>
      <ul>
        {todos.map(item => (
          <li key={item.id}>
            {item.text}
          </li>
        ))}
      </ul>
    </>
  );
}
```

Show more

Next Example

---

### Resetting state with a key

You’ll often encounter the `key` attribute when [rendering lists.](https://react.dev/learn/rendering-lists) However, it also serves another purpose.

You can **reset a component’s state by passing a different `key` to a component.** In this example, the Reset button changes the `version` state variable, which we pass as a `key` to the `Form`. When the `key` changes, React re-creates the `Form` component (and all of its children) from scratch, so its state gets reset.

Read [preserving and resetting state](https://react.dev/learn/preserving-and-resetting-state) to learn more.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function App() {
  const [version, setVersion] = useState(0);

  function handleReset() {
    setVersion(version + 1);
  }

  return (
    <>
      <button onClick={handleReset}>Reset</button>
      <Form key={version} />
    </>
  );
}

function Form() {
  const [name, setName] = useState('Taylor');

  return (
    <>
      <input
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <p>Hello, {name}.</p>
    </>
  );
}
```

Show more

---

### Storing information from previous renders

Usually, you will update state in event handlers. However, in rare cases you might want to adjust state in response to rendering — for example, you might want to change a state variable when a prop changes.

In most cases, you don’t need this:

* **If the value you need can be computed entirely from the current props or other state, [remove that redundant state altogether.](https://react.dev/learn/choosing-the-state-structure#avoid-redundant-state)** If you’re worried about recomputing too often, the [`useMemo` Hook](https://react.dev/reference/react/useMemo) can help.
* If you want to reset the entire component tree’s state, [pass a different `key` to your component.](https://react.dev/reference/react/useState#resetting-state-with-a-key)
* If you can, update all the relevant state in the event handlers.

In the rare case that none of these apply, there is a pattern you can use to update state based on the values that have been rendered so far, by calling a `set` function while your component is rendering.

Here’s an example. This `CountLabel` component displays the `count` prop passed to it:

```
export default function CountLabel({ count }) {

return <h1>{count}</h1>

}
```

Say you want to show whether the counter has *increased or decreased* since the last change. The `count` prop doesn’t tell you this — you need to keep track of its previous value. Add the `prevCount` state variable to track it. Add another state variable called `trend` to hold whether the count has increased or decreased. Compare `prevCount` with `count`, and if they’re not equal, update both `prevCount` and `trend`. Now you can show both the current count prop and *how it has changed since the last render*.

App.jsCountLabel.js

CountLabel.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function CountLabel({ count }) {
  const [prevCount, setPrevCount] = useState(count);
  const [trend, setTrend] = useState(null);
  if (prevCount !== count) {
    setPrevCount(count);
    setTrend(count > prevCount ? 'increasing' : 'decreasing');
  }
  return (
    <>
      <h1>{count}</h1>
      {trend && <p>The count is {trend}</p>}
    </>
  );
}
```

Show more

Note that if you call a `set` function while rendering, it must be inside a condition like `prevCount !== count`, and there must be a call like `setPrevCount(count)` inside of the condition. Otherwise, your component would re-render in a loop until it crashes. Also, you can only update the state of the *currently rendering* component like this. Calling the `set` function of *another* component during rendering is an error. Finally, your `set` call should still [update state without mutation](https://react.dev/reference/react/useState#updating-objects-and-arrays-in-state) — this doesn’t mean you can break other rules of [pure functions.](https://react.dev/learn/keeping-components-pure)

This pattern can be hard to understand and is usually best avoided. However, it’s better than updating state in an effect. When you call the `set` function during render, React will re-render that component immediately after your component exits with a `return` statement, and before rendering the children. This way, children don’t need to render twice. The rest of your component function will still execute (and the result will be thrown away). If your condition is below all the Hook calls, you may add an early `return;` to restart rendering earlier.

---

## Troubleshooting

### I’ve updated the state, but logging gives me the old value

Calling the `set` function **does not change state in the running code**:

```
function handleClick() {

console.log(count);  // 0

setCount(count + 1); // Request a re-render with 1

console.log(count);  // Still 0!

setTimeout(() => {

console.log(count); // Also 0!

}, 5000);

}
```

This is because [states behaves like a snapshot.](https://react.dev/learn/state-as-a-snapshot) Updating state requests another render with the new state value, but does not affect the `count` JavaScript variable in your already-running event handler.

If you need to use the next state, you can save it in a variable before passing it to the `set` function:

```
const nextCount = count + 1;

setCount(nextCount);

console.log(count);     // 0

console.log(nextCount); // 1
```

---

### I’ve updated the state, but the screen doesn’t update

React will **ignore your update if the next state is equal to the previous state,** as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. This usually happens when you change an object or an array in state directly:

```
obj.x = 10;  // 🚩 Wrong: mutating existing object

setObj(obj); // 🚩 Doesn't do anything
```

You mutated an existing `obj` object and passed it back to `setObj`, so React ignored the update. To fix this, you need to ensure that you’re always [*replacing* objects and arrays in state instead of *mutating* them](https://react.dev/reference/react/useState#updating-objects-and-arrays-in-state):

```
// ✅ Correct: creating a new object

setObj({

...obj,

x: 10

});
```

---

### I’m getting an error: “Too many re-renders”

You might get an error that says: `Too many re-renders. React limits the number of renders to prevent an infinite loop.` Typically, this means that you’re unconditionally setting state *during render*, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:

```
// 🚩 Wrong: calls the handler during render

return <button onClick={handleClick()}>Click me</button>

// ✅ Correct: passes down the event handler

return <button onClick={handleClick}>Click me</button>

// ✅ Correct: passes down an inline function

return <button onClick={(e) => handleClick(e)}>Click me</button>
```

If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific `set` function call responsible for the error.

---

### My initializer or updater function runs twice

In [Strict Mode](https://react.dev/reference/react/StrictMode), React will call some of your functions twice instead of once:

```
function TodoList() {

// This component function will run twice for every render.

const [todos, setTodos] = useState(() => {

// This initializer function will run twice during initialization.

return createTodos();

});

function handleClick() {

setTodos(prevTodos => {

// This updater function will run twice for every click.

return [...prevTodos, createTodo()];

});

}

// ...
```

This is expected and shouldn’t break your code.

This **development-only** behavior helps you [keep components pure.](https://react.dev/learn/keeping-components-pure) React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.

For example, this impure updater function mutates an array in state:

```
setTodos(prevTodos => {

// 🚩 Mistake: mutating state

prevTodos.push(createTodo());

});
```

Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by [replacing the array instead of mutating it](https://react.dev/reference/react/useState#updating-objects-and-arrays-in-state):

```
setTodos(prevTodos => {

// ✅ Correct: replacing with new state

return [...prevTodos, createTodo()];

});
```

Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. **Only component, initializer, and updater functions need to be pure.** Event handlers don’t need to be pure, so React will never call your event handlers twice.

Read [keeping components pure](https://react.dev/learn/keeping-components-pure) to learn more.

---

### I’m trying to set state to a function, but it gets called instead

You can’t put a function into state like this:

```
const [fn, setFn] = useState(someFunction);

function handleClick() {

setFn(someOtherFunction);

}
```

Because you’re passing a function, React assumes that `someFunction` is an [initializer function](https://react.dev/reference/react/useState#avoiding-recreating-the-initial-state), and that `someOtherFunction` is an [updater function](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state), so it tries to call them and store the result. To actually *store* a function, you have to put `() =>` before them in both cases. Then React will store the functions you pass.

```
const [fn, setFn] = useState(() => someFunction);

function handleClick() {

setFn(() => someOtherFunction);

}
```

[PrevioususeRef](https://react.dev/reference/react/useRef)[NextuseSyncExternalStore](https://react.dev/reference/react/useSyncExternalStore)

---

---


# Denial of Service and Source Code Exposure in React Server Components – React

URL: https://react.dev/blog/2025/12/11/denial-of-service-and-source-code-exposure-in-react-server-components

[Blog](https://react.dev/blog)

# Denial of Service and Source Code Exposure in React Server Components

December 11, 2025 by [The React Team](https://react.dev/community/team)

*Updated January 26, 2026.*

---

Security researchers have found and disclosed two additional vulnerabilities in React Server Components while attempting to exploit the patches in last week’s critical vulnerability.

**These new vulnerabilities do not allow for Remote Code Execution.** The patch for React2Shell remains effective at mitigating the Remote Code Execution exploit.

---

The new vulnerabilities are disclosed as:

* **Denial of Service - High Severity**: [CVE-2025-55184](https://www.cve.org/CVERecord?id=CVE-2025-55184), [CVE-2025-67779](https://www.cve.org/CVERecord?id=CVE-2025-67779), and [CVE-2026-23864](https://www.cve.org/CVERecord?id=CVE-2026-23864) (CVSS 7.5)
* **Source Code Exposure - Medium Severity**: [CVE-2025-55183](https://www.cve.org/CVERecord?id=CVE-2025-55183) (CVSS 5.3)

We recommend upgrading immediately due to the severity of the newly disclosed vulnerabilities.

### Note

#### The patches published earlier are vulnerable.

If you already updated for the previous vulnerabilities, you will need to update again.

If you updated to 19.0.3, 19.1.4, and 19.2.3, [these are incomplete](https://react.dev/blog/2025/12/11/denial-of-service-and-source-code-exposure-in-react-server-components#additional-fix-published), and you will need to update again.

Please see [the instructions in the previous post](https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components#update-instructions) for upgrade steps.

---

*Updated January 26, 2026.*

Further details of these vulnerabilities will be provided after the rollout of the fixes are complete.

## Immediate Action Required

These vulnerabilities are present in the same packages and versions as [CVE-2025-55182](https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components).

This includes 19.0.0, 19.0.1, 19.0.2, 19.0.3, 19.1.0, 19.1.1, 19.1.2, 19.1.3, 19.2.0, 19.2.1, 19.2.2, and 19.2.3 of:

* [react-server-dom-webpack](https://www.npmjs.com/package/react-server-dom-webpack)
* [react-server-dom-parcel](https://www.npmjs.com/package/react-server-dom-parcel)
* [react-server-dom-turbopack](https://www.npmjs.com/package/react-server-dom-turbopack?activeTab=readme)

Fixes were backported to versions 19.0.4, 19.1.5, and 19.2.4. If you are using any of the above packages please upgrade to any of the fixed versions immediately.

As before, if your app’s React code does not use a server, your app is not affected by these vulnerabilities. If your app does not use a framework, bundler, or bundler plugin that supports React Server Components, your app is not affected by these vulnerabilities.

### Note

#### It’s common for critical CVEs to uncover follow‑up vulnerabilities.

When a critical vulnerability is disclosed, researchers scrutinize adjacent code paths looking for variant exploit techniques to test whether the initial mitigation can be bypassed.

This pattern shows up across the industry, not just in JavaScript. For example, after [Log4Shell](https://nvd.nist.gov/vuln/detail/cve-2021-44228), additional CVEs ([1](https://nvd.nist.gov/vuln/detail/cve-2021-45046), [2](https://nvd.nist.gov/vuln/detail/cve-2021-45105)) were reported as the community probed the original fix.

Additional disclosures can be frustrating, but they are generally a sign of a healthy response cycle.

### Affected frameworks and bundlers

Some React frameworks and bundlers depended on, had peer dependencies for, or included the vulnerable React packages. The following React frameworks & bundlers are affected: [next](https://www.npmjs.com/package/next), [react-router](https://www.npmjs.com/package/react-router), [waku](https://www.npmjs.com/package/waku), [@parcel/rsc](https://www.npmjs.com/package/@parcel/rsc), [@vite/rsc-plugin](https://www.npmjs.com/package/@vitejs/plugin-rsc), and [rwsdk](https://www.npmjs.com/package/rwsdk).

Please see [the instructions in the previous post](https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components#update-instructions) for upgrade steps.

### Hosting Provider Mitigations

As before, we have worked with a number of hosting providers to apply temporary mitigations.

You should not depend on these to secure your app, and still update immediately.

### React Native

For React Native users not using a monorepo or `react-dom`, your `react` version should be pinned in your `package.json`, and there are no additional steps needed.

If you are using React Native in a monorepo, you should update *only* the impacted packages if they are installed:

* `react-server-dom-webpack`
* `react-server-dom-parcel`
* `react-server-dom-turbopack`

This is required to mitigate the security advisories, but you do not need to update `react` and `react-dom` so this will not cause the version mismatch error in React Native.

See [this issue](https://github.com/facebook/react-native/issues/54772#issuecomment-3617929832) for more information.

---

## High Severity: Multiple Denial of Service

**CVEs:** [CVE-2026-23864](https://www.cve.org/CVERecord?id=CVE-2026-23864)
**Base Score:** 7.5 (High)
**Date**: January 26, 2025

Security researchers discovered additional DoS vulnerabilities still exist in React Server Components.

The vulnerabilities are triggered by sending specially crafted HTTP requests to Server Function endpoints, and could lead to server crashes, out-of-memory exceptions or excessive CPU usage; depending on the vulnerable code path being exercised, the application configuration and application code.

The patches published January 26th mitigate these DoS vulnerabilities.

### Note

#### Additional fixes published

The original fix addressing the DoS in [CVE-2025-55184](https://www.cve.org/CVERecord?id=CVE-2025-55184) was incomplete.

This left previous versions vulnerable. Versions 19.0.4, 19.1.5, 19.2.4 are safe.

---

*Updated January 26, 2026.*

---

## High Severity: Denial of Service

**CVEs:** [CVE-2025-55184](https://www.cve.org/CVERecord?id=CVE-2025-55184) and [CVE-2025-67779](https://www.cve.org/CVERecord?id=CVE-2025-67779)
**Base Score:** 7.5 (High)

Security researchers have discovered that a malicious HTTP request can be crafted and sent to any Server Functions endpoint that, when deserialized by React, can cause an infinite loop that hangs the server process and consumes CPU. Even if your app does not implement any React Server Function endpoints it may still be vulnerable if your app supports React Server Components.

This creates a vulnerability vector where an attacker may be able to deny users from accessing the product, and potentially have a performance impact on the server environment.

The patches published today mitigate by preventing the infinite loop.

## Medium Severity: Source Code Exposure

**CVE:** [CVE-2025-55183](https://www.cve.org/CVERecord?id=CVE-2025-55183)
**Base Score**: 5.3 (Medium)

A security researcher has discovered that a malicious HTTP request sent to a vulnerable Server Function may unsafely return the source code of any Server Function. Exploitation requires the existence of a Server Function which explicitly or implicitly exposes a stringified argument:

```
'use server';

export async function serverFunction(name) {

const conn = db.createConnection('SECRET KEY');

const user = await conn.createUser(name); // implicitly stringified, leaked in db

return {

id: user.id,

message: `Hello, ${name}!` // explicitly stringified, leaked in reply

}}
```

An attacker may be able to leak the following:

```
0:{"a":"$@1","f":"","b":"Wy43RxUKdxmr5iuBzJ1pN"}

1:{"id":"tva1sfodwq","message":"Hello, async function(a){console.log(\"serverFunction\");let b=i.createConnection(\"SECRET KEY\");return{id:(await b.createUser(a)).id,message:`Hello, ${a}!`}}!"}
```

The patches published today prevent stringifying the Server Function source code.

### Note

#### Only secrets in source code may be exposed.

Secrets hardcoded in source code may be exposed, but runtime secrets such as `process.env.SECRET` are not affected.

The scope of the exposed code is limited to the code inside the Server Function, which may include other functions depending on the amount of inlining your bundler provides.

Always verify against production bundles.

---

## Timeline

* **December 3rd**: Leak reported to Vercel and [Meta Bug Bounty](https://bugbounty.meta.com/) by [Andrew MacPherson](https://github.com/AndrewMohawk).
* **December 4th**: Initial DoS reported to [Meta Bug Bounty](https://bugbounty.meta.com/) by [RyotaK](https://ryotak.net).
* **December 6th**: Both issues confirmed by the React team, and the team began investigating.
* **December 7th**: Initial fixes created and the React team began verifying and planning new patch.
* **December 8th**: Affected hosting providers and open source projects notified.
* **December 10th**: Hosting provider mitigations in place and patches verified.
* **December 11th**: Additional DoS reported to [Meta Bug Bounty](https://bugbounty.meta.com/) by Shinsaku Nomura.
* **December 11th**: Patches published and publicly disclosed as [CVE-2025-55183](https://www.cve.org/CVERecord?id=CVE-2025-55183) and [CVE-2025-55184](https://www.cve.org/CVERecord?id=CVE-2025-55184).
* **December 11th**: Missing DoS case found internally, patched and publicly disclosed as [CVE-2025-67779](https://www.cve.org/CVERecord?id=CVE-2025-67779).
* **January 26th**: Additional DoS cases found, patched, and publicly disclosed as [CVE-2026-23864](https://www.cve.org/CVERecord?id=CVE-2026-23864).

---

## Attribution

Thank you to [Andrew MacPherson (AndrewMohawk)](https://github.com/AndrewMohawk) for reporting the Source Code Exposure, [RyotaK](https://ryotak.net) from GMO Flatt Security Inc and Shinsaku Nomura of Bitforest Co., Ltd. for reporting the Denial of Service vulnerabilities. Thank you to [Mufeed VH](https://x.com/mufeedvh) from [Winfunc Research](https://winfunc.com), [Joachim Viide](https://jviide.iki.fi), [RyotaK](https://ryotak.net) from [GMO Flatt Security Inc](https://flatt.tech/en/) and Xiangwei Zhang of Tencent Security YUNDING LAB for reporting the additional DoS vulnerabilities.

[PreviousBlog](https://react.dev/blog)[NextCritical Security Vulnerability in React Server Components](https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components)

---

---


# Critical Security Vulnerability in React Server Components – React

URL: https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components

[Blog](https://react.dev/blog)

# Critical Security Vulnerability in React Server Components

December 3, 2025 by [The React Team](https://react.dev/community/team)

---

There is an unauthenticated remote code execution vulnerability in React Server Components.

We recommend upgrading immediately.

---

On November 29th, Lachlan Davidson reported a security vulnerability in React that allows unauthenticated remote code execution by exploiting a flaw in how React decodes payloads sent to React Server Function endpoints.

Even if your app does not implement any React Server Function endpoints it may still be vulnerable if your app supports React Server Components.

This vulnerability was disclosed as [CVE-2025-55182](https://www.cve.org/CVERecord?id=CVE-2025-55182) and is rated CVSS 10.0.

The vulnerability is present in versions 19.0, 19.1.0, 19.1.1, and 19.2.0 of:

* [react-server-dom-webpack](https://www.npmjs.com/package/react-server-dom-webpack)
* [react-server-dom-parcel](https://www.npmjs.com/package/react-server-dom-parcel)
* [react-server-dom-turbopack](https://www.npmjs.com/package/react-server-dom-turbopack?activeTab=readme)

## Immediate Action Required

A fix was introduced in versions [19.0.1](https://github.com/facebook/react/releases/tag/v19.0.1), [19.1.2](https://github.com/facebook/react/releases/tag/v19.1.2), and [19.2.1](https://github.com/facebook/react/releases/tag/v19.2.1). If you are using any of the above packages please upgrade to any of the fixed versions immediately.

If your app’s React code does not use a server, your app is not affected by this vulnerability. If your app does not use a framework, bundler, or bundler plugin that supports React Server Components, your app is not affected by this vulnerability.

### Affected frameworks and bundlers

Some React frameworks and bundlers depended on, had peer dependencies for, or included the vulnerable React packages. The following React frameworks & bundlers are affected: [next](https://www.npmjs.com/package/next), [react-router](https://www.npmjs.com/package/react-router), [waku](https://www.npmjs.com/package/waku), [@parcel/rsc](https://www.npmjs.com/package/@parcel/rsc), [@vitejs/plugin-rsc](https://www.npmjs.com/package/@vitejs/plugin-rsc), and [rwsdk](https://www.npmjs.com/package/rwsdk).

See the [update instructions below](https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components#update-instructions) for how to upgrade to these patches.

### Hosting Provider Mitigations

We have worked with a number of hosting providers to apply temporary mitigations.

You should not depend on these to secure your app, and still update immediately.

### Vulnerability overview

[React Server Functions](https://react.dev/reference/rsc/server-functions) allow a client to call a function on a server. React provides integration points and tools that frameworks and bundlers use to help React code run on both the client and the server. React translates requests on the client into HTTP requests which are forwarded to a server. On the server, React translates the HTTP request into a function call and returns the needed data to the client.

An unauthenticated attacker could craft a malicious HTTP request to any Server Function endpoint that, when deserialized by React, achieves remote code execution on the server. Further details of the vulnerability will be provided after the rollout of the fix is complete.

## Update Instructions

### Note

These instructions have been updated to include the new vulnerabilities:

* **Denial of Service - High Severity**: [CVE-2025-55184](https://www.cve.org/CVERecord?id=CVE-2025-55184) and [CVE-2025-67779](https://www.cve.org/CVERecord?id=CVE-2025-67779) (CVSS 7.5)
* **Source Code Exposure - Medium Severity**: [CVE-2025-55183](https://www.cve.org/CVERecord?id=CVE-2025-55183) (CVSS 5.3)
* **Denial of Service - High Severity**: January 26, 2026 [CVE-2026-23864](https://www.cve.org/CVERecord?id=CVE-2026-23864) (CVSS 7.5)

See the [follow-up blog post](https://react.dev/blog/2025/12/11/denial-of-service-and-source-code-exposure-in-react-server-components) for more info.

---

*Updated January 26, 2026.*

### Next.js

All users should upgrade to the latest patched version in their release line:

```
npm install next@14.2.35  // for 13.3.x, 13.4.x, 13.5.x, 14.x

npm install next@15.0.8   // for 15.0.x

npm install next@15.1.12  // for 15.1.x

npm install next@15.2.9   // for 15.2.x

npm install next@15.3.9   // for 15.3.x

npm install next@15.4.11  // for 15.4.x

npm install next@15.5.10  // for 15.5.x

npm install next@16.0.11  // for 16.0.x

npm install next@16.1.5   // for 16.1.x

npm install next@15.6.0-canary.60   // for 15.x canary releases

npm install next@16.1.0-canary.19   // for 16.x canary releases
```

15.0.8, 15.1.12, 15.2.9, 15.3.9, 15.4.10, 15.5.10, 15.6.0-canary.61, 16.0.11, 16.1.5

If you are on version `13.3` or later version of Next.js 13 (`13.3.x`, `13.4.x`, or `13.5.x`) please upgrade to version `14.2.35`.

If you are on `next@14.3.0-canary.77` or a later canary release, downgrade to the latest stable 14.x release:

```
npm install next@14
```

See the [Next.js blog](https://nextjs.org/blog/security-update-2025-12-11) for the latest update instructions and the [previous changelog](https://nextjs.org/blog/CVE-2025-66478) for more info.

### React Router

If you are using React Router’s unstable RSC APIs, you should upgrade the following package.json dependencies if they exist:

```
npm install react@latest

npm install react-dom@latest

npm install react-server-dom-parcel@latest

npm install react-server-dom-webpack@latest

npm install @vitejs/plugin-rsc@latest
```

### Expo

To learn more about mitigating, read the article on [expo.dev/changelog](https://expo.dev/changelog/mitigating-critical-security-vulnerability-in-react-server-components).

### Redwood SDK

Ensure you are on rwsdk>=1.0.0-alpha.0

For the latest beta version:

```
npm install rwsdk@latest
```

Upgrade to the latest `react-server-dom-webpack`:

```
npm install react@latest react-dom@latest react-server-dom-webpack@latest
```

See [Redwood docs](https://docs.rwsdk.com/migrating/) for more migration instructions.

### Waku

Upgrade to the latest `react-server-dom-webpack`:

```
npm install react@latest react-dom@latest react-server-dom-webpack@latest waku@latest
```

See [Waku announcement](https://github.com/wakujs/waku/discussions/1823) for more migration instructions.

### `@vitejs/plugin-rsc`

Upgrade to the latest RSC plugin:

```
npm install react@latest react-dom@latest @vitejs/plugin-rsc@latest
```

### `react-server-dom-parcel`

Update to the latest version:

```
npm install react@latest react-dom@latest react-server-dom-parcel@latest
```

### `react-server-dom-turbopack`

Update to the latest version:

```
npm install react@latest react-dom@latest react-server-dom-turbopack@latest
```

### `react-server-dom-webpack`

Update to the latest version:

```
npm install react@latest react-dom@latest react-server-dom-webpack@latest
```

### React Native

For React Native users not using a monorepo or `react-dom`, your `react` version should be pinned in your `package.json`, and there are no additional steps needed.

If you are using React Native in a monorepo, you should update *only* the impacted packages if they are installed:

* `react-server-dom-webpack`
* `react-server-dom-parcel`
* `react-server-dom-turbopack`

This is required to mitigate the security advisory, but you do not need to update `react` and `react-dom` so this will not cause the version mismatch error in React Native.

See [this issue](https://github.com/facebook/react-native/issues/54772#issuecomment-3617929832) for more information.

## Timeline

* **November 29th**: Lachlan Davidson reported the security vulnerability via [Meta Bug Bounty](https://bugbounty.meta.com/).
* **November 30th**: Meta security researchers confirmed and began working with the React team on a fix.
* **December 1st**: A fix was created and the React team began working with affected hosting providers and open source projects to validate the fix, implement mitigations and roll out the fix
* **December 3rd**: The fix was published to npm and the publicly disclosed as CVE-2025-55182.

## Attribution

Thank you to [Lachlan Davidson](https://github.com/lachlan2k) for discovering, reporting, and working to help fix this vulnerability.

[PreviousDenial of Service and Source Code Exposure in React Server Components](https://react.dev/blog/2025/12/11/denial-of-service-and-source-code-exposure-in-react-server-components)[NextReact Conf 2025 Recap](https://react.dev/blog/2025/10/16/react-conf-2025-recap)

---

---


# React Conf 2025 Recap – React

URL: https://react.dev/blog/2025/10/16/react-conf-2025-recap

[Blog](https://react.dev/blog)

# React Conf 2025 Recap

Oct 16, 2025 by [Matt Carroll](https://x.com/mattcarrollcode) and [Ricky Hanlon](https://bsky.app/profile/ricky.fm)

---

Last week we hosted React Conf 2025 where we announced the [React Foundation](https://react.dev/blog/2025/10/07/introducing-the-react-foundation) and showcased new features coming to React and React Native.

---

React Conf 2025 was held on October 7-8, 2025, in Henderson, Nevada.

The entire [day 1](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=1067s) and [day 2](https://www.youtube.com/watch?v=p9OcztRyDl0&t=2299s) streams are available online, and you can view photos from the event [here](https://conf.react.dev/photos).

In this post, we’ll summarize the talks and announcements from the event.

## Day 1 Keynote

*Watch the full day 1 stream [here.](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=1067s)*

In the day 1 keynote, Joe Savona shared the updates from the team and community since the last React Conf and highlights from React 19.0 and 19.1.

Mofei Zhang highlighted the new features in React 19.2 including:

* [`<Activity />`](https://react.dev/reference/react/Activity) — a new component to manage visibility.
* [`useEffectEvent`](https://react.dev/reference/react/useEffectEvent) to fire events from Effects.
* [Performance Tracks](https://react.dev/reference/dev-tools/react-performance-tracks) — a new profiling tool in DevTools.
* [Partial Pre-Rendering](https://react.dev/blog/2025/10/01/react-19-2#partial-pre-rendering) to pre-render part of an app ahead of time, and resume rendering it later.

Jack Pope announced new features in Canary including:

* [`<ViewTransition />`](https://react.dev/reference/react/ViewTransition) — a new component to animate page transitions.
* [Fragment Refs](https://react.dev/reference/react/Fragment#fragmentinstance) — a new way to interact with the DOM nodes wrapped by a Fragment.

Lauren Tan announced [React Compiler v1.0](https://react.dev/blog/2025/10/07/react-compiler-1) and recommended all apps use React Compiler for benefits like:

* [Automatic memoization](https://react.dev/learn/react-compiler/introduction#what-does-react-compiler-do) that understands React code.
* [New lint rules](https://react.dev/learn/react-compiler/installation#eslint-integration) powered by React Compiler to teach best practices.
* [Default support](https://react.dev/learn/react-compiler/installation#basic-setup) for new apps in Vite, Next.js, and Expo.
* [Migration guides](https://react.dev/learn/react-compiler/incremental-adoption) for existing apps migrating to React Compiler.

Finally, Seth Webster announced the [React Foundation](https://react.dev/blog/2025/10/07/introducing-the-react-foundation) to steward React’s open source development and community.

Watch day 1 here:

## Day 2 Keynote

*Watch the full day 2 stream [here.](https://www.youtube.com/watch?v=p9OcztRyDl0&t=2299s)*

Jorge Cohen and Nicola Corti kicked off day 2 highlighting React Native’s incredible growth with 4M weekly downloads (100% growth YoY), and some notable app migrations from Shopify, Zalando, and HelloFresh, award-winning apps like RISE, RUNNA, and Partyful, and AI apps from Mistral, Replit, and v0.

Riccardo Cipolleschi shared two major announcements for React Native:

* [React Native 0.82 will be New Architecture only](https://reactnative.dev/blog/2025/10/08/react-native-0.82#new-architecture-only)
* [Experimental Hermes V1 support](https://reactnative.dev/blog/2025/10/08/react-native-0.82#experimental-hermes-v1)

Ruben Norte and Alex Hunt finished out the keynote by announcing:

* [New web-aligned DOM APIs](https://reactnative.dev/blog/2025/10/08/react-native-0.82#dom-node-apis) for improved compatibility with React on the web.
* [New Performance APIs](https://reactnative.dev/blog/2025/10/08/react-native-0.82#web-performance-apis-canary) with a new network panel and desktop app.

Watch day 2 here:

## React team talks

Throughout the conference, there were talks from the React team including:

* [Async React Part I](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=10907s) and [Part II](https://www.youtube.com/watch?v=p9OcztRyDl0&t=29073s) [(Ricky Hanlon)](https://x.com/rickhanlonii) showed what’s possible using the last 10 years of innovation.
* [Exploring React Performance](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=20274s) [(Joe Savona)](https://x.com/en_js) showed the results of our React performance research.
* [Reimagining Lists in React Native](https://www.youtube.com/watch?v=p9OcztRyDl0&t=10382s) [(Luna Wei)](https://x.com/lunaleaps) introduced Virtual View, a new primitive for lists that manages visibility with mode-based rendering (hidden/pre-render/visible).
* [Profiling with React Performance tracks](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=8276s) [(Ruslan Lesiutin)](https://x.com/ruslanlesiutin) showed how to use the new React Performance Tracks to debug performance issues and build great apps.
* [React Strict DOM](https://www.youtube.com/watch?v=p9OcztRyDl0&t=9026s) [(Nicolas Gallagher)](https://nicolasgallagher.com/) talked about Meta’s approach to using web code on native.
* [View Transitions and Activity](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=4870s) [(Chance Strickland)](https://x.com/chancethedev) — Chance worked with the React team to showcase how to use `<Activity />` and `<ViewTransition />` to build fast, native-feeling animations.
* [In case you missed the memo](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=9525s) [(Cody Olsen)](https://bsky.app/profile/codey.bsky.social) - Cody worked with the React team to adopt the Compiler at Sanity Studio, and shared how it went.

## React framework talks

The second half of day 2 had a series of talks from React Framework teams including:

* [React Native, Amplified](https://www.youtube.com/watch?v=p9OcztRyDl0&t=5737s) by [Giovanni Laquidara](https://x.com/giolaq) and [Eric Fahsl](https://x.com/efahsl).
* [React Everywhere: Bringing React Into Native Apps](https://www.youtube.com/watch?v=p9OcztRyDl0&t=18213s) by [Mike Grabowski](https://x.com/grabbou).
* [How Parcel Bundles React Server Components](https://www.youtube.com/watch?v=p9OcztRyDl0&t=19538s) by [Devon Govett](https://x.com/devonovett).
* [Designing Page Transitions](https://www.youtube.com/watch?v=p9OcztRyDl0&t=20640s) by [Delba de Oliveira](https://x.com/delba_oliveira).
* [Build Fast, Deploy Faster — Expo in 2025](https://www.youtube.com/watch?v=p9OcztRyDl0&t=21350s) by [Evan Bacon](https://x.com/baconbrix).
* [The React Router’s take on RSC](https://www.youtube.com/watch?v=p9OcztRyDl0&t=22367s) by [Kent C. Dodds](https://x.com/kentcdodds).
* [RedwoodSDK: Web Standards Meet Full-Stack React](https://www.youtube.com/watch?v=p9OcztRyDl0&t=24992s) by [Peter Pistorius](https://x.com/appfactory) and [Aurora Scharff](https://x.com/aurorascharff).
* [TanStack Start](https://www.youtube.com/watch?v=p9OcztRyDl0&t=26065s) by [Tanner Linsley](https://x.com/tannerlinsley).

## Q&A

There were three Q&A panels during the conference:

* [React Team at Meta Q&A](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=26304s) hosted by [Shruti Kapoor](https://x.com/shrutikapoor08)
* [React Frameworks Q&A](https://www.youtube.com/watch?v=p9OcztRyDl0&t=26812s) hosted by [Jack Herrington](https://x.com/jherr)
* [React and AI Panel](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=18741s) hosted by [Lee Robinson](https://x.com/leerob)

## And more…

We also heard talks from the community including:

* [Building an MCP Server](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=24204s) by [James Swinton](https://x.com/JamesSwintonDev) ([AG Grid](https://www.ag-grid.com/?utm_source=react-conf&utm_medium=react-conf-homepage&utm_campaign=react-conf-sponsorship-2025))
* [Modern Emails using React](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=25521s) by [Zeno Rocha](https://x.com/zenorocha) ([Resend](https://resend.com/))
* [Why React Native Apps Make All the Money](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=24917s) by [Perttu Lähteenlahti](https://x.com/plahteenlahti) ([RevenueCat](https://www.revenuecat.com/))
* [The invisible craft of great UX](https://www.youtube.com/watch?v=zyVRg2QR6LA&t=23400s) by [Michał Dudak](https://x.com/michaldudak) ([MUI](https://mui.com/))

## Thanks

Thank you to all the staff, speakers, and participants, who made React Conf 2025 possible. There are too many to list, but we want to thank a few in particular.

Thank you to [Matt Carroll](https://x.com/mattcarrollcode) for planning the entire event and building the conference website.

Thank you to [Michael Chan](https://x.com/chantastic) for MCing React Conf with incredible dedication and energy, delivering thoughtful speaker intros, fun jokes, and genuine enthusiasm throughout the event. Thank you to [Jorge Cohen](https://x.com/JorgeWritesCode) for hosting the livestream, interviewing each speaker, and bringing the in-person React Conf experience online.

Thank you to [Mateusz Kornacki](https://x.com/mat_kornacki), [Mike Grabowski](https://x.com/grabbou), [Kris Lis](https://www.linkedin.com/in/krzysztoflisakakris/) and the team at [Callstack](https://www.callstack.com/) for co-organizing React Conf and providing design, engineering, and marketing support. Thank you to the [ZeroSlope team](https://zeroslopeevents.com/contact-us/): Sunny Leggett, Tracey Harrison, Tara Larish, Whitney Pogue, and Brianne Smythia for helping to organize the event.

Thank you to [Jorge Cabiedes Acosta](https://github.com/jorge-cab), [Gijs Weterings](https://x.com/gweterings), [Tim Yung](https://x.com/yungsters), and [Jason Bonta](https://x.com/someextent) for bringing questions from the Discord to the livestream. Thank you to [Lynn Yu](https://github.com/lynnshaoyu) for leading the moderation of the Discord. Thank you to [Seth Webster](https://x.com/sethwebster) for welcoming us each day; and to [Christopher Chedeau](https://x.com/vjeux), [Kevin Gozali](https://x.com/fkgozali), and [Pieter De Baets](https://x.com/Javache) for joining us with a special message during the after-party.

Thank you to [Kadi Kraman](https://x.com/kadikraman), [Beto](https://x.com/betomoedano) and [Nicolas Solerieu](https://www.linkedin.com/in/nicolas-solerieu/) for building the conference mobile app. Thank you [Wojtek Szafraniec](https://x.com/wojteg1337) for help with the conference website. Thank you to [Mustache](https://www.mustachepower.com/) & [Cornerstone](https://cornerstoneav.com/) for the visuals, stage, and sound; and to the Westin Hotel for hosting us.

Thank you to all the sponsors who made the event possible: [Amazon](https://www.developer.amazon.com), [MUI](https://mui.com/), [Vercel](https://vercel.com/), [Expo](https://expo.dev/), [RedwoodSDK](https://rwsdk.com), [Ag Grid](https://www.ag-grid.com), [RevenueCat](https://www.revenuecat.com/), [Resend](https://resend.com), [Mux](https://www.mux.com/), [Old Mission](https://www.oldmissioncapital.com/), [Arcjet](https://arcjet.com), [Infinite Red](https://infinite.red/), and [RenderATL](https://renderatl.com).

Thank you to all the speakers who shared their knowledge and experience with the community.

Finally, thank you to everyone who attended in person and online to show what makes React, React. React is more than a library, it is a community, and it was inspiring to see everyone come together to share and learn together.

See you next time!

[PreviousCritical Security Vulnerability in React Server Components](https://react.dev/blog/2025/12/03/critical-security-vulnerability-in-react-server-components)[NextReact Compiler v1.0](https://react.dev/blog/2025/10/07/react-compiler-1)

---

---


# React Compiler v1.0 – React

URL: https://react.dev/blog/2025/10/07/react-compiler-1

[Blog](https://react.dev/blog)

# React Compiler v1.0

Oct 7, 2025 by [Lauren Tan](https://x.com/potetotes), [Joe Savona](https://x.com/en_JS), and [Mofei Zhang](https://x.com/zmofei).

---

The React team is excited to share new updates:

1. React Compiler 1.0 is available today.
2. Compiler-powered lint rules ship in `eslint-plugin-react-hooks`’s `recommended` and `recommended-latest` preset.
3. We’ve published an incremental adoption guide, and partnered with Expo, Vite, and Next.js so new apps can start with the compiler enabled.

---

We are releasing the compiler’s first stable release today. React Compiler works on both React and React Native, and automatically optimizes components and hooks without requiring rewrites. The compiler has been battle tested on major apps at Meta and is fully production-ready.

[React Compiler](https://react.dev/learn/react-compiler) is a build-time tool that optimizes your React app through automatic memoization. Last year, we published React Compiler’s [first beta](https://react.dev/blog/2024/10/21/react-compiler-beta-release) and received lots of great feedback and contributions. We’re excited about the wins we’ve seen from folks adopting the compiler (see case studies from [Sanity Studio](https://github.com/reactwg/react-compiler/discussions/33) and [Wakelet](https://github.com/reactwg/react-compiler/discussions/52)) and are excited to bring the compiler to more users in the React community.

This release is the culmination of a huge and complex engineering effort spanning almost a decade. The React team’s first exploration into compilers started with [Prepack](https://github.com/facebookarchive/prepack) in 2017. While this project was eventually shut down, there were many learnings that informed the team on the design of Hooks, which were designed with a future compiler in mind. In 2021, [Xuan Huang](https://x.com/Huxpro) demoed the [first iteration](https://www.youtube.com/watch?v=lGEMwh32soc) of a new take on React Compiler.

Although this first version of the new React Compiler was eventually rewritten, the first prototype gave us increased confidence that this was a tractable problem, and the learnings that an alternative compiler architecture could precisely give us the memoization characteristics we wanted. [Joe Savona](https://x.com/en_JS), [Sathya Gunasekaran](https://x.com/_gsathya), [Mofei Zhang](https://x.com/zmofei), and [Lauren Tan](https://x.com/potetotes) worked through our first rewrite, moving the compiler’s architecture into a Control Flow Graph (CFG) based High-Level Intermediate Representation (HIR). This paved the way for much more precise analysis and even type inference within React Compiler. Since then, many significant portions of the compiler have been rewritten, with each rewrite informed by our learnings from the previous attempt. And we have received significant help and contributions from many members of the [React team](https://react.dev/community/team) along the way.

This stable release is our first of many. The compiler will continue to evolve and improve, and we expect to see it become a new foundation and era for the next decade and more of React.

You can jump straight to the [quickstart](https://react.dev/learn/react-compiler), or read on for the highlights from React Conf 2025.

##### Deep Dive

#### How does React Compiler work?

Show Details

React Compiler is an optimizing compiler that optimizes components and hooks through automatic memoization. While it is implemented as a Babel plugin currently, the compiler is largely decoupled from Babel and lowers the Abstract Syntax Tree (AST) provided by Babel into its own novel HIR, and through multiple compiler passes, carefully understands data-flow and mutability of your React code. This allows the compiler to granularly memoize values used in rendering, including the ability to memoize conditionally, which is not possible through manual memoization.

```
import { use } from 'react';

export default function ThemeProvider(props) {

if (!props.children) {

return null;

}

// The compiler can still memoize code after a conditional return

const theme = mergeTheme(props.theme, use(ThemeContext));

return (

<ThemeContext value={theme}>

{props.children}

</ThemeContext>

);

}
```

*See this example in the [React Compiler Playground](https://playground.react.dev/#N4Igzg9grgTgxgUxALhASwLYAcIwC4AEwBUYCBAvgQGYwQYEDkMCAhnHowNwA6AdvwQAPHPgIATBNVZQANoWpQ+HNBD4EAKgAsEGBAAU6ANzSSYACix0sYAJRF+BAmmoFzAQisQbAOjha0WXEWPntgRycCFjxYdT45WV51Sgi4NTBCPB09AgBeAj0YAHMEbV0ES2swHyzygBoSMnMyvQBhNTxhPFtbJKdo2LcIpwAeFoR2vk6hQiNWWSgEXOBavQoAPmHI4C9ff0DghD4KLZGAenHJ6bxN5N7+ChA6kDS+ajQilHRsXEyATyw5GI+gWRTQfAA8lg8Ko+GBKDQ6AxGAAjVgohCyAC0WFB4KxLHYeCxaWwgQQMDO4jQGW4-H45nCyTOZ1JWECrBhagAshBJMgCDwQPNZEKHgQwJyae8EPCQVAwZDobC7FwnuAtBAAO4ASSmFL48zAKGksjIFCAA)*

In addition to automatic memoization, React Compiler also has validation passes that run on your React code. These passes encode the [Rules of React](https://react.dev/reference/rules), and uses the compiler’s understanding of data-flow and mutability to provide diagnostics where the Rules of React are broken. These diagnostics often expose latent bugs hiding in React code, and are primarily surfaced through `eslint-plugin-react-hooks`.

To learn more about how the compiler optimizes your code, visit the [Playground](https://playground.react.dev).

## Use React Compiler Today

To install the compiler:

npm

Terminal

Copy

```
npm install --save-dev --save-exact babel-plugin-react-compiler@latest
```

pnpm

Terminal

Copy

```
pnpm add --save-dev --save-exact babel-plugin-react-compiler@latest
```

yarn

Terminal

Copy

```
yarn add --dev --exact babel-plugin-react-compiler@latest
```

As part of the stable release, we’ve been making React Compiler easier to add to your projects and added optimizations to how the compiler generates memoization. React Compiler now supports optional chains and array indices as dependencies. These improvements ultimately result in fewer re-renders and more responsive UIs, while letting you keep writing idiomatic declarative code.

You can find more details on using the Compiler in [our docs](https://react.dev/learn/react-compiler).

## What we’re seeing in production

[The compiler has already shipped in apps like Meta Quest Store](https://youtu.be/lyEKhv8-3n0?t=3002). We’ve seen initial loads and cross-page navigations improve by up to 12%, while certain interactions are more than 2.5× faster. Memory usage stays neutral even with these wins. Although your mileage may vary, we recommend experimenting with the compiler in your app to see similar performance gains.

## Backwards Compatibility

As noted in the Beta announcement, React Compiler is compatible with React 17 and up. If you are not yet on React 19, you can use React Compiler by specifying a minimum target in your compiler config, and adding `react-compiler-runtime` as a dependency. You can find docs on this [here](https://react.dev/reference/react-compiler/target#targeting-react-17-or-18).

## Enforce the Rules of React with compiler-powered linting

React Compiler includes an ESLint rule that helps identify code that breaks the [Rules of React](https://react.dev/reference/rules). The linter does not require the compiler to be installed, so there’s no risk in upgrading eslint-plugin-react-hooks. We recommend everyone upgrade today.

If you have already installed `eslint-plugin-react-compiler`, you can now remove it and use `eslint-plugin-react-hooks@latest`. Many thanks to [@michaelfaith](https://bsky.app/profile/michael.faith) for contributing to this improvement!

To install:

npm

Terminal

Copy

```
npm install --save-dev eslint-plugin-react-hooks@latest
```

pnpm

Terminal

Copy

```
pnpm add --save-dev eslint-plugin-react-hooks@latest
```

yarn

Terminal

Copy

```
yarn add --dev eslint-plugin-react-hooks@latest
```

```
// eslint.config.js (Flat Config)

import reactHooks from 'eslint-plugin-react-hooks';

import { defineConfig } from 'eslint/config';

export default defineConfig([

reactHooks.configs.flat.recommended,

]);
```

```
// eslintrc.json (Legacy Config)

{

"extends": ["plugin:react-hooks/recommended"],

// ...

}
```

To enable React Compiler rules, we recommend using the `recommended` preset. You can also check out the [README](https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/README.md) for more instructions. Here are a few examples we featured at React Conf:

* Catching `setState` patterns that cause render loops with [`set-state-in-render`](https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render).
* Flagging expensive work inside effects via [`set-state-in-effect`](https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect).
* Preventing unsafe ref access during render with [`refs`](https://react.dev/reference/eslint-plugin-react-hooks/lints/refs).

## What should I do about useMemo, useCallback, and React.memo?

By default, React Compiler will memoize your code based on its analysis and heuristics. In most cases, this memoization will be as precise, or moreso, than what you may have written — and as noted above, the compiler can memoize even in cases where `useMemo`/`useCallback` cannot be used, such as after an early return.

However, in some cases developers may need more control over memoization. The `useMemo` and `useCallback` hooks can continue to be used with React Compiler as an escape hatch to provide control over which values are memoized. A common use-case for this is if a memoized value is used as an effect dependency, in order to ensure that an effect does not fire repeatedly even when its dependencies do not meaningfully change.

For new code, we recommend relying on the compiler for memoization and using `useMemo`/`useCallback` where needed to achieve precise control.

For existing code, we recommend either leaving existing memoization in place (removing it can change compilation output) or carefully testing before removing the memoization.

## New apps should use React Compiler

We have partnered with the Expo, Vite, and Next.js teams to add the compiler to the new app experience.

[Expo SDK 54](https://docs.expo.dev/guides/react-compiler/) and up has the compiler enabled by default, so new apps will automatically be able to take advantage of the compiler from the start.

Terminal

Copy

```
npx create-expo-app@latest
```

[Vite](https://vite.dev/guide/) and [Next.js](https://nextjs.org/docs/app/api-reference/cli/create-next-app) users can choose the compiler enabled templates in `create-vite` and `create-next-app`.

Terminal

Copy

```
npm create vite@latest
```

  

Terminal

Copy

```
npx create-next-app@latest
```

## Adopt React Compiler incrementally

If you’re maintaining an existing application, you can roll out the compiler at your own pace. We published a step-by-step [incremental adoption guide](https://react.dev/learn/react-compiler/incremental-adoption) that covers gating strategies, compatibility checks, and rollout tooling so you can enable the compiler with confidence.

## swc support (experimental)

React Compiler can be installed across [several build tools](https://react.dev/learn/react-compiler#installation) such as Babel, Vite, and Rsbuild.

In addition to those tools, we have been collaborating with Kang Dongyoon ([@kdy1dev](https://x.com/kdy1dev)) from the [swc](https://swc.rs/) team on adding additional support for React Compiler as an swc plugin. While this work isn’t done, Next.js build performance should now be considerably faster when the [React Compiler is enabled in your Next.js app](https://nextjs.org/docs/app/api-reference/config/next-config-js/reactCompiler).

We recommend using Next.js [15.3.1](https://github.com/vercel/next.js/releases/tag/v15.3.1) or greater to get the best build performance.

Vite users can continue to use [vite-plugin-react](https://github.com/vitejs/vite-plugin-react) to enable the compiler, by adding it as a [Babel plugin](https://react.dev/learn/react-compiler/installation#vite). We are also working with the [oxc](https://oxc.rs/) team to [add support for the compiler](https://github.com/oxc-project/oxc/issues/10048). Once [rolldown](https://github.com/rolldown/rolldown) is officially released and supported in Vite and oxc support is added for React Compiler, we’ll update the docs with information on how to migrate.

## Upgrading React Compiler

React Compiler works best when the auto-memoization applied is strictly for performance. Future versions of the compiler may change how memoization is applied, for example it could become more granular and precise.

However, because product code may sometimes break the [rules of React](https://react.dev/reference/rules) in ways that aren’t always statically detectable in JavaScript, changing memoization can occasionally have unexpected results. For example, a previously memoized value might be used as a dependency for a `useEffect` somewhere in the component tree. Changing how or whether this value is memoized can cause over or under-firing of that `useEffect`. While we encourage [useEffect only for synchronization](https://react.dev/learn/synchronizing-with-effects), your codebase may have `useEffect`s that cover other use cases, such as effects that needs to only run in response to specific values changing.

In other words, changing memoization may under rare circumstances cause unexpected behavior. For this reason, we recommend following the Rules of React and employing continuous end-to-end testing of your app so you can upgrade the compiler with confidence and identify any rules of React violations that might cause issues.

If you don’t have good test coverage, we recommend pinning the compiler to an exact version (eg `1.0.0`) rather than a SemVer range (eg `^1.0.0`). You can do this by passing the `--save-exact` (npm/pnpm) or `--exact` flags (yarn) when upgrading the compiler. You should then do any upgrades of the compiler manually, taking care to check that your app still works as expected.

---

Thanks to [Jason Bonta](https://x.com/someextent), [Jimmy Lai](https://x.com/feedthejim), [Kang Dongyoon](https://x.com/kdy1dev) (@kdy1dev), and [Dan Abramov](https://bsky.app/profile/danabra.mov) for reviewing and editing this post.

[PreviousReact Conf 2025 Recap](https://react.dev/blog/2025/10/16/react-conf-2025-recap)[NextIntroducing the React Foundation](https://react.dev/blog/2025/10/07/introducing-the-react-foundation)

---

---


# Built-in React Components – React

URL: https://react.dev/reference/react/components

[API Reference](https://react.dev/reference/react)

# Built-in React Components

React exposes a few built-in components that you can use in your JSX.

---

## Built-in components

* [`<Fragment>`](https://react.dev/reference/react/Fragment), alternatively written as `<>...</>`, lets you group multiple JSX nodes together.
* [`<Profiler>`](https://react.dev/reference/react/Profiler) lets you measure rendering performance of a React tree programmatically.
* [`<Suspense>`](https://react.dev/reference/react/Suspense) lets you display a fallback while the child components are loading.
* [`<StrictMode>`](https://react.dev/reference/react/StrictMode) enables extra development-only checks that help you find bugs early.
* [`<Activity>`](https://react.dev/reference/react/Activity) lets you hide and restore the UI and internal state of its children.

---

## Your own components

You can also [define your own components](https://react.dev/learn/your-first-component) as JavaScript functions.

[PrevioususeTransition](https://react.dev/reference/react/useTransition)[Next<Fragment> (<>)](https://react.dev/reference/react/Fragment)

---

---


# Built-in React APIs – React

URL: https://react.dev/reference/react/apis

[API Reference](https://react.dev/reference/react)

# Built-in React APIs

In addition to [Hooks](https://react.dev/reference/react/hooks) and [Components](https://react.dev/reference/react/components), the `react` package exports a few other APIs that are useful for defining components. This page lists all the remaining modern React APIs.

---

* [`createContext`](https://react.dev/reference/react/createContext) lets you define and provide context to the child components. Used with [`useContext`.](https://react.dev/reference/react/useContext)
* [`lazy`](https://react.dev/reference/react/lazy) lets you defer loading a component’s code until it’s rendered for the first time.
* [`memo`](https://react.dev/reference/react/memo) lets your component skip re-renders with same props. Used with [`useMemo`](https://react.dev/reference/react/useMemo) and [`useCallback`.](https://react.dev/reference/react/useCallback)
* [`startTransition`](https://react.dev/reference/react/startTransition) lets you mark a state update as non-urgent. Similar to [`useTransition`.](https://react.dev/reference/react/useTransition)
* [`act`](https://react.dev/reference/react/act) lets you wrap renders and interactions in tests to ensure updates have processed before making assertions.

---

## Resource APIs

*Resources* can be accessed by a component without having them as part of their state. For example, a component can read a message from a Promise or read styling information from a context.

To read a value from a resource, use this API:

* [`use`](https://react.dev/reference/react/use) lets you read the value of a resource like a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or [context](https://react.dev/learn/passing-data-deeply-with-context).

```
function MessageComponent({ messagePromise }) {

const message = use(messagePromise);

const theme = use(ThemeContext);

// ...

}
```

[Previous<ViewTransition>](https://react.dev/reference/react/ViewTransition)[Nextact](https://react.dev/reference/react/act)

---

---


# Legacy React APIs – React

URL: https://react.dev/reference/react/legacy

[API Reference](https://react.dev/reference/react)

# Legacy React APIs

These APIs are exported from the `react` package, but they are not recommended for use in newly written code. See the linked individual API pages for the suggested alternatives.

---

## Legacy APIs

* [`Children`](https://react.dev/reference/react/Children) lets you manipulate and transform the JSX received as the `children` prop. [See alternatives.](https://react.dev/reference/react/Children#alternatives)
* [`cloneElement`](https://react.dev/reference/react/cloneElement) lets you create a React element using another element as a starting point. [See alternatives.](https://react.dev/reference/react/cloneElement#alternatives)
* [`Component`](https://react.dev/reference/react/Component) lets you define a React component as a JavaScript class. [See alternatives.](https://react.dev/reference/react/Component#alternatives)
* [`createElement`](https://react.dev/reference/react/createElement) lets you create a React element. Typically, you’ll use JSX instead.
* [`createRef`](https://react.dev/reference/react/createRef) creates a ref object which can contain arbitrary value. [See alternatives.](https://react.dev/reference/react/createRef#alternatives)
* [`forwardRef`](https://react.dev/reference/react/forwardRef) lets your component expose a DOM node to parent component with a [ref.](https://react.dev/learn/manipulating-the-dom-with-refs)
* [`isValidElement`](https://react.dev/reference/react/isValidElement) checks whether a value is a React element. Typically used with [`cloneElement`.](https://react.dev/reference/react/cloneElement)
* [`PureComponent`](https://react.dev/reference/react/PureComponent) is similar to [`Component`,](https://react.dev/reference/react/Component) but it skip re-renders with same props. [See alternatives.](https://react.dev/reference/react/PureComponent#alternatives)

---

## Removed APIs

These APIs were removed in React 19:

* [`createFactory`](https://18.react.dev/reference/react/createFactory): use JSX instead.
* Class Components: [`static contextTypes`](https://18.react.dev//reference/react/Component#static-contexttypes): use [`static contextType`](https://react.dev/reference/react/legacy#static-contexttype) instead.
* Class Components: [`static childContextTypes`](https://18.react.dev//reference/react/Component#static-childcontexttypes): use [`static contextType`](https://react.dev/reference/react/legacy#static-contexttype) instead.
* Class Components: [`static getChildContext`](https://18.react.dev//reference/react/Component#getchildcontext): use [`Context`](https://react.dev/reference/react/createContext#provider) instead.
* Class Components: [`static propTypes`](https://18.react.dev//reference/react/Component#static-proptypes): use a type system like [TypeScript](https://www.typescriptlang.org/) instead.
* Class Components: [`this.refs`](https://18.react.dev//reference/react/Component#refs): use [`createRef`](https://react.dev/reference/react/createRef) instead.

[NextChildren](https://react.dev/reference/react/Children)

---

---


# React DOM Components – React

URL: https://react.dev/reference/react-dom/components

[API Reference](https://react.dev/reference/react)

# React DOM Components

React supports all of the browser built-in [HTML](https://developer.mozilla.org/en-US/docs/Web/HTML/Element) and [SVG](https://developer.mozilla.org/en-US/docs/Web/SVG/Element) components.

---

## Common components

All of the built-in browser components support some props and events.

* [Common components (e.g. `<div>`)](https://react.dev/reference/react-dom/components/common)

This includes React-specific props like `ref` and `dangerouslySetInnerHTML`.

---

## Form components

These built-in browser components accept user input:

* [`<input>`](https://react.dev/reference/react-dom/components/input)
* [`<select>`](https://react.dev/reference/react-dom/components/select)
* [`<textarea>`](https://react.dev/reference/react-dom/components/textarea)

They are special in React because passing the `value` prop to them makes them *[controlled.](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable)*

---

## Resource and Metadata Components

These built-in browser components let you load external resources or annotate the document with metadata:

* [`<link>`](https://react.dev/reference/react-dom/components/link)
* [`<meta>`](https://react.dev/reference/react-dom/components/meta)
* [`<script>`](https://react.dev/reference/react-dom/components/script)
* [`<style>`](https://react.dev/reference/react-dom/components/style)
* [`<title>`](https://react.dev/reference/react-dom/components/title)

They are special in React because React can render them into the document head, suspend while resources are loading, and enact other behaviors that are described on the reference page for each specific component.

---

## All HTML components

React supports all built-in browser HTML components. This includes:

* [`<aside>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/aside)
* [`<audio>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio)
* [`<b>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/b)
* [`<base>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base)
* [`<bdi>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdi)
* [`<bdo>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo)
* [`<blockquote>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote)
* [`<body>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/body)
* [`<br>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/br)
* [`<button>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button)
* [`<canvas>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas)
* [`<caption>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/caption)
* [`<cite>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/cite)
* [`<code>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/code)
* [`<col>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/col)
* [`<colgroup>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/colgroup)
* [`<data>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/data)
* [`<datalist>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist)
* [`<dd>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dd)
* [`<del>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/del)
* [`<details>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details)
* [`<dfn>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dfn)
* [`<dialog>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog)
* [`<div>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div)
* [`<dl>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dl)
* [`<dt>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dt)
* [`<em>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/em)
* [`<embed>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed)
* [`<fieldset>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset)
* [`<figcaption>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figcaption)
* [`<figure>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/figure)
* [`<footer>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/footer)
* [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form)
* [`<h1>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/h1)
* [`<head>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head)
* [`<header>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/header)
* [`<hgroup>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hgroup)
* [`<hr>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/hr)
* [`<html>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html)
* [`<i>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/i)
* [`<iframe>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe)
* [`<img>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img)
* [`<input>`](https://react.dev/reference/react-dom/components/input)
* [`<ins>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ins)
* [`<kbd>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/kbd)
* [`<label>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label)
* [`<legend>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/legend)
* [`<li>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/li)
* [`<link>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link)
* [`<main>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/main)
* [`<map>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map)
* [`<mark>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/mark)
* [`<menu>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/menu)
* [`<meta>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta)
* [`<meter>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meter)
* [`<nav>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/nav)
* [`<noscript>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/noscript)
* [`<object>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object)
* [`<ol>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ol)
* [`<optgroup>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup)
* [`<option>`](https://react.dev/reference/react-dom/components/option)
* [`<output>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/output)
* [`<p>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/p)
* [`<picture>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture)
* [`<pre>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/pre)
* [`<progress>`](https://react.dev/reference/react-dom/components/progress)
* [`<q>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q)
* [`<rp>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rp)
* [`<rt>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/rt)
* [`<ruby>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ruby)
* [`<s>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/s)
* [`<samp>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/samp)
* [`<script>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script)
* [`<section>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/section)
* [`<select>`](https://react.dev/reference/react-dom/components/select)
* [`<slot>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot)
* [`<small>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/small)
* [`<source>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source)
* [`<span>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span)
* [`<strong>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong)
* [`<style>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style)
* [`<sub>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sub)
* [`<summary>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/summary)
* [`<sup>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/sup)
* [`<table>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table)
* [`<tbody>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tbody)
* [`<td>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/td)
* [`<template>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template)
* [`<textarea>`](https://react.dev/reference/react-dom/components/textarea)
* [`<tfoot>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tfoot)
* [`<th>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th)
* [`<thead>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/thead)
* [`<time>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/time)
* [`<title>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title)
* [`<tr>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/tr)
* [`<track>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track)
* [`<u>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/u)
* [`<ul>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/ul)
* [`<var>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/var)
* [`<video>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video)
* [`<wbr>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/wbr)

### Note

Similar to the [DOM standard,](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) React uses a `camelCase` convention for prop names. For example, you’ll write `tabIndex` instead of `tabindex`. You can convert existing HTML to JSX with an [online converter.](https://transform.tools/html-to-jsx)

---

### Custom HTML elements

If you render a tag with a dash, like `<my-element>`, React will assume you want to render a [custom HTML element.](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements)

If you render a built-in browser HTML element with an [`is`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/is) attribute, it will also be treated as a custom element.

#### Setting values on custom elements

Custom elements have two methods of passing data into them:

1. Attributes: Which are displayed in markup and can only be set to string values
2. Properties: Which are not displayed in markup and can be set to arbitrary JavaScript values

By default, React will pass values bound in JSX as attributes:

```
<my-element value="Hello, world!"></my-element>
```

Non-string JavaScript values passed to custom elements will be serialized by default:

```
// Will be passed as `"1,2,3"` as the output of `[1,2,3].toString()`

<my-element value={[1,2,3]}></my-element>
```

React will, however, recognize an custom element’s property as one that it may pass arbitrary values to if the property name shows up on the class during construction:

MyElement.jsApp.js

MyElement.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export class MyElement extends HTMLElement {
  constructor() {
    super();
    // The value here will be overwritten by React 
    // when initialized as an element
    this.value = undefined;
  }

  connectedCallback() {
    this.innerHTML = this.value.join(", ");
  }
}
```

#### Listening for events on custom elements

A common pattern when using custom elements is that they may dispatch [`CustomEvent`s](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent) rather than accept a function to call when an event occur. You can listen for these events using an `on` prefix when binding to the event via JSX.

MyElement.jsApp.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export function App() {
  return (
    <my-element
      onspeak={e => console.log(e.detail.message)}
    ></my-element>
  )
}
```

### Note

Events are case-sensitive and support dashes (`-`). Preserve the casing of the event and include all dashes when listening for custom element’s events:

```
// Listens for `say-hi` events

<my-element onsay-hi={console.log}></my-element>

// Listens for `sayHi` events

<my-element onsayHi={console.log}></my-element>
```

---

## All SVG components

React supports all built-in browser SVG components. This includes:

* [`<a>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/a)
* [`<animate>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/animate)
* [`<animateMotion>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/animateMotion)
* [`<animateTransform>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/animateTransform)
* [`<circle>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle)
* [`<clipPath>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/clipPath)
* [`<defs>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs)
* [`<desc>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/desc)
* [`<discard>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/discard)
* [`<ellipse>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/ellipse)
* [`<feBlend>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feBlend)
* [`<feColorMatrix>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feColorMatrix)
* [`<feComponentTransfer>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feComponentTransfer)
* [`<feComposite>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feComposite)
* [`<feConvolveMatrix>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feConvolveMatrix)
* [`<feDiffuseLighting>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDiffuseLighting)
* [`<feDisplacementMap>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDisplacementMap)
* [`<feDistantLight>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDistantLight)
* [`<feDropShadow>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feDropShadow)
* [`<feFlood>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFlood)
* [`<feFuncA>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFuncA)
* [`<feFuncB>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFuncB)
* [`<feFuncG>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFuncG)
* [`<feFuncR>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feFuncR)
* [`<feGaussianBlur>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feGaussianBlur)
* [`<feImage>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feImage)
* [`<feMerge>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feMerge)
* [`<feMergeNode>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feMergeNode)
* [`<feMorphology>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feMorphology)
* [`<feOffset>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feOffset)
* [`<fePointLight>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/fePointLight)
* [`<feSpecularLighting>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feSpecularLighting)
* [`<feSpotLight>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feSpotLight)
* [`<feTile>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feTile)
* [`<feTurbulence>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/feTurbulence)
* [`<filter>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/filter)
* [`<foreignObject>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject)
* [`<g>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/g)
* `<hatch>`
* `<hatchpath>`
* [`<image>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/image)
* [`<line>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/line)
* [`<linearGradient>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient)
* [`<marker>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/marker)
* [`<mask>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/mask)
* [`<metadata>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/metadata)
* [`<mpath>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/mpath)
* [`<path>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/path)
* [`<pattern>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/pattern)
* [`<polygon>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polygon)
* [`<polyline>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/polyline)
* [`<radialGradient>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/radialGradient)
* [`<rect>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/rect)
* [`<script>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/script)
* [`<set>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/set)
* [`<stop>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
* [`<style>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/style)
* [`<svg>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/svg)
* [`<switch>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/switch)
* [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/symbol)
* [`<text>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/text)
* [`<textPath>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/textPath)
* [`<title>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/title)
* [`<tspan>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/tspan)
* [`<use>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/use)
* [`<view>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/view)

### Note

Similar to the [DOM standard,](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) React uses a `camelCase` convention for prop names. For example, you’ll write `tabIndex` instead of `tabindex`. You can convert existing SVG to JSX with an [online converter.](https://transform.tools/)

Namespaced attributes also have to be written without the colon:

* `xlink:actuate` becomes `xlinkActuate`.
* `xlink:arcrole` becomes `xlinkArcrole`.
* `xlink:href` becomes `xlinkHref`.
* `xlink:role` becomes `xlinkRole`.
* `xlink:show` becomes `xlinkShow`.
* `xlink:title` becomes `xlinkTitle`.
* `xlink:type` becomes `xlinkType`.
* `xml:base` becomes `xmlBase`.
* `xml:lang` becomes `xmlLang`.
* `xml:space` becomes `xmlSpace`.
* `xmlns:xlink` becomes `xmlnsXlink`.

[PrevioususeFormStatus](https://react.dev/reference/react-dom/hooks/useFormStatus)[NextCommon (e.g. <div>)](https://react.dev/reference/react-dom/components/common)

---

---


# React DOM APIs – React

URL: https://react.dev/reference/react-dom

[API Reference](https://react.dev/reference/react)

# React DOM APIs

The `react-dom` package contains methods that are only supported for the web applications (which run in the browser DOM environment). They are not supported for React Native.

---

## APIs

These APIs can be imported from your components. They are rarely used:

* [`createPortal`](https://react.dev/reference/react-dom/createPortal) lets you render child components in a different part of the DOM tree.
* [`flushSync`](https://react.dev/reference/react-dom/flushSync) lets you force React to flush a state update and update the DOM synchronously.

## Resource Preloading APIs

These APIs can be used to make apps faster by pre-loading resources such as scripts, stylesheets, and fonts as soon as you know you need them, for example before navigating to another page where the resources will be used.

[React-based frameworks](https://react.dev/learn/creating-a-react-app) frequently handle resource loading for you, so you might not have to call these APIs yourself. Consult your framework’s documentation for details.

* [`prefetchDNS`](https://react.dev/reference/react-dom/prefetchDNS) lets you prefetch the IP address of a DNS domain name that you expect to connect to.
* [`preconnect`](https://react.dev/reference/react-dom/preconnect) lets you connect to a server you expect to request resources from, even if you don’t know what resources you’ll need yet.
* [`preload`](https://react.dev/reference/react-dom/preload) lets you fetch a stylesheet, font, image, or external script that you expect to use.
* [`preloadModule`](https://react.dev/reference/react-dom/preloadModule) lets you fetch an ESM module that you expect to use.
* [`preinit`](https://react.dev/reference/react-dom/preinit) lets you fetch and evaluate an external script or fetch and insert a stylesheet.
* [`preinitModule`](https://react.dev/reference/react-dom/preinitModule) lets you fetch and evaluate an ESM module.

---

## Entry points

The `react-dom` package provides two additional entry points:

* [`react-dom/client`](https://react.dev/reference/react-dom/client) contains APIs to render React components on the client (in the browser).
* [`react-dom/server`](https://react.dev/reference/react-dom/server) contains APIs to render React components on the server.

---

## Removed APIs

These APIs were removed in React 19:

* [`findDOMNode`](https://18.react.dev/reference/react-dom/findDOMNode): see [alternatives](https://18.react.dev/reference/react-dom/findDOMNode#alternatives).
* [`hydrate`](https://18.react.dev/reference/react-dom/hydrate): use [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) instead.
* [`render`](https://18.react.dev/reference/react-dom/render): use [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) instead.
* [`unmountComponentAtNode`](https://react.dev/reference/react-dom/unmountComponentAtNode): use [`root.unmount()`](https://react.dev/reference/react-dom/client/createRoot#root-unmount) instead.
* [`renderToNodeStream`](https://18.react.dev/reference/react-dom/server/renderToNodeStream): use [`react-dom/server`](https://react.dev/reference/react-dom/server) APIs instead.
* [`renderToStaticNodeStream`](https://18.react.dev/reference/react-dom/server/renderToStaticNodeStream): use [`react-dom/server`](https://react.dev/reference/react-dom/server) APIs instead.

[Previous<title>](https://react.dev/reference/react-dom/components/title)[NextcreatePortal](https://react.dev/reference/react-dom/createPortal)

---

---


# Client React DOM APIs – React

URL: https://react.dev/reference/react-dom/client

[API Reference](https://react.dev/reference/react)

# Client React DOM APIs

The `react-dom/client` APIs let you render React components on the client (in the browser). These APIs are typically used at the top level of your app to initialize your React tree. A [framework](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) may call them for you. Most of your components don’t need to import or use them.

---

## Client APIs

* [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) lets you create a root to display React components inside a browser DOM node.
* [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) lets you display React components inside a browser DOM node whose HTML content was previously generated by [`react-dom/server`.](https://react.dev/reference/react-dom/server)

---

## Browser support

React supports all popular browsers, including Internet Explorer 9 and above. Some polyfills are required for older browsers such as IE 9 and IE 10.

[PreviouspreloadModule](https://react.dev/reference/react-dom/preloadModule)[NextcreateRoot](https://react.dev/reference/react-dom/client/createRoot)

---

---


# Server React DOM APIs – React

URL: https://react.dev/reference/react-dom/server

[API Reference](https://react.dev/reference/react)

# Server React DOM APIs

The `react-dom/server` APIs let you server-side render React components to HTML. These APIs are only used on the server at the top level of your app to generate the initial HTML. A [framework](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) may call them for you. Most of your components don’t need to import or use them.

---

## Server APIs for Web Streams

These methods are only available in the environments with [Web Streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API), which includes browsers, Deno, and some modern edge runtimes:

* [`renderToReadableStream`](https://react.dev/reference/react-dom/server/renderToReadableStream) renders a React tree to a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)
* [`resume`](https://react.dev/reference/react-dom/server/renderToPipeableStream) resumes [`prerender`](https://react.dev/reference/react-dom/static/prerender) to a [Readable Web Stream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream).

### Note

Node.js also includes these methods for compatibility, but they are not recommended due to worse performance. Use the [dedicated Node.js APIs](https://react.dev/reference/react-dom/server#server-apis-for-nodejs-streams) instead.

---

## Server APIs for Node.js Streams

These methods are only available in the environments with [Node.js Streams:](https://nodejs.org/api/stream.html)

* [`renderToPipeableStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream) renders a React tree to a pipeable [Node.js Stream.](https://nodejs.org/api/stream.html)
* [`resumeToPipeableStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream) resumes [`prerenderToNodeStream`](https://react.dev/reference/react-dom/static/prerenderToNodeStream) to a pipeable [Node.js Stream.](https://nodejs.org/api/stream.html)

---

## Legacy Server APIs for non-streaming environments

These methods can be used in the environments that don’t support streams:

* [`renderToString`](https://react.dev/reference/react-dom/server/renderToString) renders a React tree to a string.
* [`renderToStaticMarkup`](https://react.dev/reference/react-dom/server/renderToStaticMarkup) renders a non-interactive React tree to a string.

They have limited functionality compared to the streaming APIs.

[PrevioushydrateRoot](https://react.dev/reference/react-dom/client/hydrateRoot)[NextrenderToPipeableStream](https://react.dev/reference/react-dom/server/renderToPipeableStream)

---

---


# Configuration – React

URL: https://react.dev/reference/react-compiler/configuration

[API Reference](https://react.dev/reference/react)

# Configuration

This page lists all configuration options available in React Compiler.

### Note

For most apps, the default options should work out of the box. If you have a special need, you can use these advanced options.

```
// babel.config.js

module.exports = {

plugins: [

[

'babel-plugin-react-compiler', {

// compiler options

}

]

]

};
```

---

## Compilation Control

These options control *what* the compiler optimizes and *how* it selects components and hooks to compile.

* [`compilationMode`](https://react.dev/reference/react-compiler/compilationMode) controls the strategy for selecting functions to compile (e.g., all functions, only annotated ones, or intelligent detection).

```
{

compilationMode: 'annotation' // Only compile "use memo" functions

}
```

---

## Version Compatibility

React version configuration ensures the compiler generates code compatible with your React version.

[`target`](https://react.dev/reference/react-compiler/target) specifies which React version you’re using (17, 18, or 19).

```
// For React 18 projects

{

target: '18' // Also requires react-compiler-runtime package

}
```

---

## Error Handling

These options control how the compiler responds to code that doesn’t follow the [Rules of React](https://react.dev/reference/rules).

[`panicThreshold`](https://react.dev/reference/react-compiler/panicThreshold) determines whether to fail the build or skip problematic components.

```
// Recommended for production

{

panicThreshold: 'none' // Skip components with errors instead of failing the build

}
```

---

## Debugging

Logging and analysis options help you understand what the compiler is doing.

[`logger`](https://react.dev/reference/react-compiler/logger) provides custom logging for compilation events.

```
{

logger: {

logEvent(filename, event) {

if (event.kind === 'CompileSuccess') {

console.log('Compiled:', filename);

}

}

}

}
```

---

## Feature Flags

Conditional compilation lets you control when optimized code is used.

[`gating`](https://react.dev/reference/react-compiler/gating) enables runtime feature flags for A/B testing or gradual rollouts.

```
{

gating: {

source: 'my-feature-flags',

importSpecifierName: 'isCompilerEnabled'

}

}
```

---

## Common Configuration Patterns

### Default configuration

For most React 19 applications, the compiler works without configuration:

```
// babel.config.js

module.exports = {

plugins: [

'babel-plugin-react-compiler'

]

};
```

### React 17/18 projects

Older React versions need the runtime package and target configuration:

```
npm install react-compiler-runtime@latest
```

```
{

target: '18' // or '17'

}
```

### Incremental adoption

Start with specific directories and expand gradually:

```
{

compilationMode: 'annotation' // Only compile "use memo" functions

}
```

[NextcompilationMode](https://react.dev/reference/react-compiler/compilationMode)

---

---


# Directives – React

URL: https://react.dev/reference/react-compiler/directives

[API Reference](https://react.dev/reference/react)

# Directives

React Compiler directives are special string literals that control whether specific functions are compiled.

```
function MyComponent() {

"use memo"; // Opt this component into compilation

return <div>{/* ... */}</div>;

}
```

* [Overview](https://react.dev/reference/react-compiler/directives#overview) 
  + [Available directives](https://react.dev/reference/react-compiler/directives#available-directives)
  + [Quick comparison](https://react.dev/reference/react-compiler/directives#quick-comparison)
* [Usage](https://react.dev/reference/react-compiler/directives#usage) 
  + [Function-level directives](https://react.dev/reference/react-compiler/directives#function-level)
  + [Module-level directives](https://react.dev/reference/react-compiler/directives#module-level)
  + [Compilation modes interaction](https://react.dev/reference/react-compiler/directives#compilation-modes)
* [Best practices](https://react.dev/reference/react-compiler/directives#best-practices) 
  + [Use directives sparingly](https://react.dev/reference/react-compiler/directives#use-sparingly)
  + [Document directive usage](https://react.dev/reference/react-compiler/directives#document-usage)
  + [Plan for removal](https://react.dev/reference/react-compiler/directives#plan-removal)
* [Common patterns](https://react.dev/reference/react-compiler/directives#common-patterns) 
  + [Gradual adoption](https://react.dev/reference/react-compiler/directives#gradual-adoption)
* [Troubleshooting](https://react.dev/reference/react-compiler/directives#troubleshooting) 
  + [Common issues](https://react.dev/reference/react-compiler/directives#common-issues)
* [See also](https://react.dev/reference/react-compiler/directives#see-also)

---

## Overview

React Compiler directives provide fine-grained control over which functions are optimized by the compiler. They are string literals placed at the beginning of a function body or at the top of a module.

### Available directives

* **[`"use memo"`](https://react.dev/reference/react-compiler/directives/use-memo)** - Opts a function into compilation
* **[`"use no memo"`](https://react.dev/reference/react-compiler/directives/use-no-memo)** - Opts a function out of compilation

### Quick comparison

| Directive | Purpose | When to use |
| --- | --- | --- |
| [`"use memo"`](https://react.dev/reference/react-compiler/directives/use-memo) | Force compilation | When using `annotation` mode or to override `infer` mode heuristics |
| [`"use no memo"`](https://react.dev/reference/react-compiler/directives/use-no-memo) | Prevent compilation | Debugging issues or working with incompatible code |

---

## Usage

### Function-level directives

Place directives at the beginning of a function to control its compilation:

```
// Opt into compilation

function OptimizedComponent() {

"use memo";

return <div>This will be optimized</div>;

}

// Opt out of compilation

function UnoptimizedComponent() {

"use no memo";

return <div>This won't be optimized</div>;

}
```

### Module-level directives

Place directives at the top of a file to affect all functions in that module:

```
// At the very top of the file

"use memo";

// All functions in this file will be compiled

function Component1() {

return <div>Compiled</div>;

}

function Component2() {

return <div>Also compiled</div>;

}

// Can be overridden at function level

function Component3() {

"use no memo"; // This overrides the module directive

return <div>Not compiled</div>;

}
```

### Compilation modes interaction

Directives behave differently depending on your [`compilationMode`](https://react.dev/reference/react-compiler/compilationMode):

* **`annotation` mode**: Only functions with `"use memo"` are compiled
* **`infer` mode**: Compiler decides what to compile, directives override decisions
* **`all` mode**: Everything is compiled, `"use no memo"` can exclude specific functions

---

## Best practices

### Use directives sparingly

Directives are escape hatches. Prefer configuring the compiler at the project level:

```
// ✅ Good - project-wide configuration

{

plugins: [

['babel-plugin-react-compiler', {

compilationMode: 'infer'

}]

]

}

// ⚠️ Use directives only when needed

function SpecialCase() {

"use no memo"; // Document why this is needed

// ...

}
```

### Document directive usage

Always explain why a directive is used:

```
// ✅ Good - clear explanation

function DataGrid() {

"use no memo"; // TODO: Remove after fixing issue with dynamic row heights (JIRA-123)

// Complex grid implementation

}

// ❌ Bad - no explanation

function Mystery() {

"use no memo";

// ...

}
```

### Plan for removal

Opt-out directives should be temporary:

1. Add the directive with a TODO comment
2. Create a tracking issue
3. Fix the underlying problem
4. Remove the directive

```
function TemporaryWorkaround() {

"use no memo"; // TODO: Remove after upgrading ThirdPartyLib to v2.0

return <ThirdPartyComponent />;

}
```

---

## Common patterns

### Gradual adoption

When adopting the React Compiler in a large codebase:

```
// Start with annotation mode

{

compilationMode: 'annotation'

}

// Opt in stable components

function StableComponent() {

"use memo";

// Well-tested component

}

// Later, switch to infer mode and opt out problematic ones

function ProblematicComponent() {

"use no memo"; // Fix issues before removing

// ...

}
```

---

## Troubleshooting

For specific issues with directives, see the troubleshooting sections in:

* [`"use memo"` troubleshooting](https://react.dev/reference/react-compiler/directives/use-memo#troubleshooting)
* [`"use no memo"` troubleshooting](https://react.dev/reference/react-compiler/directives/use-no-memo#troubleshooting)

### Common issues

1. **Directive ignored**: Check placement (must be first) and spelling
2. **Compilation still happens**: Check `ignoreUseNoForget` setting
3. **Module directive not working**: Ensure it’s before all imports

---

## See also

* [`compilationMode`](https://react.dev/reference/react-compiler/compilationMode) - Configure how the compiler chooses what to optimize
* [`Configuration`](https://react.dev/reference/react-compiler/configuration) - Full compiler configuration options
* [React Compiler documentation](https://react.dev/learn/react-compiler) - Getting started guide

[Previoustarget](https://react.dev/reference/react-compiler/target)[Next"use memo"](https://react.dev/reference/react-compiler/directives/use-memo)

---

---


# Compiling Libraries – React

URL: https://react.dev/reference/react-compiler/compiling-libraries

[API Reference](https://react.dev/reference/react)

# Compiling Libraries

This guide helps library authors understand how to use React Compiler to ship optimized library code to their users.

* [Why Ship Compiled Code?](https://react.dev/reference/react-compiler/compiling-libraries#why-ship-compiled-code)
* [Setting Up Compilation](https://react.dev/reference/react-compiler/compiling-libraries#setting-up-compilation)
* [Backwards Compatibility](https://react.dev/reference/react-compiler/compiling-libraries#backwards-compatibility) 
  + [1. Install the runtime package](https://react.dev/reference/react-compiler/compiling-libraries#install-runtime-package)
  + [2. Configure the target version](https://react.dev/reference/react-compiler/compiling-libraries#configure-target-version)
* [Testing Strategy](https://react.dev/reference/react-compiler/compiling-libraries#testing-strategy)
* [Troubleshooting](https://react.dev/reference/react-compiler/compiling-libraries#troubleshooting) 
  + [Library doesn’t work with older React versions](https://react.dev/reference/react-compiler/compiling-libraries#library-doesnt-work-with-older-react-versions)
  + [Compilation conflicts with other Babel plugins](https://react.dev/reference/react-compiler/compiling-libraries#compilation-conflicts-with-other-babel-plugins)
  + [Runtime module not found](https://react.dev/reference/react-compiler/compiling-libraries#runtime-module-not-found)
* [Next Steps](https://react.dev/reference/react-compiler/compiling-libraries#next-steps)

## Why Ship Compiled Code?

As a library author, you can compile your library code before publishing to npm. This provides several benefits:

* **Performance improvements for all users** - Your library users get optimized code even if they aren’t using React Compiler yet
* **No configuration required by users** - The optimizations work out of the box
* **Consistent behavior** - All users get the same optimized version regardless of their build setup

## Setting Up Compilation

Add React Compiler to your library’s build process:

Terminal

Copy

```
npm install -D babel-plugin-react-compiler@latest
```

Configure your build tool to compile your library. For example, with Babel:

```
// babel.config.js

module.exports = {

plugins: [

'babel-plugin-react-compiler',

],

// ... other config

};
```

## Backwards Compatibility

If your library supports React versions below 19, you’ll need additional configuration:

### 1. Install the runtime package

We recommend installing react-compiler-runtime as a direct dependency:

Terminal

Copy

```
npm install react-compiler-runtime@latest
```

```
{

"dependencies": {

"react-compiler-runtime": "^1.0.0"

},

"peerDependencies": {

"react": "^17.0.0 || ^18.0.0 || ^19.0.0"

}

}
```

### 2. Configure the target version

Set the minimum React version your library supports:

```
{

target: '17', // Minimum supported React version

}
```

## Testing Strategy

Test your library both with and without compilation to ensure compatibility. Run your existing test suite against the compiled code, and also create a separate test configuration that bypasses the compiler. This helps catch any issues that might arise from the compilation process and ensures your library works correctly in all scenarios.

## Troubleshooting

### Library doesn’t work with older React versions

If your compiled library throws errors in React 17 or 18:

1. Verify you’ve installed `react-compiler-runtime` as a dependency
2. Check that your `target` configuration matches your minimum supported React version
3. Ensure the runtime package is included in your published bundle

### Compilation conflicts with other Babel plugins

Some Babel plugins may conflict with React Compiler:

1. Place `babel-plugin-react-compiler` early in your plugin list
2. Disable conflicting optimizations in other plugins
3. Test your build output thoroughly

### Runtime module not found

If users see “Cannot find module ‘react-compiler-runtime’“:

1. Ensure the runtime is listed in `dependencies`, not `devDependencies`
2. Check that your bundler includes the runtime in the output
3. Verify the package is published to npm with your library

## Next Steps

* Learn about [debugging techniques](https://react.dev/learn/react-compiler/debugging) for compiled code
* Check the [configuration options](https://react.dev/reference/react-compiler/configuration) for all compiler options
* Explore [compilation modes](https://react.dev/reference/react-compiler/compilationMode) for selective optimization

[Previous"use no memo"](https://react.dev/reference/react-compiler/directives/use-no-memo)

---

---


# Versioning Policy – React

URL: https://react.dev/community/versioning-policy

[Community](https://react.dev/community)

# Versioning Policy

All stable builds of React go through a high level of testing and follow semantic versioning (semver). React also offers unstable release channels to encourage early feedback on experimental features. This page describes what you can expect from React releases.

This versioning policy describes our approach to version numbers for packages such as `react` and `react-dom`. For a list of previous releases, see the [Versions](https://react.dev/versions) page.

## Stable releases

Stable React releases (also known as “Latest” release channel) follow [semantic versioning (semver)](https://semver.org/) principles.

That means that with a version number **x.y.z**:

* When releasing **critical bug fixes**, we make a **patch release** by changing the **z** number (ex: 15.6.2 to 15.6.3).
* When releasing **new features** or **non-critical fixes**, we make a **minor release** by changing the **y** number (ex: 15.6.2 to 15.7.0).
* When releasing **breaking changes**, we make a **major release** by changing the **x** number (ex: 15.6.2 to 16.0.0).

Major releases can also contain new features, and any release can include bug fixes.

Minor releases are the most common type of release.

We know our users continue to use old versions of React in production. If we learn of a security vulnerability in React, we release a backported fix for all major versions that are affected by the vulnerability.

### Breaking changes

Breaking changes are inconvenient for everyone, so we try to minimize the number of major releases – for example, React 15 was released in April 2016 and React 16 was released in September 2017, and React 17 was released in October 2020.

Instead, we release new features in minor versions. That means that minor releases are often more interesting and compelling than majors, despite their unassuming name.

### Commitment to stability

As we change React over time, we try to minimize the effort required to take advantage of new features. When possible, we’ll keep an older API working, even if that means putting it in a separate package. For example, [mixins have been discouraged for years](https://legacy.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html) but they’re supported to this day [via create-react-class](https://legacy.reactjs.org/docs/react-without-es6.html#mixins) and many codebases continue to use them in stable, legacy code.

Over a million developers use React, collectively maintaining millions of components. The Facebook codebase alone has over 50,000 React components. That means we need to make it as easy as possible to upgrade to new versions of React; if we make large changes without a migration path, people will be stuck on old versions. We test these upgrade paths on Facebook itself – if our team of less than 10 people can update 50,000+ components alone, we hope the upgrade will be manageable for anyone using React. In many cases, we write [automated scripts](https://github.com/reactjs/react-codemod) to upgrade component syntax, which we then include in the open-source release for everyone to use.

### Gradual upgrades via warnings

Development builds of React include many helpful warnings. Whenever possible, we add warnings in preparation for future breaking changes. That way, if your app has no warnings on the latest release, it will be compatible with the next major release. This allows you to upgrade your apps one component at a time.

Development warnings won’t affect the runtime behavior of your app. That way, you can feel confident that your app will behave the same way between the development and production builds — the only differences are that the production build won’t log the warnings and that it is more efficient. (If you ever notice otherwise, please file an issue.)

### What counts as a breaking change?

In general, we *don’t* bump the major version number for changes to:

* **Development warnings.** Since these don’t affect production behavior, we may add new warnings or modify existing warnings in between major versions. In fact, this is what allows us to reliably warn about upcoming breaking changes.
* **APIs starting with `unstable_`.** These are provided as experimental features whose APIs we are not yet confident in. By releasing these with an `unstable_` prefix, we can iterate faster and get to a stable API sooner.
* **Alpha and Canary versions of React.** We provide alpha versions of React as a way to test new features early, but we need the flexibility to make changes based on what we learn in the alpha period. If you use these versions, note that APIs may change before the stable release.
* **Undocumented APIs and internal data structures.** If you access internal property names like `__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED` or `__reactInternalInstance$uk43rzhitjg`, there is no warranty. You are on your own.

This policy is designed to be pragmatic: certainly, we don’t want to cause headaches for you. If we bumped the major version for all of these changes, we would end up releasing more major versions and ultimately causing more versioning pain for the community. It would also mean that we can’t make progress in improving React as fast as we’d like.

That said, if we expect that a change on this list will cause broad problems in the community, we will still do our best to provide a gradual migration path.

### If a minor release includes no new features, why isn’t it a patch?

It’s possible that a minor release will not include new features. [This is allowed by semver](https://semver.org/#spec-item-7), which states **“[a minor version] MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes.”**

However, it does raise the question of why these releases aren’t versioned as patches instead.

The answer is that any change to React (or other software) carries some risk of breaking in unexpected ways. Imagine a scenario where a patch release that fixes one bug accidentally introduces a different bug. This would not only be disruptive to developers, but also harm their confidence in future patch releases. It’s especially regrettable if the original fix is for a bug that is rarely encountered in practice.

We have a pretty good track record for keeping React releases free of bugs, but patch releases have an even higher bar for reliability because most developers assume they can be adopted without adverse consequences.

For these reasons, we reserve patch releases only for the most critical bugs and security vulnerabilities.

If a release includes non-essential changes — such as internal refactors, changes to implementation details, performance improvements, or minor bugfixes — we will bump the minor version even when there are no new features.

## All release channels

React relies on a thriving open source community to file bug reports, open pull requests, and [submit RFCs](https://github.com/reactjs/rfcs). To encourage feedback we sometimes share special builds of React that include unreleased features.

### Note

This section will be most relevant to developers who work on frameworks, libraries, or developer tooling. Developers who use React primarily to build user-facing applications should not need to worry about our prerelease channels.

Each of React’s release channels is designed for a distinct use case:

* [**Latest**](https://react.dev/community/versioning-policy#latest-channel) is for stable, semver React releases. It’s what you get when you install React from npm. This is the channel you’re already using today. **User-facing applications that consume React directly use this channel.**
* [**Canary**](https://react.dev/community/versioning-policy#canary-channel) tracks the main branch of the React source code repository. Think of these as release candidates for the next semver release. **[Frameworks or other curated setups may choose to use this channel with a pinned version of React.](https://react.dev/blog/2023/05/03/react-canaries) You can also use Canaries for integration testing between React and third party projects.**
* [**Experimental**](https://react.dev/community/versioning-policy#experimental-channel) includes experimental APIs and features that aren’t available in the stable releases. These also track the main branch, but with additional feature flags turned on. Use this to try out upcoming features before they are released.

All releases are published to npm, but only Latest uses semantic versioning. Prereleases (those in the Canary and Experimental channels) have versions generated from a hash of their contents and the commit date, e.g. `18.3.0-canary-388686f29-20230503` for Canary and `0.0.0-experimental-388686f29-20230503` for Experimental.

**Both Latest and Canary channels are officially supported for user-facing applications, but with different expectations**:

* Latest releases follow the traditional semver model.
* Canary releases [must be pinned](https://react.dev/blog/2023/05/03/react-canaries) and may include breaking changes. They exist for curated setups (like frameworks) that want to gradually release new React features and bugfixes on their own release schedule.

The Experimental releases are provided for testing purposes only, and we provide no guarantees that behavior won’t change between releases. They do not follow the semver protocol that we use for releases from Latest.

By publishing prereleases to the same registry that we use for stable releases, we are able to take advantage of the many tools that support the npm workflow, like [unpkg](https://unpkg.com) and [CodeSandbox](https://codesandbox.io).

### Latest channel

Latest is the channel used for stable React releases. It corresponds to the `latest` tag on npm. It is the recommended channel for all React apps that are shipped to real users.

**If you’re not sure which channel you should use, it’s Latest.** If you’re using React directly, this is what you’re already using. You can expect updates to Latest to be extremely stable. Versions follow the semantic versioning scheme, as [described earlier.](https://react.dev/community/versioning-policy#stable-releases)

### Canary channel

The Canary channel is a prerelease channel that tracks the main branch of the React repository. We use prereleases in the Canary channel as release candidates for the Latest channel. You can think of Canary as a superset of Latest that is updated more frequently.

The degree of change between the most recent Canary release and the most recent Latest release is approximately the same as you would find between two minor semver releases. However, **the Canary channel does not conform to semantic versioning.** You should expect occasional breaking changes between successive releases in the Canary channel.

**Do not use prereleases in user-facing applications directly unless you’re following the [Canary workflow](https://react.dev/blog/2023/05/03/react-canaries).**

Releases in Canary are published with the `canary` tag on npm. Versions are generated from a hash of the build’s contents and the commit date, e.g. `18.3.0-canary-388686f29-20230503`.

#### Using the canary channel for integration testing

The Canary channel also supports integration testing between React and other projects.

All changes to React go through extensive internal testing before they are released to the public. However, there are a myriad of environments and configurations used throughout the React ecosystem, and it’s not possible for us to test against every single one.

If you’re the author of a third party React framework, library, developer tool, or similar infrastructure-type project, you can help us keep React stable for your users and the entire React community by periodically running your test suite against the most recent changes. If you’re interested, follow these steps:

* Set up a cron job using your preferred continuous integration platform. Cron jobs are supported by both [CircleCI](https://circleci.com/docs/2.0/triggers/#scheduled-builds) and [Travis CI](https://docs.travis-ci.com/user/cron-jobs/).
* In the cron job, update your React packages to the most recent React release in the Canary channel, using `canary` tag on npm. Using the npm cli:

  ```
  npm update react@canary react-dom@canary
  ```

  Or yarn:

  ```
  yarn upgrade react@canary react-dom@canary
  ```
* Run your test suite against the updated packages.
* If everything passes, great! You can expect that your project will work with the next minor React release.
* If something breaks unexpectedly, please let us know by [filing an issue](https://github.com/facebook/react/issues).

A project that uses this workflow is Next.js. You can refer to their [CircleCI configuration](https://github.com/zeit/next.js/blob/c0a1c0f93966fe33edd93fb53e5fafb0dcd80a9e/.circleci/config.yml) as an example.

### Experimental channel

Like Canary, the Experimental channel is a prerelease channel that tracks the main branch of the React repository. Unlike Canary, Experimental releases include additional features and APIs that are not ready for wider release.

Usually, an update to Canary is accompanied by a corresponding update to Experimental. They are based on the same source revision, but are built using a different set of feature flags.

Experimental releases may be significantly different than releases to Canary and Latest. **Do not use Experimental releases in user-facing applications.** You should expect frequent breaking changes between releases in the Experimental channel.

Releases in Experimental are published with the `experimental` tag on npm. Versions are generated from a hash of the build’s contents and the commit date, e.g. `0.0.0-experimental-68053d940-20210623`.

#### What goes into an experimental release?

Experimental features are ones that are not ready to be released to the wider public, and may change drastically before they are finalized. Some experiments may never be finalized — the reason we have experiments is to test the viability of proposed changes.

For example, if the Experimental channel had existed when we announced Hooks, we would have released Hooks to the Experimental channel weeks before they were available in Latest.

You may find it valuable to run integration tests against Experimental. This is up to you. However, be advised that Experimental is even less stable than Canary. **We do not guarantee any stability between Experimental releases.**

#### How can I learn more about experimental features?

Experimental features may or may not be documented. Usually, experiments aren’t documented until they are close to shipping in Canary or Latest.

If a feature is not documented, they may be accompanied by an [RFC](https://github.com/reactjs/rfcs).

We will post to the [React blog](https://react.dev/blog) when we’re ready to announce new experiments, but that doesn’t mean we will publicize every experiment.

You can always refer to our public GitHub repository’s [history](https://github.com/facebook/react/commits/main) for a comprehensive list of changes.

[PreviousAcknowledgements](https://react.dev/community/acknowledgements)

---

---


# Introducing react.dev – React

URL: https://react.dev/blog/2023/03/16/introducing-react-dev

[Blog](https://react.dev/blog)

# Introducing react.dev

March 16, 2023 by [Dan Abramov](https://bsky.app/profile/danabra.mov) and [Rachel Nabors](https://twitter.com/rachelnabors)

---

Today we are thrilled to launch [react.dev](https://react.dev), the new home for React and its documentation. In this post, we would like to give you a tour of the new site.

---

## tl;dr

* The new React site ([react.dev](https://react.dev)) teaches modern React with function components and Hooks.
* We’ve included diagrams, illustrations, challenges, and over 600 new interactive examples.
* The previous React documentation site has now moved to [legacy.reactjs.org](https://legacy.reactjs.org).

## New site, new domain, new homepage

First, a little bit of housekeeping.

To celebrate the launch of the new docs and, more importantly, to clearly separate the old and the new content, we’ve moved to the shorter [react.dev](https://react.dev) domain. The old [reactjs.org](https://reactjs.org) domain will now redirect here.

The old React docs are now archived at [legacy.reactjs.org](https://legacy.reactjs.org). All existing links to the old content will automatically redirect there to avoid “breaking the web”, but the legacy site will not get many more updates.

Believe it or not, React will soon be ten years old. In JavaScript years, it’s like a whole century! We’ve [refreshed the React homepage](https://react.dev) to reflect why we think React is a great way to create user interfaces today, and updated the getting started guides to more prominently mention modern React-based frameworks.

If you haven’t seen the new homepage yet, check it out!

## Going all-in on modern React with Hooks

When we released React Hooks in 2018, the Hooks docs assumed the reader is familiar with class components. This helped the community adopt Hooks very swiftly, but after a while the old docs failed to serve the new readers. New readers had to learn React twice: once with class components and then once again with Hooks.

**The new docs teach React with Hooks from the beginning.** The docs are divided in two main sections:

* **[Learn React](https://react.dev/learn)** is a self-paced course that teaches React from scratch.
* **[API Reference](https://react.dev/reference)** provides the details and usage examples for every React API.

Let’s have a closer look at what you can find in each section.

### Note

There are still a few rare class component use cases that do not yet have a Hook-based equivalent. Class components remain supported, and are documented in the [Legacy API](https://react.dev/reference/react/legacy) section of the new site.

## Quick start

The Learn section begins with the [Quick Start](https://react.dev/learn) page. It is a short introductory tour of React. It introduces the syntax for concepts like components, props, and state, but doesn’t go into much detail on how to use them.

If you like to learn by doing, we recommend checking out the [Tic-Tac-Toe Tutorial](https://react.dev/learn/tutorial-tic-tac-toe) next. It walks you through building a little game with React, while teaching the skills you’ll use every day. Here’s what you’ll build:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

function Square({ value, onSquareClick }) {
  return (
    <button className="square" onClick={onSquareClick}>
      {value}
    </button>
  );
}

function Board({ xIsNext, squares, onPlay }) {
  function handleClick(i) {
    if (calculateWinner(squares) || squares[i]) {
      return;
    }
    const nextSquares = squares.slice();
    if (xIsNext) {
      nextSquares[i] = 'X';
    } else {
      nextSquares[i] = 'O';
    }
    onPlay(nextSquares);
  }

  const winner = calculateWinner(squares);
  let status;
  if (winner) {
    status = 'Winner: ' + winner;
  } else {
    status = 'Next player: ' + (xIsNext ? 'X' : 'O');
  }

  return (
    <>
      <div className="status">{status}</div>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} onSquareClick={() => handleClick(3)} />
        <Square value={squares[4]} onSquareClick={() => handleClick(4)} />
        <Square value={squares[5]} onSquareClick={() => handleClick(5)} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} onSquareClick={() => handleClick(6)} />
        <Square value={squares[7]} onSquareClick={() => handleClick(7)} />
        <Square value={squares[8]} onSquareClick={() => handleClick(8)} />
      </div>
    </>
  );
}

export default function Game() {
  const [history, setHistory] = useState([Array(9).fill(null)]);
  const [currentMove, setCurrentMove] = useState(0);
  const xIsNext = currentMove % 2 === 0;
  const currentSquares = history[currentMove];

  function handlePlay(nextSquares) {
    const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];
    setHistory(nextHistory);
    setCurrentMove(nextHistory.length - 1);
  }

  function jumpTo(nextMove) {
    setCurrentMove(nextMove);
  }

  const moves = history.map((squares, move) => {
    let description;
    if (move > 0) {
      description = 'Go to move #' + move;
    } else {
      description = 'Go to game start';
    }
    return (
      <li key={move}>
        <button onClick={() => jumpTo(move)}>{description}</button>
      </li>
    );
  });

  return (
    <div className="game">
      <div className="game-board">
        <Board xIsNext={xIsNext} squares={currentSquares} onPlay={handlePlay} />
      </div>
      <div className="game-info">
        <ol>{moves}</ol>
      </div>
    </div>
  );
}

function calculateWinner(squares) {
  const lines = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8],
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8],
    [0, 4, 8],
    [2, 4, 6],
  ];
  for (let i = 0; i < lines.length; i++) {
    const [a, b, c] = lines[i];
    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {
      return squares[a];
    }
  }
  return null;
}
```

Show more

We’d also like to highlight [Thinking in React](https://react.dev/learn/thinking-in-react)—that’s the tutorial that made React “click” for many of us. **We’ve updated both of these classic tutorials to use function components and Hooks,** so they’re as good as new.

### Note

The example above is a *sandbox*. We’ve added a lot of sandboxes—over 600!—everywhere throughout the site. You can edit any sandbox, or press “Fork” in the upper right corner to open it in a separate tab. Sandboxes let you quickly play with the React APIs, explore your ideas, and check your understanding.

## Learn React step by step

We’d like everyone in the world to have an equal opportunity to learn React for free on their own.

This is why the Learn section is organized like a self-paced course split into chapters. The first two chapters describe the fundamentals of React. If you’re new to React, or want to refresh it in your memory, start here:

* **[Describing the UI](https://react.dev/learn/describing-the-ui)** teaches how to display information with components.
* **[Adding Interactivity](https://react.dev/learn/adding-interactivity)** teaches how to update the screen in response to user input.

The next two chapters are more advanced, and will give you a deeper insight into the trickier parts:

* **[Managing State](https://react.dev/learn/managing-state)** teaches how to organize your logic as your app grows in complexity.
* **[Escape Hatches](https://react.dev/learn/escape-hatches)** teaches how you can “step outside” React, and when it makes most sense to do so.

Every chapter consists of several related pages. Most of these pages teach a specific skill or a technique—for example, [Writing Markup with JSX](https://react.dev/learn/writing-markup-with-jsx), [Updating Objects in State](https://react.dev/learn/updating-objects-in-state), or [Sharing State Between Components](https://react.dev/learn/sharing-state-between-components). Some of the pages focus on explaining an idea—like [Render and Commit](https://react.dev/learn/render-and-commit), or [State as a Snapshot](https://react.dev/learn/state-as-a-snapshot). And there are a few, like [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect), that share our suggestions based on what we’ve learned over these years.

You don’t have to read these chapters as a sequence. Who has the time for this?! But you could. Pages in the Learn section only rely on concepts introduced by the earlier pages. If you want to read it like a book, go for it!

### Check your understanding with challenges

Most pages in the Learn section end with a few challenges to check your understanding. For example, here are a few challenges from the page about [Conditional Rendering](https://react.dev/learn/conditional-rendering#challenges).

You don’t have to solve them right now! Unless you *really* want to.

1. Show an icon for incomplete items with `? :` 2. Show the item importance with `&&`

#### Challenge 1 of 2: Show an icon for incomplete items with `? :`

Use the conditional operator (`cond ? a : b`) to render a ❌ if `isPacked` isn’t `true`.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Item({ name, isPacked }) {
  return (
    <li className="item">
      {name} {isPacked && '✅'}
    </li>
  );
}

export default function PackingList() {
  return (
    <section>
      <h1>Sally Ride's Packing List</h1>
      <ul>
        <Item 
          isPacked={true} 
          name="Space suit" 
        />
        <Item 
          isPacked={true} 
          name="Helmet with a golden leaf" 
        />
        <Item 
          isPacked={false} 
          name="Photo of Tam" 
        />
      </ul>
    </section>
  );
}
```

Show more

Show solutionNext Challenge

Notice the “Show solution” button in the left bottom corner. It’s handy if you want to check yourself!

### Build an intuition with diagrams and illustrations

When we couldn’t figure out how to explain something with code and words alone, we’ve added diagrams that help provide some intuition. For example, here is one of the diagrams from [Preserving and Resetting State](https://react.dev/learn/preserving-and-resetting-state):

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'section', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'div', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.dark.png&w=1920&q=75)

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a React component labeled 'div' with a single child labeled 'section', which has a single child labeled 'Counter' containing a state bubble labeled 'count' with value 3. The middle section has the same 'div' parent, but the child components have now been deleted, indicated by a yellow 'proof' image. The third section has the same 'div' parent again, now with a new child labeled 'div', highlighted in yellow, also with a new child labeled 'Counter' containing a state bubble labeled 'count' with value 0, all highlighted in yellow.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.png&w=1920&q=75)

When `section` changes to `div`, the `section` is deleted and the new `div` is added

You’ll also see some illustrations throughout the docs—here’s one of the [browser painting the screen](https://react.dev/learn/render-and-commit#epilogue-browser-paint):

![A browser painting 'still life with card element'.](https://react.dev/images/docs/illustrations/i_browser-paint.png)

Illustrated by [Rachel Lee Nabors](https://nearestnabors.com/)

We’ve confirmed with the browser vendors that this depiction is 100% scientifically accurate.

## A new, detailed API Reference

In the [API Reference](https://react.dev/reference/react), every React API now has a dedicated page. This includes all kinds of APIs:

* Built-in Hooks like [`useState`](https://react.dev/reference/react/useState).
* Built-in components like [`<Suspense>`](https://react.dev/reference/react/Suspense).
* Built-in browser components like [`<input>`](https://react.dev/reference/react-dom/components/input).
* Framework-oriented APIs like [`renderToPipeableStream`](https://react.dev/reference/react-dom/server/renderToReadableStream).
* Other React APIs like [`memo`](https://react.dev/reference/react/memo).

You’ll notice that every API page is split into at least two segments: *Reference* and *Usage*.

[Reference](https://react.dev/reference/react/useState#reference) describes the formal API signature by listing its arguments and return values. It’s concise, but it can feel a bit abstract if you’re not familiar with that API. It describes what an API does, but not how to use it.

[Usage](https://react.dev/reference/react/useState#usage) shows why and how you would use this API in practice, like a colleague or a friend might explain. It shows the **canonical scenarios for how each API was meant to be used by the React team.** We’ve added color-coded snippets, examples of using different APIs together, and recipes that you can copy and paste from:

#### Basic useState examples

1. Counter (number) 2. Text field (string) 3. Checkbox (boolean) 4. Form (two variables)

#### Example 1 of 4: Counter (number)

In this example, the `count` state variable holds a number. Clicking the button increments it.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      You pressed me {count} times
    </button>
  );
}
```

Next Example

Some API pages also include [Troubleshooting](https://react.dev/reference/react/useEffect#troubleshooting) (for common problems) and [Alternatives](https://react.dev/reference/react-dom/findDOMNode#alternatives) (for deprecated APIs).

We hope that this approach will make the API reference useful not only as a way to look up an argument, but as a way to see all the different things you can do with any given API—and how it connects to the other ones.

## What’s next?

That’s a wrap for our little tour! Have a look around the new website, see what you like or don’t like, and keep the feedback coming in our [issue tracker](https://github.com/reactjs/react.dev/issues).

We acknowledge this project has taken a long time to ship. We wanted to maintain a high quality bar that the React community deserves. While writing these docs and creating all of the examples, we found mistakes in some of our own explanations, bugs in React, and even gaps in the React design that we are now working to address. We hope that the new documentation will help us hold React itself to a higher bar in the future.

We’ve heard many of your requests to expand the content and functionality of the website, for example:

* Providing a TypeScript version for all examples;
* Creating the updated performance, testing, and accessibility guides;
* Documenting React Server Components independently from the frameworks that support them;
* Working with our international community to get the new docs translated;
* Adding missing features to the new website (for example, RSS for this blog).

Now that [react.dev](https://react.dev/) is out, we will be able to shift our focus from “catching up” with the third-party React educational resources to adding new information and further improving our new website.

We think there’s never been a better time to learn React.

## Who worked on this?

On the React team, [Rachel Nabors](https://twitter.com/rachelnabors/) led the project (and provided the illustrations), and [Dan Abramov](https://bsky.app/profile/danabra.mov) designed the curriculum. They co-authored most of the content together as well.

Of course, no project this large happens in isolation. We have a lot of people to thank!

[Sylwia Vargas](https://twitter.com/SylwiaVargas) overhauled our examples to go beyond “foo/bar/baz” and kittens, and feature scientists, artists and cities from around the world. [Maggie Appleton](https://twitter.com/Mappletons) turned our doodles into a clear diagram system.

Thanks to [David McCabe](https://twitter.com/mcc_abe), [Sophie Alpert](https://twitter.com/sophiebits), [Rick Hanlon](https://twitter.com/rickhanlonii), [Andrew Clark](https://twitter.com/acdlite), and [Matt Carroll](https://twitter.com/mattcarrollcode) for additional writing contributions. We’d also like to thank [Natalia Tepluhina](https://twitter.com/n_tepluhina) and [Sebastian Markbåge](https://twitter.com/sebmarkbage) for their ideas and feedback.

Thanks to [Dan Lebowitz](https://twitter.com/lebo) for the site design and [Razvan Gradinar](https://dribbble.com/GradinarRazvan) for the sandbox design.

On the development front, thanks to [Jared Palmer](https://twitter.com/jaredpalmer) for prototype development. Thanks to [Dane Grant](https://twitter.com/danecando) and [Dustin Goodman](https://twitter.com/dustinsgoodman) from [ThisDotLabs](https://www.thisdot.co/) for their support on UI development. Thanks to [Ives van Hoorne](https://twitter.com/CompuIves), [Alex Moldovan](https://twitter.com/alexnmoldovan), [Jasper De Moor](https://twitter.com/JasperDeMoor), and [Danilo Woznica](https://twitter.com/danilowoz) from [CodeSandbox](https://codesandbox.io/) for their work with sandbox integration. Thanks to [Rick Hanlon](https://twitter.com/rickhanlonii) for spot development and design work, finessing our colors and finer details. Thanks to [Harish Kumar](https://www.strek.in/) and [Luna Ruan](https://twitter.com/lunaruan) for adding new features to the site and helping maintain it.

Huge thanks to the folks who volunteered their time to participate in the alpha and beta testing program. Your enthusiasm and invaluable feedback helped us shape these docs. A special shout out to our beta tester, [Debbie O’Brien](https://twitter.com/debs_obrien), who gave a talk about her experience using the React docs at React Conf 2021.

Finally, thanks to the React community for being the inspiration behind this effort. You are the reason we do this, and we hope that the new docs will help you use React to build any user interface that you want.

[PreviousReact Labs: What We've Been Working On – March 2023](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023)[NextReact Labs: What We've Been Working On – June 2022](https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022)

---

---


# React v19 – React

URL: https://react.dev/blog/2024/12/05/react-19

[Blog](https://react.dev/blog)

# React v19

December 05, 2024 by [The React Team](https://react.dev/community/team)

---

### Note

### React 19 is now stable!

Additions since this post was originally shared with the React 19 RC in April:

* **Pre-warming for suspended trees**: see [Improvements to Suspense](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#improvements-to-suspense).
* **React DOM static APIs**: see [New React DOM Static APIs](https://react.dev/blog/2024/12/05/react-19#new-react-dom-static-apis).

*The date for this post has been updated to reflect the stable release date.*

React v19 is now available on npm!

In our [React 19 Upgrade Guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide), we shared step-by-step instructions for upgrading your app to React 19. In this post, we’ll give an overview of the new features in React 19, and how you can adopt them.

* [What’s new in React 19](https://react.dev/blog/2024/12/05/react-19#whats-new-in-react-19)
* [Improvements in React 19](https://react.dev/blog/2024/12/05/react-19#improvements-in-react-19)
* [How to upgrade](https://react.dev/blog/2024/12/05/react-19#how-to-upgrade)

For a list of breaking changes, see the [Upgrade Guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide).

---

## What’s new in React 19

### Actions

A common use case in React apps is to perform a data mutation and then update state in response. For example, when a user submits a form to change their name, you will make an API request, and then handle the response. In the past, you would need to handle pending states, errors, optimistic updates, and sequential requests manually.

For example, you could handle the pending and error state in `useState`:

```
// Before Actions

function UpdateName({}) {

const [name, setName] = useState("");

const [error, setError] = useState(null);

const [isPending, setIsPending] = useState(false);

const handleSubmit = async () => {

setIsPending(true);

const error = await updateName(name);

setIsPending(false);

if (error) {

setError(error);

return;

}

redirect("/path");

};

return (

<div>

<input value={name} onChange={(event) => setName(event.target.value)} />

<button onClick={handleSubmit} disabled={isPending}>

Update

</button>

{error && <p>{error}</p>}

</div>

);

}
```

In React 19, we’re adding support for using async functions in transitions to handle pending states, errors, forms, and optimistic updates automatically.

For example, you can use `useTransition` to handle the pending state for you:

```
// Using pending state from Actions

function UpdateName({}) {

const [name, setName] = useState("");

const [error, setError] = useState(null);

const [isPending, startTransition] = useTransition();

const handleSubmit = () => {

startTransition(async () => {

const error = await updateName(name);

if (error) {

setError(error);

return;

}

redirect("/path");

})

};

return (

<div>

<input value={name} onChange={(event) => setName(event.target.value)} />

<button onClick={handleSubmit} disabled={isPending}>

Update

</button>

{error && <p>{error}</p>}

</div>

);

}
```

The async transition will immediately set the `isPending` state to true, make the async request(s), and switch `isPending` to false after any transitions. This allows you to keep the current UI responsive and interactive while the data is changing.

### Note

#### By convention, functions that use async transitions are called “Actions”.

Actions automatically manage submitting data for you:

* **Pending state**: Actions provide a pending state that starts at the beginning of a request and automatically resets when the final state update is committed.
* **Optimistic updates**: Actions support the new [`useOptimistic`](https://react.dev/blog/2024/12/05/react-19#new-hook-optimistic-updates) hook so you can show users instant feedback while the requests are submitting.
* **Error handling**: Actions provide error handling so you can display Error Boundaries when a request fails, and revert optimistic updates to their original value automatically.
* **Forms**: `<form>` elements now support passing functions to the `action` and `formAction` props. Passing functions to the `action` props use Actions by default and reset the form automatically after submission.

Building on top of Actions, React 19 introduces [`useOptimistic`](https://react.dev/blog/2024/12/05/react-19#new-hook-optimistic-updates) to manage optimistic updates, and a new hook [`React.useActionState`](https://react.dev/blog/2024/12/05/react-19#new-hook-useactionstate) to handle common cases for Actions. In `react-dom` we’re adding [`<form>` Actions](https://react.dev/blog/2024/12/05/react-19#form-actions) to manage forms automatically and [`useFormStatus`](https://react.dev/blog/2024/12/05/react-19#new-hook-useformstatus) to support the common cases for Actions in forms.

In React 19, the above example can be simplified to:

```
// Using <form> Actions and useActionState

function ChangeName({ name, setName }) {

const [error, submitAction, isPending] = useActionState(

async (previousState, formData) => {

const error = await updateName(formData.get("name"));

if (error) {

return error;

}

redirect("/path");

return null;

},

null,

);

return (

<form action={submitAction}>

<input type="text" name="name" />

<button type="submit" disabled={isPending}>Update</button>

{error && <p>{error}</p>}

</form>

);

}
```

In the next section, we’ll break down each of the new Action features in React 19.

### New hook: `useActionState`

To make the common cases easier for Actions, we’ve added a new hook called `useActionState`:

```
const [error, submitAction, isPending] = useActionState(

async (previousState, newName) => {

const error = await updateName(newName);

if (error) {

// You can return any result of the action.

// Here, we return only the error.

return error;

}

// handle success

return null;

},

null,

);
```

`useActionState` accepts a function (the “Action”), and returns a wrapped Action to call. This works because Actions compose. When the wrapped Action is called, `useActionState` will return the last result of the Action as `data`, and the pending state of the Action as `pending`.

### Note

`React.useActionState` was previously called `ReactDOM.useFormState` in the Canary releases, but we’ve renamed it and deprecated `useFormState`.

See [#28491](https://github.com/facebook/react/pull/28491) for more info.

For more information, see the docs for [`useActionState`](https://react.dev/reference/react/useActionState).

### React DOM: `<form>` Actions

Actions are also integrated with React 19’s new `<form>` features for `react-dom`. We’ve added support for passing functions as the `action` and `formAction` props of `<form>`, `<input>`, and `<button>` elements to automatically submit forms with Actions:

```
<form action={actionFunction}>
```

When a `<form>` Action succeeds, React will automatically reset the form for uncontrolled components. If you need to reset the `<form>` manually, you can call the new `requestFormReset` React DOM API.

For more information, see the `react-dom` docs for [`<form>`](https://react.dev/reference/react-dom/components/form), [`<input>`](https://react.dev/reference/react-dom/components/input), and `<button>`.

### React DOM: New hook: `useFormStatus`

In design systems, it’s common to write design components that need access to information about the `<form>` they’re in, without drilling props down to the component. This can be done via Context, but to make the common case easier, we’ve added a new hook `useFormStatus`:

```
import {useFormStatus} from 'react-dom';

function DesignButton() {

const {pending} = useFormStatus();

return <button type="submit" disabled={pending} />

}
```

`useFormStatus` reads the status of the parent `<form>` as if the form was a Context provider.

For more information, see the `react-dom` docs for [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus).

### New hook: `useOptimistic`

Another common UI pattern when performing a data mutation is to show the final state optimistically while the async request is underway. In React 19, we’re adding a new hook called `useOptimistic` to make this easier:

```
function ChangeName({currentName, onUpdateName}) {

const [optimisticName, setOptimisticName] = useOptimistic(currentName);

const submitAction = async formData => {

const newName = formData.get("name");

setOptimisticName(newName);

const updatedName = await updateName(newName);

onUpdateName(updatedName);

};

return (

<form action={submitAction}>

<p>Your name is: {optimisticName}</p>

<p>

<label>Change Name:</label>

<input

type="text"

name="name"

disabled={currentName !== optimisticName}

/>

</p>

</form>

);

}
```

The `useOptimistic` hook will immediately render the `optimisticName` while the `updateName` request is in progress. When the update finishes or errors, React will automatically switch back to the `currentName` value.

For more information, see the docs for [`useOptimistic`](https://react.dev/reference/react/useOptimistic).

### New API: `use`

In React 19 we’re introducing a new API to read resources in render: `use`.

For example, you can read a promise with `use`, and React will Suspend until the promise resolves:

```
import {use} from 'react';

function Comments({commentsPromise}) {

// `use` will suspend until the promise resolves.

const comments = use(commentsPromise);

return comments.map(comment => <p key={comment.id}>{comment}</p>);

}

function Page({commentsPromise}) {

// When `use` suspends in Comments,

// this Suspense boundary will be shown.

return (

<Suspense fallback={<div>Loading...</div>}>

<Comments commentsPromise={commentsPromise} />

</Suspense>

)

}
```

### Note

#### `use` does not support promises created in render.

If you try to pass a promise created in render to `use`, React will warn:

Console

A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.

To fix, you need to pass a promise from a Suspense powered library or framework that supports caching for promises. In the future we plan to ship features to make it easier to cache promises in render.

You can also read context with `use`, allowing you to read Context conditionally such as after early returns:

```
import {use} from 'react';

import ThemeContext from './ThemeContext'

function Heading({children}) {

if (children == null) {

return null;

}

// This would not work with useContext

// because of the early return.

const theme = use(ThemeContext);

return (

<h1 style={{color: theme.color}}>

{children}

</h1>

);

}
```

The `use` API can only be called in render, similar to hooks. Unlike hooks, `use` can be called conditionally. In the future we plan to support more ways to consume resources in render with `use`.

For more information, see the docs for [`use`](https://react.dev/reference/react/use).

## New React DOM Static APIs

We’ve added two new APIs to `react-dom/static` for static site generation:

* [`prerender`](https://react.dev/reference/react-dom/static/prerender)
* [`prerenderToNodeStream`](https://react.dev/reference/react-dom/static/prerenderToNodeStream)

These new APIs improve on `renderToString` by waiting for data to load for static HTML generation. They are designed to work with streaming environments like Node.js Streams and Web Streams. For example, in a Web Stream environment, you can prerender a React tree to static HTML with `prerender`:

```
import { prerender } from 'react-dom/static';

async function handler(request) {

const {prelude} = await prerender(<App />, {

bootstrapScripts: ['/main.js']

});

return new Response(prelude, {

headers: { 'content-type': 'text/html' },

});

}
```

Prerender APIs will wait for all data to load before returning the static HTML stream. Streams can be converted to strings, or sent with a streaming response. They do not support streaming content as it loads, which is supported by the existing [React DOM server rendering APIs](https://react.dev/reference/react-dom/server).

For more information, see [React DOM Static APIs](https://react.dev/reference/react-dom/static).

## React Server Components

### Server Components

Server Components are a new option that allows rendering components ahead of time, before bundling, in an environment separate from your client application or SSR server. This separate environment is the “server” in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server.

React 19 includes all of the React Server Components features included from the Canary channel. This means libraries that ship with Server Components can now target React 19 as a peer dependency with a `react-server` [export condition](https://github.com/reactjs/rfcs/blob/main/text/0227-server-module-conventions.md#react-server-conditional-exports) for use in frameworks that support the [Full-stack React Architecture](https://react.dev/learn/creating-a-react-app#which-features-make-up-the-react-teams-full-stack-architecture-vision).

### Note

#### How do I build support for Server Components?

While React Server Components in React 19 are stable and will not break between minor versions, the underlying APIs used to implement a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x.

To support React Server Components as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement React Server Components in the future.

For more, see the docs for [React Server Components](https://react.dev/reference/rsc/server-components).

### Server Actions

Server Actions allow Client Components to call async functions executed on the server.

When a Server Action is defined with the `"use server"` directive, your framework will automatically create a reference to the server function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.

### Note

#### There is no directive for Server Components.

A common misunderstanding is that Server Components are denoted by `"use server"`, but there is no directive for Server Components. The `"use server"` directive is used for Server Actions.

For more info, see the docs for [Directives](https://react.dev/reference/rsc/directives).

Server Actions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.

For more, see the docs for [React Server Actions](https://react.dev/reference/rsc/server-actions).

## Improvements in React 19

### `ref` as a prop

Starting in React 19, you can now access `ref` as a prop for function components:

```
function MyInput({placeholder, ref}) {

return <input placeholder={placeholder} ref={ref} />

}

//...

<MyInput ref={ref} />
```

New function components will no longer need `forwardRef`, and we will be publishing a codemod to automatically update your components to use the new `ref` prop. In future versions we will deprecate and remove `forwardRef`.

### Note

`ref`s passed to classes are not passed as props since they reference the component instance.

### Diffs for hydration errors

We also improved error reporting for hydration errors in `react-dom`. For example, instead of logging multiple errors in DEV without any information about the mismatch:

Console

Warning: Text content did not match. Server: “Server” Client: “Client”
 at span
 at App

Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.

Warning: Text content did not match. Server: “Server” Client: “Client”
 at span
 at App

Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.

Uncaught Error: Text content does not match server-rendered HTML.
 at checkForUnmatchedText
 …

We now log a single message with a diff of the mismatch:

Console

Uncaught Error: Hydration failed because the server rendered HTML didn’t match the client. As a result this tree will be regenerated on the client. This can happen if an SSR-ed Client Component used:

- A server/client branch `if (typeof window !== 'undefined')`.
- Variable input such as `Date.now()` or `Math.random()` which changes each time it’s called.
- Date formatting in a user’s locale which doesn’t match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

<https://react.dev/link/hydration-mismatch> 

 <App>
 <span>
+ Client
- Server

 at throwOnHydrationMismatch
 …

### `<Context>` as a provider

In React 19, you can render `<Context>` as a provider instead of `<Context.Provider>`:

```
const ThemeContext = createContext('');

function App({children}) {

return (

<ThemeContext value="dark">

{children}

</ThemeContext>

);

}
```

New Context providers can use `<Context>` and we will be publishing a codemod to convert existing providers. In future versions we will deprecate `<Context.Provider>`.

### Cleanup functions for refs

We now support returning a cleanup function from `ref` callbacks:

```
<input

ref={(ref) => {

// ref created

// NEW: return a cleanup function to reset

// the ref when element is removed from DOM.

return () => {

// ref cleanup

};

}}

/>
```

When the component unmounts, React will call the cleanup function returned from the `ref` callback. This works for DOM refs, refs to class components, and `useImperativeHandle`.

### Note

Previously, React would call `ref` functions with `null` when unmounting the component. If your `ref` returns a cleanup function, React will now skip this step.

In future versions, we will deprecate calling refs with `null` when unmounting components.

Due to the introduction of ref cleanup functions, returning anything else from a `ref` callback will now be rejected by TypeScript. The fix is usually to stop using implicit returns, for example:

```
- <div ref={current => (instance = current)} />

+ <div ref={current => {instance = current}} />
```

The original code returned the instance of the `HTMLDivElement` and TypeScript wouldn’t know if this was *supposed* to be a cleanup function or if you didn’t want to return a cleanup function.

You can codemod this pattern with [`no-implicit-ref-callback-return`](https://github.com/eps1lon/types-react-codemod/#no-implicit-ref-callback-return).

### `useDeferredValue` initial value

We’ve added an `initialValue` option to `useDeferredValue`:

```
function Search({deferredValue}) {

// On initial render the value is ''.

// Then a re-render is scheduled with the deferredValue.

const value = useDeferredValue(deferredValue, '');

return (

<Results query={value} />

);

}
```

When initialValue is provided, `useDeferredValue` will return it as `value` for the initial render of the component, and schedules a re-render in the background with the deferredValue returned.

For more, see [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue).

### Support for Document Metadata

In HTML, document metadata tags like `<title>`, `<link>`, and `<meta>` are reserved for placement in the `<head>` section of the document. In React, the component that decides what metadata is appropriate for the app may be very far from the place where you render the `<head>` or React does not render the `<head>` at all. In the past, these elements would need to be inserted manually in an effect, or by libraries like [`react-helmet`](https://github.com/nfl/react-helmet), and required careful handling when server rendering a React application.

In React 19, we’re adding support for rendering document metadata tags in components natively:

```
function BlogPost({post}) {

return (

<article>

<h1>{post.title}</h1>

<title>{post.title}</title>

<meta name="author" content="Josh" />

<link rel="author" href="https://twitter.com/joshcstory/" />

<meta name="keywords" content={post.keywords} />

<p>

Eee equals em-see-squared...

</p>

</article>

);

}
```

When React renders this component, it will see the `<title>` `<link>` and `<meta>` tags, and automatically hoist them to the `<head>` section of document. By supporting these metadata tags natively, we’re able to ensure they work with client-only apps, streaming SSR, and Server Components.

### Note

#### You may still want a Metadata library

For simple use cases, rendering Document Metadata as tags may be suitable, but libraries can offer more powerful features like overriding generic metadata with specific metadata based on the current route. These features make it easier for frameworks and libraries like [`react-helmet`](https://github.com/nfl/react-helmet) to support metadata tags, rather than replace them.

For more info, see the docs for [`<title>`](https://react.dev/reference/react-dom/components/title), [`<link>`](https://react.dev/reference/react-dom/components/link), and [`<meta>`](https://react.dev/reference/react-dom/components/meta).

### Support for stylesheets

Stylesheets, both externally linked (`<link rel="stylesheet" href="...">`) and inline (`<style>...</style>`), require careful positioning in the DOM due to style precedence rules. Building a stylesheet capability that allows for composability within components is hard, so users often end up either loading all of their styles far from the components that may depend on them, or they use a style library which encapsulates this complexity.

In React 19, we’re addressing this complexity and providing even deeper integration into Concurrent Rendering on the Client and Streaming Rendering on the Server with built in support for stylesheets. If you tell React the `precedence` of your stylesheet it will manage the insertion order of the stylesheet in the DOM and ensure that the stylesheet (if external) is loaded before revealing content that depends on those style rules.

```
function ComponentOne() {

return (

<Suspense fallback="loading...">

<link rel="stylesheet" href="foo" precedence="default" />

<link rel="stylesheet" href="bar" precedence="high" />

<article class="foo-class bar-class">

{...}

</article>

</Suspense>

)

}

function ComponentTwo() {

return (

<div>

<p>{...}</p>

<link rel="stylesheet" href="baz" precedence="default" />  <-- will be inserted between foo & bar

</div>

)

}
```

During Server Side Rendering React will include the stylesheet in the `<head>`, which ensures that the browser will not paint until it has loaded. If the stylesheet is discovered late after we’ve already started streaming, React will ensure that the stylesheet is inserted into the `<head>` on the client before revealing the content of a Suspense boundary that depends on that stylesheet.

During Client Side Rendering React will wait for newly rendered stylesheets to load before committing the render. If you render this component from multiple places within your application React will only include the stylesheet once in the document:

```
function App() {

return <>

<ComponentOne />

...

<ComponentOne /> // won't lead to a duplicate stylesheet link in the DOM

</>

}
```

For users accustomed to loading stylesheets manually this is an opportunity to locate those stylesheets alongside the components that depend on them allowing for better local reasoning and an easier time ensuring you only load the stylesheets that you actually depend on.

Style libraries and style integrations with bundlers can also adopt this new capability so even if you don’t directly render your own stylesheets, you can still benefit as your tools are upgraded to use this feature.

For more details, read the docs for [`<link>`](https://react.dev/reference/react-dom/components/link) and [`<style>`](https://react.dev/reference/react-dom/components/style).

### Support for async scripts

In HTML normal scripts (`<script src="...">`) and deferred scripts (`<script defer="" src="...">`) load in document order which makes rendering these kinds of scripts deep within your component tree challenging. Async scripts (`<script async="" src="...">`) however will load in arbitrary order.

In React 19 we’ve included better support for async scripts by allowing you to render them anywhere in your component tree, inside the components that actually depend on the script, without having to manage relocating and deduplicating script instances.

```
function MyComponent() {

return (

<div>

<script async={true} src="..." />

Hello World

</div>

)

}

function App() {

<html>

<body>

<MyComponent>

...

<MyComponent> // won't lead to duplicate script in the DOM

</body>

</html>

}
```

In all rendering environments, async scripts will be deduplicated so that React will only load and execute the script once even if it is rendered by multiple different components.

In Server Side Rendering, async scripts will be included in the `<head>` and prioritized behind more critical resources that block paint such as stylesheets, fonts, and image preloads.

For more details, read the docs for [`<script>`](https://react.dev/reference/react-dom/components/script).

### Support for preloading resources

During initial document load and on client side updates, telling the Browser about resources that it will likely need to load as early as possible can have a dramatic effect on page performance.

React 19 includes a number of new APIs for loading and preloading Browser resources to make it as easy as possible to build great experiences that aren’t held back by inefficient resource loading.

```
import { prefetchDNS, preconnect, preload, preinit } from 'react-dom'

function MyComponent() {

preinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly

preload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font

preload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet

prefetchDNS('https://...') // when you may not actually request anything from this host

preconnect('https://...') // when you will request something but aren't sure what

}
```

```
<!-- the above would result in the following DOM/HTML -->

<html>

<head>

<!-- links/scripts are prioritized by their utility to early loading, not call order -->

<link rel="prefetch-dns" href="https://...">

<link rel="preconnect" href="https://...">

<link rel="preload" as="font" href="https://.../path/to/font.woff">

<link rel="preload" as="style" href="https://.../path/to/stylesheet.css">

<script async="" src="https://.../path/to/some/script.js"></script>

</head>

<body>

...

</body>

</html>
```

These APIs can be used to optimize initial page loads by moving discovery of additional resources like fonts out of stylesheet loading. They can also make client updates faster by prefetching a list of resources used by an anticipated navigation and then eagerly preloading those resources on click or even on hover.

For more details see [Resource Preloading APIs](https://react.dev/reference/react-dom#resource-preloading-apis).

### Compatibility with third-party scripts and extensions

We’ve improved hydration to account for third-party scripts and browser extensions.

When hydrating, if an element that renders on the client doesn’t match the element found in the HTML from the server, React will force a client re-render to fix up the content. Previously, if an element was inserted by third-party scripts or browser extensions, it would trigger a mismatch error and client render.

In React 19, unexpected tags in the `<head>` and `<body>` will be skipped over, avoiding the mismatch errors. If React needs to re-render the entire document due to an unrelated hydration mismatch, it will leave in place stylesheets inserted by third-party scripts and browser extensions.

### Better error reporting

We improved error handling in React 19 to remove duplication and provide options for handling caught and uncaught errors. For example, when there’s an error in render caught by an Error Boundary, previously React would throw the error twice (once for the original error, then again after failing to automatically recover), and then call `console.error` with info about where the error occurred.

This resulted in three errors for every caught error:

Console

Uncaught Error: hit
 at Throws
 at renderWithHooks
 …

Uncaught Error: hit <-- Duplicate
 at Throws
 at renderWithHooks
 …

The above error occurred in the Throws component:
 at Throws
 at ErrorBoundary
 at App

React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.

In React 19, we log a single error with all the error information included:

Console

Error: hit
 at Throws
 at renderWithHooks
 …

The above error occurred in the Throws component:
 at Throws
 at ErrorBoundary
 at App

React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.
 at ErrorBoundary
 at App

Additionally, we’ve added two new root options to complement `onRecoverableError`:

* `onCaughtError`: called when React catches an error in an Error Boundary.
* `onUncaughtError`: called when an error is thrown and not caught by an Error Boundary.
* `onRecoverableError`: called when an error is thrown and automatically recovered.

For more info and examples, see the docs for [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) and [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot).

### Support for Custom Elements

React 19 adds full support for custom elements and passes all tests on [Custom Elements Everywhere](https://custom-elements-everywhere.com/).

In past versions, using Custom Elements in React has been difficult because React treated unrecognized props as attributes rather than properties. In React 19, we’ve added support for properties that works on the client and during SSR with the following strategy:

* **Server Side Rendering**: props passed to a custom element will render as attributes if their type is a primitive value like `string`, `number`, or the value is `true`. Props with non-primitive types like `object`, `symbol`, `function`, or value `false` will be omitted.
* **Client Side Rendering**: props that match a property on the Custom Element instance will be assigned as properties, otherwise they will be assigned as attributes.

Thanks to [Joey Arhar](https://github.com/josepharhar) for driving the design and implementation of Custom Element support in React.

#### How to upgrade

See the [React 19 Upgrade Guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide) for step-by-step instructions and a full list of breaking and notable changes.

*Note: this post was originally published 04/25/2024 and has been updated to 12/05/2024 with the stable release.*

[PreviousSunsetting Create React App](https://react.dev/blog/2025/02/14/sunsetting-create-react-app)[NextReact Compiler Beta Release and Roadmap](https://react.dev/blog/2024/10/21/react-compiler-beta-release)

---

---


# React 19 Upgrade Guide – React

URL: https://react.dev/blog/2024/04/25/react-19-upgrade-guide

[Blog](https://react.dev/blog)

# React 19 Upgrade Guide

April 25, 2024 by [Ricky Hanlon](https://twitter.com/rickhanlonii)

---

The improvements added to React 19 require some breaking changes, but we’ve worked to make the upgrade as smooth as possible, and we don’t expect the changes to impact most apps.

### Note

#### React 18.3 has also been published

To help make the upgrade to React 19 easier, we’ve published a `react@18.3` release that is identical to 18.2 but adds warnings for deprecated APIs and other changes that are needed for React 19.

We recommend upgrading to React 18.3 first to help identify any issues before upgrading to React 19.

For a list of changes in 18.3 see the [Release Notes](https://github.com/facebook/react/blob/main/CHANGELOG.md#1830-april-25-2024).

In this post, we will guide you through the steps for upgrading to React 19:

* [Installing](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#installing)
* [Codemods](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#codemods)
* [Breaking changes](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#breaking-changes)
* [New deprecations](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#new-deprecations)
* [Notable changes](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#notable-changes)
* [TypeScript changes](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#typescript-changes)
* [Changelog](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#changelog)

If you’d like to help us test React 19, follow the steps in this upgrade guide and [report any issues](https://github.com/facebook/react/issues/new?assignees=&labels=React+19&projects=&template=19.md&title=%5BReact+19%5D) you encounter. For a list of new features added to React 19, see the [React 19 release post](https://react.dev/blog/2024/12/05/react-19).

---

## Installing

### Note

#### New JSX Transform is now required

We introduced a [new JSX transform](https://legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) in 2020 to improve bundle size and use JSX without importing React. In React 19, we’re adding additional improvements like using ref as a prop and JSX speed improvements that require the new transform.

If the new transform is not enabled, you will see this warning:

Console

Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: <https://react.dev/link/new-jsx-transform>

We expect most apps will not be affected since the transform is enabled in most environments already. For manual instructions on how to upgrade, please see the [announcement post](https://legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html).

To install the latest version of React and React DOM:

```
npm install --save-exact react@^19.0.0 react-dom@^19.0.0
```

Or, if you’re using Yarn:

```
yarn add --exact react@^19.0.0 react-dom@^19.0.0
```

If you’re using TypeScript, you also need to update the types.

```
npm install --save-exact @types/react@^19.0.0 @types/react-dom@^19.0.0
```

Or, if you’re using Yarn:

```
yarn add --exact @types/react@^19.0.0 @types/react-dom@^19.0.0
```

We’re also including a codemod for the most common replacements. See [TypeScript changes](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#typescript-changes) below.

## Codemods

To help with the upgrade, we’ve worked with the team at [codemod.com](https://codemod.com) to publish codemods that will automatically update your code to many of the new APIs and patterns in React 19.

All codemods are available in the [`react-codemod` repo](https://github.com/reactjs/react-codemod) and the Codemod team have joined in helping maintain the codemods. To run these codemods, we recommend using the `codemod` command instead of the `react-codemod` because it runs faster, handles more complex code migrations, and provides better support for TypeScript.

### Note

#### Run all React 19 codemods

Run all codemods listed in this guide with the React 19 `codemod` recipe:

```
npx codemod@latest react/19/migration-recipe
```

This will run the following codemods from `react-codemod`:

* [`replace-reactdom-render`](https://github.com/reactjs/react-codemod?tab=readme-ov-file#replace-reactdom-render)
* [`replace-string-ref`](https://github.com/reactjs/react-codemod?tab=readme-ov-file#replace-string-ref)
* [`replace-act-import`](https://github.com/reactjs/react-codemod?tab=readme-ov-file#replace-act-import)
* [`replace-use-form-state`](https://github.com/reactjs/react-codemod?tab=readme-ov-file#replace-use-form-state)
* [`prop-types-typescript`](https://github.com/reactjs/react-codemod#react-proptypes-to-prop-types)

This does not include the TypeScript changes. See [TypeScript changes](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#typescript-changes) below.

Changes that include a codemod include the command below.

For a list of all available codemods, see the [`react-codemod` repo](https://github.com/reactjs/react-codemod).

## Breaking changes

### Errors in render are not re-thrown

In previous versions of React, errors thrown during render were caught and rethrown. In DEV, we would also log to `console.error`, resulting in duplicate error logs.

In React 19, we’ve [improved how errors are handled](https://react.dev/blog/2024/04/25/react-19#error-handling) to reduce duplication by not re-throwing:

* **Uncaught Errors**: Errors that are not caught by an Error Boundary are reported to `window.reportError`.
* **Caught Errors**: Errors that are caught by an Error Boundary are reported to `console.error`.

This change should not impact most apps, but if your production error reporting relies on errors being re-thrown, you may need to update your error handling. To support this, we’ve added new methods to `createRoot` and `hydrateRoot` for custom error handling:

```
const root = createRoot(container, {

onUncaughtError: (error, errorInfo) => {

// ... log error report

},

onCaughtError: (error, errorInfo) => {

// ... log error report

}

});
```

For more info, see the docs for [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) and [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot).

### Removed deprecated React APIs

#### Removed: `propTypes` and `defaultProps` for functions

`PropTypes` were deprecated in [April 2017 (v15.5.0)](https://legacy.reactjs.org/blog/2017/04/07/react-v15.5.0.html#new-deprecation-warnings).

In React 19, we’re removing the `propType` checks from the React package, and using them will be silently ignored. If you’re using `propTypes`, we recommend migrating to TypeScript or another type-checking solution.

We’re also removing `defaultProps` from function components in place of ES6 default parameters. Class components will continue to support `defaultProps` since there is no ES6 alternative.

```
// Before

import PropTypes from 'prop-types';

function Heading({text}) {

return <h1>{text}</h1>;

}

Heading.propTypes = {

text: PropTypes.string,

};

Heading.defaultProps = {

text: 'Hello, world!',

};
```

```
// After

interface Props {

text?: string;

}

function Heading({text = 'Hello, world!'}: Props) {

return <h1>{text}</h1>;

}
```

### Note

Codemod `propTypes` to TypeScript with:

```
npx codemod@latest react/prop-types-typescript
```

#### Removed: Legacy Context using `contextTypes` and `getChildContext`

Legacy Context was deprecated in [October 2018 (v16.6.0)](https://legacy.reactjs.org/blog/2018/10/23/react-v-16-6.html).

Legacy Context was only available in class components using the APIs `contextTypes` and `getChildContext`, and was replaced with `contextType` due to subtle bugs that were easy to miss. In React 19, we’re removing Legacy Context to make React slightly smaller and faster.

If you’re still using Legacy Context in class components, you’ll need to migrate to the new `contextType` API:

```
// Before

import PropTypes from 'prop-types';

class Parent extends React.Component {

static childContextTypes = {

foo: PropTypes.string.isRequired,

};

getChildContext() {

return { foo: 'bar' };

}

render() {

return <Child />;

}

}

class Child extends React.Component {

static contextTypes = {

foo: PropTypes.string.isRequired,

};

render() {

return <div>{this.context.foo}</div>;

}

}
```

```
// After

const FooContext = React.createContext();

class Parent extends React.Component {

render() {

return (

<FooContext value='bar'>

<Child />

</FooContext>

);

}

}

class Child extends React.Component {

static contextType = FooContext;

render() {

return <div>{this.context}</div>;

}

}
```

#### Removed: string refs

String refs were deprecated in [March, 2018 (v16.3.0)](https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html).

Class components supported string refs before being replaced by ref callbacks due to [multiple downsides](https://github.com/facebook/react/issues/1373). In React 19, we’re removing string refs to make React simpler and easier to understand.

If you’re still using string refs in class components, you’ll need to migrate to ref callbacks:

```
// Before

class MyComponent extends React.Component {

componentDidMount() {

this.refs.input.focus();

}

render() {

return <input ref='input' />;

}

}
```

```
// After

class MyComponent extends React.Component {

componentDidMount() {

this.input.focus();

}

render() {

return <input ref={input => this.input = input} />;

}

}
```

### Note

Codemod string refs with `ref` callbacks:

```
npx codemod@latest react/19/replace-string-ref
```

#### Removed: Module pattern factories

Module pattern factories were deprecated in [August 2019 (v16.9.0)](https://legacy.reactjs.org/blog/2019/08/08/react-v16.9.0.html#deprecating-module-pattern-factories).

This pattern was rarely used and supporting it causes React to be slightly larger and slower than necessary. In React 19, we’re removing support for module pattern factories, and you’ll need to migrate to regular functions:

```
// Before

function FactoryComponent() {

return { render() { return <div />; } }

}
```

```
// After

function FactoryComponent() {

return <div />;

}
```

#### Removed: `React.createFactory`

`createFactory` was deprecated in [February 2020 (v16.13.0)](https://legacy.reactjs.org/blog/2020/02/26/react-v16.13.0.html#deprecating-createfactory).

Using `createFactory` was common before broad support for JSX, but it’s rarely used today and can be replaced with JSX. In React 19, we’re removing `createFactory` and you’ll need to migrate to JSX:

```
// Before

import { createFactory } from 'react';

const button = createFactory('button');
```

```
// After

const button = <button />;
```

#### Removed: `react-test-renderer/shallow`

In React 18, we updated `react-test-renderer/shallow` to re-export [react-shallow-renderer](https://github.com/enzymejs/react-shallow-renderer). In React 19, we’re removing `react-test-render/shallow` to prefer installing the package directly:

```
npm install react-shallow-renderer --save-dev
```

```
- import ShallowRenderer from 'react-test-renderer/shallow';

+ import ShallowRenderer from 'react-shallow-renderer';
```

### Note

##### Please reconsider shallow rendering

Shallow rendering depends on React internals and can block you from future upgrades. We recommend migrating your tests to [@testing-library/react](https://testing-library.com/docs/react-testing-library/intro/) or [@testing-library/react-native](https://testing-library.com/docs/react-native-testing-library/intro).

### Removed deprecated React DOM APIs

#### Removed: `react-dom/test-utils`

We’ve moved `act` from `react-dom/test-utils` to the `react` package:

Console

`ReactDOMTestUtils.act` is deprecated in favor of `React.act`. Import `act` from `react` instead of `react-dom/test-utils`. See <https://react.dev/warnings/react-dom-test-utils> for more info.

To fix this warning, you can import `act` from `react`:

```
- import {act} from 'react-dom/test-utils'

+ import {act} from 'react';
```

All other `test-utils` functions have been removed. These utilities were uncommon, and made it too easy to depend on low level implementation details of your components and React. In React 19, these functions will error when called and their exports will be removed in a future version.

See the [warning page](https://react.dev/warnings/react-dom-test-utils) for alternatives.

### Note

Codemod `ReactDOMTestUtils.act` to `React.act`:

```
npx codemod@latest react/19/replace-act-import
```

#### Removed: `ReactDOM.render`

`ReactDOM.render` was deprecated in [March 2022 (v18.0.0)](https://react.dev/blog/2022/03/08/react-18-upgrade-guide). In React 19, we’re removing `ReactDOM.render` and you’ll need to migrate to using [`ReactDOM.createRoot`](https://react.dev/reference/react-dom/client/createRoot):

```
// Before

import {render} from 'react-dom';

render(<App />, document.getElementById('root'));

// After

import {createRoot} from 'react-dom/client';

const root = createRoot(document.getElementById('root'));

root.render(<App />);
```

### Note

Codemod `ReactDOM.render` to `ReactDOMClient.createRoot`:

```
npx codemod@latest react/19/replace-reactdom-render
```

#### Removed: `ReactDOM.hydrate`

`ReactDOM.hydrate` was deprecated in [March 2022 (v18.0.0)](https://react.dev/blog/2022/03/08/react-18-upgrade-guide). In React 19, we’re removing `ReactDOM.hydrate` you’ll need to migrate to using [`ReactDOM.hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot),

```
// Before

import {hydrate} from 'react-dom';

hydrate(<App />, document.getElementById('root'));

// After

import {hydrateRoot} from 'react-dom/client';

hydrateRoot(document.getElementById('root'), <App />);
```

### Note

Codemod `ReactDOM.hydrate` to `ReactDOMClient.hydrateRoot`:

```
npx codemod@latest react/19/replace-reactdom-render
```

#### Removed: `unmountComponentAtNode`

`ReactDOM.unmountComponentAtNode` was deprecated in [March 2022 (v18.0.0)](https://react.dev/blog/2022/03/08/react-18-upgrade-guide). In React 19, you’ll need to migrate to using `root.unmount()`.

```
// Before

unmountComponentAtNode(document.getElementById('root'));

// After

root.unmount();
```

For more see `root.unmount()` for [`createRoot`](https://react.dev/reference/react-dom/client/createRoot#root-unmount) and [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot#root-unmount).

### Note

Codemod `unmountComponentAtNode` to `root.unmount`:

```
npx codemod@latest react/19/replace-reactdom-render
```

#### Removed: `ReactDOM.findDOMNode`

`ReactDOM.findDOMNode` was [deprecated in October 2018 (v16.6.0)](https://legacy.reactjs.org/blog/2018/10/23/react-v-16-6.html#deprecations-in-strictmode).

We’re removing `findDOMNode` because it was a legacy escape hatch that was slow to execute, fragile to refactoring, only returned the first child, and broke abstraction levels (see more [here](https://legacy.reactjs.org/docs/strict-mode.html#warning-about-deprecated-finddomnode-usage)). You can replace `ReactDOM.findDOMNode` with [DOM refs](https://react.dev/learn/manipulating-the-dom-with-refs):

```
// Before

import {findDOMNode} from 'react-dom';

function AutoselectingInput() {

useEffect(() => {

const input = findDOMNode(this);

input.select()

}, []);

return <input defaultValue="Hello" />;

}
```

```
// After

function AutoselectingInput() {

const ref = useRef(null);

useEffect(() => {

ref.current.select();

}, []);

return <input ref={ref} defaultValue="Hello" />

}
```

## New deprecations

### Deprecated: `element.ref`

React 19 supports [`ref` as a prop](https://react.dev/blog/2024/04/25/react-19#ref-as-a-prop), so we’re deprecating the `element.ref` in place of `element.props.ref`.

Accessing `element.ref` will warn:

Console

Accessing element.ref is no longer supported. ref is now a regular prop. It will be removed from the JSX Element type in a future release.

### Deprecated: `react-test-renderer`

We are deprecating `react-test-renderer` because it implements its own renderer environment that doesn’t match the environment users use, promotes testing implementation details, and relies on introspection of React’s internals.

The test renderer was created before there were more viable testing strategies available like [React Testing Library](https://testing-library.com), and we now recommend using a modern testing library instead.

In React 19, `react-test-renderer` logs a deprecation warning, and has switched to concurrent rendering. We recommend migrating your tests to [@testing-library/react](https://testing-library.com/docs/react-testing-library/intro/) or [@testing-library/react-native](https://testing-library.com/docs/react-native-testing-library/intro) for a modern and well supported testing experience.

## Notable changes

### StrictMode changes

React 19 includes several fixes and improvements to Strict Mode.

When double rendering in Strict Mode in development, `useMemo` and `useCallback` will reuse the memoized results from the first render during the second render. Components that are already Strict Mode compatible should not notice a difference in behavior.

As with all Strict Mode behaviors, these features are designed to proactively surface bugs in your components during development so you can fix them before they are shipped to production. For example, during development, Strict Mode will double-invoke ref callback functions on initial mount, to simulate what happens when a mounted component is replaced by a Suspense fallback.

### Improvements to Suspense

In React 19, when a component suspends, React will immediately commit the fallback of the nearest Suspense boundary without waiting for the entire sibling tree to render. After the fallback commits, React schedules another render for the suspended siblings to “pre-warm” lazy requests in the rest of the tree:

![Diagram showing a tree of three components, one parent labeled Accordion and two children labeled Panel. Both Panel components contain isActive with value false.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fprerender.dark.png&w=3840&q=75)

![Diagram showing a tree of three components, one parent labeled Accordion and two children labeled Panel. Both Panel components contain isActive with value false.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fprerender.png&w=3840&q=75)

Previously, when a component suspended, the suspended siblings were rendered and then the fallback was committed.

![The same diagram as the previous, with the isActive of the first child Panel component highlighted indicating a click with the isActive value set to true. The second Panel component still contains value false.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fprewarm.dark.png&w=3840&q=75)

![The same diagram as the previous, with the isActive of the first child Panel component highlighted indicating a click with the isActive value set to true. The second Panel component still contains value false.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fprewarm.png&w=3840&q=75)

In React 19, when a component suspends, the fallback is committed and then the suspended siblings are rendered.

This change means Suspense fallbacks display faster, while still warming lazy requests in the suspended tree.

### UMD builds removed

UMD was widely used in the past as a convenient way to load React without a build step. Now, there are modern alternatives for loading modules as scripts in HTML documents. Starting with React 19, React will no longer produce UMD builds to reduce the complexity of its testing and release process.

To load React 19 with a script tag, we recommend using an ESM-based CDN such as [esm.sh](https://esm.sh/).

```
<script type="module">

import React from "https://esm.sh/react@19/?dev"

import ReactDOMClient from "https://esm.sh/react-dom@19/client?dev"

...

</script>
```

### Libraries depending on React internals may block upgrades

This release includes changes to React internals that may impact libraries that ignore our pleas to not use internals like `SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED`. These changes are necessary to land improvements in React 19, and will not break libraries that follow our guidelines.

Based on our [Versioning Policy](https://react.dev/community/versioning-policy#what-counts-as-a-breaking-change), these updates are not listed as breaking changes, and we are not including docs for how to upgrade them. The recommendation is to remove any code that depends on internals.

To reflect the impact of using internals, we have renamed the `SECRET_INTERNALS` suffix to:

`_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE`

In the future we will more aggressively block accessing internals from React to discourage usage and ensure users are not blocked from upgrading.

## TypeScript changes

### Removed deprecated TypeScript types

We’ve cleaned up the TypeScript types based on the removed APIs in React 19. Some of the removed have types been moved to more relevant packages, and others are no longer needed to describe React’s behavior.

### Note

We’ve published [`types-react-codemod`](https://github.com/eps1lon/types-react-codemod/) to migrate most type related breaking changes:

```
npx types-react-codemod@latest preset-19 ./path-to-app
```

If you have a lot of unsound access to `element.props`, you can run this additional codemod:

```
npx types-react-codemod@latest react-element-default-any-props ./path-to-your-react-ts-files
```

Check out [`types-react-codemod`](https://github.com/eps1lon/types-react-codemod/) for a list of supported replacements. If you feel a codemod is missing, it can be tracked in the [list of missing React 19 codemods](https://github.com/eps1lon/types-react-codemod/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22React+19%22+label%3Aenhancement).

### `ref` cleanups required

*This change is included in the `react-19` codemod preset as [`no-implicit-ref-callback-return`](https://github.com/eps1lon/types-react-codemod/#no-implicit-ref-callback-return) .*

Due to the introduction of ref cleanup functions, returning anything else from a ref callback will now be rejected by TypeScript. The fix is usually to stop using implicit returns:

```
- <div ref={current => (instance = current)} />

+ <div ref={current => {instance = current}} />
```

The original code returned the instance of the `HTMLDivElement` and TypeScript wouldn’t know if this was supposed to be a cleanup function or not.

### `useRef` requires an argument

*This change is included in the `react-19` codemod preset as [`refobject-defaults`](https://github.com/eps1lon/types-react-codemod/#refobject-defaults).*

A long-time complaint of how TypeScript and React work has been `useRef`. We’ve changed the types so that `useRef` now requires an argument. This significantly simplifies its type signature. It’ll now behave more like `createContext`.

```
// @ts-expect-error: Expected 1 argument but saw none

useRef();

// Passes

useRef(undefined);

// @ts-expect-error: Expected 1 argument but saw none

createContext();

// Passes

createContext(undefined);
```

This now also means that all refs are mutable. You’ll no longer hit the issue where you can’t mutate a ref because you initialised it with `null`:

```
const ref = useRef<number>(null);

// Cannot assign to 'current' because it is a read-only property

ref.current = 1;
```

`MutableRef` is now deprecated in favor of a single `RefObject` type which `useRef` will always return:

```
interface RefObject<T> {

current: T

}

declare function useRef<T>: RefObject<T>
```

`useRef` still has a convenience overload for `useRef<T>(null)` that automatically returns `RefObject<T | null>`. To ease migration due to the required argument for `useRef`, a convenience overload for `useRef(undefined)` was added that automatically returns `RefObject<T | undefined>`.

Check out [[RFC] Make all refs mutable](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/64772) for prior discussions about this change.

### Changes to the `ReactElement` TypeScript type

*This change is included in the [`react-element-default-any-props`](https://github.com/eps1lon/types-react-codemod#react-element-default-any-props) codemod.*

The `props` of React elements now default to `unknown` instead of `any` if the element is typed as `ReactElement`. This does not affect you if you pass a type argument to `ReactElement`:

```
type Example2 = ReactElement<{ id: string }>["props"];

//   ^? { id: string }
```

But if you relied on the default, you now have to handle `unknown`:

```
type Example = ReactElement["props"];

//   ^? Before, was 'any', now 'unknown'
```

You should only need it if you have a lot of legacy code relying on unsound access of element props. Element introspection only exists as an escape hatch, and you should make it explicit that your props access is unsound via an explicit `any`.

### The JSX namespace in TypeScript

This change is included in the `react-19` codemod preset as [`scoped-jsx`](https://github.com/eps1lon/types-react-codemod#scoped-jsx)

A long-time request is to remove the global `JSX` namespace from our types in favor of `React.JSX`. This helps prevent pollution of global types which prevents conflicts between different UI libraries that leverage JSX.

You’ll now need to wrap module augmentation of the JSX namespace in `declare module ”…”:

```
// global.d.ts

+ declare module "react" {

namespace JSX {

interface IntrinsicElements {

"my-element": {

myElementProps: string;

};

}

}

+ }
```

The exact module specifier depends on the JSX runtime you specified in the `compilerOptions` of your `tsconfig.json`:

* For `"jsx": "react-jsx"` it would be `react/jsx-runtime`.
* For `"jsx": "react-jsxdev"` it would be `react/jsx-dev-runtime`.
* For `"jsx": "react"` and `"jsx": "preserve"` it would be `react`.

### Better `useReducer` typings

`useReducer` now has improved type inference thanks to [@mfp22](https://github.com/mfp22).

However, this required a breaking change where `useReducer` doesn’t accept the full reducer type as a type parameter but instead either needs none (and rely on contextual typing) or needs both the state and action type.

The new best practice is *not* to pass type arguments to `useReducer`.

```
- useReducer<React.Reducer<State, Action>>(reducer)

+ useReducer(reducer)
```

This may not work in edge cases where you can explicitly type the state and action, by passing in the `Action` in a tuple:

```
- useReducer<React.Reducer<State, Action>>(reducer)

+ useReducer<State, [Action]>(reducer)
```

If you define the reducer inline, we encourage to annotate the function parameters instead:

```
- useReducer<React.Reducer<State, Action>>((state, action) => state)

+ useReducer((state: State, action: Action) => state)
```

This is also what you’d also have to do if you move the reducer outside of the `useReducer` call:

```
const reducer = (state: State, action: Action) => state;
```

## Changelog

### Other breaking changes

* **react-dom**: Error for javascript URLs in `src` and `href` [#26507](https://github.com/facebook/react/pull/26507)
* **react-dom**: Remove `errorInfo.digest` from `onRecoverableError` [#28222](https://github.com/facebook/react/pull/28222)
* **react-dom**: Remove `unstable_flushControlled` [#26397](https://github.com/facebook/react/pull/26397)
* **react-dom**: Remove `unstable_createEventHandle` [#28271](https://github.com/facebook/react/pull/28271)
* **react-dom**: Remove `unstable_renderSubtreeIntoContainer` [#28271](https://github.com/facebook/react/pull/28271)
* **react-dom**: Remove `unstable_runWithPriority` [#28271](https://github.com/facebook/react/pull/28271)
* **react-is**: Remove deprecated methods from `react-is` [28224](https://github.com/facebook/react/pull/28224)

### Other notable changes

* **react**: Batch sync, default and continuous lanes [#25700](https://github.com/facebook/react/pull/25700)
* **react**: Don’t prerender siblings of suspended component [#26380](https://github.com/facebook/react/pull/26380)
* **react**: Detect infinite update loops caused by render phase updates [#26625](https://github.com/facebook/react/pull/26625)
* **react-dom**: Transitions in popstate are now synchronous [#26025](https://github.com/facebook/react/pull/26025)
* **react-dom**: Remove layout effect warning during SSR [#26395](https://github.com/facebook/react/pull/26395)
* **react-dom**: Warn and don’t set empty string for src/href (except anchor tags) [#28124](https://github.com/facebook/react/pull/28124)

For a full list of changes, please see the [Changelog](https://github.com/facebook/react/blob/main/CHANGELOG.md#1900-december-5-2024).

---

Thanks to [Andrew Clark](https://twitter.com/acdlite), [Eli White](https://twitter.com/Eli_White), [Jack Pope](https://github.com/jackpope), [Jan Kassens](https://github.com/kassens), [Josh Story](https://twitter.com/joshcstory), [Matt Carroll](https://twitter.com/mattcarrollcode), [Noah Lemen](https://twitter.com/noahlemen), [Sophie Alpert](https://twitter.com/sophiebits), and [Sebastian Silbermann](https://twitter.com/sebsilbermann) for reviewing and editing this post.

[PreviousReact 19 RC](https://react.dev/blog/2024/04/25/react-19)[NextReact Labs: What We've Been Working On – February 2024](https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024)

---

---


# React Compiler Beta Release – React

URL: https://react.dev/blog/2024/10/21/react-compiler-beta-release

[Blog](https://react.dev/blog)

# React Compiler Beta Release

October 21, 2024 by [Lauren Tan](https://twitter.com/potetotes).

---

### Note

### React Compiler is now stable!

Please see the [stable release blog post](https://react.dev/blog/2025/10/07/react-compiler-1) for details.

The React team is excited to share new updates:

1. We’re publishing React Compiler Beta today, so that early adopters and library maintainers can try it and provide feedback.
2. We’re officially supporting React Compiler for apps on React 17+, through an optional `react-compiler-runtime` package.
3. We’re opening up public membership of the [React Compiler Working Group](https://github.com/reactwg/react-compiler) to prepare the community for gradual adoption of the compiler.

---

At [React Conf 2024](https://react.dev/blog/2024/05/22/react-conf-2024-recap), we announced the experimental release of React Compiler, a build-time tool that optimizes your React app through automatic memoization. [You can find an introduction to React Compiler here](https://react.dev/learn/react-compiler).

Since the first release, we’ve fixed numerous bugs reported by the React community, received several high quality bug fixes and contributions[1](https://react.dev/blog/2024/10/21/react-compiler-beta-release#user-content-fn-1) to the compiler, made the compiler more resilient to the broad diversity of JavaScript patterns, and have continued to roll out the compiler more widely at Meta.

In this post, we want to share what’s next for React Compiler.

## Try React Compiler Beta today

At [React India 2024](https://www.youtube.com/watch?v=qd5yk2gxbtg), we shared an update on React Compiler. Today, we are excited to announce a new Beta release of React Compiler and ESLint plugin. New betas are published to npm using the `@beta` tag.

To install React Compiler Beta:

Terminal

Copy

```
npm install -D babel-plugin-react-compiler@beta eslint-plugin-react-compiler@beta
```

Or, if you’re using Yarn:

Terminal

Copy

```
yarn add -D babel-plugin-react-compiler@beta eslint-plugin-react-compiler@beta
```

You can watch [Sathya Gunasekaran’s](https://twitter.com/_gsathya) talk at React India here:

## We recommend everyone use the React Compiler linter today

React Compiler’s ESLint plugin helps developers proactively identify and correct [Rules of React](https://react.dev/reference/rules) violations. **We strongly recommend everyone use the linter today**. The linter does not require that you have the compiler installed, so you can use it independently, even if you are not ready to try out the compiler.

To install the linter only:

Terminal

Copy

```
npm install -D eslint-plugin-react-compiler@beta
```

Or, if you’re using Yarn:

Terminal

Copy

```
yarn add -D eslint-plugin-react-compiler@beta
```

After installation you can enable the linter by [adding it to your ESLint config](https://react.dev/learn/react-compiler/installation#eslint-integration). Using the linter helps identify Rules of React breakages, making it easier to adopt the compiler when it’s fully released.

## Backwards Compatibility

React Compiler produces code that depends on runtime APIs added in React 19, but we’ve since added support for the compiler to also work with React 17 and 18. If you are not on React 19 yet, in the Beta release you can now try out React Compiler by specifying a minimum `target` in your compiler config, and adding `react-compiler-runtime` as a dependency. [You can find docs on this here](https://react.dev/reference/react-compiler/configuration#react-17-18).

## Using React Compiler in libraries

Our initial release was focused on identifying major issues with using the compiler in applications. We’ve gotten great feedback and have substantially improved the compiler since then. We’re now ready for broad feedback from the community, and for library authors to try out the compiler to improve performance and the developer experience of maintaining your library.

React Compiler can also be used to compile libraries. Because React Compiler needs to run on the original source code prior to any code transformations, it is not possible for an application’s build pipeline to compile the libraries they use. Hence, our recommendation is for library maintainers to independently compile and test their libraries with the compiler, and ship compiled code to npm.

Because your code is pre-compiled, users of your library will not need to have the compiler enabled in order to benefit from the automatic memoization applied to your library. If your library targets apps not yet on React 19, specify a minimum `target` and add `react-compiler-runtime` as a direct dependency. The runtime package will use the correct implementation of APIs depending on the application’s version, and polyfill the missing APIs if necessary.

[You can find more docs on this here.](https://react.dev/reference/react-compiler/compiling-libraries)

## Opening up React Compiler Working Group to everyone

We previously announced the invite-only [React Compiler Working Group](https://github.com/reactwg/react-compiler) at React Conf to provide feedback, ask questions, and collaborate on the compiler’s experimental release.

From today, together with the Beta release of React Compiler, we are opening up Working Group membership to everyone. The goal of the React Compiler Working Group is to prepare the ecosystem for a smooth, gradual adoption of React Compiler by existing applications and libraries. Please continue to file bug reports in the [React repo](https://github.com/facebook/react), but please leave feedback, ask questions, or share ideas in the [Working Group discussion forum](https://github.com/reactwg/react-compiler/discussions).

The core team will also use the discussions repo to share our research findings. As the Stable Release gets closer, any important information will also be posted on this forum.

## React Compiler at Meta

At [React Conf](https://react.dev/blog/2024/05/22/react-conf-2024-recap), we shared that our rollout of the compiler on Quest Store and Instagram were successful. Since then, we’ve deployed React Compiler across several more major web apps at Meta, including [Facebook](https://www.facebook.com) and [Threads](https://www.threads.net). That means if you’ve used any of these apps recently, you may have had your experience powered by the compiler. We were able to onboard these apps onto the compiler with few code changes required, in a monorepo with more than 100,000 React components.

We’ve seen notable performance improvements across all of these apps. As we’ve rolled out, we’re continuing to see results on the order of [the wins we shared previously at ReactConf](https://youtu.be/lyEKhv8-3n0?t=3223). These apps have already been heavily hand tuned and optimized by Meta engineers and React experts over the years, so even improvements on the order of a few percent are a huge win for us.

We also expected developer productivity wins from React Compiler. To measure this, we collaborated with our data science partners at Meta[2](https://react.dev/blog/2024/10/21/react-compiler-beta-release#user-content-fn-2) to conduct a thorough statistical analysis of the impact of manual memoization on productivity. Before rolling out the compiler at Meta, we discovered that only about 8% of React pull requests used manual memoization and that these pull requests took 31-46% longer to author[3](https://react.dev/blog/2024/10/21/react-compiler-beta-release#user-content-fn-3). This confirmed our intuition that manual memoization introduces cognitive overhead, and we anticipate that React Compiler will lead to more efficient code authoring and review. Notably, React Compiler also ensures that *all* code is memoized by default, not just the (in our case) 8% where developers explicitly apply memoization.

## Roadmap to Stable

*This is not a final roadmap, and is subject to change.*

We intend to ship a Release Candidate of the compiler in the near future following the Beta release, when the majority of apps and libraries that follow the Rules of React have been proven to work well with the compiler. After a period of final feedback from the community, we plan on a Stable Release for the compiler. The Stable Release will mark the beginning of a new foundation for React, and all apps and libraries will be strongly recommended to use the compiler and ESLint plugin.

* ✅ Experimental: Released at React Conf 2024, primarily for feedback from early adopters.
* ✅ Public Beta: Available today, for feedback from the wider community.
* 🚧 Release Candidate (RC): React Compiler works for the majority of rule-following apps and libraries without issue.
* 🚧 General Availability: After final feedback period from the community.

These releases also include the compiler’s ESLint plugin, which surfaces diagnostics statically analyzed by the compiler. We plan to combine the existing eslint-plugin-react-hooks plugin with the compiler’s ESLint plugin, so only one plugin needs to be installed.

Post-Stable, we plan to add more compiler optimizations and improvements. This includes both continual improvements to automatic memoization, and new optimizations altogether, with minimal to no change of product code. Upgrading to each new release of the compiler is aimed to be straightforward, and each upgrade will continue to improve performance and add better handling of diverse JavaScript and React patterns.

Throughout this process, we also plan to prototype an IDE extension for React. It is still very early in research, so we expect to be able to share more of our findings with you in a future React Labs blog post.

---

Thanks to [Sathya Gunasekaran](https://twitter.com/_gsathya), [Joe Savona](https://twitter.com/en_JS), [Ricky Hanlon](https://twitter.com/rickhanlonii), [Alex Taylor](https://github.com/alexmckenley), [Jason Bonta](https://twitter.com/someextent), and [Eli White](https://twitter.com/Eli_White) for reviewing and editing this post.

---

## Footnotes

1. Thanks [@nikeee](https://github.com/facebook/react/pulls?q=is%3Apr+author%3Anikeee), [@henryqdineen](https://github.com/facebook/react/pulls?q=is%3Apr+author%3Ahenryqdineen), [@TrickyPi](https://github.com/facebook/react/pulls?q=is%3Apr+author%3ATrickyPi), and several others for their contributions to the compiler. [↩](https://react.dev/blog/2024/10/21/react-compiler-beta-release#user-content-fnref-1)
2. Thanks [Vaishali Garg](https://www.linkedin.com/in/vaishaligarg09) for leading this study on React Compiler at Meta, and for reviewing this post. [↩](https://react.dev/blog/2024/10/21/react-compiler-beta-release#user-content-fnref-2)
3. After controlling on author tenure, diff length/complexity, and other potential confounding factors. [↩](https://react.dev/blog/2024/10/21/react-compiler-beta-release#user-content-fnref-3)

[PreviousReact 19](https://react.dev/blog/2024/12/05/react-19)[NextReact Conf 2024 Recap](https://react.dev/blog/2024/05/22/react-conf-2024-recap)

---

---


# React 19.2 – React

URL: https://react.dev/blog/2025/10/01/react-19-2

[Blog](https://react.dev/blog)

# React 19.2

October 1, 2025 by [The React Team](https://react.dev/community/team)

---

React 19.2 is now available on npm!

This is our third release in the last year, following React 19 in December and React 19.1 in June. In this post, we’ll give an overview of the new features in React 19.2, and highlight some notable changes.

* [New React Features](https://react.dev/blog/2025/10/01/react-19-2#new-react-features) 
  + [`<Activity />`](https://react.dev/blog/2025/10/01/react-19-2#activity)
  + [`useEffectEvent`](https://react.dev/blog/2025/10/01/react-19-2#use-effect-event)
  + [`cacheSignal`](https://react.dev/blog/2025/10/01/react-19-2#cache-signal)
  + [Performance Tracks](https://react.dev/blog/2025/10/01/react-19-2#performance-tracks)
* [New React DOM Features](https://react.dev/blog/2025/10/01/react-19-2#new-react-dom-features) 
  + [Partial Pre-rendering](https://react.dev/blog/2025/10/01/react-19-2#partial-pre-rendering)
* [Notable Changes](https://react.dev/blog/2025/10/01/react-19-2#notable-changes) 
  + [Batching Suspense Boundaries for SSR](https://react.dev/blog/2025/10/01/react-19-2#batching-suspense-boundaries-for-ssr)
  + [SSR: Web Streams support for Node](https://react.dev/blog/2025/10/01/react-19-2#ssr-web-streams-support-for-node)
  + [`eslint-plugin-react-hooks` v6](https://react.dev/blog/2025/10/01/react-19-2#eslint-plugin-react-hooks)
  + [Update the default `useId` prefix](https://react.dev/blog/2025/10/01/react-19-2#update-the-default-useid-prefix)
* [Changelog](https://react.dev/blog/2025/10/01/react-19-2#changelog)

---

## New React Features

### `<Activity />`

`<Activity>` lets you break your app into “activities” that can be controlled and prioritized.

You can use Activity as an alternative to conditionally rendering parts of your app:

```
// Before

{isVisible && <Page />}

// After

<Activity mode={isVisible ? 'visible' : 'hidden'}>

<Page />

</Activity>
```

In React 19.2, Activity supports two modes: `visible` and `hidden`.

* `hidden`: hides the children, unmounts effects, and defers all updates until React has nothing left to work on.
* `visible`: shows the children, mounts effects, and allows updates to be processed normally.

This means you can pre-render and keep rendering hidden parts of the app without impacting the performance of anything visible on screen.

You can use Activity to render hidden parts of the app that a user is likely to navigate to next, or to save the state of parts the user navigates away from. This helps make navigations quicker by loading data, css, and images in the background, and allows back navigations to maintain state such as input fields.

In the future, we plan to add more modes to Activity for different use cases.

For examples on how to use Activity, check out the [Activity docs](https://react.dev/reference/react/Activity).

---

### `useEffectEvent`

One common pattern with `useEffect` is to notify the app code about some kind of “events” from an external system. For example, when a chat room gets connected, you might want to display a notification:

```
function ChatRoom({ roomId, theme }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.on('connected', () => {

showNotification('Connected!', theme);

});

connection.connect();

return () => {

connection.disconnect()

};

}, [roomId, theme]);

// ...
```

The problem with the code above is that a change to any values used inside such an “event” will cause the surrounding Effect to re-run. For example, changing the `theme` will cause the chat room to reconnect. This makes sense for values related to the Effect logic itself, like `roomId`, but it doesn’t make sense for `theme`.

To solve this, most users just disable the lint rule and exclude the dependency. But that can lead to bugs since the linter can no longer help you keep the dependencies up to date if you need to update the Effect later.

With `useEffectEvent`, you can split the “event” part of this logic out of the Effect that emits it:

```
function ChatRoom({ roomId, theme }) {

const onConnected = useEffectEvent(() => {

showNotification('Connected!', theme);

});

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.on('connected', () => {

onConnected();

});

connection.connect();

return () => connection.disconnect();

}, [roomId]); // ✅ All dependencies declared (Effect Events aren't dependencies)

// ...
```

Similar to DOM events, Effect Events always “see” the latest props and state.

**Effect Events should *not* be declared in the dependency array**. You’ll need to upgrade to `eslint-plugin-react-hooks@latest` so that the linter doesn’t try to insert them as dependencies. Note that Effect Events can only be declared in the same component or Hook as “their” Effect. These restrictions are verified by the linter.

### Note

#### When to use `useEffectEvent`

You should use `useEffectEvent` for functions that are conceptually “events” that happen to be fired from an Effect instead of a user event (that’s what makes it an “Effect Event”). You don’t need to wrap everything in `useEffectEvent`, or to use it just to silence the lint error, as this can lead to bugs.

For a deep dive on how to think about Event Effects, see: [Separating Events from Effects](https://react.dev/learn/separating-events-from-effects#extracting-non-reactive-logic-out-of-effects).

---

### `cacheSignal`

### React Server Components

`cacheSignal` is only for use with [React Server Components](https://react.dev/reference/rsc/server-components).

`cacheSignal` allows you to know when the [`cache()`](https://react.dev/reference/react/cache) lifetime is over:

```
import {cache, cacheSignal} from 'react';

const dedupedFetch = cache(fetch);

async function Component() {

await dedupedFetch(url, { signal: cacheSignal() });

}
```

This allows you to clean up or abort work when the result will no longer be used in the cache, such as:

* React has successfully completed rendering
* The render was aborted
* The render has failed

For more info, see the [`cacheSignal` docs](https://react.dev/reference/react/cacheSignal).

---

### Performance Tracks

React 19.2 adds a new set of [custom tracks](https://developer.chrome.com/docs/devtools/performance/extension) to Chrome DevTools performance profiles to provide more information about the performance of your React app:

![](https://react.dev/images/blog/react-labs-april-2025/perf_tracks.webp)![](https://react.dev/images/blog/react-labs-april-2025/perf_tracks_dark.webp)

The [React Performance Tracks docs](https://react.dev/reference/dev-tools/react-performance-tracks) explain everything included in the tracks, but here is a high-level overview.

#### Scheduler ⚛

The Scheduler track shows what React is working on for different priorities such as “blocking” for user interactions, or “transition” for updates inside startTransition. Inside each track, you will see the type of work being performed such as the event that scheduled an update, and when the render for that update happened.

We also show information such as when an update is blocked waiting for a different priority, or when React is waiting for paint before continuing. The Scheduler track helps you understand how React splits your code into different priorities, and the order it completed the work.

See the [Scheduler track](https://react.dev/reference/dev-tools/react-performance-tracks#scheduler) docs to see everything included.

#### Components ⚛

The Components track shows the tree of components that React is working on either to render or run effects. Inside you’ll see labels such as “Mount” for when children mount or effects are mounted, or “Blocked” for when rendering is blocked due to yielding to work outside React.

The Components track helps you understand when components are rendered or run effects, and the time it takes to complete that work to help identify performance problems.

See the [Components track docs](https://react.dev/reference/dev-tools/react-performance-tracks#components) for see everything included.

---

## New React DOM Features

### Partial Pre-rendering

In 19.2 we’re adding a new capability to pre-render part of the app ahead of time, and resume rendering it later.

This feature is called “Partial Pre-rendering”, and allows you to pre-render the static parts of your app and serve it from a CDN, and then resume rendering the shell to fill it in with dynamic content later.

To pre-render an app to resume later, first call `prerender` with an `AbortController`:

```
const {prelude, postponed} = await prerender(<App />, {

signal: controller.signal,

});

// Save the postponed state for later

await savePostponedState(postponed);

// Send prelude to client or CDN.
```

Then, you can return the `prelude` shell to the client, and later call `resume` to “resume” to a SSR stream:

```
const postponed = await getPostponedState(request);

const resumeStream = await resume(<App />, postponed);

// Send stream to client.
```

Or you can call `resumeAndPrerender` to resume to get static HTML for SSG:

```
const postponedState = await getPostponedState(request);

const { prelude } = await resumeAndPrerender(<App />, postponedState);

// Send complete HTML prelude to CDN.
```

For more info, see the docs for the new APIs:

* `react-dom/server`
  + [`resume`](https://react.dev/reference/react-dom/server/resume): for Web Streams.
  + [`resumeToPipeableStream`](https://react.dev/reference/react-dom/server/resumeToPipeableStream) for Node Streams.
* `react-dom/static`
  + [`resumeAndPrerender`](https://react.dev/reference/react-dom/static/resumeAndPrerender) for Web Streams.
  + [`resumeAndPrerenderToNodeStream`](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream) for Node Streams.

Additionally, the prerender apis now return a `postpone` state to pass to the `resume` apis.

---

## Notable Changes

### Batching Suspense Boundaries for SSR

We fixed a behavioral bug where Suspense boundaries would reveal differently depending on if they were rendered on the client or when streaming from server-side rendering.

Starting in 19.2, React will batch reveals of server-rendered Suspense boundaries for a short time, to allow more content to be revealed together and align with the client-rendered behavior.

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a page rectangle showing a glimmer loading state with faded bars. The second panel shows the top half of the page revealed and highlighted in blue. The third panel shows the entire the page revealed and highlighted in blue.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2F19_2_batching_before.dark.png&w=3840&q=75)

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a page rectangle showing a glimmer loading state with faded bars. The second panel shows the top half of the page revealed and highlighted in blue. The third panel shows the entire the page revealed and highlighted in blue.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2F19_2_batching_before.png&w=3840&q=75)

Previously, during streaming server-side rendering, suspense content would immediately replace fallbacks.

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a page rectangle showing a glimmer loading state with faded bars. The second panel shows the same page. The third panel shows the entire the page revealed and highlighted in blue.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2F19_2_batching_after.dark.png&w=3840&q=75)

![Diagram with three sections, with an arrow transitioning each section in between. The first section contains a page rectangle showing a glimmer loading state with faded bars. The second panel shows the same page. The third panel shows the entire the page revealed and highlighted in blue.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2F19_2_batching_after.png&w=3840&q=75)

In React 19.2, suspense boundaries are batched for a small amount of time, to allow revealing more content together.

This fix also prepares apps for supporting `<ViewTransition>` for Suspense during SSR. By revealing more content together, animations can run in larger batches of content, and avoid chaining animations of content that stream in close together.

### Note

React uses heuristics to ensure throttling does not impact core web vitals and search ranking.

For example, if the total page load time is approaching 2.5s (which is the time considered “good” for [LCP](https://web.dev/articles/lcp)), React will stop batching and reveal content immediately so that the throttling is not the reason to miss the metric.

---

### SSR: Web Streams support for Node

React 19.2 adds support for Web Streams for streaming SSR in Node.js:

* [`renderToReadableStream`](https://react.dev/reference/react-dom/server/renderToReadableStream) is now available for Node.js
* [`prerender`](https://react.dev/reference/react-dom/static/prerender) is now available for Node.js

As well as the new `resume` APIs:

* [`resume`](https://react.dev/reference/react-dom/server/resume) is available for Node.js.
* [`resumeAndPrerender`](https://react.dev/reference/react-dom/static/resumeAndPrerender) is available for Node.js.

### Pitfall

#### Prefer Node Streams for server-side rendering in Node.js

In Node.js environments, we still highly recommend using the Node Streams APIs:

* [`renderToPipeableStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream)
* [`resumeToPipeableStream`](https://react.dev/reference/react-dom/server/resumeToPipeableStream)
* [`prerenderToNodeStream`](https://react.dev/reference/react-dom/static/prerenderToNodeStream)
* [`resumeAndPrerenderToNodeStream`](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream)

This is because Node Streams are much faster than Web Streams in Node, and Web Streams do not support compression by default, leading to users accidentally missing the benefits of streaming.

---

### `eslint-plugin-react-hooks` v6

We also published `eslint-plugin-react-hooks@latest` with flat config by default in the `recommended` preset, and opt-in for new React Compiler powered rules.

To continue using the legacy config, you can change to `recommended-legacy`:

```
- extends: ['plugin:react-hooks/recommended']

+ extends: ['plugin:react-hooks/recommended-legacy']
```

For a full list of compiler enabled rules, [check out the linter docs](https://react.dev/reference/eslint-plugin-react-hooks#recommended).

Check out the `eslint-plugin-react-hooks` [changelog for a full list of changes](https://github.com/facebook/react/blob/main/packages/eslint-plugin-react-hooks/CHANGELOG.md#610).

---

### Update the default `useId` prefix

In 19.2, we’re updating the default `useId` prefix from `:r:` (19.0.0) or `«r»` (19.1.0) to `_r_`.

The original intent of using a special character that was not valid for CSS selectors was that it would be unlikely to collide with IDs written by users. However, to support View Transitions, we need to ensure that IDs generated by `useId` are valid for `view-transition-name` and XML 1.0 names.

---

## Changelog

Other notable changes

* `react-dom`: Allow nonce to be used on hoistable styles [#32461](https://github.com/facebook/react/pull/32461)
* `react-dom`: Warn for using a React owned node as a Container if it also has text content [#32774](https://github.com/facebook/react/pull/32774)

Notable bug fixes

* `react`: Stringify context as “SomeContext” instead of “SomeContext.Provider” [#33507](https://github.com/facebook/react/pull/33507)
* `react`: Fix infinite useDeferredValue loop in popstate event [#32821](https://github.com/facebook/react/pull/32821)
* `react`: Fix a bug when an initial value was passed to useDeferredValue [#34376](https://github.com/facebook/react/pull/34376)
* `react`: Fix a crash when submitting forms with Client Actions [#33055](https://github.com/facebook/react/pull/33055)
* `react`: Hide/unhide the content of dehydrated suspense boundaries if they resuspend [#32900](https://github.com/facebook/react/pull/32900)
* `react`: Avoid stack overflow on wide trees during Hot Reload [#34145](https://github.com/facebook/react/pull/34145)
* `react`: Improve component stacks in various places [#33629](https://github.com/facebook/react/pull/33629), [#33724](https://github.com/facebook/react/pull/33724), [#32735](https://github.com/facebook/react/pull/32735), [#33723](https://github.com/facebook/react/pull/33723)
* `react`: Fix a bug with React.use inside React.lazy-ed Component [#33941](https://github.com/facebook/react/pull/33941)
* `react-dom`: Stop warning when ARIA 1.3 attributes are used [#34264](https://github.com/facebook/react/pull/34264)
* `react-dom`: Fix a bug with deeply nested Suspense inside Suspense fallbacks [#33467](https://github.com/facebook/react/pull/33467)
* `react-dom`: Avoid hanging when suspending after aborting while rendering [#34192](https://github.com/facebook/react/pull/34192)

For a full list of changes, please see the [Changelog](https://github.com/facebook/react/blob/main/CHANGELOG.md).

---

*Thanks to [Ricky Hanlon](https://bsky.app/profile/ricky.fm) for [writing this post](https://www.youtube.com/shorts/T9X3YkgZRG0), [Dan Abramov](https://bsky.app/profile/danabra.mov), [Matt Carroll](https://twitter.com/mattcarrollcode), [Jack Pope](https://jackpope.me), and [Joe Savona](https://x.com/en_JS) for reviewing this post.*

[PreviousIntroducing the React Foundation](https://react.dev/blog/2025/10/07/introducing-the-react-foundation)[NextReact Labs: View Transitions, Activity, and more](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more)

---

---


# React v18.0 – React

URL: https://react.dev/blog/2022/03/29/react-v18

[Blog](https://react.dev/blog)

# React v18.0

March 29, 2022 by [The React Team](https://react.dev/community/team)

---

React 18 is now available on npm! In our last post, we shared step-by-step instructions for [upgrading your app to React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide). In this post, we’ll give an overview of what’s new in React 18, and what it means for the future.

---

Our latest major version includes out-of-the-box improvements like automatic batching, new APIs like startTransition, and streaming server-side rendering with support for Suspense.

Many of the features in React 18 are built on top of our new concurrent renderer, a behind-the-scenes change that unlocks powerful new capabilities. Concurrent React is opt-in — it’s only enabled when you use a concurrent feature — but we think it will have a big impact on the way people build applications.

We’ve spent years researching and developing support for concurrency in React, and we’ve taken extra care to provide a gradual adoption path for existing users. Last summer, [we formed the React 18 Working Group](https://react.dev/blog/2021/06/08/the-plan-for-react-18) to gather feedback from experts in the community and ensure a smooth upgrade experience for the entire React ecosystem.

In case you missed it, we shared a lot of this vision at React Conf 2021:

* In [the keynote](https://www.youtube.com/watch?v=FZ0cG47msEk&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa), we explain how React 18 fits into our mission to make it easy for developers to build great user experiences
* [Shruti Kapoor](https://twitter.com/shrutikapoor08) [demonstrated how to use the new features in React 18](https://www.youtube.com/watch?v=ytudH8je5ko&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=2)
* [Shaundai Person](https://twitter.com/shaundai) gave us an overview of [streaming server rendering with Suspense](https://www.youtube.com/watch?v=pj5N-Khihgc&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa&index=3)

Below is a full overview of what to expect in this release, starting with Concurrent Rendering.

### Note

For React Native users, React 18 will ship in React Native with the New React Native Architecture. For more information, see the [React Conf keynote here](https://www.youtube.com/watch?v=FZ0cG47msEk&t=1530s).

## What is Concurrent React?

The most important addition in React 18 is something we hope you never have to think about: concurrency. We think this is largely true for application developers, though the story may be a bit more complicated for library maintainers.

Concurrency is not a feature, per se. It’s a new behind-the-scenes mechanism that enables React to prepare multiple versions of your UI at the same time. You can think of concurrency as an implementation detail — it’s valuable because of the features that it unlocks. React uses sophisticated techniques in its internal implementation, like priority queues and multiple buffering. But you won’t see those concepts anywhere in our public APIs.

When we design APIs, we try to hide implementation details from developers. As a React developer, you focus on *what* you want the user experience to look like, and React handles *how* to deliver that experience. So we don’t expect React developers to know how concurrency works under the hood.

However, Concurrent React is more important than a typical implementation detail — it’s a foundational update to React’s core rendering model. So while it’s not super important to know how concurrency works, it may be worth knowing what it is at a high level.

A key property of Concurrent React is that rendering is interruptible. When you first upgrade to React 18, before adding any concurrent features, updates are rendered the same as in previous versions of React — in a single, uninterrupted, synchronous transaction. With synchronous rendering, once an update starts rendering, nothing can interrupt it until the user can see the result on screen.

In a concurrent render, this is not always the case. React may start rendering an update, pause in the middle, then continue later. It may even abandon an in-progress render altogether. React guarantees that the UI will appear consistent even if a render is interrupted. To do this, it waits to perform DOM mutations until the end, once the entire tree has been evaluated. With this capability, React can prepare new screens in the background without blocking the main thread. This means the UI can respond immediately to user input even if it’s in the middle of a large rendering task, creating a fluid user experience.

Another example is reusable state. Concurrent React can remove sections of the UI from the screen, then add them back later while reusing the previous state. For example, when a user tabs away from a screen and back, React should be able to restore the previous screen in the same state it was in before. In an upcoming minor, we’re planning to add a new component called `<Offscreen>` that implements this pattern. Similarly, you’ll be able to use Offscreen to prepare new UI in the background so that it’s ready before the user reveals it.

Concurrent rendering is a powerful new tool in React and most of our new features are built to take advantage of it, including Suspense, transitions, and streaming server rendering. But React 18 is just the beginning of what we aim to build on this new foundation.

## Gradually Adopting Concurrent Features

Technically, concurrent rendering is a breaking change. Because concurrent rendering is interruptible, components behave slightly differently when it is enabled.

In our testing, we’ve upgraded thousands of components to React 18. What we’ve found is that nearly all existing components “just work” with concurrent rendering, without any changes. However, some of them may require some additional migration effort. Although the changes are usually small, you’ll still have the ability to make them at your own pace. The new rendering behavior in React 18 is **only enabled in the parts of your app that use new features.**

The overall upgrade strategy is to get your application running on React 18 without breaking existing code. Then you can gradually start adding concurrent features at your own pace. You can use [`<StrictMode>`](https://react.dev/reference/react/StrictMode) to help surface concurrency-related bugs during development. Strict Mode doesn’t affect production behavior, but during development it will log extra warnings and double-invoke functions that are expected to be idempotent. It won’t catch everything, but it’s effective at preventing the most common types of mistakes.

After you upgrade to React 18, you’ll be able to start using concurrent features immediately. For example, you can use startTransition to navigate between screens without blocking user input. Or useDeferredValue to throttle expensive re-renders.

However, long term, we expect the main way you’ll add concurrency to your app is by using a concurrent-enabled library or framework. In most cases, you won’t interact with concurrent APIs directly. For example, instead of developers calling startTransition whenever they navigate to a new screen, router libraries will automatically wrap navigations in startTransition.

It may take some time for libraries to upgrade to be concurrent compatible. We’ve provided new APIs to make it easier for libraries to take advantage of concurrent features. In the meantime, please be patient with maintainers as we work to gradually migrate the React ecosystem.

For more info, see our previous post: [How to upgrade to React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide).

## Suspense in Data Frameworks

In React 18, you can start using [Suspense](https://react.dev/reference/react/Suspense) for data fetching in opinionated frameworks like Relay, Next.js, Hydrogen, or Remix. Ad hoc data fetching with Suspense is technically possible, but still not recommended as a general strategy.

In the future, we may expose additional primitives that could make it easier to access your data with Suspense, perhaps without the use of an opinionated framework. However, Suspense works best when it’s deeply integrated into your application’s architecture: your router, your data layer, and your server rendering environment. So even long term, we expect that libraries and frameworks will play a crucial role in the React ecosystem.

As in previous versions of React, you can also use Suspense for code splitting on the client with React.lazy. But our vision for Suspense has always been about much more than loading code — the goal is to extend support for Suspense so that eventually, the same declarative Suspense fallback can handle any asynchronous operation (loading code, data, images, etc).

## Server Components is Still in Development

[**Server Components**](https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components) is an upcoming feature that allows developers to build apps that span the server and client, combining the rich interactivity of client-side apps with the improved performance of traditional server rendering. Server Components is not inherently coupled to Concurrent React, but it’s designed to work best with concurrent features like Suspense and streaming server rendering.

Server Components is still experimental, but we expect to release an initial version in a minor 18.x release. In the meantime, we’re working with frameworks like Next.js, Hydrogen, and Remix to advance the proposal and get it ready for broad adoption.

## What’s New in React 18

### New Feature: Automatic Batching

Batching is when React groups multiple state updates into a single re-render for better performance. Without automatic batching, we only batched updates inside React event handlers. Updates inside of promises, setTimeout, native event handlers, or any other event were not batched in React by default. With automatic batching, these updates will be batched automatically:

```
// Before: only React events were batched.

setTimeout(() => {

setCount(c => c + 1);

setFlag(f => !f);

// React will render twice, once for each state update (no batching)

}, 1000);

// After: updates inside of timeouts, promises,

// native event handlers or any other event are batched.

setTimeout(() => {

setCount(c => c + 1);

setFlag(f => !f);

// React will only re-render once at the end (that's batching!)

}, 1000);
```

For more info, see this post for [Automatic batching for fewer renders in React 18](https://github.com/reactwg/react-18/discussions/21).

### New Feature: Transitions

A transition is a new concept in React to distinguish between urgent and non-urgent updates.

* **Urgent updates** reflect direct interaction, like typing, clicking, pressing, and so on.
* **Transition updates** transition the UI from one view to another.

Urgent updates like typing, clicking, or pressing, need immediate response to match our intuitions about how physical objects behave. Otherwise they feel “wrong”. However, transitions are different because the user doesn’t expect to see every intermediate value on screen.

For example, when you select a filter in a dropdown, you expect the filter button itself to respond immediately when you click. However, the actual results may transition separately. A small delay would be imperceptible and often expected. And if you change the filter again before the results are done rendering, you only care to see the latest results.

Typically, for the best user experience, a single user input should result in both an urgent update and a non-urgent one. You can use startTransition API inside an input event to inform React which updates are urgent and which are “transitions”:

```
import { startTransition } from 'react';

// Urgent: Show what was typed

setInputValue(input);

// Mark any state updates inside as transitions

startTransition(() => {

// Transition: Show the results

setSearchQuery(input);

});
```

Updates wrapped in startTransition are handled as non-urgent and will be interrupted if more urgent updates like clicks or key presses come in. If a transition gets interrupted by the user (for example, by typing multiple characters in a row), React will throw out the stale rendering work that wasn’t finished and render only the latest update.

* `useTransition`: a Hook to start transitions, including a value to track the pending state.
* `startTransition`: a method to start transitions when the Hook cannot be used.

Transitions will opt in to concurrent rendering, which allows the update to be interrupted. If the content re-suspends, transitions also tell React to continue showing the current content while rendering the transition content in the background (see the [Suspense RFC](https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md) for more info).

[See docs for transitions here](https://react.dev/reference/react/useTransition).

### New Suspense Features

Suspense lets you declaratively specify the loading state for a part of the component tree if it’s not yet ready to be displayed:

```
<Suspense fallback={<Spinner />}>

<Comments />

</Suspense>
```

Suspense makes the “UI loading state” a first-class declarative concept in the React programming model. This lets us build higher-level features on top of it.

We introduced a limited version of Suspense several years ago. However, the only supported use case was code splitting with React.lazy, and it wasn’t supported at all when rendering on the server.

In React 18, we’ve added support for Suspense on the server and expanded its capabilities using concurrent rendering features.

Suspense in React 18 works best when combined with the transition API. If you suspend during a transition, React will prevent already-visible content from being replaced by a fallback. Instead, React will delay the render until enough data has loaded to prevent a bad loading state.

For more, see the RFC for [Suspense in React 18](https://github.com/reactjs/rfcs/blob/main/text/0213-suspense-in-react-18.md).

### New Client and Server Rendering APIs

In this release we took the opportunity to redesign the APIs we expose for rendering on the client and server. These changes allow users to continue using the old APIs in React 17 mode while they upgrade to the new APIs in React 18.

#### React DOM Client

These new APIs are now exported from `react-dom/client`:

* `createRoot`: New method to create a root to `render` or `unmount`. Use it instead of `ReactDOM.render`. New features in React 18 don’t work without it.
* `hydrateRoot`: New method to hydrate a server rendered application. Use it instead of `ReactDOM.hydrate` in conjunction with the new React DOM Server APIs. New features in React 18 don’t work without it.

Both `createRoot` and `hydrateRoot` accept a new option called `onRecoverableError` in case you want to be notified when React recovers from errors during rendering or hydration for logging. By default, React will use [`reportError`](https://developer.mozilla.org/en-US/docs/Web/API/reportError), or `console.error` in the older browsers.

[See docs for React DOM Client here](https://react.dev/reference/react-dom/client).

#### React DOM Server

These new APIs are now exported from `react-dom/server` and have full support for streaming Suspense on the server:

* `renderToPipeableStream`: for streaming in Node environments.
* `renderToReadableStream`: for modern edge runtime environments, such as Deno and Cloudflare workers.

The existing `renderToString` method keeps working but is discouraged.

[See docs for React DOM Server here](https://react.dev/reference/react-dom/server).

### New Strict Mode Behaviors

In the future, we’d like to add a feature that allows React to add and remove sections of the UI while preserving state. For example, when a user tabs away from a screen and back, React should be able to immediately show the previous screen. To do this, React would unmount and remount trees using the same component state as before.

This feature will give React apps better performance out-of-the-box, but requires components to be resilient to effects being mounted and destroyed multiple times. Most effects will work without any changes, but some effects assume they are only mounted or destroyed once.

To help surface these issues, React 18 introduces a new development-only check to Strict Mode. This new check will automatically unmount and remount every component, whenever a component mounts for the first time, restoring the previous state on the second mount.

Before this change, React would mount the component and create the effects:

```
* React mounts the component.

* Layout effects are created.

* Effects are created.
```

With Strict Mode in React 18, React will simulate unmounting and remounting the component in development mode:

```
* React mounts the component.

* Layout effects are created.

* Effects are created.

* React simulates unmounting the component.

* Layout effects are destroyed.

* Effects are destroyed.

* React simulates mounting the component with the previous state.

* Layout effects are created.

* Effects are created.
```

[See docs for ensuring reusable state here](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-re-running-effects-in-development).

### New Hooks

#### useId

`useId` is a new Hook for generating unique IDs on both the client and server, while avoiding hydration mismatches. It is primarily useful for component libraries integrating with accessibility APIs that require unique IDs. This solves an issue that already exists in React 17 and below, but it’s even more important in React 18 because of how the new streaming server renderer delivers HTML out-of-order. [See docs here](https://react.dev/reference/react/useId).

> Note
>
> `useId` is **not** for generating [keys in a list](https://react.dev/learn/rendering-lists#where-to-get-your-key). Keys should be generated from your data.

#### useTransition

`useTransition` and `startTransition` let you mark some state updates as not urgent. Other state updates are considered urgent by default. React will allow urgent state updates (for example, updating a text input) to interrupt non-urgent state updates (for example, rendering a list of search results). [See docs here](https://react.dev/reference/react/useTransition).

#### useDeferredValue

`useDeferredValue` lets you defer re-rendering a non-urgent part of the tree. It is similar to debouncing, but has a few advantages compared to it. There is no fixed time delay, so React will attempt the deferred render right after the first render is reflected on the screen. The deferred render is interruptible and doesn’t block user input. [See docs here](https://react.dev/reference/react/useDeferredValue).

#### useSyncExternalStore

`useSyncExternalStore` is a new Hook that allows external stores to support concurrent reads by forcing updates to the store to be synchronous. It removes the need for useEffect when implementing subscriptions to external data sources, and is recommended for any library that integrates with state external to React. [See docs here](https://react.dev/reference/react/useSyncExternalStore).

> Note
>
> `useSyncExternalStore` is intended to be used by libraries, not application code.

#### useInsertionEffect

`useInsertionEffect` is a new Hook that allows CSS-in-JS libraries to address performance issues of injecting styles in render. Unless you’ve already built a CSS-in-JS library we don’t expect you to ever use this. This Hook will run after the DOM is mutated, but before layout effects read the new layout. This solves an issue that already exists in React 17 and below, but is even more important in React 18 because React yields to the browser during concurrent rendering, giving it a chance to recalculate layout. [See docs here](https://react.dev/reference/react/useInsertionEffect).

> Note
>
> `useInsertionEffect` is intended to be used by libraries, not application code.

## How to Upgrade

See [How to Upgrade to React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide) for step-by-step instructions and a full list of breaking and notable changes.

## Changelog

### React

* Add `useTransition` and `useDeferredValue` to separate urgent updates from transitions. ([#10426](https://github.com/facebook/react/pull/10426), [#10715](https://github.com/facebook/react/pull/10715), [#15593](https://github.com/facebook/react/pull/15593), [#15272](https://github.com/facebook/react/pull/15272), [#15578](https://github.com/facebook/react/pull/15578), [#15769](https://github.com/facebook/react/pull/15769), [#17058](https://github.com/facebook/react/pull/17058), [#18796](https://github.com/facebook/react/pull/18796), [#19121](https://github.com/facebook/react/pull/19121), [#19703](https://github.com/facebook/react/pull/19703), [#19719](https://github.com/facebook/react/pull/19719), [#19724](https://github.com/facebook/react/pull/19724), [#20672](https://github.com/facebook/react/pull/20672), [#20976](https://github.com/facebook/react/pull/20976) by [@acdlite](https://github.com/acdlite), [@lunaruan](https://github.com/lunaruan), [@rickhanlonii](https://github.com/rickhanlonii), and [@sebmarkbage](https://github.com/sebmarkbage))
* Add `useId` for generating unique IDs. ([#17322](https://github.com/facebook/react/pull/17322), [#18576](https://github.com/facebook/react/pull/18576), [#22644](https://github.com/facebook/react/pull/22644), [#22672](https://github.com/facebook/react/pull/22672), [#21260](https://github.com/facebook/react/pull/21260) by [@acdlite](https://github.com/acdlite), [@lunaruan](https://github.com/lunaruan), and [@sebmarkbage](https://github.com/sebmarkbage))
* Add `useSyncExternalStore` to help external store libraries integrate with React. ([#15022](https://github.com/facebook/react/pull/15022), [#18000](https://github.com/facebook/react/pull/18000), [#18771](https://github.com/facebook/react/pull/18771), [#22211](https://github.com/facebook/react/pull/22211), [#22292](https://github.com/facebook/react/pull/22292), [#22239](https://github.com/facebook/react/pull/22239), [#22347](https://github.com/facebook/react/pull/22347), [#23150](https://github.com/facebook/react/pull/23150) by [@acdlite](https://github.com/acdlite), [@bvaughn](https://github.com/bvaughn), and [@drarmstr](https://github.com/drarmstr))
* Add `startTransition` as a version of `useTransition` without pending feedback. ([#19696](https://github.com/facebook/react/pull/19696) by [@rickhanlonii](https://github.com/rickhanlonii))
* Add `useInsertionEffect` for CSS-in-JS libraries. ([#21913](https://github.com/facebook/react/pull/21913) by [@rickhanlonii](https://github.com/rickhanlonii))
* Make Suspense remount layout effects when content reappears. ([#19322](https://github.com/facebook/react/pull/19322), [#19374](https://github.com/facebook/react/pull/19374), [#19523](https://github.com/facebook/react/pull/19523), [#20625](https://github.com/facebook/react/pull/20625), [#21079](https://github.com/facebook/react/pull/21079) by [@acdlite](https://github.com/acdlite), [@bvaughn](https://github.com/bvaughn), and [@lunaruan](https://github.com/lunaruan))
* Make `<StrictMode>` re-run effects to check for restorable state. ([#19523](https://github.com/facebook/react/pull/19523) , [#21418](https://github.com/facebook/react/pull/21418) by [@bvaughn](https://github.com/bvaughn) and [@lunaruan](https://github.com/lunaruan))
* Assume Symbols are always available. ([#23348](https://github.com/facebook/react/pull/23348) by [@sebmarkbage](https://github.com/sebmarkbage))
* Remove `object-assign` polyfill. ([#23351](https://github.com/facebook/react/pull/23351) by [@sebmarkbage](https://github.com/sebmarkbage))
* Remove unsupported `unstable_changedBits` API. ([#20953](https://github.com/facebook/react/pull/20953) by [@acdlite](https://github.com/acdlite))
* Allow components to render undefined. ([#21869](https://github.com/facebook/react/pull/21869) by [@rickhanlonii](https://github.com/rickhanlonii))
* Flush `useEffect` resulting from discrete events like clicks synchronously. ([#21150](https://github.com/facebook/react/pull/21150) by [@acdlite](https://github.com/acdlite))
* Suspense `fallback={undefined}` now behaves the same as `null` and isn’t ignored. ([#21854](https://github.com/facebook/react/pull/21854) by [@rickhanlonii](https://github.com/rickhanlonii))
* Consider all `lazy()` resolving to the same component equivalent. ([#20357](https://github.com/facebook/react/pull/20357) by [@sebmarkbage](https://github.com/sebmarkbage))
* Don’t patch console during first render. ([#22308](https://github.com/facebook/react/pull/22308) by [@lunaruan](https://github.com/lunaruan))
* Improve memory usage. ([#21039](https://github.com/facebook/react/pull/21039) by [@bgirard](https://github.com/bgirard))
* Improve messages if string coercion throws (Temporal.\*, Symbol, etc.) ([#22064](https://github.com/facebook/react/pull/22064) by [@justingrant](https://github.com/justingrant))
* Use `setImmediate` when available over `MessageChannel`. ([#20834](https://github.com/facebook/react/pull/20834) by [@gaearon](https://github.com/gaearon))
* Fix context failing to propagate inside suspended trees. ([#23095](https://github.com/facebook/react/pull/23095) by [@gaearon](https://github.com/gaearon))
* Fix `useReducer` observing incorrect props by removing the eager bailout mechanism. ([#22445](https://github.com/facebook/react/pull/22445) by [@josephsavona](https://github.com/josephsavona))
* Fix `setState` being ignored in Safari when appending iframes. ([#23111](https://github.com/facebook/react/pull/23111) by [@gaearon](https://github.com/gaearon))
* Fix a crash when rendering `ZonedDateTime` in the tree. ([#20617](https://github.com/facebook/react/pull/20617) by [@dimaqq](https://github.com/dimaqq))
* Fix a crash when document is set to `null` in tests. ([#22695](https://github.com/facebook/react/pull/22695) by [@SimenB](https://github.com/SimenB))
* Fix `onLoad` not triggering when concurrent features are on. ([#23316](https://github.com/facebook/react/pull/23316) by [@gnoff](https://github.com/gnoff))
* Fix a warning when a selector returns `NaN`. ([#23333](https://github.com/facebook/react/pull/23333) by [@hachibeeDI](https://github.com/hachibeeDI))
* Fix a crash when document is set to `null` in tests. ([#22695](https://github.com/facebook/react/pull/22695) by [@SimenB](https://github.com/SimenB))
* Fix the generated license header. ([#23004](https://github.com/facebook/react/pull/23004) by [@vitaliemiron](https://github.com/vitaliemiron))
* Add `package.json` as one of the entry points. ([#22954](https://github.com/facebook/react/pull/22954) by [@Jack](https://github.com/Jack-Works))
* Allow suspending outside a Suspense boundary. ([#23267](https://github.com/facebook/react/pull/23267) by [@acdlite](https://github.com/acdlite))
* Log a recoverable error whenever hydration fails. ([#23319](https://github.com/facebook/react/pull/23319) by [@acdlite](https://github.com/acdlite))

### React DOM

* Add `createRoot` and `hydrateRoot`. ([#10239](https://github.com/facebook/react/pull/10239), [#11225](https://github.com/facebook/react/pull/11225), [#12117](https://github.com/facebook/react/pull/12117), [#13732](https://github.com/facebook/react/pull/13732), [#15502](https://github.com/facebook/react/pull/15502), [#15532](https://github.com/facebook/react/pull/15532), [#17035](https://github.com/facebook/react/pull/17035), [#17165](https://github.com/facebook/react/pull/17165), [#20669](https://github.com/facebook/react/pull/20669), [#20748](https://github.com/facebook/react/pull/20748), [#20888](https://github.com/facebook/react/pull/20888), [#21072](https://github.com/facebook/react/pull/21072), [#21417](https://github.com/facebook/react/pull/21417), [#21652](https://github.com/facebook/react/pull/21652), [#21687](https://github.com/facebook/react/pull/21687), [#23207](https://github.com/facebook/react/pull/23207), [#23385](https://github.com/facebook/react/pull/23385) by [@acdlite](https://github.com/acdlite), [@bvaughn](https://github.com/bvaughn), [@gaearon](https://github.com/gaearon), [@lunaruan](https://github.com/lunaruan), [@rickhanlonii](https://github.com/rickhanlonii), [@trueadm](https://github.com/trueadm), and [@sebmarkbage](https://github.com/sebmarkbage))
* Add selective hydration. ([#14717](https://github.com/facebook/react/pull/14717), [#14884](https://github.com/facebook/react/pull/14884), [#16725](https://github.com/facebook/react/pull/16725), [#16880](https://github.com/facebook/react/pull/16880), [#17004](https://github.com/facebook/react/pull/17004), [#22416](https://github.com/facebook/react/pull/22416), [#22629](https://github.com/facebook/react/pull/22629), [#22448](https://github.com/facebook/react/pull/22448), [#22856](https://github.com/facebook/react/pull/22856), [#23176](https://github.com/facebook/react/pull/23176) by [@acdlite](https://github.com/acdlite), [@gaearon](https://github.com/gaearon), [@salazarm](https://github.com/salazarm), and [@sebmarkbage](https://github.com/sebmarkbage))
* Add `aria-description` to the list of known ARIA attributes. ([#22142](https://github.com/facebook/react/pull/22142) by [@mahyareb](https://github.com/mahyareb))
* Add `onResize` event to video elements. ([#21973](https://github.com/facebook/react/pull/21973) by [@rileyjshaw](https://github.com/rileyjshaw))
* Add `imageSizes` and `imageSrcSet` to known props. ([#22550](https://github.com/facebook/react/pull/22550) by [@eps1lon](https://github.com/eps1lon))
* Allow non-string `<option>` children if `value` is provided. ([#21431](https://github.com/facebook/react/pull/21431) by [@sebmarkbage](https://github.com/sebmarkbage))
* Fix `aspectRatio` style not being applied. ([#21100](https://github.com/facebook/react/pull/21100) by [@gaearon](https://github.com/gaearon))
* Warn if `renderSubtreeIntoContainer` is called. ([#23355](https://github.com/facebook/react/pull/23355) by [@acdlite](https://github.com/acdlite))

### React DOM Server

* Add the new streaming renderer. ([#14144](https://github.com/facebook/react/pull/14144), [#20970](https://github.com/facebook/react/pull/20970), [#21056](https://github.com/facebook/react/pull/21056), [#21255](https://github.com/facebook/react/pull/21255), [#21200](https://github.com/facebook/react/pull/21200), [#21257](https://github.com/facebook/react/pull/21257), [#21276](https://github.com/facebook/react/pull/21276), [#22443](https://github.com/facebook/react/pull/22443), [#22450](https://github.com/facebook/react/pull/22450), [#23247](https://github.com/facebook/react/pull/23247), [#24025](https://github.com/facebook/react/pull/24025), [#24030](https://github.com/facebook/react/pull/24030) by [@sebmarkbage](https://github.com/sebmarkbage))
* Fix context providers in SSR when handling multiple requests. ([#23171](https://github.com/facebook/react/pull/23171) by [@frandiox](https://github.com/frandiox))
* Revert to client render on text mismatch. ([#23354](https://github.com/facebook/react/pull/23354) by [@acdlite](https://github.com/acdlite))
* Deprecate `renderToNodeStream`. ([#23359](https://github.com/facebook/react/pull/23359) by [@sebmarkbage](https://github.com/sebmarkbage))
* Fix a spurious error log in the new server renderer. ([#24043](https://github.com/facebook/react/pull/24043) by [@eps1lon](https://github.com/eps1lon))
* Fix a bug in the new server renderer. ([#22617](https://github.com/facebook/react/pull/22617) by [@shuding](https://github.com/shuding))
* Ignore function and symbol values inside custom elements on the server. ([#21157](https://github.com/facebook/react/pull/21157) by [@sebmarkbage](https://github.com/sebmarkbage))

### React DOM Test Utils

* Throw when `act` is used in production. ([#21686](https://github.com/facebook/react/pull/21686) by [@acdlite](https://github.com/acdlite))
* Support disabling spurious act warnings with `global.IS_REACT_ACT_ENVIRONMENT`. ([#22561](https://github.com/facebook/react/pull/22561) by [@acdlite](https://github.com/acdlite))
* Expand act warning to cover all APIs that might schedule React work. ([#22607](https://github.com/facebook/react/pull/22607) by [@acdlite](https://github.com/acdlite))
* Make `act` batch updates. ([#21797](https://github.com/facebook/react/pull/21797) by [@acdlite](https://github.com/acdlite))
* Remove warning for dangling passive effects. ([#22609](https://github.com/facebook/react/pull/22609) by [@acdlite](https://github.com/acdlite))

### React Refresh

* Track late-mounted roots in Fast Refresh. ([#22740](https://github.com/facebook/react/pull/22740) by [@anc95](https://github.com/anc95))
* Add `exports` field to `package.json`. ([#23087](https://github.com/facebook/react/pull/23087) by [@otakustay](https://github.com/otakustay))

### Server Components (Experimental)

* Add Server Context support. ([#23244](https://github.com/facebook/react/pull/23244) by [@salazarm](https://github.com/salazarm))
* Add `lazy` support. ([#24068](https://github.com/facebook/react/pull/24068) by [@gnoff](https://github.com/gnoff))
* Update webpack plugin for webpack 5 ([#22739](https://github.com/facebook/react/pull/22739) by [@michenly](https://github.com/michenly))
* Fix a mistake in the Node loader. ([#22537](https://github.com/facebook/react/pull/22537) by [@btea](https://github.com/btea))
* Use `globalThis` instead of `window` for edge environments. ([#22777](https://github.com/facebook/react/pull/22777) by [@huozhi](https://github.com/huozhi))

[PreviousReact Labs: What We've Been Working On – June 2022](https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022)[NextHow to Upgrade to React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide)

---

---


# How to Upgrade to React 18 – React

URL: https://react.dev/blog/2022/03/08/react-18-upgrade-guide

[Blog](https://react.dev/blog)

# How to Upgrade to React 18

March 08, 2022 by [Rick Hanlon](https://twitter.com/rickhanlonii)

---

As we shared in the [release post](https://react.dev/blog/2022/03/29/react-v18), React 18 introduces features powered by our new concurrent renderer, with a gradual adoption strategy for existing applications. In this post, we will guide you through the steps for upgrading to React 18.

Please [report any issues](https://github.com/facebook/react/issues/new/choose) you encounter while upgrading to React 18.

### Note

For React Native users, React 18 will ship in a future version of React Native. This is because React 18 relies on the New React Native Architecture to benefit from the new capabilities presented in this blogpost. For more information, see the [React Conf keynote here](https://www.youtube.com/watch?v=FZ0cG47msEk&t=1530s).

---

## Installing

To install the latest version of React:

```
npm install react react-dom
```

Or if you’re using yarn:

```
yarn add react react-dom
```

## Updates to Client Rendering APIs

When you first install React 18, you will see a warning in the console:

Console

ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it’s running React 17. Learn more: <https://reactjs.org/link/switch-to-createroot>

React 18 introduces a new root API which provides better ergonomics for managing roots. The new root API also enables the new concurrent renderer, which allows you to opt-into concurrent features.

```
// Before

import { render } from 'react-dom';

const container = document.getElementById('app');

render(<App tab="home" />, container);

// After

import { createRoot } from 'react-dom/client';

const container = document.getElementById('app');

const root = createRoot(container); // createRoot(container!) if you use TypeScript

root.render(<App tab="home" />);
```

We’ve also changed `unmountComponentAtNode` to `root.unmount`:

```
// Before

unmountComponentAtNode(container);

// After

root.unmount();
```

We’ve also removed the callback from render, since it usually does not have the expected result when using Suspense:

```
// Before

const container = document.getElementById('app');

render(<App tab="home" />, container, () => {

console.log('rendered');

});

// After

function AppWithCallbackAfterRender() {

useEffect(() => {

console.log('rendered');

});

return <App tab="home" />

}

const container = document.getElementById('app');

const root = createRoot(container);

root.render(<AppWithCallbackAfterRender />);
```

### Note

There is no one-to-one replacement for the old render callback API — it depends on your use case. See the working group post for [Replacing render with createRoot](https://github.com/reactwg/react-18/discussions/5) for more information.

Finally, if your app uses server-side rendering with hydration, upgrade `hydrate` to `hydrateRoot`:

```
// Before

import { hydrate } from 'react-dom';

const container = document.getElementById('app');

hydrate(<App tab="home" />, container);

// After

import { hydrateRoot } from 'react-dom/client';

const container = document.getElementById('app');

const root = hydrateRoot(container, <App tab="home" />);

// Unlike with createRoot, you don't need a separate root.render() call here.
```

For more information, see the [working group discussion here](https://github.com/reactwg/react-18/discussions/5).

### Note

**If your app doesn’t work after upgrading, check whether it’s wrapped in `<StrictMode>`.** [Strict Mode has gotten stricter in React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide#updates-to-strict-mode), and not all your components may be resilient to the new checks it adds in development mode. If removing Strict Mode fixes your app, you can remove it during the upgrade, and then add it back (either at the top or for a part of the tree) after you fix the issues that it’s pointing out.

## Updates to Server Rendering APIs

In this release, we’re revamping our `react-dom/server` APIs to fully support Suspense on the server and Streaming SSR. As part of these changes, we’re deprecating the old Node streaming API, which does not support incremental Suspense streaming on the server.

Using this API will now warn:

* `renderToNodeStream`: **Deprecated ⛔️️**

Instead, for streaming in Node environments, use:

* `renderToPipeableStream`: **New ✨**

We’re also introducing a new API to support streaming SSR with Suspense for modern edge runtime environments, such as Deno and Cloudflare workers:

* `renderToReadableStream`: **New ✨**

The following APIs will continue working, but with limited support for Suspense:

* `renderToString`: **Limited** ⚠️
* `renderToStaticMarkup`: **Limited** ⚠️

Finally, this API will continue to work for rendering e-mails:

* `renderToStaticNodeStream`

For more information on the changes to server rendering APIs, see the working group post on [Upgrading to React 18 on the server](https://github.com/reactwg/react-18/discussions/22), a [deep dive on the new Suspense SSR Architecture](https://github.com/reactwg/react-18/discussions/37), and [Shaundai Person’s](https://twitter.com/shaundai) talk on [Streaming Server Rendering with Suspense](https://www.youtube.com/watch?v=pj5N-Khihgc) at React Conf 2021.

## Updates to TypeScript definitions

If your project uses TypeScript, you will need to update your `@types/react` and `@types/react-dom` dependencies to the latest versions. The new types are safer and catch issues that used to be ignored by the type checker. The most notable change is that the `children` prop now needs to be listed explicitly when defining props, for example:

```
interface MyButtonProps {

color: string;

children?: React.ReactNode;

}
```

See the [React 18 typings pull request](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/56210) for a full list of type-only changes. It links to example fixes in library types so you can see how to adjust your code. You can use the [automated migration script](https://github.com/eps1lon/types-react-codemod) to help port your application code to the new and safer typings faster.

If you find a bug in the typings, please [file an issue](https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/new?category=issues-with-a-types-package) in the DefinitelyTyped repo.

## Automatic Batching

React 18 adds out-of-the-box performance improvements by doing more batching by default. Batching is when React groups multiple state updates into a single re-render for better performance. Before React 18, we only batched updates inside React event handlers. Updates inside of promises, setTimeout, native event handlers, or any other event were not batched in React by default:

```
// Before React 18 only React events were batched

function handleClick() {

setCount(c => c + 1);

setFlag(f => !f);

// React will only re-render once at the end (that's batching!)

}

setTimeout(() => {

setCount(c => c + 1);

setFlag(f => !f);

// React will render twice, once for each state update (no batching)

}, 1000);
```

Starting in React 18 with `createRoot`, all updates will be automatically batched, no matter where they originate from. This means that updates inside of timeouts, promises, native event handlers or any other event will batch the same way as updates inside of React events:

```
// After React 18 updates inside of timeouts, promises,

// native event handlers or any other event are batched.

function handleClick() {

setCount(c => c + 1);

setFlag(f => !f);

// React will only re-render once at the end (that's batching!)

}

setTimeout(() => {

setCount(c => c + 1);

setFlag(f => !f);

// React will only re-render once at the end (that's batching!)

}, 1000);
```

This is a breaking change, but we expect this to result in less work rendering, and therefore better performance in your applications. To opt-out of automatic batching, you can use `flushSync`:

```
import { flushSync } from 'react-dom';

function handleClick() {

flushSync(() => {

setCounter(c => c + 1);

});

// React has updated the DOM by now

flushSync(() => {

setFlag(f => !f);

});

// React has updated the DOM by now

}
```

For more information, see the [Automatic batching deep dive](https://github.com/reactwg/react-18/discussions/21).

## New APIs for Libraries

In the React 18 Working Group we worked with library maintainers to create new APIs needed to support concurrent rendering for use cases specific to their use case in areas like styles, and external stores. To support React 18, some libraries may need to switch to one of the following APIs:

* `useSyncExternalStore` is a new Hook that allows external stores to support concurrent reads by forcing updates to the store to be synchronous. This new API is recommended for any library that integrates with state external to React. For more information, see the [useSyncExternalStore overview post](https://github.com/reactwg/react-18/discussions/70) and [useSyncExternalStore API details](https://github.com/reactwg/react-18/discussions/86).
* `useInsertionEffect` is a new Hook that allows CSS-in-JS libraries to address performance issues of injecting styles in render. Unless you’ve already built a CSS-in-JS library we don’t expect you to ever use this. This Hook will run after the DOM is mutated, but before layout effects read the new layout. This solves an issue that already exists in React 17 and below, but is even more important in React 18 because React yields to the browser during concurrent rendering, giving it a chance to recalculate layout. For more information, see the [Library Upgrade Guide for `<style>`](https://github.com/reactwg/react-18/discussions/110).

React 18 also introduces new APIs for concurrent rendering such as `startTransition`, `useDeferredValue` and `useId`, which we share more about in the [release post](https://react.dev/blog/2022/03/29/react-v18).

## Updates to Strict Mode

In the future, we’d like to add a feature that allows React to add and remove sections of the UI while preserving state. For example, when a user tabs away from a screen and back, React should be able to immediately show the previous screen. To do this, React would unmount and remount trees using the same component state as before.

This feature will give React better performance out-of-the-box, but requires components to be resilient to effects being mounted and destroyed multiple times. Most effects will work without any changes, but some effects assume they are only mounted or destroyed once.

To help surface these issues, React 18 introduces a new development-only check to Strict Mode. This new check will automatically unmount and remount every component, whenever a component mounts for the first time, restoring the previous state on the second mount.

Before this change, React would mount the component and create the effects:

```
* React mounts the component.

* Layout effects are created.

* Effect effects are created.
```

With Strict Mode in React 18, React will simulate unmounting and remounting the component in development mode:

```
* React mounts the component.

* Layout effects are created.

* Effect effects are created.

* React simulates unmounting the component.

* Layout effects are destroyed.

* Effects are destroyed.

* React simulates mounting the component with the previous state.

* Layout effect setup code runs

* Effect setup code runs
```

For more information, see the Working Group posts for [Adding Reusable State to StrictMode](https://github.com/reactwg/react-18/discussions/19) and [How to support Reusable State in Effects](https://github.com/reactwg/react-18/discussions/18).

## Configuring Your Testing Environment

When you first update your tests to use `createRoot`, you may see this warning in your test console:

Console

The current testing environment is not configured to support act(…)

To fix this, set `globalThis.IS_REACT_ACT_ENVIRONMENT` to `true` before running your test:

```
// In your test setup file

globalThis.IS_REACT_ACT_ENVIRONMENT = true;
```

The purpose of the flag is to tell React that it’s running in a unit test-like environment. React will log helpful warnings if you forget to wrap an update with `act`.

You can also set the flag to `false` to tell React that `act` isn’t needed. This can be useful for end-to-end tests that simulate a full browser environment.

Eventually, we expect testing libraries will configure this for you automatically. For example, the [next version of React Testing Library has built-in support for React 18](https://github.com/testing-library/react-testing-library/issues/509#issuecomment-917989936) without any additional configuration.

[More background on the `act` testing API and related changes](https://github.com/reactwg/react-18/discussions/102) is available in the working group.

## Dropping Support for Internet Explorer

In this release, React is dropping support for Internet Explorer, which is [going out of support on June 15, 2022](https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge). We’re making this change now because new features introduced in React 18 are built using modern browser features such as microtasks which cannot be adequately polyfilled in IE.

If you need to support Internet Explorer we recommend you stay with React 17.

## Deprecations

* `react-dom`: `ReactDOM.render` has been deprecated. Using it will warn and run your app in React 17 mode.
* `react-dom`: `ReactDOM.hydrate` has been deprecated. Using it will warn and run your app in React 17 mode.
* `react-dom`: `ReactDOM.unmountComponentAtNode` has been deprecated.
* `react-dom`: `ReactDOM.renderSubtreeIntoContainer` has been deprecated.
* `react-dom/server`: `ReactDOMServer.renderToNodeStream` has been deprecated.

## Other Breaking Changes

* **Consistent useEffect timing**: React now always synchronously flushes effect functions if the update was triggered during a discrete user input event such as a click or a keydown event. Previously, the behavior wasn’t always predictable or consistent.
* **Stricter hydration errors**: Hydration mismatches due to missing or extra text content are now treated like errors instead of warnings. React will no longer attempt to “patch up” individual nodes by inserting or deleting a node on the client in an attempt to match the server markup, and will revert to client rendering up to the closest `<Suspense>` boundary in the tree. This ensures the hydrated tree is consistent and avoids potential privacy and security holes that can be caused by hydration mismatches.
* **Suspense trees are always consistent:** If a component suspends before it’s fully added to the tree, React will not add it to the tree in an incomplete state or fire its effects. Instead, React will throw away the new tree completely, wait for the asynchronous operation to finish, and then retry rendering again from scratch. React will render the retry attempt concurrently, and without blocking the browser.
* **Layout Effects with Suspense**: When a tree re-suspends and reverts to a fallback, React will now clean up layout effects, and then re-create them when the content inside the boundary is shown again. This fixes an issue which prevented component libraries from correctly measuring layout when used with Suspense.
* **New JS Environment Requirements**: React now depends on modern browsers features including `Promise`, `Symbol`, and `Object.assign`. If you support older browsers and devices such as Internet Explorer which do not provide modern browser features natively or have non-compliant implementations, consider including a global polyfill in your bundled application.

## Other Notable Changes

### React

* **Components can now render `undefined`:** React no longer warns if you return `undefined` from a component. This makes the allowed component return values consistent with values that are allowed in the middle of a component tree. We suggest to use a linter to prevent mistakes like forgetting a `return` statement before JSX.
* **In tests, `act` warnings are now opt-in:** If you’re running end-to-end tests, the `act` warnings are unnecessary. We’ve introduced an [opt-in](https://github.com/reactwg/react-18/discussions/102) mechanism so you can enable them only for unit tests where they are useful and beneficial.
* **No warning about `setState` on unmounted components:** Previously, React warned about memory leaks when you call `setState` on an unmounted component. This warning was added for subscriptions, but people primarily run into it in scenarios where setting state is fine, and workarounds make the code worse. We’ve [removed](https://github.com/facebook/react/pull/22114) this warning.
* **No suppression of console logs:** When you use Strict Mode, React renders each component twice to help you find unexpected side effects. In React 17, we’ve suppressed console logs for one of the two renders to make the logs easier to read. In response to [community feedback](https://github.com/facebook/react/issues/21783) about this being confusing, we’ve removed the suppression. Instead, if you have React DevTools installed, the second log’s renders will be displayed in grey, and there will be an option (off by default) to suppress them completely.
* **Improved memory usage:** React now cleans up more internal fields on unmount, making the impact from unfixed memory leaks that may exist in your application code less severe.

### React DOM Server

* **`renderToString`:** Will no longer error when suspending on the server. Instead, it will emit the fallback HTML for the closest `<Suspense>` boundary and then retry rendering the same content on the client. It is still recommended that you switch to a streaming API like `renderToPipeableStream` or `renderToReadableStream` instead.
* **`renderToStaticMarkup`:** Will no longer error when suspending on the server. Instead, it will emit the fallback HTML for the closest `<Suspense>` boundary.

## Changelog

You can view the [full changelog here](https://github.com/facebook/react/blob/main/CHANGELOG.md).

[PreviousReact v18.0](https://react.dev/blog/2022/03/29/react-v18)[NextReact Conf 2021 Recap](https://react.dev/blog/2021/12/17/react-conf-2021-recap)

---

---


# The Plan for React 18 – React

URL: https://react.dev/blog/2021/06/08/the-plan-for-react-18

[Blog](https://react.dev/blog)

# The Plan for React 18

June 8, 2021 by [Andrew Clark](https://twitter.com/acdlite), [Brian Vaughn](https://github.com/bvaughn), [Christine Abernathy](https://twitter.com/abernathyca), [Dan Abramov](https://bsky.app/profile/danabra.mov), [Rachel Nabors](https://twitter.com/rachelnabors), [Rick Hanlon](https://twitter.com/rickhanlonii), [Sebastian Markbåge](https://twitter.com/sebmarkbage), and [Seth Webster](https://twitter.com/sethwebster)

---

The React team is excited to share a few updates:

1. We’ve started work on the React 18 release, which will be our next major version.
2. We’ve created a Working Group to prepare the community for gradual adoption of new features in React 18.
3. We’ve published a React 18 Alpha so that library authors can try it and provide feedback.

These updates are primarily aimed at maintainers of third-party libraries. If you’re learning, teaching, or using React to build user-facing applications, you can safely ignore this post. But you are welcome to follow the discussions in the React 18 Working Group if you’re curious!

---

## What’s coming in React 18

When it’s released, React 18 will include out-of-the-box improvements (like [automatic batching](https://github.com/reactwg/react-18/discussions/21)), new APIs (like [`startTransition`](https://github.com/reactwg/react-18/discussions/41)), and a [new streaming server renderer](https://github.com/reactwg/react-18/discussions/37) with built-in support for `React.lazy`.

These features are possible thanks to a new opt-in mechanism we’re adding in React 18. It’s called “concurrent rendering” and it lets React prepare multiple versions of the UI at the same time. This change is mostly behind-the-scenes, but it unlocks new possibilities to improve both real and perceived performance of your app.

If you’ve been following our research into the future of React (we don’t expect you to!), you might have heard of something called “concurrent mode” or that it might break your app. In response to this feedback from the community, we’ve redesigned the upgrade strategy for gradual adoption. Instead of an all-or-nothing “mode”, concurrent rendering will only be enabled for updates triggered by one of the new features. In practice, this means **you will be able to adopt React 18 without rewrites and try the new features at your own pace.**

## A gradual adoption strategy

Since concurrency in React 18 is opt-in, there are no significant out-of-the-box breaking changes to component behavior. **You can upgrade to React 18 with minimal or no changes to your application code, with a level of effort comparable to a typical major React release**. Based on our experience converting several apps to React 18, we expect that many users will be able to upgrade within a single afternoon.

We successfully shipped concurrent features to tens of thousands of components at Facebook, and in our experience, we’ve found that most React components “just work” without additional changes. We’re committed to making sure this is a smooth upgrade for the entire community, so today we’re announcing the React 18 Working Group.

## Working with the community

We’re trying something new for this release: We’ve invited a panel of experts, developers, library authors, and educators from across the React community to participate in our [React 18 Working Group](https://github.com/reactwg/react-18) to provide feedback, ask questions, and collaborate on the release. We couldn’t invite everyone we wanted to this initial, small group, but if this experiment works out, we hope there will be more in the future!

**The goal of the React 18 Working Group is to prepare the ecosystem for a smooth, gradual adoption of React 18 by existing applications and libraries.** The Working Group is hosted on [GitHub Discussions](https://github.com/reactwg/react-18/discussions) and is available for the public to read. Members of the working group can leave feedback, ask questions, and share ideas. The core team will also use the discussions repo to share our research findings. As the stable release gets closer, any important information will also be posted on this blog.

For more information on upgrading to React 18, or additional resources about the release, see the [React 18 announcement post](https://github.com/reactwg/react-18/discussions/4).

## Accessing the React 18 Working Group

Everyone can read the discussions in the [React 18 Working Group repo](https://github.com/reactwg/react-18).

Because we expect an initial surge of interest in the Working Group, only invited members will be allowed to create or comment on threads. However, the threads are fully visible to the public, so everyone has access to the same information. We believe this is a good compromise between creating a productive environment for working group members, while maintaining transparency with the wider community.

As always, you can submit bug reports, questions, and general feedback to our [issue tracker](https://github.com/facebook/react/issues).

## How to try React 18 Alpha today

New alphas are [regularly published to npm using the `@alpha` tag](https://github.com/reactwg/react-18/discussions/9). These releases are built using the most recent commit to our main repo. When a feature or bugfix is merged, it will appear in an alpha the following weekday.

There may be significant behavioral or API changes between alpha releases. Please remember that **alpha releases are not recommended for user-facing, production applications**.

## Projected React 18 release timeline

We don’t have a specific release date scheduled, but we expect it will take several months of feedback and iteration before React 18 is ready for most production applications.

* Library Alpha: Available today
* Public Beta: At least several months
* Release Candidate (RC): At least several weeks after Beta
* General Availability: At least several weeks after RC

More details about our projected release timeline are [available in the Working Group](https://github.com/reactwg/react-18/discussions/9). We’ll post updates on this blog when we’re closer to a public release.

[PreviousReact Conf 2021 Recap](https://react.dev/blog/2021/12/17/react-conf-2021-recap)[NextIntroducing Server Components](https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components)

---

---


# Built-in React Hooks – React

URL: https://react.dev/reference/react/hooks

[API Reference](https://react.dev/reference/react)

# Built-in React Hooks

*Hooks* let you use different React features from your components. You can either use the built-in Hooks or combine them to build your own. This page lists all built-in Hooks in React.

---

## State Hooks

*State* lets a component [“remember” information like user input.](https://react.dev/learn/state-a-components-memory) For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index.

To add state to a component, use one of these Hooks:

* [`useState`](https://react.dev/reference/react/useState) declares a state variable that you can update directly.
* [`useReducer`](https://react.dev/reference/react/useReducer) declares a state variable with the update logic inside a [reducer function.](https://react.dev/learn/extracting-state-logic-into-a-reducer)

```
function ImageGallery() {

const [index, setIndex] = useState(0);

// ...
```

---

## Context Hooks

*Context* lets a component [receive information from distant parents without passing it as props.](https://react.dev/learn/passing-props-to-a-component) For example, your app’s top-level component can pass the current UI theme to all components below, no matter how deep.

* [`useContext`](https://react.dev/reference/react/useContext) reads and subscribes to a context.

```
function Button() {

const theme = useContext(ThemeContext);

// ...
```

---

## Ref Hooks

*Refs* let a component [hold some information that isn’t used for rendering,](https://react.dev/learn/referencing-values-with-refs) like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs.

* [`useRef`](https://react.dev/reference/react/useRef) declares a ref. You can hold any value in it, but most often it’s used to hold a DOM node.
* [`useImperativeHandle`](https://react.dev/reference/react/useImperativeHandle) lets you customize the ref exposed by your component. This is rarely used.

```
function Form() {

const inputRef = useRef(null);

// ...
```

---

## Effect Hooks

*Effects* let a component [connect to and synchronize with external systems.](https://react.dev/learn/synchronizing-with-effects) This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code.

* [`useEffect`](https://react.dev/reference/react/useEffect) connects a component to an external system.

```
function ChatRoom({ roomId }) {

useEffect(() => {

const connection = createConnection(roomId);

connection.connect();

return () => connection.disconnect();

}, [roomId]);

// ...
```

Effects are an “escape hatch” from the React paradigm. Don’t use Effects to orchestrate the data flow of your application. If you’re not interacting with an external system, [you might not need an Effect.](https://react.dev/learn/you-might-not-need-an-effect)

There are two rarely used variations of `useEffect` with differences in timing:

* [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) fires before the browser repaints the screen. You can measure layout here.
* [`useInsertionEffect`](https://react.dev/reference/react/useInsertionEffect) fires before React makes changes to the DOM. Libraries can insert dynamic CSS here.

---

## Performance Hooks

A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render.

To skip calculations and unnecessary re-rendering, use one of these Hooks:

* [`useMemo`](https://react.dev/reference/react/useMemo) lets you cache the result of an expensive calculation.
* [`useCallback`](https://react.dev/reference/react/useCallback) lets you cache a function definition before passing it down to an optimized component.

```
function TodoList({ todos, tab, theme }) {

const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);

// ...

}
```

Sometimes, you can’t skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don’t need to block the user interface (like updating a chart).

To prioritize rendering, use one of these Hooks:

* [`useTransition`](https://react.dev/reference/react/useTransition) lets you mark a state transition as non-blocking and allow other updates to interrupt it.
* [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) lets you defer updating a non-critical part of the UI and let other parts update first.

---

## Other Hooks

These Hooks are mostly useful to library authors and aren’t commonly used in the application code.

* [`useDebugValue`](https://react.dev/reference/react/useDebugValue) lets you customize the label React DevTools displays for your custom Hook.
* [`useId`](https://react.dev/reference/react/useId) lets a component associate a unique ID with itself. Typically used with accessibility APIs.
* [`useSyncExternalStore`](https://react.dev/reference/react/useSyncExternalStore) lets a component subscribe to an external store.

* [`useActionState`](https://react.dev/reference/react/useActionState) allows you to manage state of actions.

---

## Your own Hooks

You can also [define your own custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component) as JavaScript functions.

[PreviousOverview](https://react.dev/reference/react)[NextuseActionState](https://react.dev/reference/react/useActionState)

---

---


# useActionState – React

URL: https://react.dev/reference/react/useActionState

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useActionState

`useActionState` is a Hook that allows you to update state based on the result of a form action.

```
const [state, formAction, isPending] = useActionState(fn, initialState, permalink?);
```

### Note

In earlier React Canary versions, this API was part of React DOM and called `useFormState`.

* [Reference](https://react.dev/reference/react/useActionState#reference) 
  + [`useActionState(action, initialState, permalink?)`](https://react.dev/reference/react/useActionState#useactionstate)
* [Usage](https://react.dev/reference/react/useActionState#usage) 
  + [Using information returned by a form action](https://react.dev/reference/react/useActionState#using-information-returned-by-a-form-action)
* [Troubleshooting](https://react.dev/reference/react/useActionState#troubleshooting) 
  + [My action can no longer read the submitted form data](https://react.dev/reference/react/useActionState#my-action-can-no-longer-read-the-submitted-form-data)

---

## Reference

### `useActionState(action, initialState, permalink?)`

Call `useActionState` at the top level of your component to create component state that is updated [when a form action is invoked](https://react.dev/reference/react-dom/components/form). You pass `useActionState` an existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state and whether the Action is still pending. The latest form state is also passed to the function that you provided.

```
import { useActionState } from "react";

async function increment(previousState, formData) {

return previousState + 1;

}

function StatefulForm({}) {

const [state, formAction] = useActionState(increment, 0);

return (

<form>

{state}

<button formAction={formAction}>Increment</button>

</form>

)

}
```

The form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass.

If used with a Server Function, `useActionState` allows the server’s response from submitting the form to be shown even before hydration has completed.

[See more examples below.](https://react.dev/reference/react/useActionState#usage)

#### Parameters

* `fn`: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially the `initialState` that you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives.
* `initialState`: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked.
* **optional** `permalink`: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: if `fn` is a [server function](https://react.dev/reference/rsc/server-functions) and the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current page’s URL. Ensure that the same form component is rendered on the destination page (including the same action `fn` and `permalink`) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect.

#### Returns

`useActionState` returns an array with the following values:

1. The current state. During the first render, it will match the `initialState` you have passed. After the action is invoked, it will match the value returned by the action.
2. A new action that you can pass as the `action` prop to your `form` component or `formAction` prop to any `button` component within the form. The action can also be called manually within [`startTransition`](https://react.dev/reference/react/startTransition).
3. The `isPending` flag that tells you whether there is a pending Transition.

#### Caveats

* When used with a framework that supports React Server Components, `useActionState` lets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state.
* The function passed to `useActionState` receives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without using `useActionState`.

---

## Usage

### Using information returned by a form action

Call `useActionState` at the top level of your component to access the return value of an action from the last time a form was submitted.

```
import { useActionState } from 'react';

import { action } from './actions.js';

function MyComponent() {

const [state, formAction] = useActionState(action, null);

// ...

return (

<form action={formAction}>

{/* ... */}

</form>

);

}
```

`useActionState` returns an array with the following items:

1. The current state of the form, which is initially set to the initial state you provided, and after the form is submitted is set to the return value of the action you provided.
2. A new action that you pass to `<form>` as its `action` prop or call manually within `startTransition`.
3. A pending state that you can utilise while your action is processing.

When the form is submitted, the action function that you provided will be called. Its return value will become the new current state of the form.

The action that you provide will also receive a new first argument, namely the current state of the form. The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as if `useActionState` had not been used.

```
function action(currentState, formData) {

// ...

return 'next state';

}
```

#### Display information after submitting a form

1. Display form errors 2. Display structured information after submitting a form

#### Example 1 of 2: Display form errors

To display messages such as an error message or toast that’s returned by a Server Function, wrap the action in a call to `useActionState`.

App.jsactions.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useActionState, useState } from "react";
import { addToCart } from "./actions.js";

function AddToCartForm({itemID, itemTitle}) {
  const [message, formAction, isPending] = useActionState(addToCart, null);
  return (
    <form action={formAction}>
      <h2>{itemTitle}</h2>
      <input type="hidden" name="itemID" value={itemID} />
      <button type="submit">Add to Cart</button>
      {isPending ? "Loading..." : message}
    </form>
  );
}

export default function App() {
  return (
    <>
      <AddToCartForm itemID="1" itemTitle="JavaScript: The Definitive Guide" />
      <AddToCartForm itemID="2" itemTitle="JavaScript: The Good Parts" />
    </>
  )
}
```

Show more

Next Example

## Troubleshooting

### My action can no longer read the submitted form data

When you wrap an action with `useActionState`, it gets an extra argument *as its first argument*. The submitted form data is therefore its *second* argument instead of its first as it would usually be. The new first argument that gets added is the current state of the form.

```
function action(currentState, formData) {

// ...

}
```

[PreviousHooks](https://react.dev/reference/react/hooks)[NextuseCallback](https://react.dev/reference/react/useCallback)

---

---


# useCallback – React

URL: https://react.dev/reference/react/useCallback

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useCallback

`useCallback` is a React Hook that lets you cache a function definition between re-renders.

```
const cachedFn = useCallback(fn, dependencies)
```

### Note

[React Compiler](https://react.dev/learn/react-compiler) automatically memoizes values and functions, reducing the need for manual `useCallback` calls. You can use the compiler to handle memoization automatically.

* [Reference](https://react.dev/reference/react/useCallback#reference) 
  + [`useCallback(fn, dependencies)`](https://react.dev/reference/react/useCallback#usecallback)
* [Usage](https://react.dev/reference/react/useCallback#usage) 
  + [Skipping re-rendering of components](https://react.dev/reference/react/useCallback#skipping-re-rendering-of-components)
  + [Updating state from a memoized callback](https://react.dev/reference/react/useCallback#updating-state-from-a-memoized-callback)
  + [Preventing an Effect from firing too often](https://react.dev/reference/react/useCallback#preventing-an-effect-from-firing-too-often)
  + [Optimizing a custom Hook](https://react.dev/reference/react/useCallback#optimizing-a-custom-hook)
* [Troubleshooting](https://react.dev/reference/react/useCallback#troubleshooting) 
  + [Every time my component renders, `useCallback` returns a different function](https://react.dev/reference/react/useCallback#every-time-my-component-renders-usecallback-returns-a-different-function)
  + [I need to call `useCallback` for each list item in a loop, but it’s not allowed](https://react.dev/reference/react/useCallback#i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed)

---

## Reference

### `useCallback(fn, dependencies)`

Call `useCallback` at the top level of your component to cache a function definition between re-renders:

```
import { useCallback } from 'react';

export default function ProductPage({ productId, referrer, theme }) {

const handleSubmit = useCallback((orderDetails) => {

post('/product/' + productId + '/buy', {

referrer,

orderDetails,

});

}, [productId, referrer]);
```

[See more examples below.](https://react.dev/reference/react/useCallback#usage)

#### Parameters

* `fn`: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the `dependencies` have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.
* `dependencies`: The list of all reactive values referenced inside of the `fn` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm.

#### Returns

On the initial render, `useCallback` returns the `fn` function you have passed.

During subsequent renders, it will either return an already stored `fn` function from the last render (if the dependencies haven’t changed), or return the `fn` function you have passed during this render.

#### Caveats

* `useCallback` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
* React **will not throw away the cached function unless there is a specific reason to do that.** For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on `useCallback` as a performance optimization. Otherwise, a [state variable](https://react.dev/reference/react/useState#im-trying-to-set-state-to-a-function-but-it-gets-called-instead) or a [ref](https://react.dev/reference/react/useRef#avoiding-recreating-the-ref-contents) may be more appropriate.

---

## Usage

### Skipping re-rendering of components

When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let’s first look at the syntax for how to do this, and then see in which cases it’s useful.

To cache a function between re-renders of your component, wrap its definition into the `useCallback` Hook:

```
import { useCallback } from 'react';

function ProductPage({ productId, referrer, theme }) {

const handleSubmit = useCallback((orderDetails) => {

post('/product/' + productId + '/buy', {

referrer,

orderDetails,

});

}, [productId, referrer]);

// ...
```

You need to pass two things to `useCallback`:

1. A function definition that you want to cache between re-renders.
2. A list of dependencies including every value within your component that’s used inside your function.

On the initial render, the returned function you’ll get from `useCallback` will be the function you passed.

On the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), `useCallback` will return the same function as before. Otherwise, `useCallback` will return the function you passed on *this* render.

In other words, `useCallback` caches a function between re-renders until its dependencies change.

**Let’s walk through an example to see when this is useful.**

Say you’re passing a `handleSubmit` function down from the `ProductPage` to the `ShippingForm` component:

```
function ProductPage({ productId, referrer, theme }) {

// ...

return (

<div className={theme}>

<ShippingForm onSubmit={handleSubmit} />

</div>

);
```

You’ve noticed that toggling the `theme` prop freezes the app for a moment, but if you remove `<ShippingForm />` from your JSX, it feels fast. This tells you that it’s worth trying to optimize the `ShippingForm` component.

**By default, when a component re-renders, React re-renders all of its children recursively.** This is why, when `ProductPage` re-renders with a different `theme`, the `ShippingForm` component *also* re-renders. This is fine for components that don’t require much calculation to re-render. But if you verified a re-render is slow, you can tell `ShippingForm` to skip re-rendering when its props are the same as on last render by wrapping it in [`memo`:](https://react.dev/reference/react/memo)

```
import { memo } from 'react';

const ShippingForm = memo(function ShippingForm({ onSubmit }) {

// ...

});
```

**With this change, `ShippingForm` will skip re-rendering if all of its props are the *same* as on the last render.** This is when caching a function becomes important! Let’s say you defined `handleSubmit` without `useCallback`:

```
function ProductPage({ productId, referrer, theme }) {

// Every time the theme changes, this will be a different function...

function handleSubmit(orderDetails) {

post('/product/' + productId + '/buy', {

referrer,

orderDetails,

});

}

return (

<div className={theme}>

{/* ... so ShippingForm's props will never be the same, and it will re-render every time */}

<ShippingForm onSubmit={handleSubmit} />

</div>

);

}
```

**In JavaScript, a `function () {}` or `() => {}` always creates a *different* function,** similar to how the `{}` object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that `ShippingForm` props will never be the same, and your [`memo`](https://react.dev/reference/react/memo) optimization won’t work. This is where `useCallback` comes in handy:

```
function ProductPage({ productId, referrer, theme }) {

// Tell React to cache your function between re-renders...

const handleSubmit = useCallback((orderDetails) => {

post('/product/' + productId + '/buy', {

referrer,

orderDetails,

});

}, [productId, referrer]); // ...so as long as these dependencies don't change...

return (

<div className={theme}>

{/* ...ShippingForm will receive the same props and can skip re-rendering */}

<ShippingForm onSubmit={handleSubmit} />

</div>

);

}
```

**By wrapping `handleSubmit` in `useCallback`, you ensure that it’s the *same* function between the re-renders** (until dependencies change). You don’t *have to* wrap a function in `useCallback` unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in [`memo`,](https://react.dev/reference/react/memo) and this lets it skip re-rendering. There are other reasons you might need `useCallback` which are described further on this page.

### Note

**You should only rely on `useCallback` as a performance optimization.** If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add `useCallback` back.

##### Deep Dive

#### How is useCallback related to useMemo?

Show Details

You will often see [`useMemo`](https://react.dev/reference/react/useMemo) alongside `useCallback`. They are both useful when you’re trying to optimize a child component. They let you [memoize](https://en.wikipedia.org/wiki/Memoization) (or, in other words, cache) something you’re passing down:

```
import { useMemo, useCallback } from 'react';

function ProductPage({ productId, referrer }) {

const product = useData('/product/' + productId);

const requirements = useMemo(() => { // Calls your function and caches its result

return computeRequirements(product);

}, [product]);

const handleSubmit = useCallback((orderDetails) => { // Caches your function itself

post('/product/' + productId + '/buy', {

referrer,

orderDetails,

});

}, [productId, referrer]);

return (

<div className={theme}>

<ShippingForm requirements={requirements} onSubmit={handleSubmit} />

</div>

);

}
```

The difference is in *what* they’re letting you cache:

* **[`useMemo`](https://react.dev/reference/react/useMemo) caches the *result* of calling your function.** In this example, it caches the result of calling `computeRequirements(product)` so that it doesn’t change unless `product` has changed. This lets you pass the `requirements` object down without unnecessarily re-rendering `ShippingForm`. When necessary, React will call the function you’ve passed during rendering to calculate the result.
* **`useCallback` caches *the function itself.*** Unlike `useMemo`, it does not call the function you provide. Instead, it caches the function you provided so that `handleSubmit` *itself* doesn’t change unless `productId` or `referrer` has changed. This lets you pass the `handleSubmit` function down without unnecessarily re-rendering `ShippingForm`. Your code won’t run until the user submits the form.

If you’re already familiar with [`useMemo`,](https://react.dev/reference/react/useMemo) you might find it helpful to think of `useCallback` as this:

```
// Simplified implementation (inside React)

function useCallback(fn, dependencies) {

return useMemo(() => fn, dependencies);

}
```

[Read more about the difference between `useMemo` and `useCallback`.](https://react.dev/reference/react/useMemo#memoizing-a-function)

##### Deep Dive

#### Should you add useCallback everywhere?

Show Details

If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.

Caching a function with `useCallback` is only valuable in a few cases:

* You pass it as a prop to a component wrapped in [`memo`.](https://react.dev/reference/react/memo) You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only if dependencies changed.
* The function you’re passing is later used as a dependency of some Hook. For example, another function wrapped in `useCallback` depends on it, or you depend on this function from [`useEffect.`](https://react.dev/reference/react/useEffect)

There is no benefit to wrapping a function in `useCallback` in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.

Note that `useCallback` does not prevent *creating* the function. You’re always creating a function (and that’s fine!), but React ignores it and gives you back a cached function if nothing changed.

**In practice, you can make a lot of memoization unnecessary by following a few principles:**

1. When a component visually wraps other components, let it [accept JSX as children.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) Then, if the wrapper component updates its own state, React knows that its children don’t need to re-render.
2. Prefer local state and don’t [lift state up](https://react.dev/learn/sharing-state-between-components) any further than necessary. Don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.
3. Keep your [rendering logic pure.](https://react.dev/learn/keeping-components-pure) If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.
4. Avoid [unnecessary Effects that update state.](https://react.dev/learn/you-might-not-need-an-effect) Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.
5. Try to [remove unnecessary dependencies from your Effects.](https://react.dev/learn/removing-effect-dependencies) For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component.

If a specific interaction still feels laggy, [use the React Developer Tools profiler](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) to see which components benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In long term, we’re researching [doing memoization automatically](https://www.youtube.com/watch?v=lGEMwh32soc) to solve this once and for all.

#### The difference between useCallback and declaring a function directly

1. Skipping re-rendering with `useCallback` and `memo` 2. Always re-rendering a component

#### Example 1 of 2: Skipping re-rendering with `useCallback` and `memo`

In this example, the `ShippingForm` component is **artificially slowed down** so that you can see what happens when a React component you’re rendering is genuinely slow. Try incrementing the counter and toggling the theme.

Incrementing the counter feels slow because it forces the slowed down `ShippingForm` to re-render. That’s expected because the counter has changed, and so you need to reflect the user’s new choice on the screen.

Next, try toggling the theme. **Thanks to `useCallback` together with [`memo`](https://react.dev/reference/react/memo), it’s fast despite the artificial slowdown!** `ShippingForm` skipped re-rendering because the `handleSubmit` function has not changed. The `handleSubmit` function has not changed because both `productId` and `referrer` (your `useCallback` dependencies) haven’t changed since last render.

App.jsProductPage.jsShippingForm.js

ProductPage.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useCallback } from 'react';
import ShippingForm from './ShippingForm.js';

export default function ProductPage({ productId, referrer, theme }) {
  const handleSubmit = useCallback((orderDetails) => {
    post('/product/' + productId + '/buy', {
      referrer,
      orderDetails,
    });
  }, [productId, referrer]);

  return (
    <div className={theme}>
      <ShippingForm onSubmit={handleSubmit} />
    </div>
  );
}

function post(url, data) {
  // Imagine this sends a request...
  console.log('POST /' + url);
  console.log(data);
}
```

Show more

Next Example

---

### Updating state from a memoized callback

Sometimes, you might need to update state based on previous state from a memoized callback.

This `handleAddTodo` function specifies `todos` as a dependency because it computes the next todos from it:

```
function TodoList() {

const [todos, setTodos] = useState([]);

const handleAddTodo = useCallback((text) => {

const newTodo = { id: nextId++, text };

setTodos([...todos, newTodo]);

}, [todos]);

// ...
```

You’ll usually want memoized functions to have as few dependencies as possible. When you read some state only to calculate the next state, you can remove that dependency by passing an [updater function](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state) instead:

```
function TodoList() {

const [todos, setTodos] = useState([]);

const handleAddTodo = useCallback((text) => {

const newTodo = { id: nextId++, text };

setTodos(todos => [...todos, newTodo]);

}, []); // ✅ No need for the todos dependency

// ...
```

Here, instead of making `todos` a dependency and reading it inside, you pass an instruction about *how* to update the state (`todos => [...todos, newTodo]`) to React. [Read more about updater functions.](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state)

---

### Preventing an Effect from firing too often

Sometimes, you might want to call a function from inside an [Effect:](https://react.dev/learn/synchronizing-with-effects)

```
function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

function createOptions() {

return {

serverUrl: 'https://localhost:1234',

roomId: roomId

};

}

useEffect(() => {

const options = createOptions();

const connection = createConnection(options);

connection.connect();

// ...
```

This creates a problem. [Every reactive value must be declared as a dependency of your Effect.](https://react.dev/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency) However, if you declare `createOptions` as a dependency, it will cause your Effect to constantly reconnect to the chat room:

```
useEffect(() => {

const options = createOptions();

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [createOptions]); // 🔴 Problem: This dependency changes on every render

// ...
```

To solve this, you can wrap the function you need to call from an Effect into `useCallback`:

```
function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

const createOptions = useCallback(() => {

return {

serverUrl: 'https://localhost:1234',

roomId: roomId

};

}, [roomId]); // ✅ Only changes when roomId changes

useEffect(() => {

const options = createOptions();

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [createOptions]); // ✅ Only changes when createOptions changes

// ...
```

This ensures that the `createOptions` function is the same between re-renders if the `roomId` is the same. **However, it’s even better to remove the need for a function dependency.** Move your function *inside* the Effect:

```
function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

useEffect(() => {

function createOptions() { // ✅ No need for useCallback or function dependencies!

return {

serverUrl: 'https://localhost:1234',

roomId: roomId

};

}

const options = createOptions();

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [roomId]); // ✅ Only changes when roomId changes

// ...
```

Now your code is simpler and doesn’t need `useCallback`. [Learn more about removing Effect dependencies.](https://react.dev/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect)

---

### Optimizing a custom Hook

If you’re writing a [custom Hook,](https://react.dev/learn/reusing-logic-with-custom-hooks) it’s recommended to wrap any functions that it returns into `useCallback`:

```
function useRouter() {

const { dispatch } = useContext(RouterStateContext);

const navigate = useCallback((url) => {

dispatch({ type: 'navigate', url });

}, [dispatch]);

const goBack = useCallback(() => {

dispatch({ type: 'back' });

}, [dispatch]);

return {

navigate,

goBack,

};

}
```

This ensures that the consumers of your Hook can optimize their own code when needed.

---

## Troubleshooting

### Every time my component renders, `useCallback` returns a different function

Make sure you’ve specified the dependency array as a second argument!

If you forget the dependency array, `useCallback` will return a new function every time:

```
function ProductPage({ productId, referrer }) {

const handleSubmit = useCallback((orderDetails) => {

post('/product/' + productId + '/buy', {

referrer,

orderDetails,

});

}); // 🔴 Returns a new function every time: no dependency array

// ...
```

This is the corrected version passing the dependency array as a second argument:

```
function ProductPage({ productId, referrer }) {

const handleSubmit = useCallback((orderDetails) => {

post('/product/' + productId + '/buy', {

referrer,

orderDetails,

});

}, [productId, referrer]); // ✅ Does not return a new function unnecessarily

// ...
```

If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:

```
const handleSubmit = useCallback((orderDetails) => {

// ..

}, [productId, referrer]);

console.log([productId, referrer]);
```

You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as `temp1` and the second one got saved as `temp2`, you can then use the browser console to check whether each dependency in both arrays is the same:

```
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?

Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?

Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
```

When you find which dependency is breaking memoization, either find a way to remove it, or [memoize it as well.](https://react.dev/reference/react/useMemo#memoizing-a-dependency-of-another-hook)

---

### I need to call `useCallback` for each list item in a loop, but it’s not allowed

Suppose the `Chart` component is wrapped in [`memo`](https://react.dev/reference/react/memo). You want to skip re-rendering every `Chart` in the list when the `ReportList` component re-renders. However, you can’t call `useCallback` in a loop:

```
function ReportList({ items }) {

return (

<article>

{items.map(item => {

// 🔴 You can't call useCallback in a loop like this:

const handleClick = useCallback(() => {

sendReport(item)

}, [item]);

return (

<figure key={item.id}>

<Chart onClick={handleClick} />

</figure>

);

})}

</article>

);

}
```

Instead, extract a component for an individual item, and put `useCallback` there:

```
function ReportList({ items }) {

return (

<article>

{items.map(item =>

<Report key={item.id} item={item} />

)}

</article>

);

}

function Report({ item }) {

// ✅ Call useCallback at the top level:

const handleClick = useCallback(() => {

sendReport(item)

}, [item]);

return (

<figure>

<Chart onClick={handleClick} />

</figure>

);

}
```

Alternatively, you could remove `useCallback` in the last snippet and instead wrap `Report` itself in [`memo`.](https://react.dev/reference/react/memo) If the `item` prop does not change, `Report` will skip re-rendering, so `Chart` will skip re-rendering too:

```
function ReportList({ items }) {

// ...

}

const Report = memo(function Report({ item }) {

function handleClick() {

sendReport(item);

}

return (

<figure>

<Chart onClick={handleClick} />

</figure>

);

});
```

[PrevioususeActionState](https://react.dev/reference/react/useActionState)[NextuseContext](https://react.dev/reference/react/useContext)

---

---


# useContext – React

URL: https://react.dev/reference/react/useContext

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useContext

`useContext` is a React Hook that lets you read and subscribe to [context](https://react.dev/learn/passing-data-deeply-with-context) from your component.

```
const value = useContext(SomeContext)
```

* [Reference](https://react.dev/reference/react/useContext#reference) 
  + [`useContext(SomeContext)`](https://react.dev/reference/react/useContext#usecontext)
* [Usage](https://react.dev/reference/react/useContext#usage) 
  + [Passing data deeply into the tree](https://react.dev/reference/react/useContext#passing-data-deeply-into-the-tree)
  + [Updating data passed via context](https://react.dev/reference/react/useContext#updating-data-passed-via-context)
  + [Specifying a fallback default value](https://react.dev/reference/react/useContext#specifying-a-fallback-default-value)
  + [Overriding context for a part of the tree](https://react.dev/reference/react/useContext#overriding-context-for-a-part-of-the-tree)
  + [Optimizing re-renders when passing objects and functions](https://react.dev/reference/react/useContext#optimizing-re-renders-when-passing-objects-and-functions)
* [Troubleshooting](https://react.dev/reference/react/useContext#troubleshooting) 
  + [My component doesn’t see the value from my provider](https://react.dev/reference/react/useContext#my-component-doesnt-see-the-value-from-my-provider)
  + [I am always getting `undefined` from my context although the default value is different](https://react.dev/reference/react/useContext#i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different)

---

## Reference

### `useContext(SomeContext)`

Call `useContext` at the top level of your component to read and subscribe to [context.](https://react.dev/learn/passing-data-deeply-with-context)

```
import { useContext } from 'react';

function MyComponent() {

const theme = useContext(ThemeContext);

// ...
```

[See more examples below.](https://react.dev/reference/react/useContext#usage)

#### Parameters

* `SomeContext`: The context that you’ve previously created with [`createContext`](https://react.dev/reference/react/createContext). The context itself does not hold the information, it only represents the kind of information you can provide or read from components.

#### Returns

`useContext` returns the context value for the calling component. It is determined as the `value` passed to the closest `SomeContext` above the calling component in the tree. If there is no such provider, then the returned value will be the `defaultValue` you have passed to [`createContext`](https://react.dev/reference/react/createContext) for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.

#### Caveats

* `useContext()` call in a component is not affected by providers returned from the *same* component. The corresponding `<Context>` **needs to be *above*** the component doing the `useContext()` call.
* React **automatically re-renders** all the children that use a particular context starting from the provider that receives a different `value`. The previous and the next values are compared with the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. Skipping re-renders with [`memo`](https://react.dev/reference/react/memo) does not prevent the children receiving fresh context values.
* If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if `SomeContext` that you use to provide context and `SomeContext` that you use to read it are ***exactly* the same object**, as determined by a `===` comparison.

---

## Usage

### Passing data deeply into the tree

Call `useContext` at the top level of your component to read and subscribe to [context.](https://react.dev/learn/passing-data-deeply-with-context)

```
import { useContext } from 'react';

function Button() {

const theme = useContext(ThemeContext);

// ...
```

`useContext` returns the context value for the context you passed. To determine the context value, React searches the component tree and finds **the closest context provider above** for that particular context.

To pass context to a `Button`, wrap it or one of its parent components into the corresponding context provider:

```
function MyPage() {

return (

<ThemeContext value="dark">

<Form />

</ThemeContext>

);

}

function Form() {

// ... renders buttons inside ...

}
```

It doesn’t matter how many layers of components there are between the provider and the `Button`. When a `Button` *anywhere* inside of `Form` calls `useContext(ThemeContext)`, it will receive `"dark"` as the value.

### Pitfall

`useContext()` always looks for the closest provider *above* the component that calls it. It searches upwards and **does not** consider providers in the component from which you’re calling `useContext()`.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext, useContext } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className}>
      {children}
    </button>
  );
}
```

Show more

---

### Updating data passed via context

Often, you’ll want the context to change over time. To update context, combine it with [state.](https://react.dev/reference/react/useState) Declare a state variable in the parent component, and pass the current state down as the context value to the provider.

```
function MyPage() {

const [theme, setTheme] = useState('dark');

return (

<ThemeContext value={theme}>

<Form />

<Button onClick={() => {

setTheme('light');

}}>

Switch to light theme

</Button>

</ThemeContext>

);

}
```

Now any `Button` inside of the provider will receive the current `theme` value. If you call `setTheme` to update the `theme` value that you pass to the provider, all `Button` components will re-render with the new `'light'` value.

#### Examples of updating context

1. Updating a value via context 2. Updating an object via context 3. Multiple contexts 4. Extracting providers to a component 5. Scaling up with context and a reducer

#### Example 1 of 5: Updating a value via context

In this example, the `MyApp` component holds a state variable which is then passed to the `ThemeContext` provider. Checking the “Dark mode” checkbox updates the state. Changing the provided value re-renders all the components using that context.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  const [theme, setTheme] = useState('light');
  return (
    <ThemeContext value={theme}>
      <Form />
      <label>
        <input
          type="checkbox"
          checked={theme === 'dark'}
          onChange={(e) => {
            setTheme(e.target.checked ? 'dark' : 'light')
          }}
        />
        Use dark mode
      </label>
    </ThemeContext>
  )
}

function Form({ children }) {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className}>
      {children}
    </button>
  );
}
```

Show more

Note that `value="dark"` passes the `"dark"` string, but `value={theme}` passes the value of the JavaScript `theme` variable with [JSX curly braces.](https://react.dev/learn/javascript-in-jsx-with-curly-braces) Curly braces also let you pass context values that aren’t strings.

Next Example

---

### Specifying a fallback default value

If React can’t find any providers of that particular context in the parent tree, the context value returned by `useContext()` will be equal to the default value that you specified when you [created that context](https://react.dev/reference/react/createContext):

```
const ThemeContext = createContext(null);
```

The default value **never changes**. If you want to update context, use it with state as [described above.](https://react.dev/reference/react/useContext#updating-data-passed-via-context)

Often, instead of `null`, there is some more meaningful value you can use as a default, for example:

```
const ThemeContext = createContext('light');
```

This way, if you accidentally render some component without a corresponding provider, it won’t break. This also helps your components work well in a test environment without setting up a lot of providers in the tests.

In the example below, the “Toggle theme” button is always light because it’s **outside any theme context provider** and the default context theme value is `'light'`. Try editing the default theme to be `'dark'`.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext('light');

export default function MyApp() {
  const [theme, setTheme] = useState('light');
  return (
    <>
      <ThemeContext value={theme}>
        <Form />
      </ThemeContext>
      <Button onClick={() => {
        setTheme(theme === 'dark' ? 'light' : 'dark');
      }}>
        Toggle theme
      </Button>
    </>
  )
}

function Form({ children }) {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ children, onClick }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className} onClick={onClick}>
      {children}
    </button>
  );
}
```

Show more

---

### Overriding context for a part of the tree

You can override the context for a part of the tree by wrapping that part in a provider with a different value.

```
<ThemeContext value="dark">

...

<ThemeContext value="light">

<Footer />

</ThemeContext>

...

</ThemeContext>
```

You can nest and override providers as many times as you need.

#### Examples of overriding context

1. Overriding a theme 2. Automatically nested headings

#### Example 1 of 2: Overriding a theme

Here, the button *inside* the `Footer` receives a different context value (`"light"`) than the buttons outside (`"dark"`).

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext, useContext } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
      <ThemeContext value="light">
        <Footer />
      </ThemeContext>
    </Panel>
  );
}

function Footer() {
  return (
    <footer>
      <Button>Settings</Button>
    </footer>
  );
}

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      {title && <h1>{title}</h1>}
      {children}
    </section>
  )
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className}>
      {children}
    </button>
  );
}
```

Show more

Next Example

---

### Optimizing re-renders when passing objects and functions

You can pass any values via context, including objects and functions.

```
function MyApp() {

const [currentUser, setCurrentUser] = useState(null);

function login(response) {

storeCredentials(response.credentials);

setCurrentUser(response.user);

}

return (

<AuthContext value={{ currentUser, login }}>

<Page />

</AuthContext>

);

}
```

Here, the context value is a JavaScript object with two properties, one of which is a function. Whenever `MyApp` re-renders (for example, on a route update), this will be a *different* object pointing at a *different* function, so React will also have to re-render all components deep in the tree that call `useContext(AuthContext)`.

In smaller apps, this is not a problem. However, there is no need to re-render them if the underlying data, like `currentUser`, has not changed. To help React take advantage of that fact, you may wrap the `login` function with [`useCallback`](https://react.dev/reference/react/useCallback) and wrap the object creation into [`useMemo`](https://react.dev/reference/react/useMemo). This is a performance optimization:

```
import { useCallback, useMemo } from 'react';

function MyApp() {

const [currentUser, setCurrentUser] = useState(null);

const login = useCallback((response) => {

storeCredentials(response.credentials);

setCurrentUser(response.user);

}, []);

const contextValue = useMemo(() => ({

currentUser,

login

}), [currentUser, login]);

return (

<AuthContext value={contextValue}>

<Page />

</AuthContext>

);

}
```

As a result of this change, even if `MyApp` needs to re-render, the components calling `useContext(AuthContext)` won’t need to re-render unless `currentUser` has changed.

Read more about [`useMemo`](https://react.dev/reference/react/useMemo#skipping-re-rendering-of-components) and [`useCallback`.](https://react.dev/reference/react/useCallback#skipping-re-rendering-of-components)

---

## Troubleshooting

### My component doesn’t see the value from my provider

There are a few common ways that this can happen:

1. You’re rendering `<SomeContext>` in the same component (or below) as where you’re calling `useContext()`. Move `<SomeContext>` *above and outside* the component calling `useContext()`.
2. You may have forgotten to wrap your component with `<SomeContext>`, or you might have put it in a different part of the tree than you thought. Check whether the hierarchy is right using [React DevTools.](https://react.dev/learn/react-developer-tools)
3. You might be running into some build issue with your tooling that causes `SomeContext` as seen from the providing component and `SomeContext` as seen by the reading component to be two different objects. This can happen if you use symlinks, for example. You can verify this by assigning them to globals like `window.SomeContext1` and `window.SomeContext2` and then checking whether `window.SomeContext1 === window.SomeContext2` in the console. If they’re not the same, fix that issue on the build tool level.

### I am always getting `undefined` from my context although the default value is different

You might have a provider without a `value` in the tree:

```
// 🚩 Doesn't work: no value prop

<ThemeContext>

<Button />

</ThemeContext>
```

If you forget to specify `value`, it’s like passing `value={undefined}`.

You may have also mistakingly used a different prop name by mistake:

```
// 🚩 Doesn't work: prop should be called "value"

<ThemeContext theme={theme}>

<Button />

</ThemeContext>
```

In both of these cases you should see a warning from React in the console. To fix them, call the prop `value`:

```
// ✅ Passing the value prop

<ThemeContext value={theme}>

<Button />

</ThemeContext>
```

Note that the [default value from your `createContext(defaultValue)` call](https://react.dev/reference/react/useContext#specifying-a-fallback-default-value) is only used **if there is no matching provider above at all.** If there is a `<SomeContext value={undefined}>` component somewhere in the parent tree, the component calling `useContext(SomeContext)` *will* receive `undefined` as the context value.

[PrevioususeCallback](https://react.dev/reference/react/useCallback)[NextuseDebugValue](https://react.dev/reference/react/useDebugValue)

---

---


# useDebugValue – React

URL: https://react.dev/reference/react/useDebugValue

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useDebugValue

`useDebugValue` is a React Hook that lets you add a label to a custom Hook in [React DevTools.](https://react.dev/learn/react-developer-tools)

```
useDebugValue(value, format?)
```

* [Reference](https://react.dev/reference/react/useDebugValue#reference) 
  + [`useDebugValue(value, format?)`](https://react.dev/reference/react/useDebugValue#usedebugvalue)
* [Usage](https://react.dev/reference/react/useDebugValue#usage) 
  + [Adding a label to a custom Hook](https://react.dev/reference/react/useDebugValue#adding-a-label-to-a-custom-hook)
  + [Deferring formatting of a debug value](https://react.dev/reference/react/useDebugValue#deferring-formatting-of-a-debug-value)

---

## Reference

### `useDebugValue(value, format?)`

Call `useDebugValue` at the top level of your [custom Hook](https://react.dev/learn/reusing-logic-with-custom-hooks) to display a readable debug value:

```
import { useDebugValue } from 'react';

function useOnlineStatus() {

// ...

useDebugValue(isOnline ? 'Online' : 'Offline');

// ...

}
```

[See more examples below.](https://react.dev/reference/react/useDebugValue#usage)

#### Parameters

* `value`: The value you want to display in React DevTools. It can have any type.
* **optional** `format`: A formatting function. When the component is inspected, React DevTools will call the formatting function with the `value` as the argument, and then display the returned formatted value (which may have any type). If you don’t specify the formatting function, the original `value` itself will be displayed.

#### Returns

`useDebugValue` does not return anything.

## Usage

### Adding a label to a custom Hook

Call `useDebugValue` at the top level of your [custom Hook](https://react.dev/learn/reusing-logic-with-custom-hooks) to display a readable debug value for [React DevTools.](https://react.dev/learn/react-developer-tools)

```
import { useDebugValue } from 'react';

function useOnlineStatus() {

// ...

useDebugValue(isOnline ? 'Online' : 'Offline');

// ...

}
```

This gives components calling `useOnlineStatus` a label like `OnlineStatus: "Online"` when you inspect them:

![A screenshot of React DevTools showing the debug value](https://react.dev/images/docs/react-devtools-usedebugvalue.png)

Without the `useDebugValue` call, only the underlying data (in this example, `true`) would be displayed.

App.jsuseOnlineStatus.js

useOnlineStatus.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useSyncExternalStore, useDebugValue } from 'react';

export function useOnlineStatus() {
  const isOnline = useSyncExternalStore(subscribe, () => navigator.onLine, () => true);
  useDebugValue(isOnline ? 'Online' : 'Offline');
  return isOnline;
}

function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}
```

Show more

### Note

Don’t add debug values to every custom Hook. It’s most valuable for custom Hooks that are part of shared libraries and that have a complex internal data structure that’s difficult to inspect.

---

### Deferring formatting of a debug value

You can also pass a formatting function as the second argument to `useDebugValue`:

```
useDebugValue(date, date => date.toDateString());
```

Your formatting function will receive the debug value as a parameter and should return a formatted display value. When your component is inspected, React DevTools will call this function and display its result.

This lets you avoid running potentially expensive formatting logic unless the component is actually inspected. For example, if `date` is a Date value, this avoids calling `toDateString()` on it for every render.

[PrevioususeContext](https://react.dev/reference/react/useContext)[NextuseDeferredValue](https://react.dev/reference/react/useDeferredValue)

---

---


# useDeferredValue – React

URL: https://react.dev/reference/react/useDeferredValue

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useDeferredValue

`useDeferredValue` is a React Hook that lets you defer updating a part of the UI.

```
const deferredValue = useDeferredValue(value)
```

* [Reference](https://react.dev/reference/react/useDeferredValue#reference) 
  + [`useDeferredValue(value, initialValue?)`](https://react.dev/reference/react/useDeferredValue#usedeferredvalue)
* [Usage](https://react.dev/reference/react/useDeferredValue#usage) 
  + [Showing stale content while fresh content is loading](https://react.dev/reference/react/useDeferredValue#showing-stale-content-while-fresh-content-is-loading)
  + [Indicating that the content is stale](https://react.dev/reference/react/useDeferredValue#indicating-that-the-content-is-stale)
  + [Deferring re-rendering for a part of the UI](https://react.dev/reference/react/useDeferredValue#deferring-re-rendering-for-a-part-of-the-ui)

---

## Reference

### `useDeferredValue(value, initialValue?)`

Call `useDeferredValue` at the top level of your component to get a deferred version of that value.

```
import { useState, useDeferredValue } from 'react';

function SearchPage() {

const [query, setQuery] = useState('');

const deferredQuery = useDeferredValue(query);

// ...

}
```

[See more examples below.](https://react.dev/reference/react/useDeferredValue#usage)

#### Parameters

* `value`: The value you want to defer. It can have any type.
* **optional** `initialValue`: A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead.

#### Returns

* `currentValue`: During the initial render, the returned deferred value will be the `initialValue`, or the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value).

#### Caveats

* When an update is inside a Transition, `useDeferredValue` always returns the new `value` and does not spawn a deferred render, since the update is already deferred.
* The values you pass to `useDeferredValue` should either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it to `useDeferredValue`, it will be different on every render, causing unnecessary background re-renders.
* When `useDeferredValue` receives a different value (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there’s another update to the `value`, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing.
* `useDeferredValue` is integrated with [`<Suspense>`.](https://react.dev/reference/react/Suspense) If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads.
* `useDeferredValue` does not by itself prevent extra network requests.
* There is no fixed delay caused by `useDeferredValue` itself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it.
* The background re-render caused by `useDeferredValue` does not fire Effects until it’s committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates.

---

## Usage

### Showing stale content while fresh content is loading

Call `useDeferredValue` at the top level of your component to defer updating some part of your UI.

```
import { useState, useDeferredValue } from 'react';

function SearchPage() {

const [query, setQuery] = useState('');

const deferredQuery = useDeferredValue(query);

// ...

}
```

During the initial render, the deferred value will be the same as the value you provided.

During updates, the deferred value will “lag behind” the latest value. In particular, React will first re-render *without* updating the deferred value, and then try to re-render with the newly received value in the background.

**Let’s walk through an example to see when this is useful.**

### Note

This example assumes you use a Suspense-enabled data source:

* Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/app/getting-started/fetching-data#with-suspense)
* Lazy-loading component code with [`lazy`](https://react.dev/reference/react/lazy)
* Reading the value of a Promise with [`use`](https://react.dev/reference/react/use)

[Learn more about Suspense and its limitations.](https://react.dev/reference/react/Suspense)

In this example, the `SearchResults` component [suspends](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading) while fetching the search results. Try typing `"a"`, waiting for the results, and then editing it to `"ab"`. The results for `"a"` get replaced by the loading fallback.

App.jsSearchResults.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={query} />
      </Suspense>
    </>
  );
}
```

Show more

A common alternative UI pattern is to *defer* updating the list of results and to keep showing the previous results until the new results are ready. Call `useDeferredValue` to pass a deferred version of the query down:

```
export default function App() {

const [query, setQuery] = useState('');

const deferredQuery = useDeferredValue(query);

return (

<>

<label>

Search albums:

<input value={query} onChange={e => setQuery(e.target.value)} />

</label>

<Suspense fallback={<h2>Loading...</h2>}>

<SearchResults query={deferredQuery} />

</Suspense>

</>

);

}
```

The `query` will update immediately, so the input will display the new value. However, the `deferredQuery` will keep its previous value until the data has loaded, so `SearchResults` will show the stale results for a bit.

Enter `"a"` in the example below, wait for the results to load, and then edit the input to `"ab"`. Notice how instead of the Suspense fallback, you now see the stale result list until the new results have loaded:

App.jsSearchResults.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={deferredQuery} />
      </Suspense>
    </>
  );
}
```

Show more

##### Deep Dive

#### How does deferring a value work under the hood?

Show Details

You can think of it as happening in two steps:

1. **First, React re-renders with the new `query` (`"ab"`) but with the old `deferredQuery` (still `"a"`).** The `deferredQuery` value, which you pass to the result list, is *deferred:* it “lags behind” the `query` value.
2. **In the background, React tries to re-render with *both* `query` and `deferredQuery` updated to `"ab"`.** If this re-render completes, React will show it on the screen. However, if it suspends (the results for `"ab"` have not loaded yet), React will abandon this rendering attempt, and retry this re-render again after the data has loaded. The user will keep seeing the stale deferred value until the data is ready.

The deferred “background” rendering is interruptible. For example, if you type into the input again, React will abandon it and restart with the new value. React will always use the latest provided value.

Note that there is still a network request per each keystroke. What’s being deferred here is displaying results (until they’re ready), not the network requests themselves. Even if the user continues typing, responses for each keystroke get cached, so pressing Backspace is instant and doesn’t fetch again.

---

### Indicating that the content is stale

In the example above, there is no indication that the result list for the latest query is still loading. This can be confusing to the user if the new results take a while to load. To make it more obvious to the user that the result list does not match the latest query, you can add a visual indication when the stale result list is displayed:

```
<div style={{

opacity: query !== deferredQuery ? 0.5 : 1,

}}>

<SearchResults query={deferredQuery} />

</div>
```

With this change, as soon as you start typing, the stale result list gets slightly dimmed until the new result list loads. You can also add a CSS transition to delay dimming so that it feels gradual, like in the example below:

App.jsSearchResults.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <div style={{
          opacity: isStale ? 0.5 : 1,
          transition: isStale ? 'opacity 0.2s 0.2s linear' : 'opacity 0s 0s linear'
        }}>
          <SearchResults query={deferredQuery} />
        </div>
      </Suspense>
    </>
  );
}
```

Show more

---

### Deferring re-rendering for a part of the UI

You can also apply `useDeferredValue` as a performance optimization. It is useful when a part of your UI is slow to re-render, there’s no easy way to optimize it, and you want to prevent it from blocking the rest of the UI.

Imagine you have a text field and a component (like a chart or a long list) that re-renders on every keystroke:

```
function App() {

const [text, setText] = useState('');

return (

<>

<input value={text} onChange={e => setText(e.target.value)} />

<SlowList text={text} />

</>

);

}
```

First, optimize `SlowList` to skip re-rendering when its props are the same. To do this, [wrap it in `memo`:](https://react.dev/reference/react/memo#skipping-re-rendering-when-props-are-unchanged)

```
const SlowList = memo(function SlowList({ text }) {

// ...

});
```

However, this only helps if the `SlowList` props are *the same* as during the previous render. The problem you’re facing now is that it’s slow when they’re *different,* and when you actually need to show different visual output.

Concretely, the main performance problem is that whenever you type into the input, the `SlowList` receives new props, and re-rendering its entire tree makes the typing feel janky. In this case, `useDeferredValue` lets you prioritize updating the input (which must be fast) over updating the result list (which is allowed to be slower):

```
function App() {

const [text, setText] = useState('');

const deferredText = useDeferredValue(text);

return (

<>

<input value={text} onChange={e => setText(e.target.value)} />

<SlowList text={deferredText} />

</>

);

}
```

This does not make re-rendering of the `SlowList` faster. However, it tells React that re-rendering the list can be deprioritized so that it doesn’t block the keystrokes. The list will “lag behind” the input and then “catch up”. Like before, React will attempt to update the list as soon as possible, but will not block the user from typing.

#### The difference between useDeferredValue and unoptimized re-rendering

1. Deferred re-rendering of the list 2. Unoptimized re-rendering of the list

#### Example 1 of 2: Deferred re-rendering of the list

In this example, each item in the `SlowList` component is **artificially slowed down** so that you can see how `useDeferredValue` lets you keep the input responsive. Type into the input and notice that typing feels snappy while the list “lags behind” it.

App.jsSlowList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useDeferredValue } from 'react';
import SlowList from './SlowList.js';

export default function App() {
  const [text, setText] = useState('');
  const deferredText = useDeferredValue(text);
  return (
    <>
      <input value={text} onChange={e => setText(e.target.value)} />
      <SlowList text={deferredText} />
    </>
  );
}
```

Next Example

### Pitfall

This optimization requires `SlowList` to be wrapped in [`memo`.](https://react.dev/reference/react/memo) This is because whenever the `text` changes, React needs to be able to re-render the parent component quickly. During that re-render, `deferredText` still has its previous value, so `SlowList` is able to skip re-rendering (its props have not changed). Without [`memo`,](https://react.dev/reference/react/memo) it would have to re-render anyway, defeating the point of the optimization.

##### Deep Dive

#### How is deferring a value different from debouncing and throttling?

Show Details

There are two common optimization techniques you might have used before in this scenario:

* *Debouncing* means you’d wait for the user to stop typing (e.g. for a second) before updating the list.
* *Throttling* means you’d update the list every once in a while (e.g. at most once a second).

While these techniques are helpful in some cases, `useDeferredValue` is better suited to optimizing rendering because it is deeply integrated with React itself and adapts to the user’s device.

Unlike debouncing or throttling, it doesn’t require choosing any fixed delay. If the user’s device is fast (e.g. powerful laptop), the deferred re-render would happen almost immediately and wouldn’t be noticeable. If the user’s device is slow, the list would “lag behind” the input proportionally to how slow the device is.

Also, unlike with debouncing or throttling, deferred re-renders done by `useDeferredValue` are interruptible by default. This means that if React is in the middle of re-rendering a large list, but the user makes another keystroke, React will abandon that re-render, handle the keystroke, and then start rendering in the background again. By contrast, debouncing and throttling still produce a janky experience because they’re *blocking:* they merely postpone the moment when rendering blocks the keystroke.

If the work you’re optimizing doesn’t happen during rendering, debouncing and throttling are still useful. For example, they can let you fire fewer network requests. You can also use these techniques together.

[PrevioususeDebugValue](https://react.dev/reference/react/useDebugValue)[NextuseEffect](https://react.dev/reference/react/useEffect)

---

---


# useEffect – React

URL: https://react.dev/reference/react/useEffect

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useEffect

`useEffect` is a React Hook that lets you [synchronize a component with an external system.](https://react.dev/learn/synchronizing-with-effects)

```
useEffect(setup, dependencies?)
```

* [Reference](https://react.dev/reference/react/useEffect#reference) 
  + [`useEffect(setup, dependencies?)`](https://react.dev/reference/react/useEffect#useeffect)
* [Usage](https://react.dev/reference/react/useEffect#usage) 
  + [Connecting to an external system](https://react.dev/reference/react/useEffect#connecting-to-an-external-system)
  + [Wrapping Effects in custom Hooks](https://react.dev/reference/react/useEffect#wrapping-effects-in-custom-hooks)
  + [Controlling a non-React widget](https://react.dev/reference/react/useEffect#controlling-a-non-react-widget)
  + [Fetching data with Effects](https://react.dev/reference/react/useEffect#fetching-data-with-effects)
  + [Specifying reactive dependencies](https://react.dev/reference/react/useEffect#specifying-reactive-dependencies)
  + [Updating state based on previous state from an Effect](https://react.dev/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect)
  + [Removing unnecessary object dependencies](https://react.dev/reference/react/useEffect#removing-unnecessary-object-dependencies)
  + [Removing unnecessary function dependencies](https://react.dev/reference/react/useEffect#removing-unnecessary-function-dependencies)
  + [Reading the latest props and state from an Effect](https://react.dev/reference/react/useEffect#reading-the-latest-props-and-state-from-an-effect)
  + [Displaying different content on the server and the client](https://react.dev/reference/react/useEffect#displaying-different-content-on-the-server-and-the-client)
* [Troubleshooting](https://react.dev/reference/react/useEffect#troubleshooting) 
  + [My Effect runs twice when the component mounts](https://react.dev/reference/react/useEffect#my-effect-runs-twice-when-the-component-mounts)
  + [My Effect runs after every re-render](https://react.dev/reference/react/useEffect#my-effect-runs-after-every-re-render)
  + [My Effect keeps re-running in an infinite cycle](https://react.dev/reference/react/useEffect#my-effect-keeps-re-running-in-an-infinite-cycle)
  + [My cleanup logic runs even though my component didn’t unmount](https://react.dev/reference/react/useEffect#my-cleanup-logic-runs-even-though-my-component-didnt-unmount)
  + [My Effect does something visual, and I see a flicker before it runs](https://react.dev/reference/react/useEffect#my-effect-does-something-visual-and-i-see-a-flicker-before-it-runs)

---

## Reference

### `useEffect(setup, dependencies?)`

Call `useEffect` at the top level of your component to declare an Effect:

```
import { useState, useEffect } from 'react';

import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, [serverUrl, roomId]);

// ...

}
```

[See more examples below.](https://react.dev/reference/react/useEffect#usage)

#### Parameters

* `setup`: The function with your Effect’s logic. Your setup function may also optionally return a *cleanup* function. When your [component commits](https://react.dev/learn/render-and-commit#step-3-react-commits-changes-to-the-dom), React will run your setup function. After every commit with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function.
* **optional** `dependencies`: The list of all reactive values referenced inside of the `setup` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. If you omit this argument, your Effect will re-run after every commit of the component. [See the difference between passing an array of dependencies, an empty array, and no dependencies at all.](https://react.dev/reference/react/useEffect#examples-dependencies)

#### Returns

`useEffect` returns `undefined`.

#### Caveats

* `useEffect` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
* If you’re **not trying to synchronize with some external system,** [you probably don’t need an Effect.](https://react.dev/learn/you-might-not-need-an-effect)
* When Strict Mode is on, React will **run one extra development-only setup+cleanup cycle** before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, [implement the cleanup function.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)
* If some of your dependencies are objects or functions defined inside the component, there is a risk that they will **cause the Effect to re-run more often than needed.** To fix this, remove unnecessary [object](https://react.dev/reference/react/useEffect#removing-unnecessary-object-dependencies) and [function](https://react.dev/reference/react/useEffect#removing-unnecessary-function-dependencies) dependencies. You can also [extract state updates](https://react.dev/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect) and [non-reactive logic](https://react.dev/reference/react/useEffect#reading-the-latest-props-and-state-from-an-effect) outside of your Effect.
* If your Effect wasn’t caused by an interaction (like a click), React will generally let the browser **paint the updated screen first before running your Effect.** If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace `useEffect` with [`useLayoutEffect`.](https://react.dev/reference/react/useLayoutEffect)
* If your Effect is caused by an interaction (like a click), **React may run your Effect before the browser paints the updated screen**. This ensures that the result of the Effect can be observed by the event system. Usually, this works as expected. However, if you must defer the work until after paint, such as an `alert()`, you can use `setTimeout`. See [reactwg/react-18/128](https://github.com/reactwg/react-18/discussions/128) for more information.
* Even if your Effect was caused by an interaction (like a click), **React may allow the browser to repaint the screen before processing the state updates inside your Effect.** Usually, this works as expected. However, if you must block the browser from repainting the screen, you need to replace `useEffect` with [`useLayoutEffect`.](https://react.dev/reference/react/useLayoutEffect)
* Effects **only run on the client.** They don’t run during server rendering.

---

## Usage

### Connecting to an external system

Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren’t controlled by React, so they are called *external.*

To [connect your component to some external system,](https://react.dev/learn/synchronizing-with-effects) call `useEffect` at the top level of your component:

```
import { useState, useEffect } from 'react';

import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, [serverUrl, roomId]);

// ...

}
```

You need to pass two arguments to `useEffect`:

1. A *setup function* with setup code that connects to that system.
   * It should return a *cleanup function* with cleanup code that disconnects from that system.
2. A list of dependencies including every value from your component used inside of those functions.

**React calls your setup and cleanup functions whenever it’s necessary, which may happen multiple times:**

1. Your setup code runs when your component is added to the page *(mounts)*.
2. After every commit of your component where the dependencies have changed:
   * First, your cleanup code runs with the old props and state.
   * Then, your setup code runs with the new props and state.
3. Your cleanup code runs one final time after your component is removed from the page *(unmounts).*

**Let’s illustrate this sequence for the example above.**

When the `ChatRoom` component above gets added to the page, it will connect to the chat room with the initial `serverUrl` and `roomId`. If either `serverUrl` or `roomId` change as a result of a commit (say, if the user picks a different chat room in a dropdown), your Effect will *disconnect from the previous room, and connect to the next one.* When the `ChatRoom` component is removed from the page, your Effect will disconnect one last time.

**To [help you find bugs,](https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) in development React runs setup and cleanup one extra time before the setup.** This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a *setup* → *cleanup* → *setup* sequence (as in development). [See common solutions.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)

**Try to [write every Effect as an independent process](https://react.dev/learn/lifecycle-of-reactive-effects#each-effect-represents-a-separate-synchronization-process) and [think about a single setup/cleanup cycle at a time.](https://react.dev/learn/lifecycle-of-reactive-effects#thinking-from-the-effects-perspective)** It shouldn’t matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly “mirrors” the setup logic, your Effect is resilient to running setup and cleanup as often as needed.

### Note

An Effect lets you [keep your component synchronized](https://react.dev/learn/synchronizing-with-effects) with some external system (like a chat service). Here, *external system* means any piece of code that’s not controlled by React, such as:

* A timer managed with [`setInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) and [`clearInterval()`](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval).
* An event subscription using [`window.addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) and [`window.removeEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener).
* A third-party animation library with an API like `animation.start()` and `animation.reset()`.

**If you’re not connecting to any external system, [you probably don’t need an Effect.](https://react.dev/learn/you-might-not-need-an-effect)**

#### Examples of connecting to an external system

1. Connecting to a chat server 2. Listening to a global browser event 3. Triggering an animation 4. Controlling a modal dialog 5. Tracking element visibility

#### Example 1 of 5: Connecting to a chat server

In this example, the `ChatRoom` component uses an Effect to stay connected to an external system defined in `chat.js`. Press “Open chat” to make the `ChatRoom` component appear. This sandbox runs in development mode, so there is an extra connect-and-disconnect cycle, as [explained here.](https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) Try changing the `roomId` and `serverUrl` using the dropdown and the input, and see how the Effect re-connects to the chat. Press “Close chat” to see the Effect disconnect one last time.

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}
```

Show more

Next Example

---

### Wrapping Effects in custom Hooks

Effects are an [“escape hatch”:](https://react.dev/learn/escape-hatches) you use them when you need to “step outside React” and when there is no better built-in solution for your use case. If you find yourself often needing to manually write Effects, it’s usually a sign that you need to extract some [custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks) for common behaviors your components rely on.

For example, this `useChatRoom` custom Hook “hides” the logic of your Effect behind a more declarative API:

```
function useChatRoom({ serverUrl, roomId }) {

useEffect(() => {

const options = {

serverUrl: serverUrl,

roomId: roomId

};

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [roomId, serverUrl]);

}
```

Then you can use it from any component like this:

```
function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

useChatRoom({

roomId: roomId,

serverUrl: serverUrl

});

// ...
```

There are also many excellent custom Hooks for every purpose available in the React ecosystem.

[Learn more about wrapping Effects in custom Hooks.](https://react.dev/learn/reusing-logic-with-custom-hooks)

#### Examples of wrapping Effects in custom Hooks

1. Custom `useChatRoom` Hook 2. Custom `useWindowListener` Hook 3. Custom `useIntersectionObserver` Hook

#### Example 1 of 3: Custom `useChatRoom` Hook

This example is identical to one of the [earlier examples,](https://react.dev/reference/react/useEffect#examples-connecting) but the logic is extracted to a custom Hook.

App.jsuseChatRoom.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { useChatRoom } from './useChatRoom.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl
  });

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  const [show, setShow] = useState(false);
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <button onClick={() => setShow(!show)}>
        {show ? 'Close chat' : 'Open chat'}
      </button>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId} />}
    </>
  );
}
```

Show more

Next Example

---

### Controlling a non-React widget

Sometimes, you want to keep an external system synchronized to some prop or state of your component.

For example, if you have a third-party map widget or a video player component written without React, you can use an Effect to call methods on it that make its state match the current state of your React component. This Effect creates an instance of a `MapWidget` class defined in `map-widget.js`. When you change the `zoomLevel` prop of the `Map` component, the Effect calls the `setZoom()` on the class instance to keep it synchronized:

App.jsMap.jsmap-widget.js

Map.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useEffect } from 'react';
import { MapWidget } from './map-widget.js';

export default function Map({ zoomLevel }) {
  const containerRef = useRef(null);
  const mapRef = useRef(null);

  useEffect(() => {
    if (mapRef.current === null) {
      mapRef.current = new MapWidget(containerRef.current);
    }

    const map = mapRef.current;
    map.setZoom(zoomLevel);
  }, [zoomLevel]);

  return (
    <div
      style={{ width: 200, height: 200 }}
      ref={containerRef}
    />
  );
}
```

Show more

In this example, a cleanup function is not needed because the `MapWidget` class manages only the DOM node that was passed to it. After the `Map` React component is removed from the tree, both the DOM node and the `MapWidget` class instance will be automatically garbage-collected by the browser JavaScript engine.

---

### Fetching data with Effects

You can use an Effect to fetch data for your component. Note that [if you use a framework,](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) using your framework’s data fetching mechanism will be a lot more efficient than writing Effects manually.

If you want to fetch data from an Effect manually, your code might look like this:

```
import { useState, useEffect } from 'react';

import { fetchBio } from './api.js';

export default function Page() {

const [person, setPerson] = useState('Alice');

const [bio, setBio] = useState(null);

useEffect(() => {

let ignore = false;

setBio(null);

fetchBio(person).then(result => {

if (!ignore) {

setBio(result);

}

});

return () => {

ignore = true;

};

}, [person]);

// ...
```

Note the `ignore` variable which is initialized to `false`, and is set to `true` during cleanup. This ensures [your code doesn’t suffer from “race conditions”:](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect) network responses may arrive in a different order than you sent them.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);
  useEffect(() => {
    let ignore = false;
    setBio(null);
    fetchBio(person).then(result => {
      if (!ignore) {
        setBio(result);
      }
    });
    return () => {
      ignore = true;
    }
  }, [person]);

  return (
    <>
      <select value={person} onChange={e => {
        setPerson(e.target.value);
      }}>
        <option value="Alice">Alice</option>
        <option value="Bob">Bob</option>
        <option value="Taylor">Taylor</option>
      </select>
      <hr />
      <p><i>{bio ?? 'Loading...'}</i></p>
    </>
  );
}
```

Show more

You can also rewrite using the [`async` / `await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) syntax, but you still need to provide a cleanup function:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { fetchBio } from './api.js';

export default function Page() {
  const [person, setPerson] = useState('Alice');
  const [bio, setBio] = useState(null);
  useEffect(() => {
    async function startFetching() {
      setBio(null);
      const result = await fetchBio(person);
      if (!ignore) {
        setBio(result);
      }
    }

    let ignore = false;
    startFetching();
    return () => {
      ignore = true;
    }
  }, [person]);

  return (
    <>
      <select value={person} onChange={e => {
        setPerson(e.target.value);
      }}>
        <option value="Alice">Alice</option>
        <option value="Bob">Bob</option>
        <option value="Taylor">Taylor</option>
      </select>
      <hr />
      <p><i>{bio ?? 'Loading...'}</i></p>
    </>
  );
}
```

Show more

Writing data fetching directly in Effects gets repetitive and makes it difficult to add optimizations like caching and server rendering later. [It’s easier to use a custom Hook—either your own or maintained by the community.](https://react.dev/learn/reusing-logic-with-custom-hooks#when-to-use-custom-hooks)

##### Deep Dive

#### What are good alternatives to data fetching in Effects?

Show Details

Writing `fetch` calls inside Effects is a [popular way to fetch data](https://www.robinwieruch.de/react-hooks-fetch-data/), especially in fully client-side apps. This is, however, a very manual approach and it has significant downsides:

* **Effects don’t run on the server.** This means that the initial server-rendered HTML will only include a loading state with no data. The client computer will have to download all JavaScript and render your app only to discover that now it needs to load the data. This is not very efficient.
* **Fetching directly in Effects makes it easy to create “network waterfalls”.** You render the parent component, it fetches some data, renders the child components, and then they start fetching their data. If the network is not very fast, this is significantly slower than fetching all data in parallel.
* **Fetching directly in Effects usually means you don’t preload or cache data.** For example, if the component unmounts and then mounts again, it would have to fetch the data again.
* **It’s not very ergonomic.** There’s quite a bit of boilerplate code involved when writing `fetch` calls in a way that doesn’t suffer from bugs like [race conditions.](https://maxrozen.com/race-conditions-fetching-data-react-with-useeffect)

This list of downsides is not specific to React. It applies to fetching data on mount with any library. Like with routing, data fetching is not trivial to do well, so we recommend the following approaches:

* **If you use a [framework](https://react.dev/learn/creating-a-react-app#full-stack-frameworks), use its built-in data fetching mechanism.** Modern React frameworks have integrated data fetching mechanisms that are efficient and don’t suffer from the above pitfalls.
* **Otherwise, consider using or building a client-side cache.** Popular open source solutions include [TanStack Query](https://tanstack.com/query/latest/), [useSWR](https://swr.vercel.app/), and [React Router 6.4+.](https://beta.reactrouter.com/en/main/start/overview) You can build your own solution too, in which case you would use Effects under the hood but also add logic for deduplicating requests, caching responses, and avoiding network waterfalls (by preloading data or hoisting data requirements to routes).

You can continue fetching data directly in Effects if neither of these approaches suit you.

---

### Specifying reactive dependencies

**Notice that you can’t “choose” the dependencies of your Effect.** Every reactive value used by your Effect’s code must be declared as a dependency. Your Effect’s dependency list is determined by the surrounding code:

```
function ChatRoom({ roomId }) { // This is a reactive value

const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // This is a reactive value too

useEffect(() => {

const connection = createConnection(serverUrl, roomId); // This Effect reads these reactive values

connection.connect();

return () => connection.disconnect();

}, [serverUrl, roomId]); // ✅ So you must specify them as dependencies of your Effect

// ...

}
```

If either `serverUrl` or `roomId` change, your Effect will reconnect to the chat using the new values.

**[Reactive values](https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) include props and all variables and functions declared directly inside of your component.** Since `roomId` and `serverUrl` are reactive values, you can’t remove them from the dependencies. If you try to omit them and [your linter is correctly configured for React,](https://react.dev/learn/editor-setup#linting) the linter will flag this as a mistake you need to fix:

```
function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => connection.disconnect();

}, []); // 🔴 React Hook useEffect has missing dependencies: 'roomId' and 'serverUrl'

// ...

}
```

**To remove a dependency, you need to [“prove” to the linter that it *doesn’t need* to be a dependency.](https://react.dev/learn/removing-effect-dependencies#removing-unnecessary-dependencies)** For example, you can move `serverUrl` out of your component to prove that it’s not reactive and won’t change on re-renders:

```
const serverUrl = 'https://localhost:1234'; // Not a reactive value anymore

function ChatRoom({ roomId }) {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => connection.disconnect();

}, [roomId]); // ✅ All dependencies declared

// ...

}
```

Now that `serverUrl` is not a reactive value (and can’t change on a re-render), it doesn’t need to be a dependency. **If your Effect’s code doesn’t use any reactive values, its dependency list should be empty (`[]`):**

```
const serverUrl = 'https://localhost:1234'; // Not a reactive value anymore

const roomId = 'music'; // Not a reactive value anymore

function ChatRoom() {

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => connection.disconnect();

}, []); // ✅ All dependencies declared

// ...

}
```

[An Effect with empty dependencies](https://react.dev/learn/lifecycle-of-reactive-effects#what-an-effect-with-empty-dependencies-means) doesn’t re-run when any of your component’s props or state change.

### Pitfall

If you have an existing codebase, you might have some Effects that suppress the linter like this:

```
useEffect(() => {

// ...

// 🔴 Avoid suppressing the linter like this:

// eslint-ignore-next-line react-hooks/exhaustive-deps

}, []);
```

**When dependencies don’t match the code, there is a high risk of introducing bugs.** By suppressing the linter, you “lie” to React about the values your Effect depends on. [Instead, prove they’re unnecessary.](https://react.dev/learn/removing-effect-dependencies#removing-unnecessary-dependencies)

#### Examples of passing reactive dependencies

1. Passing a dependency array 2. Passing an empty dependency array 3. Passing no dependency array at all

#### Example 1 of 3: Passing a dependency array

If you specify the dependencies, your Effect runs **after the initial commit *and* after commits with changed dependencies.**

```
useEffect(() => {

// ...

}, [a, b]); // Runs again if a or b are different
```

In the below example, `serverUrl` and `roomId` are [reactive values,](https://react.dev/learn/lifecycle-of-reactive-effects#effects-react-to-reactive-values) so they both must be specified as dependencies. As a result, selecting a different room in the dropdown or editing the server URL input causes the chat to re-connect. However, since `message` isn’t used in the Effect (and so it isn’t a dependency), editing the message doesn’t re-connect to the chat.

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
      <label>
        Your message:{' '}
        <input value={message} onChange={e => setMessage(e.target.value)} />
      </label>
    </>
  );
}

export default function App() {
  const [show, setShow] = useState(false);
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
        <button onClick={() => setShow(!show)}>
          {show ? 'Close chat' : 'Open chat'}
        </button>
      </label>
      {show && <hr />}
      {show && <ChatRoom roomId={roomId}/>}
    </>
  );
}
```

Show more

Next Example

---

### Updating state based on previous state from an Effect

When you want to update state based on previous state from an Effect, you might run into a problem:

```
function Counter() {

const [count, setCount] = useState(0);

useEffect(() => {

const intervalId = setInterval(() => {

setCount(count + 1); // You want to increment the counter every second...

}, 1000)

return () => clearInterval(intervalId);

}, [count]); // 🚩 ... but specifying `count` as a dependency always resets the interval.

// ...

}
```

Since `count` is a reactive value, it must be specified in the list of dependencies. However, that causes the Effect to cleanup and setup again every time the `count` changes. This is not ideal.

To fix this, [pass the `c => c + 1` state updater](https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state) to `setCount`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const intervalId = setInterval(() => {
      setCount(c => c + 1); // ✅ Pass a state updater
    }, 1000);
    return () => clearInterval(intervalId);
  }, []); // ✅ Now count is not a dependency

  return <h1>{count}</h1>;
}
```

Now that you’re passing `c => c + 1` instead of `count + 1`, [your Effect no longer needs to depend on `count`.](https://react.dev/learn/removing-effect-dependencies#are-you-reading-some-state-to-calculate-the-next-state) As a result of this fix, it won’t need to cleanup and setup the interval again every time the `count` changes.

---

### Removing unnecessary object dependencies

If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every commit because the `options` object is [different for every render:](https://react.dev/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally)

```
const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

const options = { // 🚩 This object is created from scratch on every re-render

serverUrl: serverUrl,

roomId: roomId

};

useEffect(() => {

const connection = createConnection(options); // It's used inside the Effect

connection.connect();

return () => connection.disconnect();

}, [options]); // 🚩 As a result, these dependencies are always different on a commit

// ...
```

Avoid using an object created during rendering as a dependency. Instead, create the object inside the Effect:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

Now that you create the `options` object inside the Effect, the Effect itself only depends on the `roomId` string.

With this fix, typing into the input doesn’t reconnect the chat. Unlike an object which gets re-created, a string like `roomId` doesn’t change unless you set it to another value. [Read more about removing dependencies.](https://react.dev/learn/removing-effect-dependencies)

---

### Removing unnecessary function dependencies

If your Effect depends on an object or a function created during rendering, it might run too often. For example, this Effect re-connects after every commit because the `createOptions` function is [different for every render:](https://react.dev/learn/removing-effect-dependencies#does-some-reactive-value-change-unintentionally)

```
function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

function createOptions() { // 🚩 This function is created from scratch on every re-render

return {

serverUrl: serverUrl,

roomId: roomId

};

}

useEffect(() => {

const options = createOptions(); // It's used inside the Effect

const connection = createConnection();

connection.connect();

return () => connection.disconnect();

}, [createOptions]); // 🚩 As a result, these dependencies are always different on a commit

// ...
```

By itself, creating a function from scratch on every re-render is not a problem. You don’t need to optimize that. However, if you use it as a dependency of your Effect, it will cause your Effect to re-run after every commit.

Avoid using a function created during rendering as a dependency. Instead, declare it inside the Effect:

App.jschat.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    function createOptions() {
      return {
        serverUrl: serverUrl,
        roomId: roomId
      };
    }

    const options = createOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]);

  return (
    <>
      <h1>Welcome to the {roomId} room!</h1>
      <input value={message} onChange={e => setMessage(e.target.value)} />
    </>
  );
}

export default function App() {
  const [roomId, setRoomId] = useState('general');
  return (
    <>
      <label>
        Choose the chat room:{' '}
        <select
          value={roomId}
          onChange={e => setRoomId(e.target.value)}
        >
          <option value="general">general</option>
          <option value="travel">travel</option>
          <option value="music">music</option>
        </select>
      </label>
      <hr />
      <ChatRoom roomId={roomId} />
    </>
  );
}
```

Show more

Now that you define the `createOptions` function inside the Effect, the Effect itself only depends on the `roomId` string. With this fix, typing into the input doesn’t reconnect the chat. Unlike a function which gets re-created, a string like `roomId` doesn’t change unless you set it to another value. [Read more about removing dependencies.](https://react.dev/learn/removing-effect-dependencies)

---

### Reading the latest props and state from an Effect

By default, when you read a reactive value from an Effect, you have to add it as a dependency. This ensures that your Effect “reacts” to every change of that value. For most dependencies, that’s the behavior you want.

**However, sometimes you’ll want to read the *latest* props and state from an Effect without “reacting” to them.** For example, imagine you want to log the number of the items in the shopping cart for every page visit:

```
function Page({ url, shoppingCart }) {

useEffect(() => {

logVisit(url, shoppingCart.length);

}, [url, shoppingCart]); // ✅ All dependencies declared

// ...

}
```

**What if you want to log a new page visit after every `url` change, but *not* if only the `shoppingCart` changes?** You can’t exclude `shoppingCart` from dependencies without breaking the [reactivity rules.](https://react.dev/reference/react/useEffect#specifying-reactive-dependencies) However, you can express that you *don’t want* a piece of code to “react” to changes even though it is called from inside an Effect. [Declare an *Effect Event*](https://react.dev/learn/separating-events-from-effects#declaring-an-effect-event) with the [`useEffectEvent`](https://react.dev/reference/react/useEffectEvent) Hook, and move the code reading `shoppingCart` inside of it:

```
function Page({ url, shoppingCart }) {

const onVisit = useEffectEvent(visitedUrl => {

logVisit(visitedUrl, shoppingCart.length)

});

useEffect(() => {

onVisit(url);

}, [url]); // ✅ All dependencies declared

// ...

}
```

**Effect Events are not reactive and must always be omitted from dependencies of your Effect.** This is what lets you put non-reactive code (where you can read the latest value of some props and state) inside of them. By reading `shoppingCart` inside of `onVisit`, you ensure that `shoppingCart` won’t re-run your Effect.

[Read more about how Effect Events let you separate reactive and non-reactive code.](https://react.dev/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events)

---

### Displaying different content on the server and the client

If your app uses server rendering (either [directly](https://react.dev/reference/react-dom/server) or via a [framework](https://react.dev/learn/creating-a-react-app#full-stack-frameworks)), your component will render in two different environments. On the server, it will render to produce the initial HTML. On the client, React will run the rendering code again so that it can attach your event handlers to that HTML. This is why, for [hydration](https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-server-rendered-html) to work, your initial render output must be identical on the client and the server.

In rare cases, you might need to display different content on the client. For example, if your app reads some data from [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage), it can’t possibly do that on the server. Here is how you could implement this:

```
function MyComponent() {

const [didMount, setDidMount] = useState(false);

useEffect(() => {

setDidMount(true);

}, []);

if (didMount) {

// ... return client-only JSX ...

}  else {

// ... return initial JSX ...

}

}
```

While the app is loading, the user will see the initial render output. Then, when it’s loaded and hydrated, your Effect will run and set `didMount` to `true`, triggering a re-render. This will switch to the client-only render output. Effects don’t run on the server, so this is why `didMount` was `false` during the initial server render.

Use this pattern sparingly. Keep in mind that users with a slow connection will see the initial content for quite a bit of time—potentially, many seconds—so you don’t want to make jarring changes to your component’s appearance. In many cases, you can avoid the need for this by conditionally showing different things with CSS.

---

## Troubleshooting

### My Effect runs twice when the component mounts

When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup.

This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development).

Read more about [how this helps find bugs](https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed) and [how to fix your logic.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)

---

### My Effect runs after every re-render

First, check that you haven’t forgotten to specify the dependency array:

```
useEffect(() => {

// ...

}); // 🚩 No dependency array: re-runs after every commit!
```

If you’ve specified the dependency array but your Effect still re-runs in a loop, it’s because one of your dependencies is different on every re-render.

You can debug this problem by manually logging your dependencies to the console:

```
useEffect(() => {

// ..

}, [serverUrl, roomId]);

console.log([serverUrl, roomId]);
```

You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as `temp1` and the second one got saved as `temp2`, you can then use the browser console to check whether each dependency in both arrays is the same:

```
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?

Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?

Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
```

When you find the dependency that is different on every re-render, you can usually fix it in one of these ways:

* [Updating state based on previous state from an Effect](https://react.dev/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect)
* [Removing unnecessary object dependencies](https://react.dev/reference/react/useEffect#removing-unnecessary-object-dependencies)
* [Removing unnecessary function dependencies](https://react.dev/reference/react/useEffect#removing-unnecessary-function-dependencies)
* [Reading the latest props and state from an Effect](https://react.dev/reference/react/useEffect#reading-the-latest-props-and-state-from-an-effect)

As a last resort (if these methods didn’t help), wrap its creation with [`useMemo`](https://react.dev/reference/react/useMemo#memoizing-a-dependency-of-another-hook) or [`useCallback`](https://react.dev/reference/react/useCallback#preventing-an-effect-from-firing-too-often) (for functions).

---

### My Effect keeps re-running in an infinite cycle

If your Effect runs in an infinite cycle, these two things must be true:

* Your Effect is updating some state.
* That state leads to a re-render, which causes the Effect’s dependencies to change.

Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application’s data flow with it?

If there is no external system, consider whether [removing the Effect altogether](https://react.dev/learn/you-might-not-need-an-effect) would simplify your logic.

If you’re genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component’s visual output? If you need to keep track of some data that isn’t used by rendering, a [ref](https://react.dev/reference/react/useRef#referencing-a-value-with-a-ref) (which doesn’t trigger re-renders) might be more appropriate. Verify your Effect doesn’t update the state (and trigger re-renders) more than needed.

Finally, if your Effect is updating the state at the right time, but there is still a loop, it’s because that state update leads to one of the Effect’s dependencies changing. [Read how to debug dependency changes.](https://react.dev/reference/react/useEffect#my-effect-runs-after-every-re-render)

---

### My cleanup logic runs even though my component didn’t unmount

The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React [runs setup+cleanup one extra time immediately after component mounts.](https://react.dev/reference/react/useEffect#my-effect-runs-twice-when-the-component-mounts)

If you have cleanup code without corresponding setup code, it’s usually a code smell:

```
useEffect(() => {

// 🔴 Avoid: Cleanup logic without corresponding setup logic

return () => {

doSomething();

};

}, []);
```

Your cleanup logic should be “symmetrical” to the setup logic, and should stop or undo whatever setup did:

```
useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, [serverUrl, roomId]);
```

[Learn how the Effect lifecycle is different from the component’s lifecycle.](https://react.dev/learn/lifecycle-of-reactive-effects#the-lifecycle-of-an-effect)

---

### My Effect does something visual, and I see a flicker before it runs

If your Effect must block the browser from [painting the screen,](https://react.dev/learn/render-and-commit#epilogue-browser-paint) replace `useEffect` with [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect). Note that **this shouldn’t be needed for the vast majority of Effects.** You’ll only need this if it’s crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it.

[PrevioususeDeferredValue](https://react.dev/reference/react/useDeferredValue)[NextuseEffectEvent](https://react.dev/reference/react/useEffectEvent)

---

---


# useEffectEvent – React

URL: https://react.dev/reference/react/useEffectEvent

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useEffectEvent

`useEffectEvent` is a React Hook that lets you extract non-reactive logic from your Effects into a reusable function called an [Effect Event](https://react.dev/learn/separating-events-from-effects#declaring-an-effect-event).

```
const onSomething = useEffectEvent(callback)
```

* [Reference](https://react.dev/reference/react/useEffectEvent#reference) 
  + [`useEffectEvent(callback)`](https://react.dev/reference/react/useEffectEvent#useeffectevent)
* [Usage](https://react.dev/reference/react/useEffectEvent#usage) 
  + [Reading the latest props and state](https://react.dev/reference/react/useEffectEvent#reading-the-latest-props-and-state)

## Reference

### `useEffectEvent(callback)`

Call `useEffectEvent` at the top level of your component to declare an Effect Event. Effect Events are functions you can call inside Effects, such as `useEffect`:

```
import { useEffectEvent, useEffect } from 'react';

function ChatRoom({ roomId, theme }) {

const onConnected = useEffectEvent(() => {

showNotification('Connected!', theme);

});

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.on('connected', () => {

onConnected();

});

connection.connect();

return () => connection.disconnect();

}, [roomId]);

// ...

}
```

[See more examples below.](https://react.dev/reference/react/useEffectEvent#usage)

#### Parameters

* `callback`: A function containing the logic for your Effect Event. When you define an Effect Event with `useEffectEvent`, the `callback` always accesses the latest values from props and state when it is invoked. This helps avoid issues with stale closures.

#### Returns

Returns an Effect Event function. You can call this function inside `useEffect`, `useLayoutEffect`, or `useInsertionEffect`.

#### Caveats

* **Only call inside Effects:** Effect Events should only be called within Effects. Define them just before the Effect that uses them. Do not pass them to other components or hooks. The [`eslint-plugin-react-hooks`](https://react.dev/reference/eslint-plugin-react-hooks) linter (version 6.1.1 or higher) will enforce this restriction to prevent calling Effect Events in the wrong context.
* **Not a dependency shortcut:** Do not use `useEffectEvent` to avoid specifying dependencies in your Effect’s dependency array. This can hide bugs and make your code harder to understand. Prefer explicit dependencies or use refs to compare previous values if needed.
* **Use for non-reactive logic:** Only use `useEffectEvent` to extract logic that does not depend on changing values.

---

## Usage

### Reading the latest props and state

Typically, when you access a reactive value inside an Effect, you must include it in the dependency array. This makes sure your Effect runs again whenever that value changes, which is usually the desired behavior.

But in some cases, you may want to read the most recent props or state inside an Effect without causing the Effect to re-run when those values change.

To [read the latest props or state](https://react.dev/learn/separating-events-from-effects#reading-latest-props-and-state-with-effect-events) in your Effect, without making those values reactive, include them in an Effect Event.

```
import { useEffect, useContext, useEffectEvent } from 'react';

function Page({ url }) {

const { items } = useContext(ShoppingCartContext);

const numberOfItems = items.length;

const onNavigate = useEffectEvent((visitedUrl) => {

logVisit(visitedUrl, numberOfItems);

});

useEffect(() => {

onNavigate(url);

}, [url]);

// ...

}
```

In this example, the Effect should re-run after a render when `url` changes (to log the new page visit), but it should **not** re-run when `numberOfItems` changes. By wrapping the logging logic in an Effect Event, `numberOfItems` becomes non-reactive. It’s always read from the latest value without triggering the Effect.

You can pass reactive values like `url` as arguments to the Effect Event to keep them reactive while accessing the latest non-reactive values inside the event.

[PrevioususeEffect](https://react.dev/reference/react/useEffect)[NextuseId](https://react.dev/reference/react/useId)

---

---


# useId – React

URL: https://react.dev/reference/react/useId

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useId

`useId` is a React Hook for generating unique IDs that can be passed to accessibility attributes.

```
const id = useId()
```

* [Reference](https://react.dev/reference/react/useId#reference) 
  + [`useId()`](https://react.dev/reference/react/useId#useid)
* [Usage](https://react.dev/reference/react/useId#usage) 
  + [Generating unique IDs for accessibility attributes](https://react.dev/reference/react/useId#generating-unique-ids-for-accessibility-attributes)
  + [Generating IDs for several related elements](https://react.dev/reference/react/useId#generating-ids-for-several-related-elements)
  + [Specifying a shared prefix for all generated IDs](https://react.dev/reference/react/useId#specifying-a-shared-prefix-for-all-generated-ids)
  + [Using the same ID prefix on the client and the server](https://react.dev/reference/react/useId#using-the-same-id-prefix-on-the-client-and-the-server)

---

## Reference

### `useId()`

Call `useId` at the top level of your component to generate a unique ID:

```
import { useId } from 'react';

function PasswordField() {

const passwordHintId = useId();

// ...
```

[See more examples below.](https://react.dev/reference/react/useId#usage)

#### Parameters

`useId` does not take any parameters.

#### Returns

`useId` returns a unique ID string associated with this particular `useId` call in this particular component.

#### Caveats

* `useId` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
* `useId` **should not be used to generate cache keys** for [use()](https://react.dev/reference/react/use). The ID is stable when a component is mounted but may change during rendering. Cache keys should be generated from your data.
* `useId` **should not be used to generate keys** in a list. [Keys should be generated from your data.](https://react.dev/learn/rendering-lists#where-to-get-your-key)
* `useId` currently cannot be used in [async Server Components](https://react.dev/reference/rsc/server-components#async-components-with-server-components).

---

## Usage

### Pitfall

**Do not call `useId` to generate keys in a list.** [Keys should be generated from your data.](https://react.dev/learn/rendering-lists#where-to-get-your-key)

### Generating unique IDs for accessibility attributes

Call `useId` at the top level of your component to generate a unique ID:

```
import { useId } from 'react';

function PasswordField() {

const passwordHintId = useId();

// ...
```

You can then pass the generated ID to different attributes:

```
<>

<input type="password" aria-describedby={passwordHintId} />

<p id={passwordHintId}>

</>
```

**Let’s walk through an example to see when this is useful.**

[HTML accessibility attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA) like [`aria-describedby`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-describedby) let you specify that two tags are related to each other. For example, you can specify that an element (like an input) is described by another element (like a paragraph).

In regular HTML, you would write it like this:

```
<label>

Password:

<input

type="password"

aria-describedby="password-hint"

/>

</label>

<p id="password-hint">

The password should contain at least 18 characters

</p>
```

However, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page—but IDs have to be unique! Instead of hardcoding an ID, generate a unique ID with `useId`:

```
import { useId } from 'react';

function PasswordField() {

const passwordHintId = useId();

return (

<>

<label>

Password:

<input

type="password"

aria-describedby={passwordHintId}

/>

</label>

<p id={passwordHintId}>

The password should contain at least 18 characters

</p>

</>

);

}
```

Now, even if `PasswordField` appears multiple times on the screen, the generated IDs won’t clash.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useId } from 'react';

function PasswordField() {
  const passwordHintId = useId();
  return (
    <>
      <label>
        Password:
        <input
          type="password"
          aria-describedby={passwordHintId}
        />
      </label>
      <p id={passwordHintId}>
        The password should contain at least 18 characters
      </p>
    </>
  );
}

export default function App() {
  return (
    <>
      <h2>Choose password</h2>
      <PasswordField />
      <h2>Confirm password</h2>
      <PasswordField />
    </>
  );
}
```

Show more

[Watch this video](https://www.youtube.com/watch?v=0dNzNcuEuOo) to see the difference in the user experience with assistive technologies.

### Pitfall

With [server rendering](https://react.dev/reference/react-dom/server), **`useId` requires an identical component tree on the server and the client**. If the trees you render on the server and the client don’t match exactly, the generated IDs won’t match.

##### Deep Dive

#### Why is useId better than an incrementing counter?

Show Details

You might be wondering why `useId` is better than incrementing a global variable like `nextId++`.

The primary benefit of `useId` is that React ensures that it works with [server rendering.](https://react.dev/reference/react-dom/server) During server rendering, your components generate HTML output. Later, on the client, [hydration](https://react.dev/reference/react-dom/client/hydrateRoot) attaches your event handlers to the generated HTML. For hydration to work, the client output must match the server HTML.

This is very difficult to guarantee with an incrementing counter because the order in which the Client Components are hydrated may not match the order in which the server HTML was emitted. By calling `useId`, you ensure that hydration will work, and the output will match between the server and the client.

Inside React, `useId` is generated from the “parent path” of the calling component. This is why, if the client and the server tree are the same, the “parent path” will match up regardless of rendering order.

---

### Generating IDs for several related elements

If you need to give IDs to multiple related elements, you can call `useId` to generate a shared prefix for them:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useId } from 'react';

export default function Form() {
  const id = useId();
  return (
    <form>
      <label htmlFor={id + '-firstName'}>First Name:</label>
      <input id={id + '-firstName'} type="text" />
      <hr />
      <label htmlFor={id + '-lastName'}>Last Name:</label>
      <input id={id + '-lastName'} type="text" />
    </form>
  );
}
```

This lets you avoid calling `useId` for every single element that needs a unique ID.

---

### Specifying a shared prefix for all generated IDs

If you render multiple independent React applications on a single page, pass `identifierPrefix` as an option to your [`createRoot`](https://react.dev/reference/react-dom/client/createRoot#parameters) or [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) calls. This ensures that the IDs generated by the two different apps never clash because every identifier generated with `useId` will start with the distinct prefix you’ve specified.

index.jsindex.htmlApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRoot } from 'react-dom/client';
import App from './App.js';
import './styles.css';

const root1 = createRoot(document.getElementById('root1'), {
  identifierPrefix: 'my-first-app-'
});
root1.render(<App />);

const root2 = createRoot(document.getElementById('root2'), {
  identifierPrefix: 'my-second-app-'
});
root2.render(<App />);
```

---

### Using the same ID prefix on the client and the server

If you [render multiple independent React apps on the same page](https://react.dev/reference/react/useId#specifying-a-shared-prefix-for-all-generated-ids), and some of these apps are server-rendered, make sure that the `identifierPrefix` you pass to the [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) call on the client side is the same as the `identifierPrefix` you pass to the [server APIs](https://react.dev/reference/react-dom/server) such as [`renderToPipeableStream`.](https://react.dev/reference/react-dom/server/renderToPipeableStream)

```
// Server

import { renderToPipeableStream } from 'react-dom/server';

const { pipe } = renderToPipeableStream(

<App />,

{ identifierPrefix: 'react-app1' }

);
```

```
// Client

import { hydrateRoot } from 'react-dom/client';

const domNode = document.getElementById('root');

const root = hydrateRoot(

domNode,

reactNode,

{ identifierPrefix: 'react-app1' }

);
```

You do not need to pass `identifierPrefix` if you only have one React app on the page.

[PrevioususeEffectEvent](https://react.dev/reference/react/useEffectEvent)[NextuseImperativeHandle](https://react.dev/reference/react/useImperativeHandle)

---

---


# useImperativeHandle – React

URL: https://react.dev/reference/react/useImperativeHandle

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useImperativeHandle

`useImperativeHandle` is a React Hook that lets you customize the handle exposed as a [ref.](https://react.dev/learn/manipulating-the-dom-with-refs)

```
useImperativeHandle(ref, createHandle, dependencies?)
```

* [Reference](https://react.dev/reference/react/useImperativeHandle#reference) 
  + [`useImperativeHandle(ref, createHandle, dependencies?)`](https://react.dev/reference/react/useImperativeHandle#useimperativehandle)
* [Usage](https://react.dev/reference/react/useImperativeHandle#usage) 
  + [Exposing a custom ref handle to the parent component](https://react.dev/reference/react/useImperativeHandle#exposing-a-custom-ref-handle-to-the-parent-component)
  + [Exposing your own imperative methods](https://react.dev/reference/react/useImperativeHandle#exposing-your-own-imperative-methods)

---

## Reference

### `useImperativeHandle(ref, createHandle, dependencies?)`

Call `useImperativeHandle` at the top level of your component to customize the ref handle it exposes:

```
import { useImperativeHandle } from 'react';

function MyInput({ ref }) {

useImperativeHandle(ref, () => {

return {

// ... your methods ...

};

}, []);

// ...
```

[See more examples below.](https://react.dev/reference/react/useImperativeHandle#usage)

#### Parameters

* `ref`: The `ref` you received as a prop to the `MyInput` component.
* `createHandle`: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.
* **optional** `dependencies`: The list of all reactive values referenced inside of the `createHandle` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, your `createHandle` function will re-execute, and the newly created handle will be assigned to the ref.

### Note

Starting with React 19, [`ref` is available as a prop.](https://react.dev/blog/2024/12/05/react-19#ref-as-a-prop) In React 18 and earlier, it was necessary to get the `ref` from [`forwardRef`.](https://react.dev/reference/react/forwardRef)

#### Returns

`useImperativeHandle` returns `undefined`.

---

## Usage

### Exposing a custom ref handle to the parent component

To expose a DOM node to the parent element, pass in the `ref` prop to the node.

```
function MyInput({ ref }) {

return <input ref={ref} />;

};
```

With the code above, [a ref to `MyInput` will receive the `<input>` DOM node.](https://react.dev/learn/manipulating-the-dom-with-refs) However, you can expose a custom value instead. To customize the exposed handle, call `useImperativeHandle` at the top level of your component:

```
import { useImperativeHandle } from 'react';

function MyInput({ ref }) {

useImperativeHandle(ref, () => {

return {

// ... your methods ...

};

}, []);

return <input />;

};
```

Note that in the code above, the `ref` is no longer passed to the `<input>`.

For example, suppose you don’t want to expose the entire `<input>` DOM node, but you want to expose two of its methods: `focus` and `scrollIntoView`. To do this, keep the real browser DOM in a separate ref. Then use `useImperativeHandle` to expose a handle with only the methods that you want the parent component to call:

```
import { useRef, useImperativeHandle } from 'react';

function MyInput({ ref }) {

const inputRef = useRef(null);

useImperativeHandle(ref, () => {

return {

focus() {

inputRef.current.focus();

},

scrollIntoView() {

inputRef.current.scrollIntoView();

},

};

}, []);

return <input ref={inputRef} />;

};
```

Now, if the parent component gets a ref to `MyInput`, it will be able to call the `focus` and `scrollIntoView` methods on it. However, it will not have full access to the underlying `<input>` DOM node.

App.jsMyInput.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();
    // This won't work because the DOM node isn't exposed:
    // ref.current.style.opacity = 0.5;
  }

  return (
    <form>
      <MyInput placeholder="Enter your name" ref={ref} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}
```

Show more

---

### Exposing your own imperative methods

The methods you expose via an imperative handle don’t have to match the DOM methods exactly. For example, this `Post` component exposes a `scrollAndFocusAddComment` method via an imperative handle. This lets the parent `Page` scroll the list of comments *and* focus the input field when you click the button:

App.jsPost.jsCommentList.jsAddComment.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';
import Post from './Post.js';

export default function Page() {
  const postRef = useRef(null);

  function handleClick() {
    postRef.current.scrollAndFocusAddComment();
  }

  return (
    <>
      <button onClick={handleClick}>
        Write a comment
      </button>
      <Post ref={postRef} />
    </>
  );
}
```

Show more

### Pitfall

**Do not overuse refs.** You should only use refs for *imperative* behaviors that you can’t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.

**If you can express something as a prop, you should not use a ref.** For example, instead of exposing an imperative handle like `{ open, close }` from a `Modal` component, it is better to take `isOpen` as a prop like `<Modal isOpen={isOpen} />`. [Effects](https://react.dev/learn/synchronizing-with-effects) can help you expose imperative behaviors via props.

[PrevioususeId](https://react.dev/reference/react/useId)[NextuseInsertionEffect](https://react.dev/reference/react/useInsertionEffect)

---

---


# useInsertionEffect – React

URL: https://react.dev/reference/react/useInsertionEffect

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useInsertionEffect

### Pitfall

`useInsertionEffect` is for CSS-in-JS library authors. Unless you are working on a CSS-in-JS library and need a place to inject the styles, you probably want [`useEffect`](https://react.dev/reference/react/useEffect) or [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) instead.

`useInsertionEffect` allows inserting elements into the DOM before any layout Effects fire.

```
useInsertionEffect(setup, dependencies?)
```

* [Reference](https://react.dev/reference/react/useInsertionEffect#reference) 
  + [`useInsertionEffect(setup, dependencies?)`](https://react.dev/reference/react/useInsertionEffect#useinsertioneffect)
* [Usage](https://react.dev/reference/react/useInsertionEffect#usage) 
  + [Injecting dynamic styles from CSS-in-JS libraries](https://react.dev/reference/react/useInsertionEffect#injecting-dynamic-styles-from-css-in-js-libraries)

---

## Reference

### `useInsertionEffect(setup, dependencies?)`

Call `useInsertionEffect` to insert styles before any Effects fire that may need to read layout:

```
import { useInsertionEffect } from 'react';

// Inside your CSS-in-JS library

function useCSS(rule) {

useInsertionEffect(() => {

// ... inject <style> tags here ...

});

return rule;

}
```

[See more examples below.](https://react.dev/reference/react/useInsertionEffect#usage)

#### Parameters

* `setup`: The function with your Effect’s logic. Your setup function may also optionally return a *cleanup* function. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function.
* **optional** `dependencies`: The list of all reactive values referenced inside of the `setup` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison algorithm. If you don’t specify the dependencies at all, your Effect will re-run after every re-render of the component.

#### Returns

`useInsertionEffect` returns `undefined`.

#### Caveats

* Effects only run on the client. They don’t run during server rendering.
* You can’t update state from inside `useInsertionEffect`.
* By the time `useInsertionEffect` runs, refs are not attached yet.
* `useInsertionEffect` may run either before or after the DOM has been updated. You shouldn’t rely on the DOM being updated at any particular time.
* Unlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect, `useInsertionEffect` will fire both cleanup and setup one component at a time. This results in an “interleaving” of the cleanup and setup functions.

---

## Usage

### Injecting dynamic styles from CSS-in-JS libraries

Traditionally, you would style React components using plain CSS.

```
// In your JS file:

<button className="success" />

// In your CSS file:

.success { color: green; }
```

Some teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS:

1. Static extraction to CSS files with a compiler
2. Inline styles, e.g. `<div style={{ opacity: 1 }}>`
3. Runtime injection of `<style>` tags

If you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles). **We don’t recommend runtime `<style>` tag injection for two reasons:**

1. Runtime injection forces the browser to recalculate the styles a lot more often.
2. Runtime injection can be very slow if it happens at the wrong time in the React lifecycle.

The first problem is not solvable, but `useInsertionEffect` helps you solve the second problem.

Call `useInsertionEffect` to insert the styles before any layout Effects fire:

```
// Inside your CSS-in-JS library

let isInserted = new Set();

function useCSS(rule) {

useInsertionEffect(() => {

// As explained earlier, we don't recommend runtime injection of <style> tags.

// But if you have to do it, then it's important to do in useInsertionEffect.

if (!isInserted.has(rule)) {

isInserted.add(rule);

document.head.appendChild(getStyleForRule(rule));

}

});

return rule;

}

function Button() {

const className = useCSS('...');

return <div className={className} />;

}
```

Similarly to `useEffect`, `useInsertionEffect` does not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:

```
let collectedRulesSet = new Set();

function useCSS(rule) {

if (typeof window === 'undefined') {

collectedRulesSet.add(rule);

}

useInsertionEffect(() => {

// ...

});

return rule;

}
```

[Read more about upgrading CSS-in-JS libraries with runtime injection to `useInsertionEffect`.](https://github.com/reactwg/react-18/discussions/110)

##### Deep Dive

#### How is this better than injecting styles during rendering or useLayoutEffect?

Show Details

If you insert styles during rendering and React is processing a [non-blocking update,](https://react.dev/reference/react/useTransition#perform-non-blocking-updates-with-actions) the browser will recalculate the styles every single frame while rendering a component tree, which can be **extremely slow.**

`useInsertionEffect` is better than inserting styles during [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) or [`useEffect`](https://react.dev/reference/react/useEffect) because it ensures that by the time other Effects run in your components, the `<style>` tags have already been inserted. Otherwise, layout calculations in regular Effects would be wrong due to outdated styles.

[PrevioususeImperativeHandle](https://react.dev/reference/react/useImperativeHandle)[NextuseLayoutEffect](https://react.dev/reference/react/useLayoutEffect)

---

---


# useLayoutEffect – React

URL: https://react.dev/reference/react/useLayoutEffect

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useLayoutEffect

### Pitfall

`useLayoutEffect` can hurt performance. Prefer [`useEffect`](https://react.dev/reference/react/useEffect) when possible.

`useLayoutEffect` is a version of [`useEffect`](https://react.dev/reference/react/useEffect) that fires before the browser repaints the screen.

```
useLayoutEffect(setup, dependencies?)
```

* [Reference](https://react.dev/reference/react/useLayoutEffect#reference) 
  + [`useLayoutEffect(setup, dependencies?)`](https://react.dev/reference/react/useLayoutEffect#useinsertioneffect)
* [Usage](https://react.dev/reference/react/useLayoutEffect#usage) 
  + [Measuring layout before the browser repaints the screen](https://react.dev/reference/react/useLayoutEffect#measuring-layout-before-the-browser-repaints-the-screen)
* [Troubleshooting](https://react.dev/reference/react/useLayoutEffect#troubleshooting) 
  + [I’m getting an error: “`useLayoutEffect` does nothing on the server”](https://react.dev/reference/react/useLayoutEffect#im-getting-an-error-uselayouteffect-does-nothing-on-the-server)

---

## Reference

### `useLayoutEffect(setup, dependencies?)`

Call `useLayoutEffect` to perform the layout measurements before the browser repaints the screen:

```
import { useState, useRef, useLayoutEffect } from 'react';

function Tooltip() {

const ref = useRef(null);

const [tooltipHeight, setTooltipHeight] = useState(0);

useLayoutEffect(() => {

const { height } = ref.current.getBoundingClientRect();

setTooltipHeight(height);

}, []);

// ...
```

[See more examples below.](https://react.dev/reference/react/useLayoutEffect#usage)

#### Parameters

* `setup`: The function with your Effect’s logic. Your setup function may also optionally return a *cleanup* function. Before your [component commits](https://react.dev/learn/render-and-commit#step-3-react-commits-changes-to-the-dom), React will run your setup function. After every commit with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function.
* **optional** `dependencies`: The list of all reactive values referenced inside of the `setup` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. If you omit this argument, your Effect will re-run after every commit of the component.

#### Returns

`useLayoutEffect` returns `undefined`.

#### Caveats

* `useLayoutEffect` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a component and move the Effect there.
* When Strict Mode is on, React will **run one extra development-only setup+cleanup cycle** before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, [implement the cleanup function.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)
* If some of your dependencies are objects or functions defined inside the component, there is a risk that they will **cause the Effect to re-run more often than needed.** To fix this, remove unnecessary [object](https://react.dev/reference/react/useEffect#removing-unnecessary-object-dependencies) and [function](https://react.dev/reference/react/useEffect#removing-unnecessary-function-dependencies) dependencies. You can also [extract state updates](https://react.dev/reference/react/useEffect#updating-state-based-on-previous-state-from-an-effect) and [non-reactive logic](https://react.dev/reference/react/useEffect#reading-the-latest-props-and-state-from-an-effect) outside of your Effect.
* Effects **only run on the client.** They don’t run during server rendering.
* The code inside `useLayoutEffect` and all state updates scheduled from it **block the browser from repainting the screen.** When used excessively, this makes your app slow. When possible, prefer [`useEffect`.](https://react.dev/reference/react/useEffect)
* If you trigger a state update inside `useLayoutEffect`, React will execute all remaining Effects immediately including `useEffect`.

---

## Usage

### Measuring layout before the browser repaints the screen

Most components don’t need to know their position and size on the screen to decide what to render. They only return some JSX. Then the browser calculates their *layout* (position and size) and repaints the screen.

Sometimes, that’s not enough. Imagine a tooltip that appears next to some element on hover. If there’s enough space, the tooltip should appear above the element, but if it doesn’t fit, it should appear below. In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top).

To do this, you need to render in two passes:

1. Render the tooltip anywhere (even with a wrong position).
2. Measure its height and decide where to place the tooltip.
3. Render the tooltip *again* in the correct place.

**All of this needs to happen before the browser repaints the screen.** You don’t want the user to see the tooltip moving. Call `useLayoutEffect` to perform the layout measurements before the browser repaints the screen:

```
function Tooltip() {

const ref = useRef(null);

const [tooltipHeight, setTooltipHeight] = useState(0); // You don't know real height yet

useLayoutEffect(() => {

const { height } = ref.current.getBoundingClientRect();

setTooltipHeight(height); // Re-render now that you know the real height

}, []);

// ...use tooltipHeight in the rendering logic below...

}
```

Here’s how this works step by step:

1. `Tooltip` renders with the initial `tooltipHeight = 0` (so the tooltip may be wrongly positioned).
2. React places it in the DOM and runs the code in `useLayoutEffect`.
3. Your `useLayoutEffect` [measures the height](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) of the tooltip content and triggers an immediate re-render.
4. `Tooltip` renders again with the real `tooltipHeight` (so the tooltip is correctly positioned).
5. React updates it in the DOM, and the browser finally displays the tooltip.

Hover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:

App.jsButtonWithTooltip.jsTooltip.jsTooltipContainer.js

Tooltip.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useLayoutEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import TooltipContainer from './TooltipContainer.js';

export default function Tooltip({ children, targetRect }) {
  const ref = useRef(null);
  const [tooltipHeight, setTooltipHeight] = useState(0);

  useLayoutEffect(() => {
    const { height } = ref.current.getBoundingClientRect();
    setTooltipHeight(height);
    console.log('Measured tooltip height: ' + height);
  }, []);

  let tooltipX = 0;
  let tooltipY = 0;
  if (targetRect !== null) {
    tooltipX = targetRect.left;
    tooltipY = targetRect.top - tooltipHeight;
    if (tooltipY < 0) {
      // It doesn't fit above, so place below.
      tooltipY = targetRect.bottom;
    }
  }

  return createPortal(
    <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>
      {children}
    </TooltipContainer>,
    document.body
  );
}
```

Show more

Notice that even though the `Tooltip` component has to render in two passes (first, with `tooltipHeight` initialized to `0` and then with the real measured height), you only see the final result. This is why you need `useLayoutEffect` instead of [`useEffect`](https://react.dev/reference/react/useEffect) for this example. Let’s look at the difference in detail below.

#### useLayoutEffect vs useEffect

1. `useLayoutEffect` blocks the browser from repainting 2. `useEffect` does not block the browser

#### Example 1 of 2: `useLayoutEffect` blocks the browser from repainting

React guarantees that the code inside `useLayoutEffect` and any state updates scheduled inside it will be processed **before the browser repaints the screen.** This lets you render the tooltip, measure it, and re-render the tooltip again without the user noticing the first extra render. In other words, `useLayoutEffect` blocks the browser from painting.

App.jsButtonWithTooltip.jsTooltip.jsTooltipContainer.js

Tooltip.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useLayoutEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import TooltipContainer from './TooltipContainer.js';

export default function Tooltip({ children, targetRect }) {
  const ref = useRef(null);
  const [tooltipHeight, setTooltipHeight] = useState(0);

  useLayoutEffect(() => {
    const { height } = ref.current.getBoundingClientRect();
    setTooltipHeight(height);
  }, []);

  let tooltipX = 0;
  let tooltipY = 0;
  if (targetRect !== null) {
    tooltipX = targetRect.left;
    tooltipY = targetRect.top - tooltipHeight;
    if (tooltipY < 0) {
      // It doesn't fit above, so place below.
      tooltipY = targetRect.bottom;
    }
  }

  return createPortal(
    <TooltipContainer x={tooltipX} y={tooltipY} contentRef={ref}>
      {children}
    </TooltipContainer>,
    document.body
  );
}
```

Show more

Next Example

### Note

Rendering in two passes and blocking the browser hurts performance. Try to avoid this when you can.

---

## Troubleshooting

### I’m getting an error: “`useLayoutEffect` does nothing on the server”

The purpose of `useLayoutEffect` is to let your component [use layout information for rendering:](https://react.dev/reference/react/useLayoutEffect#measuring-layout-before-the-browser-repaints-the-screen)

1. Render the initial content.
2. Measure the layout *before the browser repaints the screen.*
3. Render the final content using the layout information you’ve read.

When you or your framework uses [server rendering](https://react.dev/reference/react-dom/server), your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads.

The problem is that on the server, there is no layout information.

In the [earlier example](https://react.dev/reference/react/useLayoutEffect#measuring-layout-before-the-browser-repaints-the-screen), the `useLayoutEffect` call in the `Tooltip` component lets it position itself correctly (either above or below content) depending on the content height. If you tried to render `Tooltip` as a part of the initial server HTML, this would be impossible to determine. On the server, there is no layout yet! So, even if you rendered it on the server, its position would “jump” on the client after the JavaScript loads and runs.

Usually, components that rely on layout information don’t need to render on the server anyway. For example, it probably doesn’t make sense to show a `Tooltip` during the initial render. It is triggered by a client interaction.

However, if you’re running into this problem, you have a few different options:

* Replace `useLayoutEffect` with [`useEffect`.](https://react.dev/reference/react/useEffect) This tells React that it’s okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs).
* Alternatively, [mark your component as client-only.](https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content) This tells React to replace its content up to the closest [`<Suspense>`](https://react.dev/reference/react/Suspense) boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering.
* Alternatively, you can render a component with `useLayoutEffect` only after hydration. Keep a boolean `isMounted` state that’s initialized to `false`, and set it to `true` inside a `useEffect` call. Your rendering logic can then be like `return isMounted ? <RealContent /> : <FallbackContent />`. On the server and during the hydration, the user will see `FallbackContent` which should not call `useLayoutEffect`. Then React will replace it with `RealContent` which runs on the client only and can include `useLayoutEffect` calls.
* If you synchronize your component with an external data store and rely on `useLayoutEffect` for different reasons than measuring layout, consider [`useSyncExternalStore`](https://react.dev/reference/react/useSyncExternalStore) instead which [supports server rendering.](https://react.dev/reference/react/useSyncExternalStore#adding-support-for-server-rendering)

[PrevioususeInsertionEffect](https://react.dev/reference/react/useInsertionEffect)[NextuseMemo](https://react.dev/reference/react/useMemo)

---

---


# useMemo – React

URL: https://react.dev/reference/react/useMemo

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useMemo

`useMemo` is a React Hook that lets you cache the result of a calculation between re-renders.

```
const cachedValue = useMemo(calculateValue, dependencies)
```

### Note

[React Compiler](https://react.dev/learn/react-compiler) automatically memoizes values and functions, reducing the need for manual `useMemo` calls. You can use the compiler to handle memoization automatically.

* [Reference](https://react.dev/reference/react/useMemo#reference) 
  + [`useMemo(calculateValue, dependencies)`](https://react.dev/reference/react/useMemo#usememo)
* [Usage](https://react.dev/reference/react/useMemo#usage) 
  + [Skipping expensive recalculations](https://react.dev/reference/react/useMemo#skipping-expensive-recalculations)
  + [Skipping re-rendering of components](https://react.dev/reference/react/useMemo#skipping-re-rendering-of-components)
  + [Preventing an Effect from firing too often](https://react.dev/reference/react/useMemo#preventing-an-effect-from-firing-too-often)
  + [Memoizing a dependency of another Hook](https://react.dev/reference/react/useMemo#memoizing-a-dependency-of-another-hook)
  + [Memoizing a function](https://react.dev/reference/react/useMemo#memoizing-a-function)
* [Troubleshooting](https://react.dev/reference/react/useMemo#troubleshooting) 
  + [My calculation runs twice on every re-render](https://react.dev/reference/react/useMemo#my-calculation-runs-twice-on-every-re-render)
  + [My `useMemo` call is supposed to return an object, but returns undefined](https://react.dev/reference/react/useMemo#my-usememo-call-is-supposed-to-return-an-object-but-returns-undefined)
  + [Every time my component renders, the calculation in `useMemo` re-runs](https://react.dev/reference/react/useMemo#every-time-my-component-renders-the-calculation-in-usememo-re-runs)
  + [I need to call `useMemo` for each list item in a loop, but it’s not allowed](https://react.dev/reference/react/useMemo#i-need-to-call-usememo-for-each-list-item-in-a-loop-but-its-not-allowed)

---

## Reference

### `useMemo(calculateValue, dependencies)`

Call `useMemo` at the top level of your component to cache a calculation between re-renders:

```
import { useMemo } from 'react';

function TodoList({ todos, tab }) {

const visibleTodos = useMemo(

() => filterTodos(todos, tab),

[todos, tab]

);

// ...

}
```

[See more examples below.](https://react.dev/reference/react/useMemo#usage)

#### Parameters

* `calculateValue`: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the `dependencies` have not changed since the last render. Otherwise, it will call `calculateValue`, return its result, and store it so it can be reused later.
* `dependencies`: The list of all reactive values referenced inside of the `calculateValue` code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is [configured for React](https://react.dev/learn/editor-setup#linting), it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like `[dep1, dep2, dep3]`. React will compare each dependency with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison.

#### Returns

On the initial render, `useMemo` returns the result of calling `calculateValue` with no arguments.

During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call `calculateValue` again, and return the result that `calculateValue` has returned.

#### Caveats

* `useMemo` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
* In Strict Mode, React will **call your calculation function twice** in order to [help you find accidental impurities.](https://react.dev/reference/react/useMemo#my-calculation-runs-twice-on-every-re-render) This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored.
* React **will not throw away the cached value unless there is a specific reason to do that.** For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely on `useMemo` solely as a performance optimization. Otherwise, a [state variable](https://react.dev/reference/react/useState#avoiding-recreating-the-initial-state) or a [ref](https://react.dev/reference/react/useRef#avoiding-recreating-the-ref-contents) may be more appropriate.

### Note

Caching return values like this is also known as [*memoization*,](https://en.wikipedia.org/wiki/Memoization) which is why this Hook is called `useMemo`.

---

## Usage

### Skipping expensive recalculations

To cache a calculation between re-renders, wrap it in a `useMemo` call at the top level of your component:

```
import { useMemo } from 'react';

function TodoList({ todos, tab, theme }) {

const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);

// ...

}
```

You need to pass two things to `useMemo`:

1. A calculation function that takes no arguments, like `() =>`, and returns what you wanted to calculate.
2. A list of dependencies including every value within your component that’s used inside your calculation.

On the initial render, the value you’ll get from `useMemo` will be the result of calling your calculation.

On every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), `useMemo` will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value.

In other words, `useMemo` caches a calculation result between re-renders until its dependencies change.

**Let’s walk through an example to see when this is useful.**

By default, React will re-run the entire body of your component every time that it re-renders. For example, if this `TodoList` updates its state or receives new props from its parent, the `filterTodos` function will re-run:

```
function TodoList({ todos, tab, theme }) {

const visibleTodos = filterTodos(todos, tab);

// ...

}
```

Usually, this isn’t a problem because most calculations are very fast. However, if you’re filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn’t changed. If both `todos` and `tab` are the same as they were during the last render, wrapping the calculation in `useMemo` like earlier lets you reuse `visibleTodos` you’ve already calculated before.

This type of caching is called *[memoization.](https://en.wikipedia.org/wiki/Memoization)*

### Note

**You should only rely on `useMemo` as a performance optimization.** If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add `useMemo` to improve performance.

##### Deep Dive

#### How to tell if a calculation is expensive?

Show Details

In general, unless you’re creating or looping over thousands of objects, it’s probably not expensive. If you want to get more confidence, you can add a console log to measure the time spent in a piece of code:

```
console.time('filter array');

const visibleTodos = filterTodos(todos, tab);

console.timeEnd('filter array');
```

Perform the interaction you’re measuring (for example, typing into the input). You will then see logs like `filter array: 0.15ms` in your console. If the overall logged time adds up to a significant amount (say, `1ms` or more), it might make sense to memoize that calculation. As an experiment, you can then wrap the calculation in `useMemo` to verify whether the total logged time has decreased for that interaction or not:

```
console.time('filter array');

const visibleTodos = useMemo(() => {

return filterTodos(todos, tab); // Skipped if todos and tab haven't changed

}, [todos, tab]);

console.timeEnd('filter array');
```

`useMemo` won’t make the *first* render faster. It only helps you skip unnecessary work on updates.

Keep in mind that your machine is probably faster than your users’ so it’s a good idea to test the performance with an artificial slowdown. For example, Chrome offers a [CPU Throttling](https://developer.chrome.com/blog/new-in-devtools-61/#throttling) option for this.

Also note that measuring performance in development will not give you the most accurate results. (For example, when [Strict Mode](https://react.dev/reference/react/StrictMode) is on, you will see each component render twice rather than once.) To get the most accurate timings, build your app for production and test it on a device like your users have.

##### Deep Dive

#### Should you add useMemo everywhere?

Show Details

If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.

Optimizing with `useMemo` is only valuable in a few cases:

* The calculation you’re putting in `useMemo` is noticeably slow, and its dependencies rarely change.
* You pass it as a prop to a component wrapped in [`memo`.](https://react.dev/reference/react/memo) You want to skip re-rendering if the value hasn’t changed. Memoization lets your component re-render only when dependencies aren’t the same.
* The value you’re passing is later used as a dependency of some Hook. For example, maybe another `useMemo` calculation value depends on it. Or maybe you are depending on this value from [`useEffect.`](https://react.dev/reference/react/useEffect)

There is no benefit to wrapping a calculation in `useMemo` in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.

**In practice, you can make a lot of memoization unnecessary by following a few principles:**

1. When a component visually wraps other components, let it [accept JSX as children.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render.
2. Prefer local state and don’t [lift state up](https://react.dev/learn/sharing-state-between-components) any further than necessary. For example, don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.
3. Keep your [rendering logic pure.](https://react.dev/learn/keeping-components-pure) If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.
4. Avoid [unnecessary Effects that update state.](https://react.dev/learn/you-might-not-need-an-effect) Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.
5. Try to [remove unnecessary dependencies from your Effects.](https://react.dev/learn/removing-effect-dependencies) For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component.

If a specific interaction still feels laggy, [use the React Developer Tools profiler](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In the long term, we’re researching [doing granular memoization automatically](https://www.youtube.com/watch?v=lGEMwh32soc) to solve this once and for all.

#### The difference between useMemo and calculating a value directly

1. Skipping recalculation with `useMemo` 2. Always recalculating a value

#### Example 1 of 2: Skipping recalculation with `useMemo`

In this example, the `filterTodos` implementation is **artificially slowed down** so that you can see what happens when some JavaScript function you’re calling during rendering is genuinely slow. Try switching the tabs and toggling the theme.

Switching the tabs feels slow because it forces the slowed down `filterTodos` to re-execute. That’s expected because the `tab` has changed, and so the entire calculation *needs* to re-run. (If you’re curious why it runs twice, it’s explained [here.](https://react.dev/reference/react/useMemo#my-calculation-runs-twice-on-every-re-render))

Toggle the theme. **Thanks to `useMemo`, it’s fast despite the artificial slowdown!** The slow `filterTodos` call was skipped because both `todos` and `tab` (which you pass as dependencies to `useMemo`) haven’t changed since the last render.

App.jsTodoList.jsutils.js

TodoList.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useMemo } from 'react';
import { filterTodos } from './utils.js'

export default function TodoList({ todos, theme, tab }) {
  const visibleTodos = useMemo(
    () => filterTodos(todos, tab),
    [todos, tab]
  );
  return (
    <div className={theme}>
      <p><b>Note: <code>filterTodos</code> is artificially slowed down!</b></p>
      <ul>
        {visibleTodos.map(todo => (
          <li key={todo.id}>
            {todo.completed ?
              <s>{todo.text}</s> :
              todo.text
            }
          </li>
        ))}
      </ul>
    </div>
  );
}
```

Show more

Next Example

---

### Skipping re-rendering of components

In some cases, `useMemo` can also help you optimize performance of re-rendering child components. To illustrate this, let’s say this `TodoList` component passes the `visibleTodos` as a prop to the child `List` component:

```
export default function TodoList({ todos, tab, theme }) {

// ...

return (

<div className={theme}>

<List items={visibleTodos} />

</div>

);

}
```

You’ve noticed that toggling the `theme` prop freezes the app for a moment, but if you remove `<List />` from your JSX, it feels fast. This tells you that it’s worth trying to optimize the `List` component.

**By default, when a component re-renders, React re-renders all of its children recursively.** This is why, when `TodoList` re-renders with a different `theme`, the `List` component *also* re-renders. This is fine for components that don’t require much calculation to re-render. But if you’ve verified that a re-render is slow, you can tell `List` to skip re-rendering when its props are the same as on last render by wrapping it in [`memo`:](https://react.dev/reference/react/memo)

```
import { memo } from 'react';

const List = memo(function List({ items }) {

// ...

});
```

**With this change, `List` will skip re-rendering if all of its props are the *same* as on the last render.** This is where caching the calculation becomes important! Imagine that you calculated `visibleTodos` without `useMemo`:

```
export default function TodoList({ todos, tab, theme }) {

// Every time the theme changes, this will be a different array...

const visibleTodos = filterTodos(todos, tab);

return (

<div className={theme}>

{/* ... so List's props will never be the same, and it will re-render every time */}

<List items={visibleTodos} />

</div>

);

}
```

**In the above example, the `filterTodos` function always creates a *different* array,** similar to how the `{}` object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that `List` props will never be the same, and your [`memo`](https://react.dev/reference/react/memo) optimization won’t work. This is where `useMemo` comes in handy:

```
export default function TodoList({ todos, tab, theme }) {

// Tell React to cache your calculation between re-renders...

const visibleTodos = useMemo(

() => filterTodos(todos, tab),

[todos, tab] // ...so as long as these dependencies don't change...

);

return (

<div className={theme}>

{/* ...List will receive the same props and can skip re-rendering */}

<List items={visibleTodos} />

</div>

);

}
```

**By wrapping the `visibleTodos` calculation in `useMemo`, you ensure that it has the *same* value between the re-renders** (until dependencies change). You don’t *have to* wrap a calculation in `useMemo` unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in [`memo`,](https://react.dev/reference/react/memo) and this lets it skip re-rendering. There are a few other reasons to add `useMemo` which are described further on this page.

##### Deep Dive

#### Memoizing individual JSX nodes

Show Details

Instead of wrapping `List` in [`memo`](https://react.dev/reference/react/memo), you could wrap the `<List />` JSX node itself in `useMemo`:

```
export default function TodoList({ todos, tab, theme }) {

const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);

const children = useMemo(() => <List items={visibleTodos} />, [visibleTodos]);

return (

<div className={theme}>

{children}

</div>

);

}
```

The behavior would be the same. If the `visibleTodos` haven’t changed, `List` won’t be re-rendered.

A JSX node like `<List items={visibleTodos} />` is an object like `{ type: List, props: { items: visibleTodos } }`. Creating this object is very cheap, but React doesn’t know whether its contents is the same as last time or not. This is why by default, React will re-render the `List` component.

However, if React sees the same exact JSX as during the previous render, it won’t try to re-render your component. This is because JSX nodes are [immutable.](https://en.wikipedia.org/wiki/Immutable_object) A JSX node object could not have changed over time, so React knows it’s safe to skip a re-render. However, for this to work, the node has to *actually be the same object*, not merely look the same in code. This is what `useMemo` does in this example.

Manually wrapping JSX nodes into `useMemo` is not convenient. For example, you can’t do this conditionally. This is usually why you would wrap components with [`memo`](https://react.dev/reference/react/memo) instead of wrapping JSX nodes.

#### The difference between skipping re-renders and always re-rendering

1. Skipping re-rendering with `useMemo` and `memo` 2. Always re-rendering a component

#### Example 1 of 2: Skipping re-rendering with `useMemo` and `memo`

In this example, the `List` component is **artificially slowed down** so that you can see what happens when a React component you’re rendering is genuinely slow. Try switching the tabs and toggling the theme.

Switching the tabs feels slow because it forces the slowed down `List` to re-render. That’s expected because the `tab` has changed, and so you need to reflect the user’s new choice on the screen.

Next, try toggling the theme. **Thanks to `useMemo` together with [`memo`](https://react.dev/reference/react/memo), it’s fast despite the artificial slowdown!** The `List` skipped re-rendering because the `visibleTodos` array has not changed since the last render. The `visibleTodos` array has not changed because both `todos` and `tab` (which you pass as dependencies to `useMemo`) haven’t changed since the last render.

App.jsTodoList.jsList.jsutils.js

TodoList.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useMemo } from 'react';
import List from './List.js';
import { filterTodos } from './utils.js'

export default function TodoList({ todos, theme, tab }) {
  const visibleTodos = useMemo(
    () => filterTodos(todos, tab),
    [todos, tab]
  );
  return (
    <div className={theme}>
      <p><b>Note: <code>List</code> is artificially slowed down!</b></p>
      <List items={visibleTodos} />
    </div>
  );
}
```

Show more

Next Example

---

### Preventing an Effect from firing too often

Sometimes, you might want to use a value inside an [Effect:](https://react.dev/learn/synchronizing-with-effects)

```
function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

const options = {

serverUrl: 'https://localhost:1234',

roomId: roomId

}

useEffect(() => {

const connection = createConnection(options);

connection.connect();

// ...
```

This creates a problem. [Every reactive value must be declared as a dependency of your Effect.](https://react.dev/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency) However, if you declare `options` as a dependency, it will cause your Effect to constantly reconnect to the chat room:

```
useEffect(() => {

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [options]); // 🔴 Problem: This dependency changes on every render

// ...
```

To solve this, you can wrap the object you need to call from an Effect in `useMemo`:

```
function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

const options = useMemo(() => {

return {

serverUrl: 'https://localhost:1234',

roomId: roomId

};

}, [roomId]); // ✅ Only changes when roomId changes

useEffect(() => {

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [options]); // ✅ Only changes when options changes

// ...
```

This ensures that the `options` object is the same between re-renders if `useMemo` returns the cached object.

However, since `useMemo` is performance optimization, not a semantic guarantee, React may throw away the cached value if [there is a specific reason to do that](https://react.dev/reference/react/useMemo#caveats). This will also cause the effect to re-fire, **so it’s even better to remove the need for a function dependency** by moving your object *inside* the Effect:

```
function ChatRoom({ roomId }) {

const [message, setMessage] = useState('');

useEffect(() => {

const options = { // ✅ No need for useMemo or object dependencies!

serverUrl: 'https://localhost:1234',

roomId: roomId

}

const connection = createConnection(options);

connection.connect();

return () => connection.disconnect();

}, [roomId]); // ✅ Only changes when roomId changes

// ...
```

Now your code is simpler and doesn’t need `useMemo`. [Learn more about removing Effect dependencies.](https://react.dev/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect)

### Memoizing a dependency of another Hook

Suppose you have a calculation that depends on an object created directly in the component body:

```
function Dropdown({ allItems, text }) {

const searchOptions = { matchMode: 'whole-word', text };

const visibleItems = useMemo(() => {

return searchItems(allItems, searchOptions);

}, [allItems, searchOptions]); // 🚩 Caution: Dependency on an object created in the component body

// ...
```

Depending on an object like this defeats the point of memoization. When a component re-renders, all of the code directly inside the component body runs again. **The lines of code creating the `searchOptions` object will also run on every re-render.** Since `searchOptions` is a dependency of your `useMemo` call, and it’s different every time, React knows the dependencies are different, and recalculate `searchItems` every time.

To fix this, you could memoize the `searchOptions` object *itself* before passing it as a dependency:

```
function Dropdown({ allItems, text }) {

const searchOptions = useMemo(() => {

return { matchMode: 'whole-word', text };

}, [text]); // ✅ Only changes when text changes

const visibleItems = useMemo(() => {

return searchItems(allItems, searchOptions);

}, [allItems, searchOptions]); // ✅ Only changes when allItems or searchOptions changes

// ...
```

In the example above, if the `text` did not change, the `searchOptions` object also won’t change. However, an even better fix is to move the `searchOptions` object declaration *inside* of the `useMemo` calculation function:

```
function Dropdown({ allItems, text }) {

const visibleItems = useMemo(() => {

const searchOptions = { matchMode: 'whole-word', text };

return searchItems(allItems, searchOptions);

}, [allItems, text]); // ✅ Only changes when allItems or text changes

// ...
```

Now your calculation depends on `text` directly (which is a string and can’t “accidentally” become different).

---

### Memoizing a function

Suppose the `Form` component is wrapped in [`memo`.](https://react.dev/reference/react/memo) You want to pass a function to it as a prop:

```
export default function ProductPage({ productId, referrer }) {

function handleSubmit(orderDetails) {

post('/product/' + productId + '/buy', {

referrer,

orderDetails

});

}

return <Form onSubmit={handleSubmit} />;

}
```

Just as `{}` creates a different object, function declarations like `function() {}` and expressions like `() => {}` produce a *different* function on every re-render. By itself, creating a new function is not a problem. This is not something to avoid! However, if the `Form` component is memoized, presumably you want to skip re-rendering it when no props have changed. A prop that is *always* different would defeat the point of memoization.

To memoize a function with `useMemo`, your calculation function would have to return another function:

```
export default function Page({ productId, referrer }) {

const handleSubmit = useMemo(() => {

return (orderDetails) => {

post('/product/' + productId + '/buy', {

referrer,

orderDetails

});

};

}, [productId, referrer]);

return <Form onSubmit={handleSubmit} />;

}
```

This looks clunky! **Memoizing functions is common enough that React has a built-in Hook specifically for that. Wrap your functions into [`useCallback`](https://react.dev/reference/react/useCallback) instead of `useMemo`** to avoid having to write an extra nested function:

```
export default function Page({ productId, referrer }) {

const handleSubmit = useCallback((orderDetails) => {

post('/product/' + productId + '/buy', {

referrer,

orderDetails

});

}, [productId, referrer]);

return <Form onSubmit={handleSubmit} />;

}
```

The two examples above are completely equivalent. The only benefit to `useCallback` is that it lets you avoid writing an extra nested function inside. It doesn’t do anything else. [Read more about `useCallback`.](https://react.dev/reference/react/useCallback)

---

## Troubleshooting

### My calculation runs twice on every re-render

In [Strict Mode](https://react.dev/reference/react/StrictMode), React will call some of your functions twice instead of once:

```
function TodoList({ todos, tab }) {

// This component function will run twice for every render.

const visibleTodos = useMemo(() => {

// This calculation will run twice if any of the dependencies change.

return filterTodos(todos, tab);

}, [todos, tab]);

// ...
```

This is expected and shouldn’t break your code.

This **development-only** behavior helps you [keep components pure.](https://react.dev/learn/keeping-components-pure) React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake.

For example, this impure calculation function mutates an array you received as a prop:

```
const visibleTodos = useMemo(() => {

// 🚩 Mistake: mutating a prop

todos.push({ id: 'last', text: 'Go for a walk!' });

const filtered = filterTodos(todos, tab);

return filtered;

}, [todos, tab]);
```

React calls your function twice, so you’d notice the todo is added twice. Your calculation shouldn’t change any existing objects, but it’s okay to change any *new* objects you created during the calculation. For example, if the `filterTodos` function always returns a *different* array, you can mutate *that* array instead:

```
const visibleTodos = useMemo(() => {

const filtered = filterTodos(todos, tab);

// ✅ Correct: mutating an object you created during the calculation

filtered.push({ id: 'last', text: 'Go for a walk!' });

return filtered;

}, [todos, tab]);
```

Read [keeping components pure](https://react.dev/learn/keeping-components-pure) to learn more about purity.

Also, check out the guides on [updating objects](https://react.dev/learn/updating-objects-in-state) and [updating arrays](https://react.dev/learn/updating-arrays-in-state) without mutation.

---

### My `useMemo` call is supposed to return an object, but returns undefined

This code doesn’t work:

```
// 🔴 You can't return an object from an arrow function with () => {

const searchOptions = useMemo(() => {

matchMode: 'whole-word',

text: text

}, [text]);
```

In JavaScript, `() => {` starts the arrow function body, so the `{` brace is not a part of your object. This is why it doesn’t return an object, and leads to mistakes. You could fix it by adding parentheses like `({` and `})`:

```
// This works, but is easy for someone to break again

const searchOptions = useMemo(() => ({

matchMode: 'whole-word',

text: text

}), [text]);
```

However, this is still confusing and too easy for someone to break by removing the parentheses.

To avoid this mistake, write a `return` statement explicitly:

```
// ✅ This works and is explicit

const searchOptions = useMemo(() => {

return {

matchMode: 'whole-word',

text: text

};

}, [text]);
```

---

### Every time my component renders, the calculation in `useMemo` re-runs

Make sure you’ve specified the dependency array as a second argument!

If you forget the dependency array, `useMemo` will re-run the calculation every time:

```
function TodoList({ todos, tab }) {

// 🔴 Recalculates every time: no dependency array

const visibleTodos = useMemo(() => filterTodos(todos, tab));

// ...
```

This is the corrected version passing the dependency array as a second argument:

```
function TodoList({ todos, tab }) {

// ✅ Does not recalculate unnecessarily

const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);

// ...
```

If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:

```
const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);

console.log([todos, tab]);
```

You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as `temp1` and the second one got saved as `temp2`, you can then use the browser console to check whether each dependency in both arrays is the same:

```
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?

Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?

Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
```

When you find which dependency breaks memoization, either find a way to remove it, or [memoize it as well.](https://react.dev/reference/react/useMemo#memoizing-a-dependency-of-another-hook)

---

### I need to call `useMemo` for each list item in a loop, but it’s not allowed

Suppose the `Chart` component is wrapped in [`memo`](https://react.dev/reference/react/memo). You want to skip re-rendering every `Chart` in the list when the `ReportList` component re-renders. However, you can’t call `useMemo` in a loop:

```
function ReportList({ items }) {

return (

<article>

{items.map(item => {

// 🔴 You can't call useMemo in a loop like this:

const data = useMemo(() => calculateReport(item), [item]);

return (

<figure key={item.id}>

<Chart data={data} />

</figure>

);

})}

</article>

);

}
```

Instead, extract a component for each item and memoize data for individual items:

```
function ReportList({ items }) {

return (

<article>

{items.map(item =>

<Report key={item.id} item={item} />

)}

</article>

);

}

function Report({ item }) {

// ✅ Call useMemo at the top level:

const data = useMemo(() => calculateReport(item), [item]);

return (

<figure>

<Chart data={data} />

</figure>

);

}
```

Alternatively, you could remove `useMemo` and instead wrap `Report` itself in [`memo`.](https://react.dev/reference/react/memo) If the `item` prop does not change, `Report` will skip re-rendering, so `Chart` will skip re-rendering too:

```
function ReportList({ items }) {

// ...

}

const Report = memo(function Report({ item }) {

const data = calculateReport(item);

return (

<figure>

<Chart data={data} />

</figure>

);

});
```

[PrevioususeLayoutEffect](https://react.dev/reference/react/useLayoutEffect)[NextuseOptimistic](https://react.dev/reference/react/useOptimistic)

---

---


# useOptimistic – React

URL: https://react.dev/reference/react/useOptimistic

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useOptimistic

`useOptimistic` is a React Hook that lets you optimistically update the UI.

```
const [optimisticState, addOptimistic] = useOptimistic(state, updateFn);
```

* [Reference](https://react.dev/reference/react/useOptimistic#reference) 
  + [`useOptimistic(state, updateFn)`](https://react.dev/reference/react/useOptimistic#use)
* [Usage](https://react.dev/reference/react/useOptimistic#usage) 
  + [Optimistically updating forms](https://react.dev/reference/react/useOptimistic#optimistically-updating-with-forms)

---

## Reference

### `useOptimistic(state, updateFn)`

`useOptimistic` is a React Hook that lets you show a different state while an async action is underway. It accepts some state as an argument and returns a copy of that state that can be different during the duration of an async action such as a network request. You provide a function that takes the current state and the input to the action, and returns the optimistic state to be used while the action is pending.

This state is called the “optimistic” state because it is usually used to immediately present the user with the result of performing an action, even though the action actually takes time to complete.

```
import { useOptimistic } from 'react';

function AppContainer() {

const [optimisticState, addOptimistic] = useOptimistic(

state,

// updateFn

(currentState, optimisticValue) => {

// merge and return new state

// with optimistic value

}

);

}
```

[See more examples below.](https://react.dev/reference/react/useOptimistic#usage)

#### Parameters

* `state`: the value to be returned initially and whenever no action is pending.
* `updateFn(currentState, optimisticValue)`: a function that takes the current state and the optimistic value passed to `addOptimistic` and returns the resulting optimistic state. It must be a pure function. `updateFn` takes in two parameters. The `currentState` and the `optimisticValue`. The return value will be the merged value of the `currentState` and `optimisticValue`.

#### Returns

* `optimisticState`: The resulting optimistic state. It is equal to `state` unless an action is pending, in which case it is equal to the value returned by `updateFn`.
* `addOptimistic`: `addOptimistic` is the dispatching function to call when you have an optimistic update. It takes one argument, `optimisticValue`, of any type and will call the `updateFn` with `state` and `optimisticValue`.

---

## Usage

### Optimistically updating forms

The `useOptimistic` Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server’s response to reflect the changes, the interface is immediately updated with the expected outcome.

For example, when a user types a message into the form and hits the “Send” button, the `useOptimistic` Hook allows the message to immediately appear in the list with a “Sending…” label, even before the message is actually sent to a server. This “optimistic” approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the “Sending…” label is removed.

App.jsactions.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useOptimistic, useState, useRef, startTransition } from "react";
import { deliverMessage } from "./actions.js";

function Thread({ messages, sendMessageAction }) {
  const formRef = useRef();
  function formAction(formData) {
    addOptimisticMessage(formData.get("message"));
    formRef.current.reset();
    startTransition(async () => {
      await sendMessageAction(formData);
    });
  }
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [
      {
        text: newMessage,
        sending: true
      },
      ...state,
    ]
  );

  return (
    <>
      <form action={formAction} ref={formRef}>
        <input type="text" name="message" placeholder="Hello!" />
        <button type="submit">Send</button>
      </form>
      {optimisticMessages.map((message, index) => (
        <div key={index}>
          {message.text}
          {!!message.sending && <small> (Sending...)</small>}
        </div>
      ))}
      
    </>
  );
}

export default function App() {
  const [messages, setMessages] = useState([
    { text: "Hello there!", sending: false, key: 1 }
  ]);
  async function sendMessageAction(formData) {
    const sentMessage = await deliverMessage(formData.get("message"));
    startTransition(() => {
      setMessages((messages) => [{ text: sentMessage }, ...messages]);
    })
  }
  return <Thread messages={messages} sendMessageAction={sendMessageAction} />;
}
```

Show more

[PrevioususeMemo](https://react.dev/reference/react/useMemo)[NextuseReducer](https://react.dev/reference/react/useReducer)

---

---


# useReducer – React

URL: https://react.dev/reference/react/useReducer

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useReducer

`useReducer` is a React Hook that lets you add a [reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer) to your component.

```
const [state, dispatch] = useReducer(reducer, initialArg, init?)
```

* [Reference](https://react.dev/reference/react/useReducer#reference) 
  + [`useReducer(reducer, initialArg, init?)`](https://react.dev/reference/react/useReducer#usereducer)
  + [`dispatch` function](https://react.dev/reference/react/useReducer#dispatch)
* [Usage](https://react.dev/reference/react/useReducer#usage) 
  + [Adding a reducer to a component](https://react.dev/reference/react/useReducer#adding-a-reducer-to-a-component)
  + [Writing the reducer function](https://react.dev/reference/react/useReducer#writing-the-reducer-function)
  + [Avoiding recreating the initial state](https://react.dev/reference/react/useReducer#avoiding-recreating-the-initial-state)
* [Troubleshooting](https://react.dev/reference/react/useReducer#troubleshooting) 
  + [I’ve dispatched an action, but logging gives me the old state value](https://react.dev/reference/react/useReducer#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value)
  + [I’ve dispatched an action, but the screen doesn’t update](https://react.dev/reference/react/useReducer#ive-dispatched-an-action-but-the-screen-doesnt-update)
  + [A part of my reducer state becomes undefined after dispatching](https://react.dev/reference/react/useReducer#a-part-of-my-reducer-state-becomes-undefined-after-dispatching)
  + [My entire reducer state becomes undefined after dispatching](https://react.dev/reference/react/useReducer#my-entire-reducer-state-becomes-undefined-after-dispatching)
  + [I’m getting an error: “Too many re-renders”](https://react.dev/reference/react/useReducer#im-getting-an-error-too-many-re-renders)
  + [My reducer or initializer function runs twice](https://react.dev/reference/react/useReducer#my-reducer-or-initializer-function-runs-twice)

---

## Reference

### `useReducer(reducer, initialArg, init?)`

Call `useReducer` at the top level of your component to manage its state with a [reducer.](https://react.dev/learn/extracting-state-logic-into-a-reducer)

```
import { useReducer } from 'react';

function reducer(state, action) {

// ...

}

function MyComponent() {

const [state, dispatch] = useReducer(reducer, { age: 42 });

// ...
```

[See more examples below.](https://react.dev/reference/react/useReducer#usage)

#### Parameters

* `reducer`: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.
* `initialArg`: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next `init` argument.
* **optional** `init`: The initializer function that should return the initial state. If it’s not specified, the initial state is set to `initialArg`. Otherwise, the initial state is set to the result of calling `init(initialArg)`.

#### Returns

`useReducer` returns an array with exactly two values:

1. The current state. During the first render, it’s set to `init(initialArg)` or `initialArg` (if there’s no `init`).
2. The [`dispatch` function](https://react.dev/reference/react/useReducer#dispatch) that lets you update the state to a different value and trigger a re-render.

#### Caveats

* `useReducer` is a Hook, so you can only call it **at the top level of your component** or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
* The `dispatch` function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. [Learn more about removing Effect dependencies.](https://react.dev/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect)
* In Strict Mode, React will **call your reducer and initializer twice** in order to [help you find accidental impurities.](https://react.dev/reference/react/useReducer#my-reducer-or-initializer-function-runs-twice) This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored.

---

### `dispatch` function

The `dispatch` function returned by `useReducer` lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the `dispatch` function:

```
const [state, dispatch] = useReducer(reducer, { age: 42 });

function handleClick() {

dispatch({ type: 'incremented_age' });

// ...
```

React will set the next state to the result of calling the `reducer` function you’ve provided with the current `state` and the action you’ve passed to `dispatch`.

#### Parameters

* `action`: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with a `type` property identifying it and, optionally, other properties with additional information.

#### Returns

`dispatch` functions do not have a return value.

#### Caveats

* The `dispatch` function **only updates the state variable for the *next* render**. If you read the state variable after calling the `dispatch` function, [you will still get the old value](https://react.dev/reference/react/useReducer#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value) that was on the screen before your call.
* If the new value you provide is identical to the current `state`, as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison, React will **skip re-rendering the component and its children.** This is an optimization. React may still need to call your component before ignoring the result, but it shouldn’t affect your code.
* React [batches state updates.](https://react.dev/learn/queueing-a-series-of-state-updates) It updates the screen **after all the event handlers have run** and have called their `set` functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use [`flushSync`.](https://react.dev/reference/react-dom/flushSync)

---

## Usage

### Adding a reducer to a component

Call `useReducer` at the top level of your component to manage state with a [reducer.](https://react.dev/learn/extracting-state-logic-into-a-reducer)

```
import { useReducer } from 'react';

function reducer(state, action) {

// ...

}

function MyComponent() {

const [state, dispatch] = useReducer(reducer, { age: 42 });

// ...
```

`useReducer` returns an array with exactly two items:

1. The current state of this state variable, initially set to the initial state you provided.
2. The `dispatch` function that lets you change it in response to interaction.

To update what’s on the screen, call `dispatch` with an object representing what the user did, called an *action*:

```
function handleClick() {

dispatch({ type: 'incremented_age' });

}
```

React will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useReducer } from 'react';

function reducer(state, action) {
  if (action.type === 'incremented_age') {
    return {
      age: state.age + 1
    };
  }
  throw Error('Unknown action.');
}

export default function Counter() {
  const [state, dispatch] = useReducer(reducer, { age: 42 });

  return (
    <>
      <button onClick={() => {
        dispatch({ type: 'incremented_age' })
      }}>
        Increment age
      </button>
      <p>Hello! You are {state.age}.</p>
    </>
  );
}
```

Show more

`useReducer` is very similar to [`useState`](https://react.dev/reference/react/useState), but it lets you move the state update logic from event handlers into a single function outside of your component. Read more about [choosing between `useState` and `useReducer`.](https://react.dev/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer)

---

### Writing the reducer function

A reducer function is declared like this:

```
function reducer(state, action) {

// ...

}
```

Then you need to fill in the code that will calculate and return the next state. By convention, it is common to write it as a [`switch` statement.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch) For each `case` in the `switch`, calculate and return some next state.

```
function reducer(state, action) {

switch (action.type) {

case 'incremented_age': {

return {

name: state.name,

age: state.age + 1

};

}

case 'changed_name': {

return {

name: action.nextName,

age: state.age

};

}

}

throw Error('Unknown action: ' + action.type);

}
```

Actions can have any shape. By convention, it’s common to pass objects with a `type` property identifying the action. It should include the minimal necessary information that the reducer needs to compute the next state.

```
function Form() {

const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });

function handleButtonClick() {

dispatch({ type: 'incremented_age' });

}

function handleInputChange(e) {

dispatch({

type: 'changed_name',

nextName: e.target.value

});

}

// ...
```

The action type names are local to your component. [Each action describes a single interaction, even if that leads to multiple changes in data.](https://react.dev/learn/extracting-state-logic-into-a-reducer#writing-reducers-well) The shape of the state is arbitrary, but usually it’ll be an object or an array.

Read [extracting state logic into a reducer](https://react.dev/learn/extracting-state-logic-into-a-reducer) to learn more.

### Pitfall

State is read-only. Don’t modify any objects or arrays in state:

```
function reducer(state, action) {

switch (action.type) {

case 'incremented_age': {

// 🚩 Don't mutate an object in state like this:

state.age = state.age + 1;

return state;

}
```

Instead, always return new objects from your reducer:

```
function reducer(state, action) {

switch (action.type) {

case 'incremented_age': {

// ✅ Instead, return a new object

return {

...state,

age: state.age + 1

};

}
```

Read [updating objects in state](https://react.dev/learn/updating-objects-in-state) and [updating arrays in state](https://react.dev/learn/updating-arrays-in-state) to learn more.

#### Basic useReducer examples

1. Form (object) 2. Todo list (array) 3. Writing concise update logic with Immer

#### Example 1 of 3: Form (object)

In this example, the reducer manages a state object with two fields: `name` and `age`.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useReducer } from 'react';

function reducer(state, action) {
  switch (action.type) {
    case 'incremented_age': {
      return {
        name: state.name,
        age: state.age + 1
      };
    }
    case 'changed_name': {
      return {
        name: action.nextName,
        age: state.age
      };
    }
  }
  throw Error('Unknown action: ' + action.type);
}

const initialState = { name: 'Taylor', age: 42 };

export default function Form() {
  const [state, dispatch] = useReducer(reducer, initialState);

  function handleButtonClick() {
    dispatch({ type: 'incremented_age' });
  }

  function handleInputChange(e) {
    dispatch({
      type: 'changed_name',
      nextName: e.target.value
    }); 
  }

  return (
    <>
      <input
        value={state.name}
        onChange={handleInputChange}
      />
      <button onClick={handleButtonClick}>
        Increment age
      </button>
      <p>Hello, {state.name}. You are {state.age}.</p>
    </>
  );
}
```

Show more

Next Example

---

### Avoiding recreating the initial state

React saves the initial state once and ignores it on the next renders.

```
function createInitialState(username) {

// ...

}

function TodoList({ username }) {

const [state, dispatch] = useReducer(reducer, createInitialState(username));

// ...
```

Although the result of `createInitialState(username)` is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating large arrays or performing expensive calculations.

To solve this, you may **pass it as an *initializer* function** to `useReducer` as the third argument instead:

```
function createInitialState(username) {

// ...

}

function TodoList({ username }) {

const [state, dispatch] = useReducer(reducer, username, createInitialState);

// ...
```

Notice that you’re passing `createInitialState`, which is the *function itself*, and not `createInitialState()`, which is the result of calling it. This way, the initial state does not get re-created after initialization.

In the above example, `createInitialState` takes a `username` argument. If your initializer doesn’t need any information to compute the initial state, you may pass `null` as the second argument to `useReducer`.

#### The difference between passing an initializer and passing the initial state directly

1. Passing the initializer function 2. Passing the initial state directly

#### Example 1 of 2: Passing the initializer function

This example passes the initializer function, so the `createInitialState` function only runs during initialization. It does not run when component re-renders, such as when you type into the input.

TodoList.js

TodoList.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useReducer } from 'react';

function createInitialState(username) {
  const initialTodos = [];
  for (let i = 0; i < 50; i++) {
    initialTodos.push({
      id: i,
      text: username + "'s task #" + (i + 1)
    });
  }
  return {
    draft: '',
    todos: initialTodos,
  };
}

function reducer(state, action) {
  switch (action.type) {
    case 'changed_draft': {
      return {
        draft: action.nextDraft,
        todos: state.todos,
      };
    };
    case 'added_todo': {
      return {
        draft: '',
        todos: [{
          id: state.todos.length,
          text: state.draft
        }, ...state.todos]
      }
    }
  }
  throw Error('Unknown action: ' + action.type);
}

export default function TodoList({ username }) {
  const [state, dispatch] = useReducer(
    reducer,
    username,
    createInitialState
  );
  return (
    <>
      <input
        value={state.draft}
        onChange={e => {
          dispatch({
            type: 'changed_draft',
            nextDraft: e.target.value
          })
        }}
      />
      <button onClick={() => {
        dispatch({ type: 'added_todo' });
      }}>Add</button>
      <ul>
        {state.todos.map(item => (
          <li key={item.id}>
            {item.text}
          </li>
        ))}
      </ul>
    </>
  );
}
```

Show more

Next Example

---

## Troubleshooting

### I’ve dispatched an action, but logging gives me the old state value

Calling the `dispatch` function **does not change state in the running code**:

```
function handleClick() {

console.log(state.age);  // 42

dispatch({ type: 'incremented_age' }); // Request a re-render with 43

console.log(state.age);  // Still 42!

setTimeout(() => {

console.log(state.age); // Also 42!

}, 5000);

}
```

This is because [states behaves like a snapshot.](https://react.dev/learn/state-as-a-snapshot) Updating state requests another render with the new state value, but does not affect the `state` JavaScript variable in your already-running event handler.

If you need to guess the next state value, you can calculate it manually by calling the reducer yourself:

```
const action = { type: 'incremented_age' };

dispatch(action);

const nextState = reducer(state, action);

console.log(state);     // { age: 42 }

console.log(nextState); // { age: 43 }
```

---

### I’ve dispatched an action, but the screen doesn’t update

React will **ignore your update if the next state is equal to the previous state,** as determined by an [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. This usually happens when you change an object or an array in state directly:

```
function reducer(state, action) {

switch (action.type) {

case 'incremented_age': {

// 🚩 Wrong: mutating existing object

state.age++;

return state;

}

case 'changed_name': {

// 🚩 Wrong: mutating existing object

state.name = action.nextName;

return state;

}

// ...

}

}
```

You mutated an existing `state` object and returned it, so React ignored the update. To fix this, you need to ensure that you’re always [updating objects in state](https://react.dev/learn/updating-objects-in-state) and [updating arrays in state](https://react.dev/learn/updating-arrays-in-state) instead of mutating them:

```
function reducer(state, action) {

switch (action.type) {

case 'incremented_age': {

// ✅ Correct: creating a new object

return {

...state,

age: state.age + 1

};

}

case 'changed_name': {

// ✅ Correct: creating a new object

return {

...state,

name: action.nextName

};

}

// ...

}

}
```

---

### A part of my reducer state becomes undefined after dispatching

Make sure that every `case` branch **copies all of the existing fields** when returning the new state:

```
function reducer(state, action) {

switch (action.type) {

case 'incremented_age': {

return {

...state, // Don't forget this!

age: state.age + 1

};

}

// ...
```

Without `...state` above, the returned next state would only contain the `age` field and nothing else.

---

### My entire reducer state becomes undefined after dispatching

If your state unexpectedly becomes `undefined`, you’re likely forgetting to `return` state in one of the cases, or your action type doesn’t match any of the `case` statements. To find why, throw an error outside the `switch`:

```
function reducer(state, action) {

switch (action.type) {

case 'incremented_age': {

// ...

}

case 'edited_name': {

// ...

}

}

throw Error('Unknown action: ' + action.type);

}
```

You can also use a static type checker like TypeScript to catch such mistakes.

---

### I’m getting an error: “Too many re-renders”

You might get an error that says: `Too many re-renders. React limits the number of renders to prevent an infinite loop.` Typically, this means that you’re unconditionally dispatching an action *during render*, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:

```
// 🚩 Wrong: calls the handler during render

return <button onClick={handleClick()}>Click me</button>

// ✅ Correct: passes down the event handler

return <button onClick={handleClick}>Click me</button>

// ✅ Correct: passes down an inline function

return <button onClick={(e) => handleClick(e)}>Click me</button>
```

If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific `dispatch` function call responsible for the error.

---

### My reducer or initializer function runs twice

In [Strict Mode](https://react.dev/reference/react/StrictMode), React will call your reducer and initializer functions twice. This shouldn’t break your code.

This **development-only** behavior helps you [keep components pure.](https://react.dev/learn/keeping-components-pure) React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes.

For example, this impure reducer function mutates an array in state:

```
function reducer(state, action) {

switch (action.type) {

case 'added_todo': {

// 🚩 Mistake: mutating state

state.todos.push({ id: nextId++, text: action.text });

return state;

}

// ...

}

}
```

Because React calls your reducer function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by [replacing the array instead of mutating it](https://react.dev/learn/updating-arrays-in-state#adding-to-an-array):

```
function reducer(state, action) {

switch (action.type) {

case 'added_todo': {

// ✅ Correct: replacing with new state

return {

...state,

todos: [

...state.todos,

{ id: nextId++, text: action.text }

]

};

}

// ...

}

}
```

Now that this reducer function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. **Only component, initializer, and reducer functions need to be pure.** Event handlers don’t need to be pure, so React will never call your event handlers twice.

Read [keeping components pure](https://react.dev/learn/keeping-components-pure) to learn more.

[PrevioususeOptimistic](https://react.dev/reference/react/useOptimistic)[NextuseRef](https://react.dev/reference/react/useRef)

---

---


# useRef – React

URL: https://react.dev/reference/react/useRef

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useRef

`useRef` is a React Hook that lets you reference a value that’s not needed for rendering.

```
const ref = useRef(initialValue)
```

* [Reference](https://react.dev/reference/react/useRef#reference) 
  + [`useRef(initialValue)`](https://react.dev/reference/react/useRef#useref)
* [Usage](https://react.dev/reference/react/useRef#usage) 
  + [Referencing a value with a ref](https://react.dev/reference/react/useRef#referencing-a-value-with-a-ref)
  + [Manipulating the DOM with a ref](https://react.dev/reference/react/useRef#manipulating-the-dom-with-a-ref)
  + [Avoiding recreating the ref contents](https://react.dev/reference/react/useRef#avoiding-recreating-the-ref-contents)
* [Troubleshooting](https://react.dev/reference/react/useRef#troubleshooting) 
  + [I can’t get a ref to a custom component](https://react.dev/reference/react/useRef#i-cant-get-a-ref-to-a-custom-component)

---

## Reference

### `useRef(initialValue)`

Call `useRef` at the top level of your component to declare a [ref.](https://react.dev/learn/referencing-values-with-refs)

```
import { useRef } from 'react';

function MyComponent() {

const intervalRef = useRef(0);

const inputRef = useRef(null);

// ...
```

[See more examples below.](https://react.dev/reference/react/useRef#usage)

#### Parameters

* `initialValue`: The value you want the ref object’s `current` property to be initially. It can be a value of any type. This argument is ignored after the initial render.

#### Returns

`useRef` returns an object with a single property:

* `current`: Initially, it’s set to the `initialValue` you have passed. You can later set it to something else. If you pass the ref object to React as a `ref` attribute to a JSX node, React will set its `current` property.

On the next renders, `useRef` will return the same object.

#### Caveats

* You can mutate the `ref.current` property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn’t mutate that object.
* When you change the `ref.current` property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object.
* Do not write *or read* `ref.current` during rendering, except for [initialization.](https://react.dev/reference/react/useRef#avoiding-recreating-the-ref-contents) This makes your component’s behavior unpredictable.
* In Strict Mode, React will **call your component function twice** in order to [help you find accidental impurities.](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior.

---

## Usage

### Referencing a value with a ref

Call `useRef` at the top level of your component to declare one or more [refs.](https://react.dev/learn/referencing-values-with-refs)

```
import { useRef } from 'react';

function Stopwatch() {

const intervalRef = useRef(0);

// ...
```

`useRef` returns a ref object with a single `current` property initially set to the initial value you provided.

On the next renders, `useRef` will return the same object. You can change its `current` property to store information and read it later. This might remind you of [state](https://react.dev/reference/react/useState), but there is an important difference.

**Changing a ref does not trigger a re-render.** This means refs are perfect for storing information that doesn’t affect the visual output of your component. For example, if you need to store an [interval ID](https://developer.mozilla.org/en-US/docs/Web/API/setInterval) and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its `current` property:

```
function handleStartClick() {

const intervalId = setInterval(() => {

// ...

}, 1000);

intervalRef.current = intervalId;

}
```

Later, you can read that interval ID from the ref so that you can call [clear that interval](https://developer.mozilla.org/en-US/docs/Web/API/clearInterval):

```
function handleStopClick() {

const intervalId = intervalRef.current;

clearInterval(intervalId);

}
```

By using a ref, you ensure that:

* You can **store information** between re-renders (unlike regular variables, which reset on every render).
* Changing it **does not trigger a re-render** (unlike state variables, which trigger a re-render).
* The **information is local** to each copy of your component (unlike the variables outside, which are shared).

Changing a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about [choosing between `useRef` and `useState`.](https://react.dev/learn/referencing-values-with-refs#differences-between-refs-and-state)

#### Examples of referencing a value with useRef

1. Click counter 2. A stopwatch

#### Example 1 of 2: Click counter

This component uses a ref to keep track of how many times the button was clicked. Note that it’s okay to use a ref instead of state here because the click count is only read and written in an event handler.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('You clicked ' + ref.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}
```

Show more

If you show `{ref.current}` in the JSX, the number won’t update on click. This is because setting `ref.current` does not trigger a re-render. Information that’s used for rendering should be state instead.

Next Example

### Pitfall

**Do not write *or read* `ref.current` during rendering.**

React expects that the body of your component [behaves like a pure function](https://react.dev/learn/keeping-components-pure):

* If the inputs ([props](https://react.dev/learn/passing-props-to-a-component), [state](https://react.dev/learn/state-a-components-memory), and [context](https://react.dev/learn/passing-data-deeply-with-context)) are the same, it should return exactly the same JSX.
* Calling it in a different order or with different arguments should not affect the results of other calls.

Reading or writing a ref **during rendering** breaks these expectations.

```
function MyComponent() {

// ...

// 🚩 Don't write a ref during rendering

myRef.current = 123;

// ...

// 🚩 Don't read a ref during rendering

return <h1>{myOtherRef.current}</h1>;

}
```

You can read or write refs **from event handlers or effects instead**.

```
function MyComponent() {

// ...

useEffect(() => {

// ✅ You can read or write refs in effects

myRef.current = 123;

});

// ...

function handleClick() {

// ✅ You can read or write refs in event handlers

doSomething(myOtherRef.current);

}

// ...

}
```

If you *have to* read [or write](https://react.dev/reference/react/useState#storing-information-from-previous-renders) something during rendering, [use state](https://react.dev/reference/react/useState) instead.

When you break these rules, your component might still work, but most of the newer features we’re adding to React will rely on these expectations. Read more about [keeping your components pure.](https://react.dev/learn/keeping-components-pure#where-you-_can_-cause-side-effects)

---

### Manipulating the DOM with a ref

It’s particularly common to use a ref to manipulate the [DOM.](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API) React has built-in support for this.

First, declare a ref object with an initial value of `null`:

```
import { useRef } from 'react';

function MyComponent() {

const inputRef = useRef(null);

// ...
```

Then pass your ref object as the `ref` attribute to the JSX of the DOM node you want to manipulate:

```
// ...

return <input ref={inputRef} />;
```

After React creates the DOM node and puts it on the screen, React will set the `current` property of your ref object to that DOM node. Now you can access the `<input>`’s DOM node and call methods like [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus):

```
function handleClick() {

inputRef.current.focus();

}
```

React will set the `current` property back to `null` when the node is removed from the screen.

Read more about [manipulating the DOM with refs.](https://react.dev/learn/manipulating-the-dom-with-refs)

#### Examples of manipulating the DOM with useRef

1. Focusing a text input 2. Scrolling an image into view 3. Playing and pausing a video 4. Exposing a ref to your own component

#### Example 1 of 4: Focusing a text input

In this example, clicking the button will focus the input:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

Show more

Next Example

---

### Avoiding recreating the ref contents

React saves the initial ref value once and ignores it on the next renders.

```
function Video() {

const playerRef = useRef(new VideoPlayer());

// ...
```

Although the result of `new VideoPlayer()` is only used for the initial render, you’re still calling this function on every render. This can be wasteful if it’s creating expensive objects.

To solve it, you may initialize the ref like this instead:

```
function Video() {

const playerRef = useRef(null);

if (playerRef.current === null) {

playerRef.current = new VideoPlayer();

}

// ...
```

Normally, writing or reading `ref.current` during render is not allowed. However, it’s fine in this case because the result is always the same, and the condition only executes during initialization so it’s fully predictable.

##### Deep Dive

#### How to avoid null checks when initializing useRef later

Show Details

If you use a type checker and don’t want to always check for `null`, you can try a pattern like this instead:

```
function Video() {

const playerRef = useRef(null);

function getPlayer() {

if (playerRef.current !== null) {

return playerRef.current;

}

const player = new VideoPlayer();

playerRef.current = player;

return player;

}

// ...
```

Here, the `playerRef` itself is nullable. However, you should be able to convince your type checker that there is no case in which `getPlayer()` returns `null`. Then use `getPlayer()` in your event handlers.

---

## Troubleshooting

### I can’t get a ref to a custom component

If you try to pass a `ref` to your own component like this:

```
const inputRef = useRef(null);

return <MyInput ref={inputRef} />;
```

You might get an error in the console:

Console

TypeError: Cannot read properties of null

By default, your own components don’t expose refs to the DOM nodes inside them.

To fix this, find the component that you want to get a ref to:

```
export default function MyInput({ value, onChange }) {

return (

<input

value={value}

onChange={onChange}

/>

);

}
```

And then add `ref` to the list of props your component accepts and pass `ref` as a prop to the relevant child [built-in component](https://react.dev/reference/react-dom/components/common) like this:

```
function MyInput({ value, onChange, ref }) {

return (

<input

value={value}

onChange={onChange}

ref={ref}

/>

);

};

export default MyInput;
```

Then the parent component can get a ref to it.

Read more about [accessing another component’s DOM nodes.](https://react.dev/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes)

[PrevioususeReducer](https://react.dev/reference/react/useReducer)[NextuseState](https://react.dev/reference/react/useState)

---

---


# useSyncExternalStore – React

URL: https://react.dev/reference/react/useSyncExternalStore

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useSyncExternalStore

`useSyncExternalStore` is a React Hook that lets you subscribe to an external store.

```
const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)
```

* [Reference](https://react.dev/reference/react/useSyncExternalStore#reference) 
  + [`useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)`](https://react.dev/reference/react/useSyncExternalStore#usesyncexternalstore)
* [Usage](https://react.dev/reference/react/useSyncExternalStore#usage) 
  + [Subscribing to an external store](https://react.dev/reference/react/useSyncExternalStore#subscribing-to-an-external-store)
  + [Subscribing to a browser API](https://react.dev/reference/react/useSyncExternalStore#subscribing-to-a-browser-api)
  + [Extracting the logic to a custom Hook](https://react.dev/reference/react/useSyncExternalStore#extracting-the-logic-to-a-custom-hook)
  + [Adding support for server rendering](https://react.dev/reference/react/useSyncExternalStore#adding-support-for-server-rendering)
* [Troubleshooting](https://react.dev/reference/react/useSyncExternalStore#troubleshooting) 
  + [I’m getting an error: “The result of `getSnapshot` should be cached”](https://react.dev/reference/react/useSyncExternalStore#im-getting-an-error-the-result-of-getsnapshot-should-be-cached)
  + [My `subscribe` function gets called after every re-render](https://react.dev/reference/react/useSyncExternalStore#my-subscribe-function-gets-called-after-every-re-render)

---

## Reference

### `useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)`

Call `useSyncExternalStore` at the top level of your component to read a value from an external data store.

```
import { useSyncExternalStore } from 'react';

import { todosStore } from './todoStore.js';

function TodosApp() {

const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);

// ...

}
```

It returns the snapshot of the data in the store. You need to pass two functions as arguments:

1. The `subscribe` function should subscribe to the store and return a function that unsubscribes.
2. The `getSnapshot` function should read a snapshot of the data from the store.

[See more examples below.](https://react.dev/reference/react/useSyncExternalStore#usage)

#### Parameters

* `subscribe`: A function that takes a single `callback` argument and subscribes it to the store. When the store changes, it should invoke the provided `callback`, which will cause React to re-call `getSnapshot` and (if needed) re-render the component. The `subscribe` function should return a function that cleans up the subscription.
* `getSnapshot`: A function that returns a snapshot of the data in the store that’s needed by the component. While the store has not changed, repeated calls to `getSnapshot` must return the same value. If the store changes and the returned value is different (as compared by [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)), React re-renders the component.
* **optional** `getServerSnapshot`: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error.

#### Returns

The current snapshot of the store which you can use in your rendering logic.

#### Caveats

* The store snapshot returned by `getSnapshot` must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot.
* If a different `subscribe` function is passed during a re-render, React will re-subscribe to the store using the newly passed `subscribe` function. You can prevent this by declaring `subscribe` outside the component.
* If the store is mutated during a [non-blocking Transition update](https://react.dev/reference/react/useTransition), React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call `getSnapshot` a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store.
* It’s not recommended to *suspend* a render based on a store value returned by `useSyncExternalStore`. The reason is that mutations to the external store cannot be marked as [non-blocking Transition updates](https://react.dev/reference/react/useTransition), so they will trigger the nearest [`Suspense` fallback](https://react.dev/reference/react/Suspense), replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX.

  For example, the following are discouraged:

  ```
  const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));

  function ShoppingApp() {

  const selectedProductId = useSyncExternalStore(...);

  // ❌ Calling `use` with a Promise dependent on `selectedProductId`

  const data = use(fetchItem(selectedProductId))

  // ❌ Conditionally rendering a lazy component based on `selectedProductId`

  return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;

  }
  ```

---

## Usage

### Subscribing to an external store

Most of your React components will only read data from their [props,](https://react.dev/learn/passing-props-to-a-component) [state,](https://react.dev/reference/react/useState) and [context.](https://react.dev/reference/react/useContext) However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes:

* Third-party state management libraries that hold state outside of React.
* Browser APIs that expose a mutable value and events to subscribe to its changes.

Call `useSyncExternalStore` at the top level of your component to read a value from an external data store.

```
import { useSyncExternalStore } from 'react';

import { todosStore } from './todoStore.js';

function TodosApp() {

const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);

// ...

}
```

It returns the snapshot of the data in the store. You need to pass two functions as arguments:

1. The `subscribe` function should subscribe to the store and return a function that unsubscribes.
2. The `getSnapshot` function should read a snapshot of the data from the store.

React will use these functions to keep your component subscribed to the store and re-render it on changes.

For example, in the sandbox below, `todosStore` is implemented as an external store that stores data outside of React. The `TodosApp` component connects to that external store with the `useSyncExternalStore` Hook.

App.jstodoStore.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useSyncExternalStore } from 'react';
import { todosStore } from './todoStore.js';

export default function TodosApp() {
  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);
  return (
    <>
      <button onClick={() => todosStore.addTodo()}>Add todo</button>
      <hr />
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </>
  );
}
```

Show more

### Note

When possible, we recommend using built-in React state with [`useState`](https://react.dev/reference/react/useState) and [`useReducer`](https://react.dev/reference/react/useReducer) instead. The `useSyncExternalStore` API is mostly useful if you need to integrate with existing non-React code.

---

### Subscribing to a browser API

Another reason to add `useSyncExternalStore` is when you want to subscribe to some value exposed by the browser that changes over time. For example, suppose that you want your component to display whether the network connection is active. The browser exposes this information via a property called [`navigator.onLine`.](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/onLine)

This value can change without React’s knowledge, so you should read it with `useSyncExternalStore`.

```
import { useSyncExternalStore } from 'react';

function ChatIndicator() {

const isOnline = useSyncExternalStore(subscribe, getSnapshot);

// ...

}
```

To implement the `getSnapshot` function, read the current value from the browser API:

```
function getSnapshot() {

return navigator.onLine;

}
```

Next, you need to implement the `subscribe` function. For example, when `navigator.onLine` changes, the browser fires the [`online`](https://developer.mozilla.org/en-US/docs/Web/API/Window/online_event) and [`offline`](https://developer.mozilla.org/en-US/docs/Web/API/Window/offline_event) events on the `window` object. You need to subscribe the `callback` argument to the corresponding events, and then return a function that cleans up the subscriptions:

```
function subscribe(callback) {

window.addEventListener('online', callback);

window.addEventListener('offline', callback);

return () => {

window.removeEventListener('online', callback);

window.removeEventListener('offline', callback);

};

}
```

Now React knows how to read the value from the external `navigator.onLine` API and how to subscribe to its changes. Disconnect your device from the network and notice that the component re-renders in response:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useSyncExternalStore } from 'react';

export default function ChatIndicator() {
  const isOnline = useSyncExternalStore(subscribe, getSnapshot);
  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}

function getSnapshot() {
  return navigator.onLine;
}

function subscribe(callback) {
  window.addEventListener('online', callback);
  window.addEventListener('offline', callback);
  return () => {
    window.removeEventListener('online', callback);
    window.removeEventListener('offline', callback);
  };
}
```

Show more

---

### Extracting the logic to a custom Hook

Usually you won’t write `useSyncExternalStore` directly in your components. Instead, you’ll typically call it from your own custom Hook. This lets you use the same external store from different components.

For example, this custom `useOnlineStatus` Hook tracks whether the network is online:

```
import { useSyncExternalStore } from 'react';

export function useOnlineStatus() {

const isOnline = useSyncExternalStore(subscribe, getSnapshot);

return isOnline;

}

function getSnapshot() {

// ...

}

function subscribe(callback) {

// ...

}
```

Now different components can call `useOnlineStatus` without repeating the underlying implementation:

App.jsuseOnlineStatus.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useOnlineStatus } from './useOnlineStatus.js';

function StatusBar() {
  const isOnline = useOnlineStatus();
  return <h1>{isOnline ? '✅ Online' : '❌ Disconnected'}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus();

  function handleSaveClick() {
    console.log('✅ Progress saved');
  }

  return (
    <button disabled={!isOnline} onClick={handleSaveClick}>
      {isOnline ? 'Save progress' : 'Reconnecting...'}
    </button>
  );
}

export default function App() {
  return (
    <>
      <SaveButton />
      <StatusBar />
    </>
  );
}
```

Show more

---

### Adding support for server rendering

If your React app uses [server rendering,](https://react.dev/reference/react-dom/server) your React components will also run outside the browser environment to generate the initial HTML. This creates a few challenges when connecting to an external store:

* If you’re connecting to a browser-only API, it won’t work because it does not exist on the server.
* If you’re connecting to a third-party data store, you’ll need its data to match between the server and client.

To solve these issues, pass a `getServerSnapshot` function as the third argument to `useSyncExternalStore`:

```
import { useSyncExternalStore } from 'react';

export function useOnlineStatus() {

const isOnline = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);

return isOnline;

}

function getSnapshot() {

return navigator.onLine;

}

function getServerSnapshot() {

return true; // Always show "Online" for server-generated HTML

}

function subscribe(callback) {

// ...

}
```

The `getServerSnapshot` function is similar to `getSnapshot`, but it runs only in two situations:

* It runs on the server when generating the HTML.
* It runs on the client during [hydration](https://react.dev/reference/react-dom/client/hydrateRoot), i.e. when React takes the server HTML and makes it interactive.

This lets you provide the initial snapshot value which will be used before the app becomes interactive. If there is no meaningful initial value for the server rendering, omit this argument to [force rendering on the client.](https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content)

### Note

Make sure that `getServerSnapshot` returns the same exact data on the initial client render as it returned on the server. For example, if `getServerSnapshot` returned some prepopulated store content on the server, you need to transfer this content to the client. One way to do this is to emit a `<script>` tag during server rendering that sets a global like `window.MY_STORE_DATA`, and read from that global on the client in `getServerSnapshot`. Your external store should provide instructions on how to do that.

---

## Troubleshooting

### I’m getting an error: “The result of `getSnapshot` should be cached”

This error means your `getSnapshot` function returns a new object every time it’s called, for example:

```
function getSnapshot() {

// 🔴 Do not return always different objects from getSnapshot

return {

todos: myStore.todos

};

}
```

React will re-render the component if `getSnapshot` return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error.

Your `getSnapshot` object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:

```
function getSnapshot() {

// ✅ You can return immutable data

return myStore.todos;

}
```

If your store data is mutable, your `getSnapshot` function should return an immutable snapshot of it. This means it *does* need to create new objects, but it shouldn’t do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store.

---

### My `subscribe` function gets called after every re-render

This `subscribe` function is defined *inside* a component so it is different on every re-render:

```
function ChatIndicator() {

// 🚩 Always a different function, so React will resubscribe on every re-render

function subscribe() {

// ...

}

const isOnline = useSyncExternalStore(subscribe, getSnapshot);

// ...

}
```

React will resubscribe to your store if you pass a different `subscribe` function between re-renders. If this causes performance issues and you’d like to avoid resubscribing, move the `subscribe` function outside:

```
// ✅ Always the same function, so React won't need to resubscribe

function subscribe() {

// ...

}

function ChatIndicator() {

const isOnline = useSyncExternalStore(subscribe, getSnapshot);

// ...

}
```

Alternatively, wrap `subscribe` into [`useCallback`](https://react.dev/reference/react/useCallback) to only resubscribe when some argument changes:

```
function ChatIndicator({ userId }) {

// ✅ Same function as long as userId doesn't change

const subscribe = useCallback(() => {

// ...

}, [userId]);

const isOnline = useSyncExternalStore(subscribe, getSnapshot);

// ...

}
```

[PrevioususeState](https://react.dev/reference/react/useState)[NextuseTransition](https://react.dev/reference/react/useTransition)

---

---


# useTransition – React

URL: https://react.dev/reference/react/useTransition

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react/hooks)

# useTransition

`useTransition` is a React Hook that lets you render a part of the UI in the background.

```
const [isPending, startTransition] = useTransition()
```

* [Reference](https://react.dev/reference/react/useTransition#reference) 
  + [`useTransition()`](https://react.dev/reference/react/useTransition#usetransition)
  + [`startTransition(action)`](https://react.dev/reference/react/useTransition#starttransition)
* [Usage](https://react.dev/reference/react/useTransition#usage) 
  + [Perform non-blocking updates with Actions](https://react.dev/reference/react/useTransition#perform-non-blocking-updates-with-actions)
  + [Exposing `action` prop from components](https://react.dev/reference/react/useTransition#exposing-action-props-from-components)
  + [Displaying a pending visual state](https://react.dev/reference/react/useTransition#displaying-a-pending-visual-state)
  + [Preventing unwanted loading indicators](https://react.dev/reference/react/useTransition#preventing-unwanted-loading-indicators)
  + [Building a Suspense-enabled router](https://react.dev/reference/react/useTransition#building-a-suspense-enabled-router)
  + [Displaying an error to users with an error boundary](https://react.dev/reference/react/useTransition#displaying-an-error-to-users-with-error-boundary)
* [Troubleshooting](https://react.dev/reference/react/useTransition#troubleshooting) 
  + [Updating an input in a Transition doesn’t work](https://react.dev/reference/react/useTransition#updating-an-input-in-a-transition-doesnt-work)
  + [React doesn’t treat my state update as a Transition](https://react.dev/reference/react/useTransition#react-doesnt-treat-my-state-update-as-a-transition)
  + [React doesn’t treat my state update after `await` as a Transition](https://react.dev/reference/react/useTransition#react-doesnt-treat-my-state-update-after-await-as-a-transition)
  + [I want to call `useTransition` from outside a component](https://react.dev/reference/react/useTransition#i-want-to-call-usetransition-from-outside-a-component)
  + [The function I pass to `startTransition` executes immediately](https://react.dev/reference/react/useTransition#the-function-i-pass-to-starttransition-executes-immediately)
  + [My state updates in Transitions are out of order](https://react.dev/reference/react/useTransition#my-state-updates-in-transitions-are-out-of-order)

---

## Reference

### `useTransition()`

Call `useTransition` at the top level of your component to mark some state updates as Transitions.

```
import { useTransition } from 'react';

function TabContainer() {

const [isPending, startTransition] = useTransition();

// ...

}
```

[See more examples below.](https://react.dev/reference/react/useTransition#usage)

#### Parameters

`useTransition` does not take any parameters.

#### Returns

`useTransition` returns an array with exactly two items:

1. The `isPending` flag that tells you whether there is a pending Transition.
2. The [`startTransition` function](https://react.dev/reference/react/useTransition#starttransition) that lets you mark updates as a Transition.

---

### `startTransition(action)`

The `startTransition` function returned by `useTransition` lets you mark an update as a Transition.

```
function TabContainer() {

const [isPending, startTransition] = useTransition();

const [tab, setTab] = useState('about');

function selectTab(nextTab) {

startTransition(() => {

setTab(nextTab);

});

}

// ...

}
```

### Note

#### Functions called in `startTransition` are called “Actions”.

The function passed to `startTransition` is called an “Action”. By convention, any callback called inside `startTransition` (such as a callback prop) should be named `action` or include the “Action” suffix:

```
function SubmitButton({ submitAction }) {

const [isPending, startTransition] = useTransition();

return (

<button

disabled={isPending}

onClick={() => {

startTransition(async () => {

await submitAction();

});

}}

>

Submit

</button>

);

}
```

#### Parameters

* `action`: A function that updates some state by calling one or more [`set` functions](https://react.dev/reference/react/useState#setstate). React calls `action` immediately with no parameters and marks all state updates scheduled synchronously during the `action` function call as Transitions. Any async calls that are awaited in the `action` will be included in the Transition, but currently require wrapping any `set` functions after the `await` in an additional `startTransition` (see [Troubleshooting](https://react.dev/reference/react/useTransition#react-doesnt-treat-my-state-update-after-await-as-a-transition)). State updates marked as Transitions will be [non-blocking](https://react.dev/reference/react/useTransition#perform-non-blocking-updates-with-actions) and [will not display unwanted loading indicators](https://react.dev/reference/react/useTransition#preventing-unwanted-loading-indicators).

#### Returns

`startTransition` does not return anything.

#### Caveats

* `useTransition` is a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalone [`startTransition`](https://react.dev/reference/react/startTransition) instead.
* You can wrap an update into a Transition only if you have access to the `set` function of that state. If you want to start a Transition in response to some prop or a custom Hook value, try [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) instead.
* The function you pass to `startTransition` is called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in a `setTimeout`, for example, they won’t be marked as Transitions.
* You must wrap any state updates after any async requests in another `startTransition` to mark them as Transitions. This is a known limitation that we will fix in the future (see [Troubleshooting](https://react.dev/reference/react/useTransition#react-doesnt-treat-my-state-update-after-await-as-a-transition)).
* The `startTransition` function has a stable identity, so you will often see it omitted from Effect dependencies, but including it will not cause the Effect to fire. If the linter lets you omit a dependency without errors, it is safe to do. [Learn more about removing Effect dependencies.](https://react.dev/learn/removing-effect-dependencies#move-dynamic-objects-and-functions-inside-your-effect)
* A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update.
* Transition updates can’t be used to control text inputs.
* If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.

## Usage

### Perform non-blocking updates with Actions

Call `useTransition` at the top of your component to create Actions, and access the pending state:

```
import {useState, useTransition} from 'react';

function CheckoutForm() {

const [isPending, startTransition] = useTransition();

// ...

}
```

`useTransition` returns an array with exactly two items:

1. The `isPending` flag that tells you whether there is a pending Transition.
2. The `startTransition` function that lets you create an Action.

To start a Transition, pass a function to `startTransition` like this:

```
import {useState, useTransition} from 'react';

import {updateQuantity} from './api';

function CheckoutForm() {

const [isPending, startTransition] = useTransition();

const [quantity, setQuantity] = useState(1);

function onSubmit(newQuantity) {

startTransition(async function () {

const savedQuantity = await updateQuantity(newQuantity);

startTransition(() => {

setQuantity(savedQuantity);

});

});

}

// ...

}
```

The function passed to `startTransition` is called the “Action”. You can update state and (optionally) perform side effects within an Action, and the work will be done in the background without blocking user interactions on the page. A Transition can include multiple Actions, and while a Transition is in progress, your UI stays responsive. For example, if the user clicks a tab but then changes their mind and clicks another tab, the second click will be immediately handled without waiting for the first update to finish.

To give the user feedback about in-progress Transitions, the `isPending` state switches to `true` at the first call to `startTransition`, and stays `true` until all Actions complete and the final state is shown to the user. Transitions ensure side effects in Actions to complete in order to [prevent unwanted loading indicators](https://react.dev/reference/react/useTransition#preventing-unwanted-loading-indicators), and you can provide immediate feedback while the Transition is in progress with `useOptimistic`.

#### The difference between Actions and regular event handling

1. Updating the quantity in an Action 2. Updating the quantity without an Action

#### Example 1 of 2: Updating the quantity in an Action

In this example, the `updateQuantity` function simulates a request to the server to update the item’s quantity in the cart. This function is *artificially slowed down* so that it takes at least a second to complete the request.

Update the quantity multiple times quickly. Notice that the pending “Total” state is shown while any requests are in progress, and the “Total” updates only after the final request is complete. Because the update is in an Action, the “quantity” can continue to be updated while the request is in progress.

App.jsItem.jsTotal.jsapi.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useTransition } from "react";
import { updateQuantity } from "./api";
import Item from "./Item";
import Total from "./Total";

export default function App({}) {
  const [quantity, setQuantity] = useState(1);
  const [isPending, startTransition] = useTransition();

  const updateQuantityAction = async newQuantity => {
    // To access the pending state of a transition,
    // call startTransition again.
    startTransition(async () => {
      const savedQuantity = await updateQuantity(newQuantity);
      startTransition(() => {
        setQuantity(savedQuantity);
      });
    });
  };

  return (
    <div>
      <h1>Checkout</h1>
      <Item action={updateQuantityAction}/>
      <hr />
      <Total quantity={quantity} isPending={isPending} />
    </div>
  );
}
```

Show more

This is a basic example to demonstrate how Actions work, but this example does not handle requests completing out of order. When updating the quantity multiple times, it’s possible for the previous requests to finish after later requests causing the quantity to update out of order. This is a known limitation that we will fix in the future (see [Troubleshooting](https://react.dev/reference/react/useTransition#my-state-updates-in-transitions-are-out-of-order) below).

For common use cases, React provides built-in abstractions such as:

* [`useActionState`](https://react.dev/reference/react/useActionState)
* [`<form>` actions](https://react.dev/reference/react-dom/components/form)
* [Server Functions](https://react.dev/reference/rsc/server-functions)

These solutions handle request ordering for you. When using Transitions to build your own custom hooks or libraries that manage async state transitions, you have greater control over the request ordering, but you must handle it yourself.

Next Example

---

### Exposing `action` prop from components

You can expose an `action` prop from a component to allow a parent to call an Action.

For example, this `TabButton` component wraps its `onClick` logic in an `action` prop:

```
export default function TabButton({ action, children, isActive }) {

const [isPending, startTransition] = useTransition();

if (isActive) {

return <b>{children}</b>

}

return (

<button onClick={() => {

startTransition(async () => {

// await the action that's passed in.

// This allows it to be either sync or async.

await action();

});

}}>

{children}

</button>

);

}
```

Because the parent component updates its state inside the `action`, that state update gets marked as a Transition. This means you can click on “Posts” and then immediately click “Contact” and it does not block user interactions:

App.jsTabButton.jsAboutTab.jsPostsTab.jsContactTab.js

TabButton.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
  const [isPending, startTransition] = useTransition();
  if (isActive) {
    return <b>{children}</b>
  }
  if (isPending) {
    return <b className="pending">{children}</b>;
  }
  return (
    <button onClick={async () => {
      startTransition(async () => {
        // await the action that's passed in.
        // This allows it to be either sync or async.
        await action();
      });
    }}>
      {children}
    </button>
  );
}
```

Show more

### Note

When exposing an `action` prop from a component, you should `await` it inside the transition.

This allows the `action` callback to be either synchronous or asynchronous without requiring an additional `startTransition` to wrap the `await` in the action.

---

### Displaying a pending visual state

You can use the `isPending` boolean value returned by `useTransition` to indicate to the user that a Transition is in progress. For example, the tab button can have a special “pending” visual state:

```
function TabButton({ action, children, isActive }) {

const [isPending, startTransition] = useTransition();

// ...

if (isPending) {

return <b className="pending">{children}</b>;

}

// ...
```

Notice how clicking “Posts” now feels more responsive because the tab button itself updates right away:

App.jsTabButton.jsAboutTab.jsPostsTab.jsContactTab.js

TabButton.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
  const [isPending, startTransition] = useTransition();
  if (isActive) {
    return <b>{children}</b>
  }
  if (isPending) {
    return <b className="pending">{children}</b>;
  }
  return (
    <button onClick={() => {
      startTransition(async () => {
        await action();
      });
    }}>
      {children}
    </button>
  );
}
```

Show more

---

### Preventing unwanted loading indicators

In this example, the `PostsTab` component fetches some data using [use](https://react.dev/reference/react/use). When you click the “Posts” tab, the `PostsTab` component *suspends*, causing the closest loading fallback to appear:

App.jsTabButton.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, useState } from 'react';
import TabButton from './TabButton.js';
import AboutTab from './AboutTab.js';
import PostsTab from './PostsTab.js';
import ContactTab from './ContactTab.js';

export default function TabContainer() {
  const [tab, setTab] = useState('about');
  return (
    <Suspense fallback={<h1>🌀 Loading...</h1>}>
      <TabButton
        isActive={tab === 'about'}
        action={() => setTab('about')}
      >
        About
      </TabButton>
      <TabButton
        isActive={tab === 'posts'}
        action={() => setTab('posts')}
      >
        Posts
      </TabButton>
      <TabButton
        isActive={tab === 'contact'}
        action={() => setTab('contact')}
      >
        Contact
      </TabButton>
      <hr />
      {tab === 'about' && <AboutTab />}
      {tab === 'posts' && <PostsTab />}
      {tab === 'contact' && <ContactTab />}
    </Suspense>
  );
}
```

Show more

Hiding the entire tab container to show a loading indicator leads to a jarring user experience. If you add `useTransition` to `TabButton`, you can instead display the pending state in the tab button instead.

Notice that clicking “Posts” no longer replaces the entire tab container with a spinner:

App.jsTabButton.js

TabButton.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useTransition } from 'react';

export default function TabButton({ action, children, isActive }) {
  const [isPending, startTransition] = useTransition();
  if (isActive) {
    return <b>{children}</b>
  }
  if (isPending) {
    return <b className="pending">{children}</b>;
  }
  return (
    <button onClick={() => {
      startTransition(async () => {
        await action();
      });
    }}>
      {children}
    </button>
  );
}
```

Show more

[Read more about using Transitions with Suspense.](https://react.dev/reference/react/Suspense#preventing-already-revealed-content-from-hiding)

### Note

Transitions only “wait” long enough to avoid hiding *already revealed* content (like the tab container). If the Posts tab had a [nested `<Suspense>` boundary,](https://react.dev/reference/react/Suspense#revealing-nested-content-as-it-loads) the Transition would not “wait” for it.

---

### Building a Suspense-enabled router

If you’re building a React framework or a router, we recommend marking page navigations as Transitions.

```
function Router() {

const [page, setPage] = useState('/');

const [isPending, startTransition] = useTransition();

function navigate(url) {

startTransition(() => {

setPage(url);

});

}

// ...
```

This is recommended for three reasons:

* [Transitions are interruptible,](https://react.dev/reference/react/useTransition#perform-non-blocking-updates-with-actions) which lets the user click away without waiting for the re-render to complete.
* [Transitions prevent unwanted loading indicators,](https://react.dev/reference/react/useTransition#preventing-unwanted-loading-indicators) which lets the user avoid jarring jumps on navigation.
* [Transitions wait for all pending actions](https://react.dev/reference/react/useTransition#perform-non-blocking-updates-with-actions) which lets the user wait for side effects to complete before the new page is shown.

Here is a simplified router example using Transitions for navigations.

App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, useState, useTransition } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');
  const [isPending, startTransition] = useTransition();

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = (
      <IndexPage navigate={navigate} />
    );
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return (
    <Layout isPending={isPending}>
      {content}
    </Layout>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}
```

Show more

### Note

[Suspense-enabled](https://react.dev/reference/react/Suspense) routers are expected to wrap the navigation updates into Transitions by default.

---

### Displaying an error to users with an error boundary

If a function passed to `startTransition` throws an error, you can display an error to your user with an [error boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary). To use an error boundary, wrap the component where you are calling the `useTransition` in an error boundary. Once the function passed to `startTransition` errors, the fallback for the error boundary will be displayed.

AddCommentContainer.js

AddCommentContainer.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useTransition } from "react";
import { ErrorBoundary } from "react-error-boundary";

export function AddCommentContainer() {
  return (
    <ErrorBoundary fallback={<p>⚠️Something went wrong</p>}>
      <AddCommentButton />
    </ErrorBoundary>
  );
}

function addComment(comment) {
  // For demonstration purposes to show Error Boundary
  if (comment == null) {
    throw new Error("Example Error: An error thrown to trigger error boundary");
  }
}

function AddCommentButton() {
  const [pending, startTransition] = useTransition();

  return (
    <button
      disabled={pending}
      onClick={() => {
        startTransition(() => {
          // Intentionally not passing a comment
          // so error gets thrown
          addComment();
        });
      }}
    >
      Add comment
    </button>
  );
}
```

Show more

---

## Troubleshooting

### Updating an input in a Transition doesn’t work

You can’t use a Transition for a state variable that controls an input:

```
const [text, setText] = useState('');

// ...

function handleChange(e) {

// ❌ Can't use Transitions for controlled input state

startTransition(() => {

setText(e.target.value);

});

}

// ...

return <input value={text} onChange={handleChange} />;
```

This is because Transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a Transition in response to typing, you have two options:

1. You can declare two separate state variables: one for the input state (which always updates synchronously), and one that you will update in a Transition. This lets you control the input using the synchronous state, and pass the Transition state variable (which will “lag behind” the input) to the rest of your rendering logic.
2. Alternatively, you can have one state variable, and add [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) which will “lag behind” the real value. It will trigger non-blocking re-renders to “catch up” with the new value automatically.

---

### React doesn’t treat my state update as a Transition

When you wrap a state update in a Transition, make sure that it happens *during* the `startTransition` call:

```
startTransition(() => {

// ✅ Setting state *during* startTransition call

setPage('/about');

});
```

The function you pass to `startTransition` must be synchronous. You can’t mark an update as a Transition like this:

```
startTransition(() => {

// ❌ Setting state *after* startTransition call

setTimeout(() => {

setPage('/about');

}, 1000);

});
```

Instead, you could do this:

```
setTimeout(() => {

startTransition(() => {

// ✅ Setting state *during* startTransition call

setPage('/about');

});

}, 1000);
```

---

### React doesn’t treat my state update after `await` as a Transition

When you use `await` inside a `startTransition` function, the state updates that happen after the `await` are not marked as Transitions. You must wrap state updates after each `await` in a `startTransition` call:

```
startTransition(async () => {

await someAsyncFunction();

// ❌ Not using startTransition after await

setPage('/about');

});
```

However, this works instead:

```
startTransition(async () => {

await someAsyncFunction();

// ✅ Using startTransition *after* await

startTransition(() => {

setPage('/about');

});

});
```

This is a JavaScript limitation due to React losing the scope of the async context. In the future, when [AsyncContext](https://github.com/tc39/proposal-async-context) is available, this limitation will be removed.

---

### I want to call `useTransition` from outside a component

You can’t call `useTransition` outside a component because it’s a Hook. In this case, use the standalone [`startTransition`](https://react.dev/reference/react/startTransition) method instead. It works the same way, but it doesn’t provide the `isPending` indicator.

---

### The function I pass to `startTransition` executes immediately

If you run this code, it will print 1, 2, 3:

```
console.log(1);

startTransition(() => {

console.log(2);

setPage('/about');

});

console.log(3);
```

**It is expected to print 1, 2, 3.** The function you pass to `startTransition` does not get delayed. Unlike with the browser `setTimeout`, it does not run the callback later. React executes your function immediately, but any state updates scheduled *while it is running* are marked as Transitions. You can imagine that it works like this:

```
// A simplified version of how React works

let isInsideTransition = false;

function startTransition(scope) {

isInsideTransition = true;

scope();

isInsideTransition = false;

}

function setState() {

if (isInsideTransition) {

// ... schedule a Transition state update ...

} else {

// ... schedule an urgent state update ...

}

}
```

### My state updates in Transitions are out of order

If you `await` inside `startTransition`, you might see the updates happen out of order.

In this example, the `updateQuantity` function simulates a request to the server to update the item’s quantity in the cart. This function *artificially returns every other request after the previous* to simulate race conditions for network requests.

Try updating the quantity once, then update it quickly multiple times. You might see the incorrect total:

App.jsItem.jsTotal.jsapi.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useTransition } from "react";
import { updateQuantity } from "./api";
import Item from "./Item";
import Total from "./Total";

export default function App({}) {
  const [quantity, setQuantity] = useState(1);
  const [isPending, startTransition] = useTransition();
  // Store the actual quantity in separate state to show the mismatch.
  const [clientQuantity, setClientQuantity] = useState(1);

  const updateQuantityAction = newQuantity => {
    setClientQuantity(newQuantity);

    // Access the pending state of the transition,
    // by wrapping in startTransition again.
    startTransition(async () => {
      const savedQuantity = await updateQuantity(newQuantity);
      startTransition(() => {
        setQuantity(savedQuantity);
      });
    });
  };

  return (
    <div>
      <h1>Checkout</h1>
      <Item action={updateQuantityAction}/>
      <hr />
      <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} />
    </div>
  );
}
```

Show more

When clicking multiple times, it’s possible for previous requests to finish after later requests. When this happens, React currently has no way to know the intended order. This is because the updates are scheduled asynchronously, and React loses context of the order across the async boundary.

This is expected, because Actions within a Transition do not guarantee execution order. For common use cases, React provides higher-level abstractions like [`useActionState`](https://react.dev/reference/react/useActionState) and [`<form>` actions](https://react.dev/reference/react-dom/components/form) that handle ordering for you. For advanced use cases, you’ll need to implement your own queuing and abort logic to handle this.

Example of `useActionState` handling execution order:

App.jsItem.jsTotal.jsapi.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useActionState } from "react";
import { updateQuantity } from "./api";
import Item from "./Item";
import Total from "./Total";

export default function App({}) {
  // Store the actual quantity in separate state to show the mismatch.
  const [clientQuantity, setClientQuantity] = useState(1);
  const [quantity, updateQuantityAction, isPending] = useActionState(
    async (prevState, payload) => {
      setClientQuantity(payload);
      const savedQuantity = await updateQuantity(payload);
      return savedQuantity; // Return the new quantity to update the state
    },
    1 // Initial quantity
  );

  return (
    <div>
      <h1>Checkout</h1>
      <Item action={updateQuantityAction}/>
      <hr />
      <Total clientQuantity={clientQuantity} savedQuantity={quantity} isPending={isPending} />
    </div>
  );
}
```

Show more

[PrevioususeSyncExternalStore](https://react.dev/reference/react/useSyncExternalStore)[NextComponents](https://react.dev/reference/react/components)

---

---


# <Fragment> (<>...</>) – React

URL: https://react.dev/reference/react/Fragment

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react/components)

# <Fragment> (<>...</>)

`<Fragment>`, often used via `<>...</>` syntax, lets you group elements without a wrapper node.

### Canary

Fragments can also accept refs, which enable interacting with underlying DOM nodes without adding wrapper elements. See reference and usage below.

```
<>

<OneChild />

<AnotherChild />

</>
```

* [Reference](https://react.dev/reference/react/Fragment#reference) 
  + [`<Fragment>`](https://react.dev/reference/react/Fragment#fragment)
  + [Canary only FragmentInstance](https://react.dev/reference/react/Fragment#fragmentinstance)
* [Usage](https://react.dev/reference/react/Fragment#usage) 
  + [Returning multiple elements](https://react.dev/reference/react/Fragment#returning-multiple-elements)
  + [Assigning multiple elements to a variable](https://react.dev/reference/react/Fragment#assigning-multiple-elements-to-a-variable)
  + [Grouping elements with text](https://react.dev/reference/react/Fragment#grouping-elements-with-text)
  + [Rendering a list of Fragments](https://react.dev/reference/react/Fragment#rendering-a-list-of-fragments)
  + [Canary only Using Fragment refs for DOM interaction](https://react.dev/reference/react/Fragment#using-fragment-refs-for-dom-interaction)
  + [Canary only Tracking visibility with Fragment refs](https://react.dev/reference/react/Fragment#tracking-visibility-with-fragment-refs)
  + [Canary only Focus management with Fragment refs](https://react.dev/reference/react/Fragment#focus-management-with-fragment-refs)

---

## Reference

### `<Fragment>`

Wrap elements in `<Fragment>` to group them together in situations where you need a single element. Grouping elements in `Fragment` has no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag `<></>` is shorthand for `<Fragment></Fragment>` in most cases.

#### Props

* **optional** `key`: Fragments declared with the explicit `<Fragment>` syntax may have [keys.](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)
* Canary only **optional** `ref`: A ref object (e.g. from [`useRef`](https://react.dev/reference/react/useRef)) or [callback function](https://react.dev/reference/react-dom/components/common#ref-callback). React provides a `FragmentInstance` as the ref value that implements methods for interacting with the DOM nodes wrapped by the Fragment.

### Canary only FragmentInstance

When you pass a ref to a fragment, React provides a `FragmentInstance` object with methods for interacting with the DOM nodes wrapped by the fragment:

**Event handling methods:**

* `addEventListener(type, listener, options?)`: Adds an event listener to all first-level DOM children of the Fragment.
* `removeEventListener(type, listener, options?)`: Removes an event listener from all first-level DOM children of the Fragment.
* `dispatchEvent(event)`: Dispatches an event to a virtual child of the Fragment to call any added listeners and can bubble to the DOM parent.

**Layout methods:**

* `compareDocumentPosition(otherNode)`: Compares the document position of the Fragment with another node.
  + If the Fragment has children, the native `compareDocumentPosition` value is returned.
  + Empty Fragments will attempt to compare positioning within the React tree and include `Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC`.
  + Elements that have a different relationship in the React tree and DOM tree due to portaling or other insertions are `Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC`.
* `getClientRects()`: Returns a flat array of `DOMRect` objects representing the bounding rectangles of all children.
* `getRootNode()`: Returns the root node containing the Fragment’s parent DOM node.

**Focus management methods:**

* `focus(options?)`: Focuses the first focusable DOM node in the Fragment. Focus is attempted on nested children depth-first.
* `focusLast(options?)`: Focuses the last focusable DOM node in the Fragment. Focus is attempted on nested children depth-first.
* `blur()`: Removes focus if `document.activeElement` is within the Fragment.

**Observer methods:**

* `observeUsing(observer)`: Starts observing the Fragment’s DOM children with an IntersectionObserver or ResizeObserver.
* `unobserveUsing(observer)`: Stops observing the Fragment’s DOM children with the specified observer.

#### Caveats

* If you want to pass `key` to a Fragment, you can’t use the `<>...</>` syntax. You have to explicitly import `Fragment` from `'react'` and render `<Fragment key={yourKey}>...</Fragment>`.
* React does not [reset state](https://react.dev/learn/preserving-and-resetting-state) when you go from rendering `<><Child /></>` to `[<Child />]` or back, or when you go from rendering `<><Child /></>` to `<Child />` and back. This only works a single level deep: for example, going from `<><><Child /></></>` to `<Child />` resets the state. See the precise semantics [here.](https://gist.github.com/clemmy/b3ef00f9507909429d8aa0d3ee4f986b)
* Canary only If you want to pass `ref` to a Fragment, you can’t use the `<>...</>` syntax. You have to explicitly import `Fragment` from `'react'` and render `<Fragment ref={yourRef}>...</Fragment>`.

---

## Usage

### Returning multiple elements

Use `Fragment`, or the equivalent `<>...</>` syntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:

```
function Post() {

return (

<>

<PostTitle />

<PostBody />

</>

);

}
```

Fragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in another container like a DOM element. If you inspect this example with the browser tools, you’ll see that all `<h1>` and `<article>` DOM nodes appear as siblings without wrappers around them:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Blog() {
  return (
    <>
      <Post title="An update" body="It's been a while since I posted..." />
      <Post title="My new blog" body="I am starting a new blog!" />
    </>
  )
}

function Post({ title, body }) {
  return (
    <>
      <PostTitle title={title} />
      <PostBody body={body} />
    </>
  );
}

function PostTitle({ title }) {
  return <h1>{title}</h1>
}

function PostBody({ body }) {
  return (
    <article>
      <p>{body}</p>
    </article>
  );
}
```

Show more

##### Deep Dive

#### How to write a Fragment without the special syntax?

Show Details

The example above is equivalent to importing `Fragment` from React:

```
import { Fragment } from 'react';

function Post() {

return (

<Fragment>

<PostTitle />

<PostBody />

</Fragment>

);

}
```

Usually you won’t need this unless you need to [pass a `key` to your `Fragment`.](https://react.dev/reference/react/Fragment#rendering-a-list-of-fragments)

---

### Assigning multiple elements to a variable

Like any other element, you can assign Fragment elements to variables, pass them as props, and so on:

```
function CloseDialog() {

const buttons = (

<>

<OKButton />

<CancelButton />

</>

);

return (

<AlertDialog buttons={buttons}>

Are you sure you want to leave this page?

</AlertDialog>

);

}
```

---

### Grouping elements with text

You can use `Fragment` to group text together with components:

```
function DateRangePicker({ start, end }) {

return (

<>

From

<DatePicker date={start} />

to

<DatePicker date={end} />

</>

);

}
```

---

### Rendering a list of Fragments

Here’s a situation where you need to write `Fragment` explicitly instead of using the `<></>` syntax. When you [render multiple elements in a loop](https://react.dev/learn/rendering-lists), you need to assign a `key` to each element. If the elements within the loop are Fragments, you need to use the normal JSX element syntax in order to provide the `key` attribute:

```
function Blog() {

return posts.map(post =>

<Fragment key={post.id}>

<PostTitle title={post.title} />

<PostBody body={post.body} />

</Fragment>

);

}
```

You can inspect the DOM to verify that there are no wrapper elements around the Fragment children:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Fragment } from 'react';

const posts = [
  { id: 1, title: 'An update', body: "It's been a while since I posted..." },
  { id: 2, title: 'My new blog', body: 'I am starting a new blog!' }
];

export default function Blog() {
  return posts.map(post =>
    <Fragment key={post.id}>
      <PostTitle title={post.title} />
      <PostBody body={post.body} />
    </Fragment>
  );
}

function PostTitle({ title }) {
  return <h1>{title}</h1>
}

function PostBody({ body }) {
  return (
    <article>
      <p>{body}</p>
    </article>
  );
}
```

Show more

---

### Canary only Using Fragment refs for DOM interaction

Fragment refs allow you to interact with the DOM nodes wrapped by a Fragment without adding extra wrapper elements. This is useful for event handling, visibility tracking, focus management, and replacing deprecated patterns like `ReactDOM.findDOMNode()`.

```
import { Fragment } from 'react';

function ClickableFragment({ children, onClick }) {

return (

<Fragment ref={fragmentInstance => {

fragmentInstance.addEventListener('click', handleClick);

return () => fragmentInstance.removeEventListener('click', handleClick);

}}>

{children}

</Fragment>

);

}
```

---

### Canary only Tracking visibility with Fragment refs

Fragment refs are useful for visibility tracking and intersection observation. This enables you to monitor when content becomes visible without requiring the child Components to expose refs:

```
import { Fragment, useRef, useLayoutEffect } from 'react';

function VisibilityObserverFragment({ threshold = 0.5, onVisibilityChange, children }) {

const fragmentRef = useRef(null);

useLayoutEffect(() => {

const observer = new IntersectionObserver(

(entries) => {

onVisibilityChange(entries.some(entry => entry.isIntersecting))

},

{ threshold }

);

fragmentRef.current.observeUsing(observer);

return () => fragmentRef.current.unobserveUsing(observer);

}, [threshold, onVisibilityChange]);

return (

<Fragment ref={fragmentRef}>

{children}

</Fragment>

);

}

function MyComponent() {

const handleVisibilityChange = (isVisible) => {

console.log('Component is', isVisible ? 'visible' : 'hidden');

};

return (

<VisibilityObserverFragment onVisibilityChange={handleVisibilityChange}>

<SomeThirdPartyComponent />

<AnotherComponent />

</VisibilityObserverFragment>

);

}
```

This pattern is an alternative to Effect-based visibility logging, which is an anti-pattern in most cases. Relying on Effects alone does not guarantee that the rendered Component is observable by the user.

---

### Canary only Focus management with Fragment refs

Fragment refs provide focus management methods that work across all DOM nodes within the Fragment:

```
import { Fragment, useRef } from 'react';

function FocusFragment({ children }) {

return (

<Fragment ref={(fragmentInstance) => fragmentInstance?.focus()}>

{children}

</Fragment>

);

}
```

The `focus()` method focuses the first focusable element within the Fragment, while `focusLast()` focuses the last focusable element.

[PreviousComponents](https://react.dev/reference/react/components)[Next<Profiler>](https://react.dev/reference/react/Profiler)

---

---


# <Profiler> – React

URL: https://react.dev/reference/react/Profiler

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react/components)

# <Profiler>

`<Profiler>` lets you measure rendering performance of a React tree programmatically.

```
<Profiler id="App" onRender={onRender}>

<App />

</Profiler>
```

* [Reference](https://react.dev/reference/react/Profiler#reference) 
  + [`<Profiler>`](https://react.dev/reference/react/Profiler#profiler)
  + [`onRender` callback](https://react.dev/reference/react/Profiler#onrender-callback)
* [Usage](https://react.dev/reference/react/Profiler#usage) 
  + [Measuring rendering performance programmatically](https://react.dev/reference/react/Profiler#measuring-rendering-performance-programmatically)
  + [Measuring different parts of the application](https://react.dev/reference/react/Profiler#measuring-different-parts-of-the-application)

---

## Reference

### `<Profiler>`

Wrap a component tree in a `<Profiler>` to measure its rendering performance.

```
<Profiler id="App" onRender={onRender}>

<App />

</Profiler>
```

#### Props

* `id`: A string identifying the part of the UI you are measuring.
* `onRender`: An [`onRender` callback](https://react.dev/reference/react/Profiler#onrender-callback) that React calls every time components within the profiled tree update. It receives information about what was rendered and how much time it took.

#### Caveats

* Profiling adds some additional overhead, so **it is disabled in the production build by default.** To opt into production profiling, you need to enable a [special production build with profiling enabled.](https://react.dev/reference/dev-tools/react-performance-tracks#using-profiling-builds)

---

### `onRender` callback

React will call your `onRender` callback with information about what was rendered.

```
function onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {

// Aggregate or log render timings...

}
```

#### Parameters

* `id`: The string `id` prop of the `<Profiler>` tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers.
* `phase`: `"mount"`, `"update"` or `"nested-update"`. This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or Hooks.
* `actualDuration`: The number of milliseconds spent rendering the `<Profiler>` and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. [`memo`](https://react.dev/reference/react/memo) and [`useMemo`](https://react.dev/reference/react/useMemo)). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change.
* `baseDuration`: The number of milliseconds estimating how much time it would take to re-render the entire `<Profiler>` subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare `actualDuration` against it to see if memoization is working.
* `startTime`: A numeric timestamp for when React began rendering the current update.
* `commitTime`: A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable.

---

## Usage

### Measuring rendering performance programmatically

Wrap the `<Profiler>` component around a React tree to measure its rendering performance.

```
<App>

<Profiler id="Sidebar" onRender={onRender}>

<Sidebar />

</Profiler>

<PageContent />

</App>
```

It requires two props: an `id` (string) and an `onRender` callback (function) which React calls any time a component within the tree “commits” an update.

### Pitfall

Profiling adds some additional overhead, so **it is disabled in the production build by default.** To opt into production profiling, you need to enable a [special production build with profiling enabled.](https://react.dev/reference/dev-tools/react-performance-tracks#using-profiling-builds)

### Note

`<Profiler>` lets you gather measurements programmatically. If you’re looking for an interactive profiler, try the Profiler tab in [React Developer Tools](https://react.dev/learn/react-developer-tools). It exposes similar functionality as a browser extension.

Components wrapped in `<Profiler>` will also be marked in the [Component tracks](https://react.dev/reference/dev-tools/react-performance-tracks#components) of React Performance tracks even in profiling builds.
In development builds, all components are marked in the Components track regardless of whether they’re wrapped in `<Profiler>`.

---

### Measuring different parts of the application

You can use multiple `<Profiler>` components to measure different parts of your application:

```
<App>

<Profiler id="Sidebar" onRender={onRender}>

<Sidebar />

</Profiler>

<Profiler id="Content" onRender={onRender}>

<Content />

</Profiler>

</App>
```

You can also nest `<Profiler>` components:

```
<App>

<Profiler id="Sidebar" onRender={onRender}>

<Sidebar />

</Profiler>

<Profiler id="Content" onRender={onRender}>

<Content>

<Profiler id="Editor" onRender={onRender}>

<Editor />

</Profiler>

<Preview />

</Content>

</Profiler>

</App>
```

Although `<Profiler>` is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application.

---

[Previous<Fragment> (<>)](https://react.dev/reference/react/Fragment)[Next<StrictMode>](https://react.dev/reference/react/StrictMode)

---

---


# <StrictMode> – React

URL: https://react.dev/reference/react/StrictMode

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react/components)

# <StrictMode>

`<StrictMode>` lets you find common bugs in your components early during development.

```
<StrictMode>

<App />

</StrictMode>
```

* [Reference](https://react.dev/reference/react/StrictMode#reference) 
  + [`<StrictMode>`](https://react.dev/reference/react/StrictMode#strictmode)
* [Usage](https://react.dev/reference/react/StrictMode#usage) 
  + [Enabling Strict Mode for entire app](https://react.dev/reference/react/StrictMode#enabling-strict-mode-for-entire-app)
  + [Enabling Strict Mode for a part of the app](https://react.dev/reference/react/StrictMode#enabling-strict-mode-for-a-part-of-the-app)
  + [Fixing bugs found by double rendering in development](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-double-rendering-in-development)
  + [Fixing bugs found by re-running Effects in development](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-re-running-effects-in-development)
  + [Fixing bugs found by re-running ref callbacks in development](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-re-running-ref-callbacks-in-development)
  + [Fixing deprecation warnings enabled by Strict Mode](https://react.dev/reference/react/StrictMode#fixing-deprecation-warnings-enabled-by-strict-mode)

---

## Reference

### `<StrictMode>`

Use `StrictMode` to enable additional development behaviors and warnings for the component tree inside:

```
import { StrictMode } from 'react';

import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));

root.render(

<StrictMode>

<App />

</StrictMode>

);
```

[See more examples below.](https://react.dev/reference/react/StrictMode#usage)

Strict Mode enables the following development-only behaviors:

* Your components will [re-render an extra time](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-double-rendering-in-development) to find bugs caused by impure rendering.
* Your components will [re-run Effects an extra time](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-re-running-effects-in-development) to find bugs caused by missing Effect cleanup.
* Your components will [re-run refs callbacks an extra time](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-re-running-ref-callbacks-in-development) to find bugs caused by missing ref cleanup.
* Your components will [be checked for usage of deprecated APIs.](https://react.dev/reference/react/StrictMode#fixing-deprecation-warnings-enabled-by-strict-mode)

#### Props

`StrictMode` accepts no props.

#### Caveats

* There is no way to opt out of Strict Mode inside a tree wrapped in `<StrictMode>`. This gives you confidence that all components inside `<StrictMode>` are checked. If two teams working on a product disagree whether they find the checks valuable, they need to either reach consensus or move `<StrictMode>` down in the tree.

---

## Usage

### Enabling Strict Mode for entire app

Strict Mode enables extra development-only checks for the entire component tree inside the `<StrictMode>` component. These checks help you find common bugs in your components early in the development process.

To enable Strict Mode for your entire app, wrap your root component with `<StrictMode>` when you render it:

```
import { StrictMode } from 'react';

import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));

root.render(

<StrictMode>

<App />

</StrictMode>

);
```

We recommend wrapping your entire app in Strict Mode, especially for newly created apps. If you use a framework that calls [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) for you, check its documentation for how to enable Strict Mode.

Although the Strict Mode checks **only run in development,** they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them.

### Note

Strict Mode enables the following checks in development:

* Your components will [re-render an extra time](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-double-rendering-in-development) to find bugs caused by impure rendering.
* Your components will [re-run Effects an extra time](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-re-running-effects-in-development) to find bugs caused by missing Effect cleanup.
* Your components will [re-run ref callbacks an extra time](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-re-running-ref-callbacks-in-development) to find bugs caused by missing ref cleanup.
* Your components will [be checked for usage of deprecated APIs.](https://react.dev/reference/react/StrictMode#fixing-deprecation-warnings-enabled-by-strict-mode)

**All of these checks are development-only and do not impact the production build.**

---

### Enabling Strict Mode for a part of the app

You can also enable Strict Mode for any part of your application:

```
import { StrictMode } from 'react';

function App() {

return (

<>

<Header />

<StrictMode>

<main>

<Sidebar />

<Content />

</main>

</StrictMode>

<Footer />

</>

);

}
```

In this example, Strict Mode checks will not run against the `Header` and `Footer` components. However, they will run on `Sidebar` and `Content`, as well as all of the components inside them, no matter how deep.

### Note

When `StrictMode` is enabled for a part of the app, React will only enable behaviors that are possible in production. For example, if `<StrictMode>` is not enabled at the root of the app, it will not [re-run Effects an extra time](https://react.dev/reference/react/StrictMode#fixing-bugs-found-by-re-running-effects-in-development) on initial mount, since this would cause child effects to double fire without the parent effects, which cannot happen in production.

---

### Fixing bugs found by double rendering in development

[React assumes that every component you write is a pure function.](https://react.dev/learn/keeping-components-pure) This means that React components you write must always return the same JSX given the same inputs (props, state, and context).

Components breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure) **twice in development.** This includes:

* Your component function body (only top-level logic, so this doesn’t include code inside event handlers)
* Functions that you pass to [`useState`](https://react.dev/reference/react/useState), [`set` functions](https://react.dev/reference/react/useState#setstate), [`useMemo`](https://react.dev/reference/react/useMemo), or [`useReducer`](https://react.dev/reference/react/useReducer)
* Some class component methods like [`constructor`](https://react.dev/reference/react/Component#constructor), [`render`](https://react.dev/reference/react/Component#render), [`shouldComponentUpdate`](https://react.dev/reference/react/Component#shouldcomponentupdate) ([see the whole list](https://reactjs.org/docs/strict-mode.html#detecting-unexpected-side-effects))

If a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running it twice tends to be noticeable (that’s what makes it impure!) This helps you spot and fix the bug early.

**Here is an example to illustrate how double rendering in Strict Mode helps you find bugs early.**

This `StoryTray` component takes an array of `stories` and adds one last “Create Story” item at the end:

index.jsApp.jsStoryTray.js

StoryTray.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function StoryTray({ stories }) {
  const items = stories;
  items.push({ id: 'create', label: 'Create Story' });
  return (
    <ul>
      {items.map(story => (
        <li key={story.id}>
          {story.label}
        </li>
      ))}
    </ul>
  );
}
```

There is a mistake in the code above. However, it is easy to miss because the initial output appears correct.

This mistake will become more noticeable if the `StoryTray` component re-renders multiple times. For example, let’s make the `StoryTray` re-render with a different background color whenever you hover over it:

index.jsApp.jsStoryTray.js

StoryTray.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function StoryTray({ stories }) {
  const [isHover, setIsHover] = useState(false);
  const items = stories;
  items.push({ id: 'create', label: 'Create Story' });
  return (
    <ul
      onPointerEnter={() => setIsHover(true)}
      onPointerLeave={() => setIsHover(false)}
      style={{
        backgroundColor: isHover ? '#ddd' : '#fff'
      }}
    >
      {items.map(story => (
        <li key={story.id}>
          {story.label}
        </li>
      ))}
    </ul>
  );
}
```

Show more

Notice how every time you hover over the `StoryTray` component, “Create Story” gets added to the list again. The intention of the code was to add it once at the end. But `StoryTray` directly modifies the `stories` array from the props. Every time `StoryTray` renders, it adds “Create Story” again at the end of the same array. In other words, `StoryTray` is not a pure function—running it multiple times produces different results.

To fix this problem, you can make a copy of the array, and modify that copy instead of the original one:

```
export default function StoryTray({ stories }) {

const items = stories.slice(); // Clone the array

// ✅ Good: Pushing into a new array

items.push({ id: 'create', label: 'Create Story' });
```

This would [make the `StoryTray` function pure.](https://react.dev/learn/keeping-components-pure) Each time it is called, it would only modify a new copy of the array, and would not affect any external objects or variables. This solves the bug, but you had to make the component re-render more often before it became obvious that something is wrong with its behavior.

**In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in `<StrictMode>`:**

index.jsApp.jsStoryTray.js

StoryTray.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function StoryTray({ stories }) {
  const items = stories;
  items.push({ id: 'create', label: 'Create Story' });
  return (
    <ul>
      {items.map(story => (
        <li key={story.id}>
          {story.label}
        </li>
      ))}
    </ul>
  );
}
```

**Strict Mode *always* calls your rendering function twice, so you can see the mistake right away** (“Create Story” appears twice). This lets you notice such mistakes early in the process. When you fix your component to render in Strict Mode, you *also* fix many possible future production bugs like the hover functionality from before:

index.jsApp.jsStoryTray.js

StoryTray.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function StoryTray({ stories }) {
  const [isHover, setIsHover] = useState(false);
  const items = stories.slice(); // Clone the array
  items.push({ id: 'create', label: 'Create Story' });
  return (
    <ul
      onPointerEnter={() => setIsHover(true)}
      onPointerLeave={() => setIsHover(false)}
      style={{
        backgroundColor: isHover ? '#ddd' : '#fff'
      }}
    >
      {items.map(story => (
        <li key={story.id}>
          {story.label}
        </li>
      ))}
    </ul>
  );
}
```

Show more

Without Strict Mode, it was easy to miss the bug until you added more re-renders. Strict Mode made the same bug appear right away. Strict Mode helps you find bugs before you push them to your team and to your users.

[Read more about keeping components pure.](https://react.dev/learn/keeping-components-pure)

### Note

If you have [React DevTools](https://react.dev/learn/react-developer-tools) installed, any `console.log` calls during the second render call will appear slightly dimmed. React DevTools also offers a setting (off by default) to suppress them completely.

---

### Fixing bugs found by re-running Effects in development

Strict Mode can also help find bugs in [Effects.](https://react.dev/learn/synchronizing-with-effects)

Every Effect has some setup code and may have some cleanup code. Normally, React calls setup when the component *mounts* (is added to the screen) and calls cleanup when the component *unmounts* (is removed from the screen). React then calls cleanup and setup again if its dependencies changed since the last render.

When Strict Mode is on, React will also run **one extra setup+cleanup cycle in development for every Effect.** This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.

**Here is an example to illustrate how re-running Effects in Strict Mode helps you find bugs early.**

Consider this example that connects a component to a chat:

index.jsApp.jschat.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

There is an issue with this code, but it might not be immediately clear.

To make the issue more obvious, let’s implement a feature. In the example below, `roomId` is not hardcoded. Instead, the user can select the `roomId` that they want to connect to from a dropdown. Click “Open chat” and then select different chat rooms one by one. Keep track of the number of active connections in the console:

index.jsApp.jschat.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(<App />);
```

You’ll notice that the number of open connections always keeps growing. In a real app, this would cause performance and network problems. The issue is that [your Effect is missing a cleanup function:](https://react.dev/learn/synchronizing-with-effects#step-3-add-cleanup-if-needed)

```
useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => connection.disconnect();

}, [roomId]);
```

Now that your Effect “cleans up” after itself and destroys the outdated connections, the leak is solved. However, notice that the problem did not become visible until you’ve added more features (the select box).

**In the original example, the bug wasn’t obvious. Now let’s wrap the original (buggy) code in `<StrictMode>`:**

index.jsApp.jschat.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

**With Strict Mode, you immediately see that there is a problem** (the number of active connections jumps to 2). Strict Mode runs an extra setup+cleanup cycle for every Effect. This Effect has no cleanup logic, so it creates an extra connection but doesn’t destroy it. This is a hint that you’re missing a cleanup function.

Strict Mode lets you notice such mistakes early in the process. When you fix your Effect by adding a cleanup function in Strict Mode, you *also* fix many possible future production bugs like the select box from before:

index.jsApp.jschat.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './styles.css';

import App from './App';

const root = createRoot(document.getElementById("root"));
root.render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

Notice how the active connection count in the console doesn’t keep growing anymore.

Without Strict Mode, it was easy to miss that your Effect needed cleanup. By running *setup → cleanup → setup* instead of *setup* for your Effect in development, Strict Mode made the missing cleanup logic more noticeable.

[Read more about implementing Effect cleanup.](https://react.dev/learn/synchronizing-with-effects#how-to-handle-the-effect-firing-twice-in-development)

---

### Fixing bugs found by re-running ref callbacks in development

Strict Mode can also help find bugs in [callbacks refs.](https://react.dev/learn/manipulating-the-dom-with-refs)

Every callback `ref` has some setup code and may have some cleanup code. Normally, React calls setup when the element is *created* (is added to the DOM) and calls cleanup when the element is *removed* (is removed from the DOM).

When Strict Mode is on, React will also run **one extra setup+cleanup cycle in development for every callback `ref`.** This may feel surprising, but it helps reveal subtle bugs that are hard to catch manually.

Consider this example, which allows you to select an animal and then scroll to one of them. Notice when you switch from “Cats” to “Dogs”, the console logs show that the number of animals in the list keeps growing, and the “Scroll to” buttons stop working:

index.jsApp.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useState } from "react";

export default function CatFriends() {
  const itemsRef = useRef([]);
  const [catList, setCatList] = useState(setupCatList);
  const [cat, setCat] = useState('neo');

  function scrollToCat(index) {
    const list = itemsRef.current;
    const {node} = list[index];
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  const cats = catList.filter(c => c.type === cat)

  return (
    <>
      <nav>
        <button onClick={() => setCat('neo')}>Neo</button>
        <button onClick={() => setCat('millie')}>Millie</button>
      </nav>
      <hr />
      <nav>
        <span>Scroll to:</span>{cats.map((cat, index) => (
          <button key={cat.src} onClick={() => scrollToCat(index)}>
            {index}
          </button>
        ))}
      </nav>
      <div>
        <ul>
          {cats.map((cat) => (
            <li
              key={cat.src}
              ref={(node) => {
                const list = itemsRef.current;
                const item = {cat: cat, node};
                list.push(item);
                console.log(`✅ Adding cat to the map. Total cats: ${list.length}`);
                if (list.length > 10) {
                  console.log('❌ Too many cats in the list!');
                }
                return () => {
                  // 🚩 No cleanup, this is a bug!
                }
              }}
            >
              <img src={cat.src} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

function setupCatList() {
  const catList = [];
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'neo', src: "https://placecats.com/neo/320/240?" + i});
  }
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'millie', src: "https://placecats.com/millie/320/240?" + i});
  }

  return catList;
}
```

Show more

**This is a production bug!** Since the ref callback doesn’t remove animals from the list in the cleanup, the list of animals keeps growing. This is a memory leak that can cause performance problems in a real app, and breaks the behavior of the app.

The issue is the ref callback doesn’t cleanup after itself:

```
<li

ref={node => {

const list = itemsRef.current;

const item = {animal, node};

list.push(item);

return () => {

// 🚩 No cleanup, this is a bug!

}

}}

</li>
```

Now let’s wrap the original (buggy) code in `<StrictMode>`:

index.jsApp.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useState } from "react";

export default function CatFriends() {
  const itemsRef = useRef([]);
  const [catList, setCatList] = useState(setupCatList);
  const [cat, setCat] = useState('neo');

  function scrollToCat(index) {
    const list = itemsRef.current;
    const {node} = list[index];
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  const cats = catList.filter(c => c.type === cat)

  return (
    <>
      <nav>
        <button onClick={() => setCat('neo')}>Neo</button>
        <button onClick={() => setCat('millie')}>Millie</button>
      </nav>
      <hr />
      <nav>
        <span>Scroll to:</span>{cats.map((cat, index) => (
          <button key={cat.src} onClick={() => scrollToCat(index)}>
            {index}
          </button>
        ))}
      </nav>
      <div>
        <ul>
          {cats.map((cat) => (
            <li
              key={cat.src}
              ref={(node) => {
                const list = itemsRef.current;
                const item = {cat: cat, node};
                list.push(item);
                console.log(`✅ Adding cat to the map. Total cats: ${list.length}`);
                if (list.length > 10) {
                  console.log('❌ Too many cats in the list!');
                }
                return () => {
                  // 🚩 No cleanup, this is a bug!
                }
              }}
            >
              <img src={cat.src} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

function setupCatList() {
  const catList = [];
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'neo', src: "https://placecats.com/neo/320/240?" + i});
  }
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'millie', src: "https://placecats.com/millie/320/240?" + i});
  }

  return catList;
}
```

Show more

**With Strict Mode, you immediately see that there is a problem**. Strict Mode runs an extra setup+cleanup cycle for every callback ref. This callback ref has no cleanup logic, so it adds refs but doesn’t remove them. This is a hint that you’re missing a cleanup function.

Strict Mode lets you eagerly find mistakes in callback refs. When you fix your callback by adding a cleanup function in Strict Mode, you *also* fix many possible future production bugs like the “Scroll to” bug from before:

index.jsApp.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useState } from "react";

export default function CatFriends() {
  const itemsRef = useRef([]);
  const [catList, setCatList] = useState(setupCatList);
  const [cat, setCat] = useState('neo');

  function scrollToCat(index) {
    const list = itemsRef.current;
    const {node} = list[index];
    node.scrollIntoView({
      behavior: "smooth",
      block: "nearest",
      inline: "center",
    });
  }

  const cats = catList.filter(c => c.type === cat)

  return (
    <>
      <nav>
        <button onClick={() => setCat('neo')}>Neo</button>
        <button onClick={() => setCat('millie')}>Millie</button>
      </nav>
      <hr />
      <nav>
        <span>Scroll to:</span>{cats.map((cat, index) => (
          <button key={cat.src} onClick={() => scrollToCat(index)}>
            {index}
          </button>
        ))}
      </nav>
      <div>
        <ul>
          {cats.map((cat) => (
            <li
              key={cat.src}
              ref={(node) => {
                const list = itemsRef.current;
                const item = {cat: cat, node};
                list.push(item);
                console.log(`✅ Adding cat to the map. Total cats: ${list.length}`);
                if (list.length > 10) {
                  console.log('❌ Too many cats in the list!');
                }
                return () => {
                  list.splice(list.indexOf(item), 1);
                  console.log(`❌ Removing cat from the map. Total cats: ${itemsRef.current.length}`);
                }
              }}
            >
              <img src={cat.src} />
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

function setupCatList() {
  const catList = [];
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'neo', src: "https://placecats.com/neo/320/240?" + i});
  }
  for (let i = 0; i < 10; i++) {
    catList.push({type: 'millie', src: "https://placecats.com/millie/320/240?" + i});
  }

  return catList;
}
```

Show more

Now on inital mount in StrictMode, the ref callbacks are all setup, cleaned up, and setup again:

```
...

✅ Adding animal to the map. Total animals: 10

...

❌ Removing animal from the map. Total animals: 0

...

✅ Adding animal to the map. Total animals: 10
```

**This is expected.** Strict Mode confirms that the ref callbacks are cleaned up correctly, so the size never grows above the expected amount. After the fix, there are no memory leaks, and all the features work as expected.

Without Strict Mode, it was easy to miss the bug until you clicked around to app to notice broken features. Strict Mode made the bugs appear right away, before you push them to production.

---

### Fixing deprecation warnings enabled by Strict Mode

React warns if some component anywhere inside a `<StrictMode>` tree uses one of these deprecated APIs:

* `UNSAFE_` class lifecycle methods like [`UNSAFE_componentWillMount`](https://react.dev/reference/react/Component#unsafe_componentwillmount). [See alternatives.](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#migrating-from-legacy-lifecycles)

These APIs are primarily used in older [class components](https://react.dev/reference/react/Component) so they rarely appear in modern apps.

[Previous<Profiler>](https://react.dev/reference/react/Profiler)[Next<Suspense>](https://react.dev/reference/react/Suspense)

---

---


# <Suspense> – React

URL: https://react.dev/reference/react/Suspense

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react/components)

# <Suspense>

`<Suspense>` lets you display a fallback until its children have finished loading.

```
<Suspense fallback={<Loading />}>

<SomeComponent />

</Suspense>
```

* [Reference](https://react.dev/reference/react/Suspense#reference) 
  + [`<Suspense>`](https://react.dev/reference/react/Suspense#suspense)
* [Usage](https://react.dev/reference/react/Suspense#usage) 
  + [Displaying a fallback while content is loading](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading)
  + [Revealing content together at once](https://react.dev/reference/react/Suspense#revealing-content-together-at-once)
  + [Revealing nested content as it loads](https://react.dev/reference/react/Suspense#revealing-nested-content-as-it-loads)
  + [Showing stale content while fresh content is loading](https://react.dev/reference/react/Suspense#showing-stale-content-while-fresh-content-is-loading)
  + [Preventing already revealed content from hiding](https://react.dev/reference/react/Suspense#preventing-already-revealed-content-from-hiding)
  + [Indicating that a Transition is happening](https://react.dev/reference/react/Suspense#indicating-that-a-transition-is-happening)
  + [Resetting Suspense boundaries on navigation](https://react.dev/reference/react/Suspense#resetting-suspense-boundaries-on-navigation)
  + [Providing a fallback for server errors and client-only content](https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content)
* [Troubleshooting](https://react.dev/reference/react/Suspense#troubleshooting) 
  + [How do I prevent the UI from being replaced by a fallback during an update?](https://react.dev/reference/react/Suspense#preventing-unwanted-fallbacks)

---

## Reference

### `<Suspense>`

#### Props

* `children`: The actual UI you intend to render. If `children` suspends while rendering, the Suspense boundary will switch to rendering `fallback`.
* `fallback`: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch to `fallback` when `children` suspends, and back to `children` when the data is ready. If `fallback` suspends while rendering, it will activate the closest parent Suspense boundary.

#### Caveats

* React does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch.
* If Suspense was displaying content for the tree, but then it suspended again, the `fallback` will be shown again unless the update causing it was caused by [`startTransition`](https://react.dev/reference/react/startTransition) or [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue).
* If React needs to hide the already visible content because it suspended again, it will clean up [layout Effects](https://react.dev/reference/react/useLayoutEffect) in the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout don’t try to do this while the content is hidden.
* React includes under-the-hood optimizations like *Streaming Server Rendering* and *Selective Hydration* that are integrated with Suspense. Read [an architectural overview](https://github.com/reactwg/react-18/discussions/37) and watch [a technical talk](https://www.youtube.com/watch?v=pj5N-Khihgc) to learn more.

---

## Usage

### Displaying a fallback while content is loading

You can wrap any part of your application with a Suspense boundary:

```
<Suspense fallback={<Loading />}>

<Albums />

</Suspense>
```

React will display your loading fallback until all the code and data needed by the children has been loaded.

In the example below, the `Albums` component *suspends* while fetching the list of albums. Until it’s ready to render, React switches the closest Suspense boundary above to show the fallback—your `Loading` component. Then, when the data loads, React hides the `Loading` fallback and renders the `Albums` component with data.

ArtistPage.jsAlbums.js

ArtistPage.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense } from 'react';
import Albums from './Albums.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Albums artistId={artist.id} />
      </Suspense>
    </>
  );
}

function Loading() {
  return <h2>🌀 Loading...</h2>;
}
```

Show more

### Note

**Only Suspense-enabled data sources will activate the Suspense component.** They include:

* Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense)
* Lazy-loading component code with [`lazy`](https://react.dev/reference/react/lazy)
* Reading the value of a cached Promise with [`use`](https://react.dev/reference/react/use)

Suspense **does not** detect when data is fetched inside an Effect or event handler.

The exact way you would load data in the `Albums` component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

---

### Revealing content together at once

By default, the whole tree inside Suspense is treated as a single unit. For example, even if *only one* of these components suspends waiting for some data, *all* of them together will be replaced by the loading indicator:

```
<Suspense fallback={<Loading />}>

<Biography />

<Panel>

<Albums />

</Panel>

</Suspense>
```

Then, after all of them are ready to be displayed, they will all appear together at once.

In the example below, both `Biography` and `Albums` fetch some data. However, because they are grouped under a single Suspense boundary, these components always “pop in” together at the same time.

ArtistPage.jsPanel.jsBiography.jsAlbums.js

ArtistPage.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<Loading />}>
        <Biography artistId={artist.id} />
        <Panel>
          <Albums artistId={artist.id} />
        </Panel>
      </Suspense>
    </>
  );
}

function Loading() {
  return <h2>🌀 Loading...</h2>;
}
```

Show more

Components that load data don’t have to be direct children of the Suspense boundary. For example, you can move `Biography` and `Albums` into a new `Details` component. This doesn’t change the behavior. `Biography` and `Albums` share the same closest parent Suspense boundary, so their reveal is coordinated together.

```
<Suspense fallback={<Loading />}>

<Details artistId={artist.id} />

</Suspense>

function Details({ artistId }) {

return (

<>

<Biography artistId={artistId} />

<Panel>

<Albums artistId={artistId} />

</Panel>

</>

);

}
```

---

### Revealing nested content as it loads

When a component suspends, the closest parent Suspense component shows the fallback. This lets you nest multiple Suspense components to create a loading sequence. Each Suspense boundary’s fallback will be filled in as the next level of content becomes available. For example, you can give the album list its own fallback:

```
<Suspense fallback={<BigSpinner />}>

<Biography />

<Suspense fallback={<AlbumsGlimmer />}>

<Panel>

<Albums />

</Panel>

</Suspense>

</Suspense>
```

With this change, displaying the `Biography` doesn’t need to “wait” for the `Albums` to load.

The sequence will be:

1. If `Biography` hasn’t loaded yet, `BigSpinner` is shown in place of the entire content area.
2. Once `Biography` finishes loading, `BigSpinner` is replaced by the content.
3. If `Albums` hasn’t loaded yet, `AlbumsGlimmer` is shown in place of `Albums` and its parent `Panel`.
4. Finally, once `Albums` finishes loading, it replaces `AlbumsGlimmer`.

ArtistPage.jsPanel.jsBiography.jsAlbums.js

ArtistPage.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense } from 'react';
import Albums from './Albums.js';
import Biography from './Biography.js';
import Panel from './Panel.js';

export default function ArtistPage({ artist }) {
  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<BigSpinner />}>
        <Biography artistId={artist.id} />
        <Suspense fallback={<AlbumsGlimmer />}>
          <Panel>
            <Albums artistId={artist.id} />
          </Panel>
        </Suspense>
      </Suspense>
    </>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}

function AlbumsGlimmer() {
  return (
    <div className="glimmer-panel">
      <div className="glimmer-line" />
      <div className="glimmer-line" />
      <div className="glimmer-line" />
    </div>
  );
}
```

Show more

Suspense boundaries let you coordinate which parts of your UI should always “pop in” together at the same time, and which parts should progressively reveal more content in a sequence of loading states. You can add, move, or delete Suspense boundaries in any place in the tree without affecting the rest of your app’s behavior.

Don’t put a Suspense boundary around every component. Suspense boundaries should not be more granular than the loading sequence that you want the user to experience. If you work with a designer, ask them where the loading states should be placed—it’s likely that they’ve already included them in their design wireframes.

---

### Showing stale content while fresh content is loading

In this example, the `SearchResults` component suspends while fetching the search results. Type `"a"`, wait for the results, and then edit it to `"ab"`. The results for `"a"` will get replaced by the loading fallback.

App.jsSearchResults.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, useState } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <SearchResults query={query} />
      </Suspense>
    </>
  );
}
```

Show more

A common alternative UI pattern is to *defer* updating the list and to keep showing the previous results until the new results are ready. The [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) Hook lets you pass a deferred version of the query down:

```
export default function App() {

const [query, setQuery] = useState('');

const deferredQuery = useDeferredValue(query);

return (

<>

<label>

Search albums:

<input value={query} onChange={e => setQuery(e.target.value)} />

</label>

<Suspense fallback={<h2>Loading...</h2>}>

<SearchResults query={deferredQuery} />

</Suspense>

</>

);

}
```

The `query` will update immediately, so the input will display the new value. However, the `deferredQuery` will keep its previous value until the data has loaded, so `SearchResults` will show the stale results for a bit.

To make it more obvious to the user, you can add a visual indication when the stale result list is displayed:

```
<div style={{

opacity: query !== deferredQuery ? 0.5 : 1

}}>

<SearchResults query={deferredQuery} />

</div>
```

Enter `"a"` in the example below, wait for the results to load, and then edit the input to `"ab"`. Notice how instead of the Suspense fallback, you now see the dimmed stale result list until the new results have loaded:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, useState, useDeferredValue } from 'react';
import SearchResults from './SearchResults.js';

export default function App() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;
  return (
    <>
      <label>
        Search albums:
        <input value={query} onChange={e => setQuery(e.target.value)} />
      </label>
      <Suspense fallback={<h2>Loading...</h2>}>
        <div style={{ opacity: isStale ? 0.5 : 1 }}>
          <SearchResults query={deferredQuery} />
        </div>
      </Suspense>
    </>
  );
}
```

Show more

### Note

Both deferred values and [Transitions](https://react.dev/reference/react/Suspense#preventing-already-revealed-content-from-hiding) let you avoid showing Suspense fallback in favor of inline indicators. Transitions mark the whole update as non-urgent so they are typically used by frameworks and router libraries for navigation. Deferred values, on the other hand, are mostly useful in application code where you want to mark a part of UI as non-urgent and let it “lag behind” the rest of the UI.

---

### Preventing already revealed content from hiding

When a component suspends, the closest parent Suspense boundary switches to showing the fallback. This can lead to a jarring user experience if it was already displaying some content. Try pressing this button:

App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    setPage(url);
  }

  let content;
  if (page === '/') {
    content = (
      <IndexPage navigate={navigate} />
    );
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return (
    <Layout>
      {content}
    </Layout>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}
```

Show more

When you pressed the button, the `Router` component rendered `ArtistPage` instead of `IndexPage`. A component inside `ArtistPage` suspended, so the closest Suspense boundary started showing the fallback. The closest Suspense boundary was near the root, so the whole site layout got replaced by `BigSpinner`.

To prevent this, you can mark the navigation state update as a *Transition* with [`startTransition`:](https://react.dev/reference/react/startTransition)

```
function Router() {

const [page, setPage] = useState('/');

function navigate(url) {

startTransition(() => {

setPage(url);

});

}

// ...
```

This tells React that the state transition is not urgent, and it’s better to keep showing the previous page instead of hiding any already revealed content. Now clicking the button “waits” for the `Biography` to load:

App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, startTransition, useState } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = (
      <IndexPage navigate={navigate} />
    );
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return (
    <Layout>
      {content}
    </Layout>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}
```

Show more

A Transition doesn’t wait for *all* content to load. It only waits long enough to avoid hiding already revealed content. For example, the website `Layout` was already revealed, so it would be bad to hide it behind a loading spinner. However, the nested `Suspense` boundary around `Albums` is new, so the Transition doesn’t wait for it.

### Note

Suspense-enabled routers are expected to wrap the navigation updates into Transitions by default.

---

### Indicating that a Transition is happening

In the above example, once you click the button, there is no visual indication that a navigation is in progress. To add an indicator, you can replace [`startTransition`](https://react.dev/reference/react/startTransition) with [`useTransition`](https://react.dev/reference/react/useTransition) which gives you a boolean `isPending` value. In the example below, it’s used to change the website header styling while a Transition is happening:

App.jsLayout.jsIndexPage.jsArtistPage.jsAlbums.jsBiography.jsPanel.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Suspense, useState, useTransition } from 'react';
import IndexPage from './IndexPage.js';
import ArtistPage from './ArtistPage.js';
import Layout from './Layout.js';

export default function App() {
  return (
    <Suspense fallback={<BigSpinner />}>
      <Router />
    </Suspense>
  );
}

function Router() {
  const [page, setPage] = useState('/');
  const [isPending, startTransition] = useTransition();

  function navigate(url) {
    startTransition(() => {
      setPage(url);
    });
  }

  let content;
  if (page === '/') {
    content = (
      <IndexPage navigate={navigate} />
    );
  } else if (page === '/the-beatles') {
    content = (
      <ArtistPage
        artist={{
          id: 'the-beatles',
          name: 'The Beatles',
        }}
      />
    );
  }
  return (
    <Layout isPending={isPending}>
      {content}
    </Layout>
  );
}

function BigSpinner() {
  return <h2>🌀 Loading...</h2>;
}
```

Show more

---

### Resetting Suspense boundaries on navigation

During a Transition, React will avoid hiding already revealed content. However, if you navigate to a route with different parameters, you might want to tell React it is *different* content. You can express this with a `key`:

```
<ProfilePage key={queryParams.id} />
```

Imagine you’re navigating within a user’s profile page, and something suspends. If that update is wrapped in a Transition, it will not trigger the fallback for already visible content. That’s the expected behavior.

However, now imagine you’re navigating between two different user profiles. In that case, it makes sense to show the fallback. For example, one user’s timeline is *different content* from another user’s timeline. By specifying a `key`, you ensure that React treats different users’ profiles as different components, and resets the Suspense boundaries during navigation. Suspense-integrated routers should do this automatically.

---

### Providing a fallback for server errors and client-only content

If you use one of the [streaming server rendering APIs](https://react.dev/reference/react-dom/server) (or a framework that relies on them), React will also use your `<Suspense>` boundaries to handle errors on the server. If a component throws an error on the server, React will not abort the server render. Instead, it will find the closest `<Suspense>` component above it and include its fallback (such as a spinner) into the generated server HTML. The user will see a spinner at first.

On the client, React will attempt to render the same component again. If it errors on the client too, React will throw the error and display the closest [Error Boundary.](https://react.dev/reference/react/Component#static-getderivedstatefromerror) However, if it does not error on the client, React will not display the error to the user since the content was eventually displayed successfully.

You can use this to opt out some components from rendering on the server. To do this, throw an error in the server environment and then wrap them in a `<Suspense>` boundary to replace their HTML with fallbacks:

```
<Suspense fallback={<Loading />}>

<Chat />

</Suspense>

function Chat() {

if (typeof window === 'undefined') {

throw Error('Chat should only render on the client.');

}

// ...

}
```

The server HTML will include the loading indicator. It will be replaced by the `Chat` component on the client.

---

## Troubleshooting

### How do I prevent the UI from being replaced by a fallback during an update?

Replacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user.

To prevent this from happening, [mark the update as non-urgent using `startTransition`](https://react.dev/reference/react/Suspense#preventing-already-revealed-content-from-hiding). During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:

```
function handleNextPageClick() {

// If this update suspends, don't hide the already displayed content

startTransition(() => {

setCurrentPage(currentPage + 1);

});

}
```

This will avoid hiding existing content. However, any newly rendered `Suspense` boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available.

**React will only prevent unwanted fallbacks during non-urgent updates**. It will not delay a render if it’s the result of an urgent update. You must opt in with an API like [`startTransition`](https://react.dev/reference/react/startTransition) or [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue).

If your router is integrated with Suspense, it should wrap its updates into [`startTransition`](https://react.dev/reference/react/startTransition) automatically.

[Previous<StrictMode>](https://react.dev/reference/react/StrictMode)[Next<Activity>](https://react.dev/reference/react/Activity)

---

---


# <Activity> – React

URL: https://react.dev/reference/react/Activity

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react/components)

# <Activity>

`<Activity>` lets you hide and restore the UI and internal state of its children.

```
<Activity mode={visibility}>

<Sidebar />

</Activity>
```

* [Reference](https://react.dev/reference/react/Activity#reference) 
  + [`<Activity>`](https://react.dev/reference/react/Activity#activity)
* [Usage](https://react.dev/reference/react/Activity#usage) 
  + [Restoring the state of hidden components](https://react.dev/reference/react/Activity#restoring-the-state-of-hidden-components)
  + [Restoring the DOM of hidden components](https://react.dev/reference/react/Activity#restoring-the-dom-of-hidden-components)
  + [Pre-rendering content that’s likely to become visible](https://react.dev/reference/react/Activity#pre-rendering-content-thats-likely-to-become-visible)
  + [Speeding up interactions during page load](https://react.dev/reference/react/Activity#speeding-up-interactions-during-page-load)
* [Troubleshooting](https://react.dev/reference/react/Activity#troubleshooting) 
  + [My hidden components have unwanted side effects](https://react.dev/reference/react/Activity#my-hidden-components-have-unwanted-side-effects)
  + [My hidden components have Effects that aren’t running](https://react.dev/reference/react/Activity#my-hidden-components-have-effects-that-arent-running)

---

## Reference

### `<Activity>`

You can use Activity to hide part of your application:

```
<Activity mode={isShowingSidebar ? "visible" : "hidden"}>

<Sidebar />

</Activity>
```

When an Activity boundary is hidden, React will visually hide its children using the `display: "none"` CSS property. It will also destroy their Effects, cleaning up any active subscriptions.

While hidden, children still re-render in response to new props, albeit at a lower priority than the rest of the content.

When the boundary becomes visible again, React will reveal the children with their previous state restored, and re-create their Effects.

In this way, Activity can be thought of as a mechanism for rendering “background activity”. Rather than completely discarding content that’s likely to become visible again, you can use Activity to maintain and restore that content’s UI and internal state, while ensuring that your hidden content has no unwanted side effects.

[See more examples below.](https://react.dev/reference/react/Activity#usage)

#### Props

* `children`: The UI you intend to show and hide.
* `mode`: A string value of either `'visible'` or `'hidden'`. If omitted, defaults to `'visible'`.

#### Caveats

* If an Activity is rendered inside of a [ViewTransition](https://react.dev/reference/react/ViewTransition), and it becomes visible as a result of an update caused by [startTransition](https://react.dev/reference/react/startTransition), it will activate the ViewTransition’s `enter` animation. If it becomes hidden, it will activate its `exit` animation.
* An Activity that just renders text will not render anything rather than rendering hidden text, because there’s no corresponding DOM element to apply visibility changes to. For example, `<Activity mode="hidden"><ComponentThatJustReturnsText /></Activity>` will not produce any output in the DOM for `const ComponentThatJustReturnsText = () => "Hello, World!"`.

---

## Usage

### Restoring the state of hidden components

In React, when you want to conditionally show or hide a component, you typically mount or unmount it based on that condition:

```
{isShowingSidebar && (

<Sidebar />

)}
```

But unmounting a component destroys its internal state, which is not always what you want.

When you hide a component using an Activity boundary instead, React will “save” its state for later:

```
<Activity mode={isShowingSidebar ? "visible" : "hidden"}>

<Sidebar />

</Activity>
```

This makes it possible to hide and then later restore components in the state they were previously in.

The following example has a sidebar with an expandable section. You can press “Overview” to reveal the three subitems below it. The main app area also has a button that hides and shows the sidebar.

Try expanding the Overview section, and then toggling the sidebar closed then open:

App.jsSidebar.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import Sidebar from './Sidebar.js';

export default function App() {
  const [isShowingSidebar, setIsShowingSidebar] = useState(true);

  return (
    <>
      {isShowingSidebar && (
        <Sidebar />
      )}

      <main>
        <button onClick={() => setIsShowingSidebar(!isShowingSidebar)}>
          Toggle sidebar
        </button>
        <h1>Main content</h1>
      </main>
    </>
  );
}
```

Show more

The Overview section always starts out collapsed. Because we unmount the sidebar when `isShowingSidebar` flips to `false`, all its internal state is lost.

This is a perfect use case for Activity. We can preserve the internal state of our sidebar, even when visually hiding it.

Let’s replace the conditional rendering of our sidebar with an Activity boundary:

```
// Before

{isShowingSidebar && (

<Sidebar />

)}

// After

<Activity mode={isShowingSidebar ? 'visible' : 'hidden'}>

<Sidebar />

</Activity>
```

and check out the new behavior:

App.jsSidebar.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Activity, useState } from 'react';

import Sidebar from './Sidebar.js';

export default function App() {
  const [isShowingSidebar, setIsShowingSidebar] = useState(true);

  return (
    <>
      <Activity mode={isShowingSidebar ? 'visible' : 'hidden'}>
        <Sidebar />
      </Activity>

      <main>
        <button onClick={() => setIsShowingSidebar(!isShowingSidebar)}>
          Toggle sidebar
        </button>
        <h1>Main content</h1>
      </main>
    </>
  );
}
```

Show more

Our sidebar’s internal state is now restored, without any changes to its implementation.

---

### Restoring the DOM of hidden components

Since Activity boundaries hide their children using `display: none`, their children’s DOM is also preserved when hidden. This makes them great for maintaining ephemeral state in parts of the UI that the user is likely to interact with again.

In this example, the Contact tab has a `<textarea>` where the user can enter a message. If you enter some text, change to the Home tab, then change back to the Contact tab, the draft message is lost:

App.jsTabButton.jsHome.jsContact.js

Contact.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Contact() {
  return (
    <div>
      <p>Send me a message!</p>

      <textarea />

      <p>You can find me online here:</p>
      <ul>
        <li>admin@mysite.com</li>
        <li>+123456789</li>
      </ul>
    </div>
  );
}
```

This is because we’re fully unmounting `Contact` in `App`. When the Contact tab unmounts, the `<textarea>` element’s internal DOM state is lost.

If we switch to using an Activity boundary to show and hide the active tab, we can preserve the state of each tab’s DOM. Try entering text and switching tabs again, and you’ll see the draft message is no longer reset:

App.jsTabButton.jsHome.jsContact.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Activity, useState } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Contact from './Contact.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('contact');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'contact'}
        onClick={() => setActiveTab('contact')}
      >
        Contact
      </TabButton>

      <hr />

      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>
        <Home />
      </Activity>
      <Activity mode={activeTab === 'contact' ? 'visible' : 'hidden'}>
        <Contact />
      </Activity>
    </>
  );
}
```

Show more

Again, the Activity boundary let us preserve the Contact tab’s internal state without changing its implementation.

---

### Pre-rendering content that’s likely to become visible

So far, we’ve seen how Activity can hide some content that the user has interacted with, without discarding that content’s ephemeral state.

But Activity boundaries can also be used to *prepare* content that the user has yet to see for the first time:

```
<Activity mode="hidden">

<SlowComponent />

</Activity>
```

When an Activity boundary is hidden during its initial render, its children won’t be visible on the page — but they will *still be rendered*, albeit at a lower priority than the visible content, and without mounting their Effects.

This *pre-rendering* allows the children to load any code or data they need ahead of time, so that later, when the Activity boundary becomes visible, the children can appear faster with reduced loading times.

Let’s look at an example.

In this demo, the Posts tab loads some data. If you press it, you’ll see a Suspense fallback displayed while the data is being fetched:

App.jsHome.jsPosts.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, Suspense } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Posts from './Posts.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('home');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'posts'}
        onClick={() => setActiveTab('posts')}
      >
        Posts
      </TabButton>

      <hr />

      <Suspense fallback={<h1>🌀 Loading...</h1>}>
        {activeTab === 'home' && <Home />}
        {activeTab === 'posts' && <Posts />}
      </Suspense>
    </>
  );
}
```

Show more

This is because `App` doesn’t mount `Posts` until its tab is active.

If we update `App` to use an Activity boundary to show and hide the active tab, `Posts` will be pre-rendered when the app first loads, allowing it to fetch its data before it becomes visible.

Try clicking the Posts tab now:

App.jsHome.jsPosts.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Activity, useState, Suspense } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Posts from './Posts.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('home');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'posts'}
        onClick={() => setActiveTab('posts')}
      >
        Posts
      </TabButton>

      <hr />

      <Suspense fallback={<h1>🌀 Loading...</h1>}>
        <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>
          <Home />
        </Activity>
        <Activity mode={activeTab === 'posts' ? 'visible' : 'hidden'}>
          <Posts />
        </Activity>
      </Suspense>
    </>
  );
}
```

Show more

`Posts` was able to prepare itself for a faster render, thanks to the hidden Activity boundary.

---

Pre-rendering components with hidden Activity boundaries is a powerful way to reduce loading times for parts of the UI that the user is likely to interact with next.

### Note

**Only Suspense-enabled data sources will be fetched during pre-rendering.** They include:

* Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense)
* Lazy-loading component code with [`lazy`](https://react.dev/reference/react/lazy)
* Reading the value of a cached Promise with [`use`](https://react.dev/reference/react/use)

Activity **does not** detect data that is fetched inside an Effect.

The exact way you would load data in the `Posts` component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

---

### Speeding up interactions during page load

React includes an under-the-hood performance optimization called Selective Hydration. It works by hydrating your app’s initial HTML *in chunks*, enabling some components to become interactive even if other components on the page haven’t loaded their code or data yet.

Suspense boundaries participate in Selective Hydration, because they naturally divide your component tree into units that are independent from one another:

```
function Page() {

return (

<>

<MessageComposer />

<Suspense fallback="Loading chats...">

<Chats />

</Suspense>

</>

)

}
```

Here, `MessageComposer` can be fully hydrated during the initial render of the page, even before `Chats` is mounted and starts to fetch its data.

So by breaking up your component tree into discrete units, Suspense allows React to hydrate your app’s server-rendered HTML in chunks, enabling parts of your app to become interactive as fast as possible.

But what about pages that don’t use Suspense?

Take this tabs example:

```
function Page() {

const [activeTab, setActiveTab] = useState('home');

return (

<>

<TabButton onClick={() => setActiveTab('home')}>

Home

</TabButton>

<TabButton onClick={() => setActiveTab('video')}>

Video

</TabButton>

{activeTab === 'home' && (

<Home />

)}

{activeTab === 'video' && (

<Video />

)}

</>

)

}
```

Here, React must hydrate the entire page all at once. If `Home` or `Video` are slower to render, they could make the tab buttons feel unresponsive during hydration.

Adding Suspense around the active tab would solve this:

```
function Page() {

const [activeTab, setActiveTab] = useState('home');

return (

<>

<TabButton onClick={() => setActiveTab('home')}>

Home

</TabButton>

<TabButton onClick={() => setActiveTab('video')}>

Video

</TabButton>

<Suspense fallback={<Placeholder />}>

{activeTab === 'home' && (

<Home />

)}

{activeTab === 'video' && (

<Video />

)}

</Suspense>

</>

)

}
```

…but it would also change the UI, since the `Placeholder` fallback would be displayed on the initial render.

Instead, we can use Activity. Since Activity boundaries show and hide their children, they already naturally divide the component tree into independent units. And just like Suspense, this feature allows them to participate in Selective Hydration.

Let’s update our example to use Activity boundaries around the active tab:

```
function Page() {

const [activeTab, setActiveTab] = useState('home');

return (

<>

<TabButton onClick={() => setActiveTab('home')}>

Home

</TabButton>

<TabButton onClick={() => setActiveTab('video')}>

Video

</TabButton>

<Activity mode={activeTab === "home" ? "visible" : "hidden"}>

<Home />

</Activity>

<Activity mode={activeTab === "video" ? "visible" : "hidden"}>

<Video />

</Activity>

</>

)

}
```

Now our initial server-rendered HTML looks the same as it did in the original version, but thanks to Activity, React can hydrate the tab buttons first, before it even mounts `Home` or `Video`.

---

Thus, in addition to hiding and showing content, Activity boundaries help improve your app’s performance during hydration by letting React know which parts of your page can become interactive in isolation.

And even if your page doesn’t ever hide part of its content, you can still add always-visible Activity boundaries to improve hydration performance:

```
function Page() {

return (

<>

<Post />

<Activity>

<Comments />

</Activity>

</>

);

}
```

---

## Troubleshooting

### My hidden components have unwanted side effects

An Activity boundary hides its content by setting `display: none` on its children and cleaning up any of their Effects. So, most well-behaved React components that properly clean up their side effects will already be robust to being hidden by Activity.

But there *are* some situations where a hidden component behaves differently than an unmounted one. Most notably, since a hidden component’s DOM is not destroyed, any side effects from that DOM will persist, even after the component is hidden.

As an example, consider a `<video>` tag. Typically it doesn’t require any cleanup, because even if you’re playing a video, unmounting the tag stops the video and audio from playing in the browser. Try playing the video and then pressing Home in this demo:

App.jsHome.jsVideo.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Video from './Video.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('video');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'video'}
        onClick={() => setActiveTab('video')}
      >
        Video
      </TabButton>

      <hr />

      {activeTab === 'home' && <Home />}
      {activeTab === 'video' && <Video />}
    </>
  );
}
```

Show more

The video stops playing as expected.

Now, let’s say we wanted to preserve the timecode where the user last watched, so that when they tab back to the video, it doesn’t start over from the beginning again.

This is a great use case for Activity!

Let’s update `App` to hide the inactive tab with a hidden Activity boundary instead of unmounting it, and see how the demo behaves this time:

App.jsHome.jsVideo.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Activity, useState } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Video from './Video.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('video');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'video'}
        onClick={() => setActiveTab('video')}
      >
        Video
      </TabButton>

      <hr />

      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>
        <Home />
      </Activity>
      <Activity mode={activeTab === 'video' ? 'visible' : 'hidden'}>
        <Video />
      </Activity>
    </>
  );
}
```

Show more

Whoops! The video and audio continue to play even after it’s been hidden, because the tab’s `<video>` element is still in the DOM.

To fix this, we can add an Effect with a cleanup function that pauses the video:

```
export default function VideoTab() {

const ref = useRef();

useLayoutEffect(() => {

const videoRef = ref.current;

return () => {

videoRef.pause()

}

}, []);

return (

<video

ref={ref}

controls

playsInline

src="..."

/>

);

}
```

We call `useLayoutEffect` instead of `useEffect` because conceptually the clean-up code is tied to the component’s UI being visually hidden. If we used a regular effect, the code could be delayed by (say) a re-suspending Suspense boundary or a View Transition.

Let’s see the new behavior. Try playing the video, switching to the Home tab, then back to the Video tab:

App.jsHome.jsVideo.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Activity, useState } from 'react';
import TabButton from './TabButton.js';
import Home from './Home.js';
import Video from './Video.js';

export default function App() {
  const [activeTab, setActiveTab] = useState('video');

  return (
    <>
      <TabButton
        isActive={activeTab === 'home'}
        onClick={() => setActiveTab('home')}
      >
        Home
      </TabButton>
      <TabButton
        isActive={activeTab === 'video'}
        onClick={() => setActiveTab('video')}
      >
        Video
      </TabButton>

      <hr />

      <Activity mode={activeTab === 'home' ? 'visible' : 'hidden'}>
        <Home />
      </Activity>
      <Activity mode={activeTab === 'video' ? 'visible' : 'hidden'}>
        <Video />
      </Activity>
    </>
  );
}
```

Show more

It works great! Our cleanup function ensures that the video stops playing if it’s ever hidden by an Activity boundary, and even better, because the `<video>` tag is never destroyed, the timecode is preserved, and the video itself doesn’t need to be initialized or downloaded again when the user switches back to keep watching it.

This is a great example of using Activity to preserve ephemeral DOM state for parts of the UI that become hidden, but the user is likely to interact with again soon.

---

Our example illustrates that for certain tags like `<video>`, unmounting and hiding have different behavior. If a component renders DOM that has a side effect, and you want to prevent that side effect when an Activity boundary hides it, add an Effect with a return function to clean it up.

The most common cases of this will be from the following tags:

* `<video>`
* `<audio>`
* `<iframe>`

Typically, though, most of your React components should already be robust to being hidden by an Activity boundary. And conceptually, you should think of “hidden” Activities as being unmounted.

To eagerly discover other Effects that don’t have proper cleanup, which is important not only for Activity boundaries but for many other behaviors in React, we recommend using [`<StrictMode>`](https://react.dev/reference/react/StrictMode).

---

### My hidden components have Effects that aren’t running

When an `<Activity>` is “hidden”, all its children’s Effects are cleaned up. Conceptually, the children are unmounted, but React saves their state for later. This is a feature of Activity because it means subscriptions won’t be active for hidden parts of the UI, reducing the amount of work needed for hidden content.

If you’re relying on an Effect mounting to clean up a component’s side effects, refactor the Effect to do the work in the returned cleanup function instead.

To eagerly find problematic Effects, we recommend adding [`<StrictMode>`](https://react.dev/reference/react/StrictMode) which will eagerly perform Activity unmounts and mounts to catch any unexpected side-effects.

[Previous<Suspense>](https://react.dev/reference/react/Suspense)[Next<ViewTransition>](https://react.dev/reference/react/ViewTransition)

---

---


# <ViewTransition> – React

URL: https://react.dev/reference/react/ViewTransition

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react/components)

# <ViewTransition> - This feature is available in the latest Canary version of React

### Canary

**The `<ViewTransition />` API is currently only available in React’s Canary and Experimental channels.**

[Learn more about React’s release channels here.](https://react.dev/community/versioning-policy#all-release-channels)

`<ViewTransition>` lets you animate elements that update inside a Transition.

```
import {ViewTransition} from 'react';

<ViewTransition>

<div>...</div>

</ViewTransition>
```

* [Reference](https://react.dev/reference/react/ViewTransition#reference) 
  + [`<ViewTransition>`](https://react.dev/reference/react/ViewTransition#viewtransition)
  + [View Transition Class](https://react.dev/reference/react/ViewTransition#view-transition-class)
  + [Styling View Transitions](https://react.dev/reference/react/ViewTransition#styling-view-transitions)
* [Usage](https://react.dev/reference/react/ViewTransition#usage) 
  + [Animating an element on enter/exit](https://react.dev/reference/react/ViewTransition#animating-an-element-on-enter)
  + [Animating a shared element](https://react.dev/reference/react/ViewTransition#animating-a-shared-element)
  + [Animating reorder of items in a list](https://react.dev/reference/react/ViewTransition#animating-reorder-of-items-in-a-list)
  + [Animating from Suspense content](https://react.dev/reference/react/ViewTransition#animating-from-suspense-content)
  + [Opting-out of an animation](https://react.dev/reference/react/ViewTransition#opting-out-of-an-animation)
  + [Customizing animations](https://react.dev/reference/react/ViewTransition#customizing-animations)
  + [Customizing animations with types](https://react.dev/reference/react/ViewTransition#customizing-animations-with-types)
  + [Building View Transition enabled routers](https://react.dev/reference/react/ViewTransition#building-view-transition-enabled-routers)
* [Troubleshooting](https://react.dev/reference/react/ViewTransition#troubleshooting) 
  + [My `<ViewTransition>` is not activating](https://react.dev/reference/react/ViewTransition#my-viewtransition-is-not-activating)
  + [I’m getting an error “There are two `<ViewTransition name=%s>` components with the same name mounted at the same time.”](https://react.dev/reference/react/ViewTransition#two-viewtransition-with-same-name)

---

## Reference

### `<ViewTransition>`

Wrap elements in `<ViewTransition>` to animate them when they update inside a [Transition](https://react.dev/reference/react/useTransition). React uses the following heuristics to determine if a View Transition activates for an animation:

* `enter`: If a `ViewTransition` itself gets inserted in this Transition, then this will activate.
* `exit`: If a `ViewTransition` itself gets deleted in this Transition, then this will activate.
* `update`: If a `ViewTransition` has any DOM mutations inside it that React is doing (such as a prop changing) or if the `ViewTransition` boundary itself changes size or position due to an immediate sibling. If there are nested `ViewTransition` then the mutation applies to them and not the parent.
* `share`: If a named `ViewTransition` is inside a deleted subtree and another named `ViewTransition` with the same name is part of an inserted subtree in the same Transition, they form a Shared Element Transition, and it animates from the deleted one to the inserted one.

By default, `<ViewTransition>` animates with a smooth cross-fade (the browser default view transition). You can customize the animation by providing a [View Transition Class](https://react.dev/reference/react/ViewTransition#view-transition-class) to the `<ViewTransition>` component. You can customize animations for each kind of trigger (see [Styling View Transitions](https://react.dev/reference/react/ViewTransition#styling-view-transitions)).

##### Deep Dive

#### How does `<ViewTransition>` work?

Show Details

Under the hood, React applies `view-transition-name` to inline styles of the nearest DOM node nested inside the `<ViewTransition>` component. If there are multiple sibling DOM nodes like `<ViewTransition><div /><div /></ViewTransition>` then React adds a suffix to the name to make each unique but conceptually they’re part of the same one. React doesn’t apply these eagerly but only at the time that boundary should participate in an animation.

React automatically calls `startViewTransition` itself behind the scenes so you should never do that yourself. In fact, if you have something else on the page running a ViewTransition React will interrupt it. So it’s recommended that you use React itself to coordinate these. If you had other ways of trigger ViewTransitions in the past, we recommend that you migrate to the built-in way.

If there are other React ViewTransitions already running then React will wait for them to finish before starting the next one. However, importantly if there are multiple updates happening while the first one is running, those will all be batched into one. If you start A->B. Then in the meantime you get an update to go to C and then D. When the first A->B animation finishes the next one will animate from B->D.

The `getSnapshotBeforeUpdate` life-cycle will be called before `startViewTransition` and some `view-transition-name` will update at the same time.

Then React calls `startViewTransition`. Inside the `updateCallback`, React will:

* Apply its mutations to the DOM and invoke useInsertionEffects.
* Wait for fonts to load.
* Call componentDidMount, componentDidUpdate, useLayoutEffect and refs.
* Wait for any pending Navigation to finish.
* Then React will measure any changes to the layout to see which boundaries will need to animate.

After the ready Promise of the `startViewTransition` is resolved, React will then revert the `view-transition-name`. Then React will invoke the `onEnter`, `onExit`, `onUpdate` and `onShare` callbacks to allow for manual programmatic control over the Animations. This will be after the built-in default ones have already been computed.

If a `flushSync` happens to get in the middle of this sequence, then React will skip the Transition since it relies on being able to complete synchronously.

After the finished Promise of the `startViewTransition` is resolved, React will then invoke `useEffect`. This prevents those from interfering with the performance of the Animation. However, this is not a guarantee because if another `setState` happens while the Animation is running it’ll still have to invoke the `useEffect` earlier to preserve the sequential guarantees.

#### Props

By default, `<ViewTransition>` animates with a smooth cross-fade. You can customize the animation, or specify a shared element transition, with these props:

* **optional** `enter`: A string or object. The [View Transition Class](https://react.dev/reference/react/ViewTransition#view-transition-class) to apply when enter is activated.
* **optional** `exit`: A string or object. The [View Transition Class](https://react.dev/reference/react/ViewTransition#view-transition-class) to apply when exit is activated.
* **optional** `update`: A string or object. The [View Transition Class](https://react.dev/reference/react/ViewTransition#view-transition-class) to apply when an update is activated.
* **optional** `share`: A string or object. The [View Transition Class](https://react.dev/reference/react/ViewTransition#view-transition-class) to apply when a shared element is activated.
* **optional** `default`: A string or object. The [View Transition Class](https://react.dev/reference/react/ViewTransition#view-transition-class) used when no other matching activation prop is found.
* **optional** `name`: A string or object. The name of the View Transition used for shared element transitions. If not provided, React will use a unique name for each View Transition to prevent unexpected animations.

#### Callback

These callbacks allow you to adjust the animation imperatively using the [animate](https://developer.mozilla.org/en-US/docs/Web/API/Element/animate) APIs:

* **optional** `onEnter`: A function. React calls `onEnter` after an “enter” animation.
* **optional** `onExit`: A function. React calls `onExit` after an “exit” animation.
* **optional** `onShare`: A function. React calls `onShare` after a “share” animation.
* **optional** `onUpdate`: A function. React calls `onUpdate` after an “update” animation.

Each callback receives as arguments:

* `element`: The DOM element that was animated.
* `types`: The [Transition Types](https://react.dev/reference/react/addTransitionType) included in the animation.

### View Transition Class

The View Transition Class is the CSS class name(s) applied by React during the transition when the ViewTransition activates. It can be a string or an object.

* `string`: the `class` added on the child elements when activated. If `'none'` is provided, no class will be added.
* `object`: the class added on the child elements will be the key matching View Transition type added with `addTransitionType`. The object can also specify a `default` to use if no matching type is found.

The value `'none'` can be used to prevent a View Transition from activating for a specific trigger.

### Styling View Transitions

### Note

In many early examples of View Transitions around the web, you’ll have seen using a [`view-transition-name`](https://developer.mozilla.org/en-US/docs/Web/CSS/view-transition-name) and then style it using `::view-transition-...(my-name)` selectors. We don’t recommend that for styling. Instead, we normally recommend using a View Transition Class instead.

To customize the animation for a `<ViewTransition>` you can provide a View Transition Class to one of the activation props. The View Transition Class is a CSS class name that React applies to the child elements when the ViewTransition activates.

For example, to customize an “enter” animation, provide a class name to the `enter` prop:

```
<ViewTransition enter="slide-in">
```

When the `<ViewTransition>` activates an “enter” animation, React will add the class name `slide-in`. Then you can refer to this class using [view transition pseudo selectors](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API#pseudo-elements) to build reusable animations:

```
::view-transition-group(.slide-in) {

}

::view-transition-old(.slide-in) {

}

::view-transition-new(.slide-in) {

}
```

In the future, CSS libraries may add built-in animations using View Transition Classes to make this easier to use.

#### Caveats

* By default, `setState` updates immediately and does not activate `<ViewTransition>`, only updates wrapped in a [Transition](https://react.dev/reference/react/useTransition). You can also use [`<Suspense>`](https://react.dev/reference/react/Suspense) to opt-in to a Transition to [reveal content](https://react.dev/reference/react/Suspense#revealing-content-together-at-once).
* `<ViewTransition>` creates an image that can be moved around, scaled and cross-faded. Unlike Layout Animations you may have seen in React Native or Motion, this means that not every individual Element inside of it animates its position. This can lead to better performance and a more continuous feeling, smooth animation compared to animating every individual piece. However, it can also lose continuity in things that should be moving by themselves. So you might have to add more `<ViewTransition>` boundaries manually as a result.
* Many users may prefer not having animations on the page. React doesn’t automatically disable animations for this case. We recommend that using the `@media (prefers-reduced-motion)` media query to disable animations or tone them down based on user preference. In the future, CSS libraries may have this built-in to their presets.
* Currently, `<ViewTransition>` only works in the DOM. We’re working on adding support for React Native and other platforms.

---

## Usage

### Animating an element on enter/exit

Enter/Exit Transitions trigger when a `<ViewTransition>` is added or removed by a component in a transition:

```
function Child() {

return (

<ViewTransition>

<div>Hi</div>

</ViewTransition>

);

}

function Parent() {

const [show, setShow] = useState();

if (show) {

return <Child />;

}

return null;

}
```

When `setShow` is called, `show` switches to `true` and the `Child` component is rendered. When `setShow` is called inside `startTransition`, and `Child` renders a `ViewTransition` before any other DOM nodes, an `enter` animation is triggered.

When `show` switches back to `false`, an `exit` animation is triggered.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {
  ViewTransition,
  useState,
  startTransition
} from 'react';
import {Video} from "./Video";
import videos from "./data"

function Item() {
  return (
    <ViewTransition>
      <Video video={videos[0]}/>
    </ViewTransition>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <button
        onClick={() => {
          startTransition(() => {
            setShowItem((prev) => !prev);
          });
        }}
      >{showItem ? '➖' : '➕'}</button>

      {showItem ? <Item /> : null}
    </>
  );
}
```

Show more

### Pitfall

`<ViewTransition>` only activates if it is placed before any DOM node. If `Child` instead looked like this, no animation would trigger:

```
function Component() {

return <ViewTransition>Hi</ViewTransition>;

}
```

---

### Animating a shared element

Normally, we don’t recommend assigning a name to a `<ViewTransition>` and instead let React assign it an automatic name. The reason you might want to assign a name is to animate between completely different components when one tree unmounts and another tree mounts at the same time. To preserve continuity.

```
<ViewTransition name={UNIQUE_NAME}>

<Child />

</ViewTransition>
```

When one tree unmounts and another mounts, if there’s a pair where the same name exists in the unmounting tree and the mounting tree, they trigger the “share” animation on both. It animates from the unmounting side to the mounting side.

Unlike an exit/enter animation this can be deeply inside the deleted/mounted tree. If a `<ViewTransition>` would also be eligible for exit/enter, then the “share” animation takes precedence.

If Transition first unmounts one side and then leads to a `<Suspense>` fallback being shown before eventually the new name being mounted, then no shared element transition happens.

App.jsVideo.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {
  ViewTransition,
  useState,
  startTransition
} from "react";
import {Video, Thumbnail, FullscreenVideo} from "./Video";
import videos from "./data";

export default function Component() {
  const [fullscreen, setFullscreen] = useState(false);
  if (fullscreen) {
    return <FullscreenVideo
      video={videos[0]}
      onExit={() => startTransition(() => setFullscreen(false))}
    />
  }
  return <Video
    video={videos[0]}
    onClick={() => startTransition(() => setFullscreen(true))}
  />
}
```

Show more

### Note

If either the mounted or unmounted side of a pair is outside the viewport, then no pair is formed. This ensures that it doesn’t fly in or out of the viewport when something is scrolled. Instead it’s treated as a regular enter/exit by itself.

This does not happen if the same Component instance changes position, which triggers an “update”. Those animate regardless if one position is outside the viewport.

There’s currently a quirk where if a deeply nested unmounted `<ViewTransition>` is inside the viewport but the mounted side is not within the viewport, then the unmounted side animates as its own “exit” animation even if it’s deeply nested instead of as part of the parent animation.

### Pitfall

It’s important that there’s only one thing with the same name mounted at a time in the entire app. Therefore it’s important to use unique namespaces for the name to avoid conflicts. To ensure you can do this you might want to add a constant in a separate module that you import.

```
export const MY_NAME = "my-globally-unique-name";

import {MY_NAME} from './shared-name';

...

<ViewTransition name={MY_NAME}>
```

---

### Animating reorder of items in a list

```
items.map(item => <Component key={item.id} item={item} />)
```

When reordering a list, without updating the content, the “update” animation triggers on each `<ViewTransition>` in the list if they’re outside a DOM node. Similar to enter/exit animations.

This means that this will trigger the animation on this `<ViewTransition>`:

```
function Component() {

return <ViewTransition><div>...</div></ViewTransition>;

}
```

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {
  ViewTransition,
  useState,
  startTransition
} from "react";
import {Video} from "./Video";
import videos from "./data";

export default function Component() {
  const [orderedVideos, setOrderedVideos] = useState(videos);
  const reorder = () => {
    startTransition(() => {
      setOrderedVideos((prev) => {
        return [...prev.sort(() => Math.random() - 0.5)];
      });
    });
  };
  return (
    <>
      <button onClick={reorder}>🎲</button>
      <div className="listContainer">
        {orderedVideos.map((video, i) => {
          return (
            <ViewTransition key={video.title}>
              <Video video={video} />
            </ViewTransition>
          );
        })}
      </div>
    </>
  );
}
```

Show more

However, this wouldn’t animate each individual item:

```
function Component() {

return <div><ViewTransition>...</ViewTransition></div>;

}
```

Instead, any parent `<ViewTransition>` would cross-fade. If there is no parent `<ViewTransition>` then there’s no animation in that case.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {
  ViewTransition,
  useState,
  startTransition
} from "react";
import {Video} from "./Video";
import videos from "./data";

export default function Component() {
  const [orderedVideos, setOrderedVideos] = useState(videos);
  const reorder = () => {
    startTransition(() => {
      setOrderedVideos((prev) => {
        return [...prev.sort(() => Math.random() - 0.5)];
      });
    });
  };
  return (
    <>
      <button onClick={reorder}>🎲</button>
      <ViewTransition>
        <div className="listContainer">
          {orderedVideos.map((video, i) => {
            return <Video video={video} key={video.title} />;
          })}
        </div>
      </ViewTransition>
    </>
  );
}
```

Show more

This means you might want to avoid wrapper elements in lists where you want to allow the Component to control its own reorder animation:

```
items.map(item => <div><Component key={item.id} item={item} /></div>)
```

The above rule also applies if one of the items updates to resize, which then causes the siblings to resize, it’ll also animate its sibling `<ViewTransition>` but only if they’re immediate siblings.

This means that during an update, which causes a lot of re-layout, it doesn’t individually animate every `<ViewTransition>` on the page. That would lead to a lot of noisy animations which distracts from the actual change. Therefore React is more conservative about when an individual animation triggers.

### Pitfall

It’s important to properly use keys to preserve identity when reordering lists. It might seem like you could use “name”, shared element transitions, to animate reorders but that would not trigger if one side was outside the viewport. To animate a reorder you often want to show that it went to a position outside the viewport.

---

### Animating from Suspense content

Just like any Transition, React waits for data and new CSS (`<link rel="stylesheet" precedence="...">`) before running the animation. In addition to this, ViewTransitions also wait up to 500ms for new fonts to load before starting the animation to avoid them flickering in later. For the same reason, an image wrapped in ViewTransition will wait for the image to load.

If it’s inside a new Suspense boundary instance, then the fallback is shown first. After the Suspense boundary fully loads, it triggers the `<ViewTransition>` to animate the reveal to the content.

Currently, this only happens for client-side Transition. In the future, this will also animate Suspense boundary for streaming SSR when content from the server suspends during the initial load.

There are two ways to animate Suspense boundaries depending on where you place the `<ViewTransition>`:

Update:

```
<ViewTransition>

<Suspense fallback={<A />}>

<B />

</Suspense>

</ViewTransition>
```

In this scenario when the content goes from A to B, it’ll be treated as an “update” and apply that class if appropriate. Both A and B will get the same view-transition-name and therefore they’re acting as a cross-fade by default.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {
  ViewTransition,
  useState,
  startTransition,
  Suspense
} from 'react';
import {Video, VideoPlaceholder} from "./Video";
import {useLazyVideoData} from "./data"

function LazyVideo() {
  const video = useLazyVideoData();
  return (
    <Video video={video}/>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <button
        onClick={() => {
          startTransition(() => {
            setShowItem((prev) => !prev);
          });
        }}
      >{showItem ? '➖' : '➕'}</button>
      {showItem ? (
        <ViewTransition>
          <Suspense fallback={<VideoPlaceholder />}>
            <LazyVideo />
          </Suspense>
        </ViewTransition>
      ) : null}
    </>
  );
}
```

Show more

Enter/Exit:

```
<Suspense fallback={<ViewTransition><A /></ViewTransition>}>

<ViewTransition><B /></ViewTransition>

</Suspense>
```

In this scenario, these are two separate ViewTransition instances each with their own `view-transition-name`. This will be treated as an “exit” of the `<A>` and an “enter” of the `<B>`.

You can achieve different effects depending on where you choose to place the `<ViewTransition>` boundary.

---

### Opting-out of an animation

Sometimes you’re wrapping a large existing component, like a whole page, and you want to animate some updates, such as changing the theme. However, you don’t want it to opt-in all updates inside the whole page to cross-fade when they’re updating. Especially if you’re incrementally adding more animations.

You can use the class “none” to opt-out of an animation. By wrapping your children in a “none” you can disable animations for updates to them while the parent still triggers.

```
<ViewTransition>

<div className={theme}>

<ViewTransition update="none">

{children}

</ViewTransition>

</div>

</ViewTransition>
```

This will only animate if the theme changes and not if only the children update. The children can still opt-in again with their own `<ViewTransition>` but at least it’s manual again.

---

### Customizing animations

By default, `<ViewTransition>` includes the default cross-fade from the browser.

To customize animations, you can provide props to the `<ViewTransition>` component to specify which animations to use, based on how the `<ViewTransition>` activates.

For example, we can slow down the default cross fade animation:

```
<ViewTransition default="slow-fade">

<Video />

</ViewTransition>
```

And define slow-fade in CSS using view transition classes:

```
::view-transition-old(.slow-fade) {

animation-duration: 500ms;

}

::view-transition-new(.slow-fade) {

animation-duration: 500ms;

}
```

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {
  ViewTransition,
  useState,
  startTransition
} from 'react';
import {Video} from "./Video";
import videos from "./data"

function Item() {
  return (
    <ViewTransition default="slow-fade">
      <Video video={videos[0]}/>
    </ViewTransition>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <button
        onClick={() => {
          startTransition(() => {
            setShowItem((prev) => !prev);
          });
        }}
      >{showItem ? '➖' : '➕'}</button>

      {showItem ? <Item /> : null}
    </>
  );
}
```

Show more

In addition to setting the `default`, you can also provide configurations for `enter`, `exit`, `update`, and `share` animations.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {
  ViewTransition,
  useState,
  startTransition
} from 'react';
import {Video} from "./Video";
import videos from "./data"

function Item() {
  return (
    <ViewTransition enter="slide-in" exit="slide-out">
      <Video video={videos[0]}/>
    </ViewTransition>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <button
        onClick={() => {
          startTransition(() => {
            setShowItem((prev) => !prev);
          });
        }}
      >{showItem ? '➖' : '➕'}</button>

      {showItem ? <Item /> : null}
    </>
  );
}
```

Show more

### Customizing animations with types

You can use the [`addTransitionType`](https://react.dev/reference/react/addTransitionType) API to add a class name to the child elements when a specific transition type is activated for a specific activation trigger. This allows you to customize the animation for each type of transition.

For example, to customize the animation for all forward and backward navigations:

```
<ViewTransition default={{

'navigation-back': 'slide-right',

'navigation-forward': 'slide-left',

}}>

<div>...</div>

</ViewTransition>

// in your router:

startTransition(() => {

addTransitionType('navigation-' + navigationType);

});
```

When the ViewTransition activates a “navigation-back” animation, React will add the class name “slide-right”. When the ViewTransition activates a “navigation-forward” animation, React will add the class name “slide-left”.

In the future, routers and other libraries may add support for standard view-transition types and styles.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {
  ViewTransition,
  addTransitionType,
  useState,
  startTransition,
} from "react";
import {Video} from "./Video";
import videos from "./data"

function Item() {
  return (
    <ViewTransition enter={
        {
          "add-video-back": "slide-in-back",
          "add-video-forward": "slide-in-forward"
        }
      }
      exit={
        {
          "remove-video-back": "slide-in-forward",
          "remove-video-forward": "slide-in-back"
        }
      }>
      <Video video={videos[0]}/>
    </ViewTransition>
  );
}

export default function Component() {
  const [showItem, setShowItem] = useState(false);
  return (
    <>
      <div className="button-container">
        <button
          onClick={() => {
            startTransition(() => {
              if (showItem) {
                addTransitionType("remove-video-back")
              } else {
                addTransitionType("add-video-back")
              }
              setShowItem((prev) => !prev);
            });
          }}
        >⬅️</button>
        <button
          onClick={() => {
            startTransition(() => {
              if (showItem) {
                addTransitionType("remove-video-forward")
              } else {
                addTransitionType("add-video-forward")
              }
              setShowItem((prev) => !prev);
            });
          }}
        >➡️</button>
      </div>
      {showItem ? <Item /> : null}
    </>
  );
}
```

Show more

### Building View Transition enabled routers

React waits for any pending Navigation to finish to ensure that scroll restoration happens within the animation. If the Navigation is blocked on React, your router must unblock in `useLayoutEffect` since `useEffect` would lead to a deadlock.

If a `startTransition` is started from the legacy popstate event, such as during a “back”-navigation then it must finish synchronously to ensure scroll and form restoration works correctly. This is in conflict with running a View Transition animation. Therefore, React will skip animations from popstate. Therefore animations won’t run for the back button. You can fix this by upgrading your router to use the Navigation API.

---

## Troubleshooting

### My `<ViewTransition>` is not activating

`<ViewTransition>` only activates if it is placed before any DOM node:

```
function Component() {

return (

<div>

<ViewTransition>Hi</ViewTransition>

</div>

);

}
```

To fix, ensure that the `<ViewTransition>` comes before any other DOM nodes:

```
function Component() {

return (

<ViewTransition>

<div>Hi</div>

</ViewTransition>

);

}
```

### I’m getting an error “There are two `<ViewTransition name=%s>` components with the same name mounted at the same time.”

This error occurs when two `<ViewTransition>` components with the same `name` are mounted at the same time:

```
function Item() {

// 🚩 All items will get the same "name".

return <ViewTransition name="item">...</ViewTransition>;

}

function ItemList({items}) {

return (

<>

{item.map(item => <Item key={item.id} />)}

</>

);

}
```

This will cause the View Transition to error. In development, React detects this issue to surface it and logs two errors:

Console

There are two `<ViewTransition name=%s>` components with the same name mounted at the same time. This is not supported and will cause View Transitions to error. Try to use a more unique name e.g. by using a namespace prefix and adding the id of an item to the name.
 at Item
 at ItemList

The existing `<ViewTransition name=%s>` duplicate has this stack trace.
 at Item
 at ItemList

To fix, ensure that there’s only one `<ViewTransition>` with the same name mounted at a time in the entire app by ensuring the `name` is unique, or adding an `id` to the name:

```
function Item({id}) {

// ✅ All items will get the same "name".

return <ViewTransition name={`item-${id}`}>...</ViewTransition>;

}

function ItemList({items}) {

return (

<>

{item.map(item => <Item key={item.id} item={item} />)}

</>

);

}
```

[Previous<Activity>](https://react.dev/reference/react/Activity)[NextAPIs](https://react.dev/reference/react/apis)

---

---


# act – React

URL: https://react.dev/reference/react/act

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# act

`act` is a test helper to apply pending React updates before making assertions.

```
await act(async actFn)
```

To prepare a component for assertions, wrap the code rendering it and performing updates inside an `await act()` call. This makes your test run closer to how React works in the browser.

### Note

You might find using `act()` directly a bit too verbose. To avoid some of the boilerplate, you could use a library like [React Testing Library](https://testing-library.com/docs/react-testing-library/intro), whose helpers are wrapped with `act()`.

* [Reference](https://react.dev/reference/react/act#reference) 
  + [`await act(async actFn)`](https://react.dev/reference/react/act#await-act-async-actfn)
* [Usage](https://react.dev/reference/react/act#usage) 
  + [Rendering components in tests](https://react.dev/reference/react/act#rendering-components-in-tests)
  + [Dispatching events in tests](https://react.dev/reference/react/act#dispatching-events-in-tests)
* [Troubleshooting](https://react.dev/reference/react/act#troubleshooting) 
  + [I’m getting an error: “The current testing environment is not configured to support act(…)”](https://react.dev/reference/react/act#error-the-current-testing-environment-is-not-configured-to-support-act)

---

## Reference

### `await act(async actFn)`

When writing UI tests, tasks like rendering, user events, or data fetching can be considered as “units” of interaction with a user interface. React provides a helper called `act()` that makes sure all updates related to these “units” have been processed and applied to the DOM before you make any assertions.

The name `act` comes from the [Arrange-Act-Assert](https://wiki.c2.com/?ArrangeActAssert) pattern.

```
it ('renders with button disabled', async () => {

await act(async () => {

root.render(<TestComponent />)

});

expect(container.querySelector('button')).toBeDisabled();

});
```

### Note

We recommend using `act` with `await` and an `async` function. Although the sync version works in many cases, it doesn’t work in all cases and due to the way React schedules updates internally, it’s difficult to predict when you can use the sync version.

We will deprecate and remove the sync version in the future.

#### Parameters

* `async actFn`: An async function wrapping renders or interactions for components being tested. Any updates triggered within the `actFn`, are added to an internal act queue, which are then flushed together to process and apply any changes to the DOM. Since it is async, React will also run any code that crosses an async boundary, and flush any updates scheduled.

#### Returns

`act` does not return anything.

## Usage

When testing a component, you can use `act` to make assertions about its output.

For example, let’s say we have this `Counter` component, the usage examples below show how to test it:

```
function Counter() {

const [count, setCount] = useState(0);

const handleClick = () => {

setCount(prev => prev + 1);

}

useEffect(() => {

document.title = `You clicked ${count} times`;

}, [count]);

return (

<div>

<p>You clicked {count} times</p>

<button onClick={handleClick}>

Click me

</button>

</div>

)

}
```

### Rendering components in tests

To test the render output of a component, wrap the render inside `act()`:

```
import {act} from 'react';

import ReactDOMClient from 'react-dom/client';

import Counter from './Counter';

it('can render and update a counter', async () => {

container = document.createElement('div');

document.body.appendChild(container);

// ✅ Render the component inside act().

await act(() => {

ReactDOMClient.createRoot(container).render(<Counter />);

});

const button = container.querySelector('button');

const label = container.querySelector('p');

expect(label.textContent).toBe('You clicked 0 times');

expect(document.title).toBe('You clicked 0 times');

});
```

Here, we create a container, append it to the document, and render the `Counter` component inside `act()`. This ensures that the component is rendered and its effects are applied before making assertions.

Using `act` ensures that all updates have been applied before we make assertions.

### Dispatching events in tests

To test events, wrap the event dispatch inside `act()`:

```
import {act} from 'react';

import ReactDOMClient from 'react-dom/client';

import Counter from './Counter';

it.only('can render and update a counter', async () => {

const container = document.createElement('div');

document.body.appendChild(container);

await act( async () => {

ReactDOMClient.createRoot(container).render(<Counter />);

});

// ✅ Dispatch the event inside act().

await act(async () => {

button.dispatchEvent(new MouseEvent('click', { bubbles: true }));

});

const button = container.querySelector('button');

const label = container.querySelector('p');

expect(label.textContent).toBe('You clicked 1 times');

expect(document.title).toBe('You clicked 1 times');

});
```

Here, we render the component with `act`, and then dispatch the event inside another `act()`. This ensures that all updates from the event are applied before making assertions.

### Pitfall

Don’t forget that dispatching DOM events only works when the DOM container is added to the document. You can use a library like [React Testing Library](https://testing-library.com/docs/react-testing-library/intro) to reduce the boilerplate code.

## Troubleshooting

### I’m getting an error: “The current testing environment is not configured to support act(…)”

Using `act` requires setting `global.IS_REACT_ACT_ENVIRONMENT=true` in your test environment. This is to ensure that `act` is only used in the correct environment.

If you don’t set the global, you will see an error like this:

Console

Warning: The current testing environment is not configured to support act(…)

To fix, add this to your global setup file for React tests:

```
global.IS_REACT_ACT_ENVIRONMENT=true
```

### Note

In testing frameworks like [React Testing Library](https://testing-library.com/docs/react-testing-library/intro), `IS_REACT_ACT_ENVIRONMENT` is already set for you.

[PreviousAPIs](https://react.dev/reference/react/apis)[NextaddTransitionType](https://react.dev/reference/react/addTransitionType)

---

---


# addTransitionType – React

URL: https://react.dev/reference/react/addTransitionType

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# addTransitionType - This feature is available in the latest Canary version of React

### Canary

**The `addTransitionType` API is currently only available in React’s Canary and Experimental channels.**

[Learn more about React’s release channels here.](https://react.dev/community/versioning-policy#all-release-channels)

`addTransitionType` lets you specify the cause of a transition.

```
startTransition(() => {

addTransitionType('my-transition-type');

setState(newState);

});
```

* [Reference](https://react.dev/reference/react/addTransitionType#reference) 
  + [`addTransitionType`](https://react.dev/reference/react/addTransitionType#addtransitiontype)
* [Usage](https://react.dev/reference/react/addTransitionType#usage) 
  + [Adding the cause of a transition](https://react.dev/reference/react/addTransitionType#adding-the-cause-of-a-transition)
  + [Customize animations using browser view transition types](https://react.dev/reference/react/addTransitionType#customize-animations-using-browser-view-transition-types)
  + [Customize animations using `View Transition` Class](https://react.dev/reference/react/addTransitionType#customize-animations-using-view-transition-class)
  + [Customize animations using `ViewTransition` events](https://react.dev/reference/react/addTransitionType#customize-animations-using-viewtransition-events)

---

## Reference

### `addTransitionType`

#### Parameters

* `type`: The type of transition to add. This can be any string.

#### Returns

`addTransitionType` does not return anything.

#### Caveats

* If multiple transitions are combined, all Transition Types are collected. You can also add more than one type to a Transition.
* Transition Types are reset after each commit. This means a `<Suspense>` fallback will associate the types after a `startTransition`, but revealing the content does not.

---

## Usage

### Adding the cause of a transition

Call `addTransitionType` inside of `startTransition` to indicate the cause of a transition:

```
import { startTransition, addTransitionType } from 'react';

function Submit({action) {

function handleClick() {

startTransition(() => {

addTransitionType('submit-click');

action();

});

}

return <button onClick={handleClick}>Click me</button>;

}
```

When you call addTransitionType inside the scope of startTransition, React will associate submit-click as one of the causes for the Transition.

Currently, Transition Types can be used to customize different animations based on what caused the Transition. You have three different ways to choose from for how to use them:

* [Customize animations using browser view transition types](https://react.dev/reference/react/addTransitionType#customize-animations-using-browser-view-transition-types)
* [Customize animations using `View Transition` Class](https://react.dev/reference/react/addTransitionType#customize-animations-using-view-transition-class)
* [Customize animations using `ViewTransition` events](https://react.dev/reference/react/addTransitionType#customize-animations-using-viewtransition-events)

In the future, we plan to support more use cases for using the cause of a transition.

---

### Customize animations using browser view transition types

When a [`ViewTransition`](https://react.dev/reference/react/ViewTransition) activates from a transition, React adds all the Transition Types as browser [view transition types](https://www.w3.org/TR/css-view-transitions-2/#active-view-transition-pseudo-examples) to the element.

This allows you to customize different animations based on CSS scopes:

```
function Component() {

return (

<ViewTransition>

<div>Hello</div>

</ViewTransition>

);

}

startTransition(() => {

addTransitionType('my-transition-type');

setShow(true);

});
```

```
:root:active-view-transition-type(my-transition-type) {

&::view-transition-...(...) {

...

}

}
```

---

### Customize animations using `View Transition` Class

You can customize animations for an activated `ViewTransition` based on type by passing an object to the View Transition Class:

```
function Component() {

return (

<ViewTransition enter={{

'my-transition-type': 'my-transition-class',

}}>

<div>Hello</div>

</ViewTransition>

);

}

// ...

startTransition(() => {

addTransitionType('my-transition-type');

setState(newState);

});
```

If multiple types match, then they’re joined together. If no types match then the special “default” entry is used instead. If any type has the value “none” then that wins and the ViewTransition is disabled (not assigned a name).

These can be combined with enter/exit/update/layout/share props to match based on kind of trigger and Transition Type.

```
<ViewTransition enter={{

'navigation-back': 'enter-right',

'navigation-forward': 'enter-left',

}}

exit={{

'navigation-back': 'exit-right',

'navigation-forward': 'exit-left',

}}>
```

---

### Customize animations using `ViewTransition` events

You can imperatively customize animations for an activated `ViewTransition` based on type using View Transition events:

```
<ViewTransition onUpdate={(inst, types) => {

if (types.includes('navigation-back')) {

...

} else if (types.includes('navigation-forward')) {

...

} else {

...

}

}}>
```

This allows you to pick different imperative Animations based on the cause.

[Previousact](https://react.dev/reference/react/act)[Nextcache](https://react.dev/reference/react/cache)

---

---


# cache – React

URL: https://react.dev/reference/react/cache

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# cache

### React Server Components

`cache` is only for use with [React Server Components](https://react.dev/reference/rsc/server-components).

`cache` lets you cache the result of a data fetch or computation.

```
const cachedFn = cache(fn);
```

* [Reference](https://react.dev/reference/react/cache#reference) 
  + [`cache(fn)`](https://react.dev/reference/react/cache#cache)
* [Usage](https://react.dev/reference/react/cache#usage) 
  + [Cache an expensive computation](https://react.dev/reference/react/cache#cache-expensive-computation)
  + [Share a snapshot of data](https://react.dev/reference/react/cache#take-and-share-snapshot-of-data)
  + [Preload data](https://react.dev/reference/react/cache#preload-data)
* [Troubleshooting](https://react.dev/reference/react/cache#troubleshooting) 
  + [My memoized function still runs even though I’ve called it with the same arguments](https://react.dev/reference/react/cache#memoized-function-still-runs)

---

## Reference

### `cache(fn)`

Call `cache` outside of any components to create a version of the function with caching.

```
import {cache} from 'react';

import calculateMetrics from 'lib/metrics';

const getMetrics = cache(calculateMetrics);

function Chart({data}) {

const report = getMetrics(data);

// ...

}
```

When `getMetrics` is first called with `data`, `getMetrics` will call `calculateMetrics(data)` and store the result in cache. If `getMetrics` is called again with the same `data`, it will return the cached result instead of calling `calculateMetrics(data)` again.

[See more examples below.](https://react.dev/reference/react/cache#usage)

#### Parameters

* `fn`: The function you want to cache results for. `fn` can take any arguments and return any value.

#### Returns

`cache` returns a cached version of `fn` with the same type signature. It does not call `fn` in the process.

When calling `cachedFn` with given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it calls `fn` with the arguments, stores the result in the cache, and returns the result. The only time `fn` is called is when there is a cache miss.

### Note

The optimization of caching return values based on inputs is known as [*memoization*](https://en.wikipedia.org/wiki/Memoization). We refer to the function returned from `cache` as a memoized function.

#### Caveats

* React will invalidate the cache for all memoized functions for each server request.
* Each call to `cache` creates a new function. This means that calling `cache` with the same function multiple times will return different memoized functions that do not share the same cache.
* `cachedFn` will also cache errors. If `fn` throws an error for certain arguments, it will be cached, and the same error is re-thrown when `cachedFn` is called with those same arguments.
* `cache` is for use in [Server Components](https://react.dev/reference/rsc/server-components) only.

---

## Usage

### Cache an expensive computation

Use `cache` to skip duplicate work.

```
import {cache} from 'react';

import calculateUserMetrics from 'lib/user';

const getUserMetrics = cache(calculateUserMetrics);

function Profile({user}) {

const metrics = getUserMetrics(user);

// ...

}

function TeamReport({users}) {

for (let user in users) {

const metrics = getUserMetrics(user);

// ...

}

// ...

}
```

If the same `user` object is rendered in both `Profile` and `TeamReport`, the two components can share work and only call `calculateUserMetrics` once for that `user`.

Assume `Profile` is rendered first. It will call `getUserMetrics`, and check if there is a cached result. Since it is the first time `getUserMetrics` is called with that `user`, there will be a cache miss. `getUserMetrics` will then call `calculateUserMetrics` with that `user` and write the result to cache.

When `TeamReport` renders its list of `users` and reaches the same `user` object, it will call `getUserMetrics` and read the result from cache.

If `calculateUserMetrics` can be aborted by passing an [`AbortSignal`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal), you can use [`cacheSignal()`](https://react.dev/reference/react/cacheSignal) to cancel the expensive computation if React has finished rendering. `calculateUserMetrics` may already handle cancellation internally by using `cacheSignal` directly.

### Pitfall

##### Calling different memoized functions will read from different caches.

To access the same cache, components must call the same memoized function.

```
// Temperature.js

import {cache} from 'react';

import {calculateWeekReport} from './report';

export function Temperature({cityData}) {

// 🚩 Wrong: Calling `cache` in component creates new `getWeekReport` for each render

const getWeekReport = cache(calculateWeekReport);

const report = getWeekReport(cityData);

// ...

}
```

```
// Precipitation.js

import {cache} from 'react';

import {calculateWeekReport} from './report';

// 🚩 Wrong: `getWeekReport` is only accessible for `Precipitation` component.

const getWeekReport = cache(calculateWeekReport);

export function Precipitation({cityData}) {

const report = getWeekReport(cityData);

// ...

}
```

In the above example, `Precipitation` and `Temperature` each call `cache` to create a new memoized function with their own cache look-up. If both components render for the same `cityData`, they will do duplicate work to call `calculateWeekReport`.

In addition, `Temperature` creates a new memoized function each time the component is rendered which doesn’t allow for any cache sharing.

To maximize cache hits and reduce work, the two components should call the same memoized function to access the same cache. Instead, define the memoized function in a dedicated module that can be [`import`-ed](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) across components.

```
// getWeekReport.js

import {cache} from 'react';

import {calculateWeekReport} from './report';

export default cache(calculateWeekReport);
```

```
// Temperature.js

import getWeekReport from './getWeekReport';

export default function Temperature({cityData}) {

const report = getWeekReport(cityData);

// ...

}
```

```
// Precipitation.js

import getWeekReport from './getWeekReport';

export default function Precipitation({cityData}) {

const report = getWeekReport(cityData);

// ...

}
```

Here, both components call the same memoized function exported from `./getWeekReport.js` to read and write to the same cache.

### Share a snapshot of data

To share a snapshot of data between components, call `cache` with a data-fetching function like `fetch`. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render.

```
import {cache} from 'react';

import {fetchTemperature} from './api.js';

const getTemperature = cache(async (city) => {

return await fetchTemperature(city);

});

async function AnimatedWeatherCard({city}) {

const temperature = await getTemperature(city);

// ...

}

async function MinimalWeatherCard({city}) {

const temperature = await getTemperature(city);

// ...

}
```

If `AnimatedWeatherCard` and `MinimalWeatherCard` both render for the same city, they will receive the same snapshot of data from the memoized function.

If `AnimatedWeatherCard` and `MinimalWeatherCard` supply different city arguments to `getTemperature`, then `fetchTemperature` will be called twice and each call site will receive different data.

The city acts as a cache key.

### Note

Asynchronous rendering is only supported for Server Components.

```
async function AnimatedWeatherCard({city}) {

const temperature = await getTemperature(city);

// ...

}
```

To render components that use asynchronous data in Client Components, see [`use()` documentation](https://react.dev/reference/react/use).

### Preload data

By caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component.

```
const getUser = cache(async (id) => {

return await db.user.query(id);

});

async function Profile({id}) {

const user = await getUser(id);

return (

<section>

<img src={user.profilePic} />

<h2>{user.name}</h2>

</section>

);

}

function Page({id}) {

// ✅ Good: start fetching the user data

getUser(id);

// ... some computational work

return (

<>

<Profile id={id} />

</>

);

}
```

When rendering `Page`, the component calls `getUser` but note that it doesn’t use the returned data. This early `getUser` call kicks off the asynchronous database query that occurs while `Page` is doing other computational work and rendering children.

When rendering `Profile`, we call `getUser` again. If the initial `getUser` call has already returned and cached the user data, when `Profile` asks and waits for this data, it can simply read from the cache without requiring another remote procedure call. If the  initial data request hasn’t been completed, preloading data in this pattern reduces delay in data-fetching.

##### Deep Dive

#### Caching asynchronous work

Show Details

When evaluating an [asynchronous function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function), you will receive a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) for that work. The promise holds the state of that work (*pending*, *fulfilled*, *failed*) and its eventual settled result.

In this example, the asynchronous function `fetchData` returns a promise that is awaiting the `fetch`.

```
async function fetchData() {

return await fetch(`https://...`);

}

const getData = cache(fetchData);

async function MyComponent() {

getData();

// ... some computational work

await getData();

// ...

}
```

In calling `getData` the first time, the promise returned from `fetchData` is cached. Subsequent look-ups will then return the same promise.

Notice that the first `getData` call does not `await` whereas the second does. [`await`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await) is a JavaScript operator that will wait and return the settled result of the promise. The first `getData` call simply initiates the `fetch` to cache the promise for the second `getData` to look-up.

If by the second call the promise is still *pending*, then `await` will pause for the result. The optimization is that while we wait on the `fetch`, React can continue with computational work, thus reducing the wait time for the second call.

If the promise is already settled, either to an error or the *fulfilled* result, `await` will return that value immediately. In both outcomes, there is a performance benefit.

### Pitfall

##### Calling a memoized function outside of a component will not use the cache.

```
import {cache} from 'react';

const getUser = cache(async (userId) => {

return await db.user.query(userId);

});

// 🚩 Wrong: Calling memoized function outside of component will not memoize.

getUser('demo-id');

async function DemoProfile() {

// ✅ Good: `getUser` will memoize.

const user = await getUser('demo-id');

return <Profile user={user} />;

}
```

React only provides cache access to the memoized function in a component. When calling `getUser` outside of a component, it will still evaluate the function but not read or update the cache.

This is because cache access is provided through a [context](https://react.dev/learn/passing-data-deeply-with-context) which is only accessible from a component.

##### Deep Dive

#### When should I use `cache`, [`memo`](https://react.dev/reference/react/memo), or [`useMemo`](https://react.dev/reference/react/useMemo)?

Show Details

All mentioned APIs offer memoization but the difference is what they’re intended to memoize, who can access the cache, and when their cache is invalidated.

#### `useMemo`

In general, you should use [`useMemo`](https://react.dev/reference/react/useMemo) for caching an expensive computation in a Client Component across renders. As an example, to memoize a transformation of data within a component.

```
'use client';

function WeatherReport({record}) {

const avgTemp = useMemo(() => calculateAvg(record), record);

// ...

}

function App() {

const record = getRecord();

return (

<>

<WeatherReport record={record} />

<WeatherReport record={record} />

</>

);

}
```

In this example, `App` renders two `WeatherReport`s with the same record. Even though both components do the same work, they cannot share work. `useMemo`’s cache is only local to the component.

However, `useMemo` does ensure that if `App` re-renders and the `record` object doesn’t change, each component instance would skip work and use the memoized value of `avgTemp`. `useMemo` will only cache the last computation of `avgTemp` with the given dependencies.

#### `cache`

In general, you should use `cache` in Server Components to memoize work that can be shared across components.

```
const cachedFetchReport = cache(fetchReport);

function WeatherReport({city}) {

const report = cachedFetchReport(city);

// ...

}

function App() {

const city = "Los Angeles";

return (

<>

<WeatherReport city={city} />

<WeatherReport city={city} />

</>

);

}
```

Re-writing the previous example to use `cache`, in this case the second instance of `WeatherReport` will be able to skip duplicate work and read from the same cache as the first `WeatherReport`. Another difference from the previous example is that `cache` is also recommended for memoizing data fetches, unlike `useMemo` which should only be used for computations.

At this time, `cache` should only be used in Server Components and the cache will be invalidated across server requests.

#### `memo`

You should use [`memo`](https://react.dev/reference/react/memo) to prevent a component re-rendering if its props are unchanged.

```
'use client';

function WeatherReport({record}) {

const avgTemp = calculateAvg(record);

// ...

}

const MemoWeatherReport = memo(WeatherReport);

function App() {

const record = getRecord();

return (

<>

<MemoWeatherReport record={record} />

<MemoWeatherReport record={record} />

</>

);

}
```

In this example, both `MemoWeatherReport` components will call `calculateAvg` when first rendered. However, if `App` re-renders, with no changes to `record`, none of the props have changed and `MemoWeatherReport` will not re-render.

Compared to `useMemo`, `memo` memoizes the component render based on props vs. specific computations. Similar to `useMemo`, the memoized component only caches the last render with the last prop values. Once the props change, the cache invalidates and the component re-renders.

---

## Troubleshooting

### My memoized function still runs even though I’ve called it with the same arguments

See prior mentioned pitfalls

* [Calling different memoized functions will read from different caches.](https://react.dev/reference/react/cache#pitfall-different-memoized-functions)
* [Calling a memoized function outside of a component will not use the cache.](https://react.dev/reference/react/cache#pitfall-memoized-call-outside-component)

If none of the above apply, it may be a problem with how React checks if something exists in cache.

If your arguments are not [primitives](https://developer.mozilla.org/en-US/docs/Glossary/Primitive) (ex. objects, functions, arrays), ensure you’re passing the same object reference.

When calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit.

```
import {cache} from 'react';

const calculateNorm = cache((vector) => {

// ...

});

function MapMarker(props) {

// 🚩 Wrong: props is an object that changes every render.

const length = calculateNorm(props);

// ...

}

function App() {

return (

<>

<MapMarker x={10} y={10} z={10} />

<MapMarker x={10} y={10} z={10} />

</>

);

}
```

In this case the two `MapMarker`s look like they’re doing the same work and calling `calculateNorm` with the same value of `{x: 10, y: 10, z:10}`. Even though the objects contain the same values, they are not the same object reference as each component creates its own `props` object.

React will call [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) on the input to verify if there is a cache hit.

```
import {cache} from 'react';

const calculateNorm = cache((x, y, z) => {

// ...

});

function MapMarker(props) {

// ✅ Good: Pass primitives to memoized function

const length = calculateNorm(props.x, props.y, props.z);

// ...

}

function App() {

return (

<>

<MapMarker x={10} y={10} z={10} />

<MapMarker x={10} y={10} z={10} />

</>

);

}
```

One way to address this could be to pass the vector dimensions to `calculateNorm`. This works because the dimensions themselves are primitives.

Another solution may be to pass the vector object itself as a prop to the component. We’ll need to pass the same object to both component instances.

```
import {cache} from 'react';

const calculateNorm = cache((vector) => {

// ...

});

function MapMarker(props) {

// ✅ Good: Pass the same `vector` object

const length = calculateNorm(props.vector);

// ...

}

function App() {

const vector = [10, 10, 10];

return (

<>

<MapMarker vector={vector} />

<MapMarker vector={vector} />

</>

);

}
```

[PreviousaddTransitionType](https://react.dev/reference/react/addTransitionType)[NextcacheSignal](https://react.dev/reference/react/cacheSignal)

---

---


# cacheSignal – React

URL: https://react.dev/reference/react/cacheSignal

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# cacheSignal

### React Server Components

`cacheSignal` is currently only used with [React Server Components](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components).

`cacheSignal` allows you to know when the `cache()` lifetime is over.

```
const signal = cacheSignal();
```

* [Reference](https://react.dev/reference/react/cacheSignal#reference) 
  + [`cacheSignal`](https://react.dev/reference/react/cacheSignal#cachesignal)
* [Usage](https://react.dev/reference/react/cacheSignal#usage) 
  + [Cancel in-flight requests](https://react.dev/reference/react/cacheSignal#cancel-in-flight-requests)
  + [Ignore errors after React has finished rendering](https://react.dev/reference/react/cacheSignal#ignore-errors-after-react-has-finished-rendering)

---

## Reference

### `cacheSignal`

Call `cacheSignal` to get an `AbortSignal`.

```
import {cacheSignal} from 'react';

async function Component() {

await fetch(url, { signal: cacheSignal() });

}
```

When React has finished rendering, the `AbortSignal` will be aborted. This allows you to cancel any in-flight work that is no longer needed.
Rendering is considered finished when:

* React has successfully completed rendering
* the render was aborted
* the render has failed

#### Parameters

This function does not accept any parameters.

#### Returns

`cacheSignal` returns an `AbortSignal` if called during rendering. Otherwise `cacheSignal()` returns `null`.

#### Caveats

* `cacheSignal` is currently for use in [React Server Components](https://react.dev/reference/rsc/server-components) only. In Client Components, it will always return `null`. In the future it will also be used for Client Component when a client cache refreshes or invalidates. You should not assume it’ll always be null on the client.
* If called outside of rendering, `cacheSignal` will return `null` to make it clear that the current scope isn’t cached forever.

---

## Usage

### Cancel in-flight requests

Call `cacheSignal` to abort in-flight requests.

```
import {cache, cacheSignal} from 'react';

const dedupedFetch = cache(fetch);

async function Component() {

await dedupedFetch(url, { signal: cacheSignal() });

}
```

### Pitfall

You can’t use `cacheSignal` to abort async work that was started outside of rendering e.g.

```
import {cacheSignal} from 'react';

// 🚩 Pitfall: The request will not actually be aborted if the rendering of `Component` is finished.

const response = fetch(url, { signal: cacheSignal() });

async function Component() {

await response;

}
```

### Ignore errors after React has finished rendering

If a function throws, it may be due to cancellation (e.g. the Database connection has been closed). You can use the `aborted` property to check if the error was due to cancellation or a real error. You may want to ignore errors that were due to cancellation.

```
import {cacheSignal} from "react";

import {queryDatabase, logError} from "./database";

async function getData(id) {

try {

return await queryDatabase(id);

} catch (x) {

if (!cacheSignal()?.aborted) {

// only log if it's a real error and not due to cancellation

logError(x);

}

return null;

}

}

async function Component({id}) {

const data = await getData(id);

if (data === null) {

return <div>No data available</div>;

}

return <div>{data.name}</div>;

}
```

[Previouscache](https://react.dev/reference/react/cache)[NextcaptureOwnerStack](https://react.dev/reference/react/captureOwnerStack)

---

---


# captureOwnerStack – React

URL: https://react.dev/reference/react/captureOwnerStack

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# captureOwnerStack

`captureOwnerStack` reads the current Owner Stack in development and returns it as a string if available.

```
const stack = captureOwnerStack();
```

* [Reference](https://react.dev/reference/react/captureOwnerStack#reference) 
  + [`captureOwnerStack()`](https://react.dev/reference/react/captureOwnerStack#captureownerstack)
* [Usage](https://react.dev/reference/react/captureOwnerStack#usage) 
  + [Enhance a custom error overlay](https://react.dev/reference/react/captureOwnerStack#enhance-a-custom-error-overlay)
* [Troubleshooting](https://react.dev/reference/react/captureOwnerStack#troubleshooting) 
  + [The Owner Stack is `null`](https://react.dev/reference/react/captureOwnerStack#the-owner-stack-is-null)
  + [`captureOwnerStack` is not available](https://react.dev/reference/react/captureOwnerStack#captureownerstack-is-not-available)

---

## Reference

### `captureOwnerStack()`

Call `captureOwnerStack` to get the current Owner Stack.

```
import * as React from 'react';

function Component() {

if (process.env.NODE_ENV !== 'production') {

const ownerStack = React.captureOwnerStack();

console.log(ownerStack);

}

}
```

#### Parameters

`captureOwnerStack` does not take any parameters.

#### Returns

`captureOwnerStack` returns `string | null`.

Owner Stacks are available in

* Component render
* Effects (e.g. `useEffect`)
* React’s event handlers (e.g. `<button onClick={...} />`)
* React error handlers ([React Root options](https://react.dev/reference/react-dom/client/createRoot#parameters) `onCaughtError`, `onRecoverableError`, and `onUncaughtError`)

If no Owner Stack is available, `null` is returned (see [Troubleshooting: The Owner Stack is `null`](https://react.dev/reference/react/captureOwnerStack#the-owner-stack-is-null)).

#### Caveats

* Owner Stacks are only available in development. `captureOwnerStack` will always return `null` outside of development.

##### Deep Dive

#### Owner Stack vs Component Stack

Show Details

The Owner Stack is different from the Component Stack available in React error handlers like [`errorInfo.componentStack` in `onUncaughtError`](https://react.dev/reference/react-dom/client/hydrateRoot#error-logging-in-production).

For example, consider the following code:

index.jsApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {captureOwnerStack} from 'react';
import {createRoot} from 'react-dom/client';
import App, {Component} from './App.js';
import './styles.css';

createRoot(document.createElement('div'), {
  onUncaughtError: (error, errorInfo) => {
    // The stacks are logged instead of showing them in the UI directly to
    // highlight that browsers will apply sourcemaps to the logged stacks.
    // Note that sourcemapping is only applied in the real browser console not
    // in the fake one displayed on this page.
    // Press "fork" to be able to view the sourcemapped stack in a real console.
    console.log(errorInfo.componentStack);
    console.log(captureOwnerStack());
  },
}).render(
  <App>
    <Component label="disabled" />
  </App>
);
```

Show more

`SubComponent` would throw an error.
The Component Stack of that error would be

```
at SubComponent

at fieldset

at Component

at main

at React.Suspense

at App
```

However, the Owner Stack would only read

```
at Component
```

Neither `App` nor the DOM components (e.g. `fieldset`) are considered Owners in this Stack since they didn’t contribute to “creating” the node containing `SubComponent`. `App` and DOM components only forwarded the node. `App` just rendered the `children` node as opposed to `Component` which created a node containing `SubComponent` via `<SubComponent />`.

Neither `Navigation` nor `legend` are in the stack at all since it’s only a sibling to a node containing `<SubComponent />`.

`SubComponent` is omitted because it’s already part of the callstack.

## Usage

### Enhance a custom error overlay

```
import { captureOwnerStack } from "react";

import { instrumentedConsoleError } from "./errorOverlay";

const originalConsoleError = console.error;

console.error = function patchedConsoleError(...args) {

originalConsoleError.apply(console, args);

const ownerStack = captureOwnerStack();

onConsoleError({

// Keep in mind that in a real application, console.error can be

// called with multiple arguments which you should account for.

consoleMessage: args[0],

ownerStack,

});

};
```

If you intercept `console.error` calls to highlight them in an error overlay, you can call `captureOwnerStack` to include the Owner Stack.

index.jserrorOverlay.jsApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { captureOwnerStack } from "react";
import { createRoot } from "react-dom/client";
import App from './App';
import { onConsoleError } from "./errorOverlay";
import './styles.css';

const originalConsoleError = console.error;
console.error = function patchedConsoleError(...args) {
  originalConsoleError.apply(console, args);
  const ownerStack = captureOwnerStack();
  onConsoleError({
    // Keep in mind that in a real application, console.error can be
    // called with multiple arguments which you should account for.
    consoleMessage: args[0],
    ownerStack,
  });
};

const container = document.getElementById("root");
createRoot(container).render(<App />);
```

Show more

## Troubleshooting

### The Owner Stack is `null`

The call of `captureOwnerStack` happened outside of a React controlled function e.g. in a `setTimeout` callback, after a `fetch` call or in a custom DOM event handler. During render, Effects, React event handlers, and React error handlers (e.g. `hydrateRoot#options.onCaughtError`) Owner Stacks should be available.

In the example below, clicking the button will log an empty Owner Stack because `captureOwnerStack` was called during a custom DOM event handler. The Owner Stack must be captured earlier e.g. by moving the call of `captureOwnerStack` into the Effect body.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {captureOwnerStack, useEffect} from 'react';

export default function App() {
  useEffect(() => {
    // Should call `captureOwnerStack` here.
    function handleEvent() {
      // Calling it in a custom DOM event handler is too late.
      // The Owner Stack will be `null` at this point.
      console.log('Owner Stack: ', captureOwnerStack());
    }

    document.addEventListener('click', handleEvent);

    return () => {
      document.removeEventListener('click', handleEvent);
    }
  })

  return <button>Click me to see that Owner Stacks are not available in custom DOM event handlers</button>;
}
```

Show more

### `captureOwnerStack` is not available

`captureOwnerStack` is only exported in development builds. It will be `undefined` in production builds. If `captureOwnerStack` is used in files that are bundled for production and development, you should conditionally access it from a namespace import.

```
// Don't use named imports of `captureOwnerStack` in files that are bundled for development and production.

import {captureOwnerStack} from 'react';

// Use a namespace import instead and access `captureOwnerStack` conditionally.

import * as React from 'react';

if (process.env.NODE_ENV !== 'production') {

const ownerStack = React.captureOwnerStack();

console.log('Owner Stack', ownerStack);

}
```

[PreviouscacheSignal](https://react.dev/reference/react/cacheSignal)[NextcreateContext](https://react.dev/reference/react/createContext)

---

---


# createContext – React

URL: https://react.dev/reference/react/createContext

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# createContext

`createContext` lets you create a [context](https://react.dev/learn/passing-data-deeply-with-context) that components can provide or read.

```
const SomeContext = createContext(defaultValue)
```

* [Reference](https://react.dev/reference/react/createContext#reference) 
  + [`createContext(defaultValue)`](https://react.dev/reference/react/createContext#createcontext)
  + [`SomeContext` Provider](https://react.dev/reference/react/createContext#provider)
  + [`SomeContext.Consumer`](https://react.dev/reference/react/createContext#consumer)
* [Usage](https://react.dev/reference/react/createContext#usage) 
  + [Creating context](https://react.dev/reference/react/createContext#creating-context)
  + [Importing and exporting context from a file](https://react.dev/reference/react/createContext#importing-and-exporting-context-from-a-file)
* [Troubleshooting](https://react.dev/reference/react/createContext#troubleshooting) 
  + [I can’t find a way to change the context value](https://react.dev/reference/react/createContext#i-cant-find-a-way-to-change-the-context-value)

---

## Reference

### `createContext(defaultValue)`

Call `createContext` outside of any components to create a context.

```
import { createContext } from 'react';

const ThemeContext = createContext('light');
```

[See more examples below.](https://react.dev/reference/react/createContext#usage)

#### Parameters

* `defaultValue`: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you don’t have any meaningful default value, specify `null`. The default value is meant as a “last resort” fallback. It is static and never changes over time.

#### Returns

`createContext` returns a context object.

**The context object itself does not hold any information.** It represents *which* context other components read or provide. Typically, you will use [`SomeContext`](https://react.dev/reference/react/createContext#provider) in components above to specify the context value, and call [`useContext(SomeContext)`](https://react.dev/reference/react/useContext) in components below to read it. The context object has a few properties:

* `SomeContext` lets you provide the context value to components.
* `SomeContext.Consumer` is an alternative and rarely used way to read the context value.
* `SomeContext.Provider` is a legacy way to provide the context value before React 19.

---

### `SomeContext` Provider

Wrap your components into a context provider to specify the value of this context for all components inside:

```
function App() {

const [theme, setTheme] = useState('light');

// ...

return (

<ThemeContext value={theme}>

<Page />

</ThemeContext>

);

}
```

### Note

Starting in React 19, you can render `<SomeContext>` as a provider.

In older versions of React, use `<SomeContext.Provider>`.

#### Props

* `value`: The value that you want to pass to all the components reading this context inside this provider, no matter how deep. The context value can be of any type. A component calling [`useContext(SomeContext)`](https://react.dev/reference/react/useContext) inside of the provider receives the `value` of the innermost corresponding context provider above it.

---

### `SomeContext.Consumer`

Before `useContext` existed, there was an older way to read context:

```
function Button() {

// 🟡 Legacy way (not recommended)

return (

<ThemeContext.Consumer>

{theme => (

<button className={theme} />

)}

</ThemeContext.Consumer>

);

}
```

Although this older way still works, **newly written code should read context with [`useContext()`](https://react.dev/reference/react/useContext) instead:**

```
function Button() {

// ✅ Recommended way

const theme = useContext(ThemeContext);

return <button className={theme} />;

}
```

#### Props

* `children`: A function. React will call the function you pass with the current context value determined by the same algorithm as [`useContext()`](https://react.dev/reference/react/useContext) does, and render the result you return from this function. React will also re-run this function and update the UI whenever the context from the parent components changes.

---

## Usage

### Creating context

Context lets components [pass information deep down](https://react.dev/learn/passing-data-deeply-with-context) without explicitly passing props.

Call `createContext` outside any components to create one or more contexts.

```
import { createContext } from 'react';

const ThemeContext = createContext('light');

const AuthContext = createContext(null);
```

`createContext` returns a context object. Components can read context by passing it to [`useContext()`](https://react.dev/reference/react/useContext):

```
function Button() {

const theme = useContext(ThemeContext);

// ...

}

function Profile() {

const currentUser = useContext(AuthContext);

// ...

}
```

By default, the values they receive will be the default values you have specified when creating the contexts. However, by itself this isn’t useful because the default values never change.

Context is useful because you can **provide other, dynamic values from your components:**

```
function App() {

const [theme, setTheme] = useState('dark');

const [currentUser, setCurrentUser] = useState({ name: 'Taylor' });

// ...

return (

<ThemeContext value={theme}>

<AuthContext value={currentUser}>

<Page />

</AuthContext>

</ThemeContext>

);

}
```

Now the `Page` component and any components inside it, no matter how deep, will “see” the passed context values. If the passed context values change, React will re-render the components reading the context as well.

[Read more about reading and providing context and see examples.](https://react.dev/reference/react/useContext)

---

### Importing and exporting context from a file

Often, components in different files will need access to the same context. This is why it’s common to declare contexts in a separate file. Then you can use the [`export` statement](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export) to make context available for other files:

```
// Contexts.js

import { createContext } from 'react';

export const ThemeContext = createContext('light');

export const AuthContext = createContext(null);
```

Components declared in other files can then use the [`import`](https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/import) statement to read or provide this context:

```
// Button.js

import { ThemeContext } from './Contexts.js';

function Button() {

const theme = useContext(ThemeContext);

// ...

}
```

```
// App.js

import { ThemeContext, AuthContext } from './Contexts.js';

function App() {

// ...

return (

<ThemeContext value={theme}>

<AuthContext value={currentUser}>

<Page />

</AuthContext>

</ThemeContext>

);

}
```

This works similar to [importing and exporting components.](https://react.dev/learn/importing-and-exporting-components)

---

## Troubleshooting

### I can’t find a way to change the context value

Code like this specifies the *default* context value:

```
const ThemeContext = createContext('light');
```

This value never changes. React only uses this value as a fallback if it can’t find a matching provider above.

To make context change over time, [add state and wrap components in a context provider.](https://react.dev/reference/react/useContext#updating-data-passed-via-context)

[PreviouscaptureOwnerStack](https://react.dev/reference/react/captureOwnerStack)[Nextlazy](https://react.dev/reference/react/lazy)

---

---


# lazy – React

URL: https://react.dev/reference/react/lazy

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# lazy

`lazy` lets you defer loading component’s code until it is rendered for the first time.

```
const SomeComponent = lazy(load)
```

* [Reference](https://react.dev/reference/react/lazy#reference) 
  + [`lazy(load)`](https://react.dev/reference/react/lazy#lazy)
  + [`load` function](https://react.dev/reference/react/lazy#load)
* [Usage](https://react.dev/reference/react/lazy#usage) 
  + [Lazy-loading components with Suspense](https://react.dev/reference/react/lazy#suspense-for-code-splitting)
* [Troubleshooting](https://react.dev/reference/react/lazy#troubleshooting) 
  + [My `lazy` component’s state gets reset unexpectedly](https://react.dev/reference/react/lazy#my-lazy-components-state-gets-reset-unexpectedly)

---

## Reference

### `lazy(load)`

Call `lazy` outside your components to declare a lazy-loaded React component:

```
import { lazy } from 'react';

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
```

[See more examples below.](https://react.dev/reference/react/lazy#usage)

#### Parameters

* `load`: A function that returns a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or another *thenable* (a Promise-like object with a `then` method). React will not call `load` until the first time you attempt to render the returned component. After React first calls `load`, it will wait for it to resolve, and then render the resolved value’s `.default` as a React component. Both the returned Promise and the Promise’s resolved value will be cached, so React will not call `load` more than once. If the Promise rejects, React will `throw` the rejection reason for the nearest Error Boundary to handle.

#### Returns

`lazy` returns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it will *suspend.* Use [`<Suspense>`](https://react.dev/reference/react/Suspense) to display a loading indicator while it’s loading.

---

### `load` function

#### Parameters

`load` receives no parameters.

#### Returns

You need to return a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or some other *thenable* (a Promise-like object with a `then` method). It needs to eventually resolve to an object whose `.default` property is a valid React component type, such as a function, [`memo`](https://react.dev/reference/react/memo), or a [`forwardRef`](https://react.dev/reference/react/forwardRef) component.

---

## Usage

### Lazy-loading components with Suspense

Usually, you import components with the static [`import`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import) declaration:

```
import MarkdownPreview from './MarkdownPreview.js';
```

To defer loading this component’s code until it’s rendered for the first time, replace this import with:

```
import { lazy } from 'react';

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
```

This code relies on [dynamic `import()`,](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) which might require support from your bundler or framework. Using this pattern requires that the lazy component you’re importing was exported as the `default` export.

Now that your component’s code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a [`<Suspense>`](https://react.dev/reference/react/Suspense) boundary:

```
<Suspense fallback={<Loading />}>

<h2>Preview</h2>

<MarkdownPreview />

</Suspense>
```

In this example, the code for `MarkdownPreview` won’t be loaded until you attempt to render it. If `MarkdownPreview` hasn’t loaded yet, `Loading` will be shown in its place. Try ticking the checkbox:

App.jsLoading.jsMarkdownPreview.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, Suspense, lazy } from 'react';
import Loading from './Loading.js';

const MarkdownPreview = lazy(() => delayForDemo(import('./MarkdownPreview.js')));

export default function MarkdownEditor() {
  const [showPreview, setShowPreview] = useState(false);
  const [markdown, setMarkdown] = useState('Hello, **world**!');
  return (
    <>
      <textarea value={markdown} onChange={e => setMarkdown(e.target.value)} />
      <label>
        <input type="checkbox" checked={showPreview} onChange={e => setShowPreview(e.target.checked)} />
        Show preview
      </label>
      <hr />
      {showPreview && (
        <Suspense fallback={<Loading />}>
          <h2>Preview</h2>
          <MarkdownPreview markdown={markdown} />
        </Suspense>
      )}
    </>
  );
}

// Add a fixed delay so you can see the loading state
function delayForDemo(promise) {
  return new Promise(resolve => {
    setTimeout(resolve, 2000);
  }).then(() => promise);
}
```

Show more

This demo loads with an artificial delay. The next time you untick and tick the checkbox, `Preview` will be cached, so there will be no loading state. To see the loading state again, click “Reset” on the sandbox.

[Learn more about managing loading states with Suspense.](https://react.dev/reference/react/Suspense)

---

## Troubleshooting

### My `lazy` component’s state gets reset unexpectedly

Do not declare `lazy` components *inside* other components:

```
import { lazy } from 'react';

function Editor() {

// 🔴 Bad: This will cause all state to be reset on re-renders

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));

// ...

}
```

Instead, always declare them at the top level of your module:

```
import { lazy } from 'react';

// ✅ Good: Declare lazy components outside of your components

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));

function Editor() {

// ...

}
```

[PreviouscreateContext](https://react.dev/reference/react/createContext)[Nextmemo](https://react.dev/reference/react/memo)

---

---


# memo – React

URL: https://react.dev/reference/react/memo

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# memo

`memo` lets you skip re-rendering a component when its props are unchanged.

```
const MemoizedComponent = memo(SomeComponent, arePropsEqual?)
```

### Note

[React Compiler](https://react.dev/learn/react-compiler) automatically applies the equivalent of `memo` to all components, reducing the need for manual memoization. You can use the compiler to handle component memoization automatically.

* [Reference](https://react.dev/reference/react/memo#reference) 
  + [`memo(Component, arePropsEqual?)`](https://react.dev/reference/react/memo#memo)
* [Usage](https://react.dev/reference/react/memo#usage) 
  + [Skipping re-rendering when props are unchanged](https://react.dev/reference/react/memo#skipping-re-rendering-when-props-are-unchanged)
  + [Updating a memoized component using state](https://react.dev/reference/react/memo#updating-a-memoized-component-using-state)
  + [Updating a memoized component using a context](https://react.dev/reference/react/memo#updating-a-memoized-component-using-a-context)
  + [Minimizing props changes](https://react.dev/reference/react/memo#minimizing-props-changes)
  + [Specifying a custom comparison function](https://react.dev/reference/react/memo#specifying-a-custom-comparison-function)
  + [Do I still need React.memo if I use React Compiler?](https://react.dev/reference/react/memo#react-compiler-memo)
* [Troubleshooting](https://react.dev/reference/react/memo#troubleshooting) 
  + [My component re-renders when a prop is an object, array, or function](https://react.dev/reference/react/memo#my-component-rerenders-when-a-prop-is-an-object-or-array)

---

## Reference

### `memo(Component, arePropsEqual?)`

Wrap a component in `memo` to get a *memoized* version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.

```
import { memo } from 'react';

const SomeComponent = memo(function SomeComponent(props) {

// ...

});
```

[See more examples below.](https://react.dev/reference/react/memo#usage)

#### Parameters

* `Component`: The component that you want to memoize. The `memo` does not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and [`forwardRef`](https://react.dev/reference/react/forwardRef) components, is accepted.
* **optional** `arePropsEqual`: A function that accepts two arguments: the component’s previous props, and its new props. It should return `true` if the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return `false`. Usually, you will not specify this function. By default, React will compare each prop with [`Object.is`.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)

#### Returns

`memo` returns a new React component. It behaves the same as the component provided to `memo` except that React will not always re-render it when its parent is being re-rendered unless its props have changed.

---

## Usage

### Skipping re-rendering when props are unchanged

React normally re-renders a component whenever its parent re-renders. With `memo`, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be *memoized*.

To memoize a component, wrap it in `memo` and use the value that it returns in place of your original component:

```
const Greeting = memo(function Greeting({ name }) {

return <h1>Hello, {name}!</h1>;

});

export default Greeting;
```

A React component should always have [pure rendering logic.](https://react.dev/learn/keeping-components-pure) This means that it must return the same output if its props, state, and context haven’t changed. By using `memo`, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props haven’t changed. Even with `memo`, your component will re-render if its own state changes or if a context that it’s using changes.

In this example, notice that the `Greeting` component re-renders whenever `name` is changed (because that’s one of its props), but not when `address` is changed (because it’s not passed to `Greeting` as a prop):

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { memo, useState } from 'react';

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}

const Greeting = memo(function Greeting({ name }) {
  console.log("Greeting was rendered at", new Date().toLocaleTimeString());
  return <h3>Hello{name && ', '}{name}!</h3>;
});
```

Show more

### Note

**You should only rely on `memo` as a performance optimization.** If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add `memo` to improve performance.

##### Deep Dive

#### Should you add memo everywhere?

Show Details

If your app is like this site, and most interactions are coarse (like replacing a page or an entire section), memoization is usually unnecessary. On the other hand, if your app is more like a drawing editor, and most interactions are granular (like moving shapes), then you might find memoization very helpful.

Optimizing with `memo` is only valuable when your component re-renders often with the same exact props, and its re-rendering logic is expensive. If there is no perceptible lag when your component re-renders, `memo` is unnecessary. Keep in mind that `memo` is completely useless if the props passed to your component are *always different,* such as if you pass an object or a plain function defined during rendering. This is why you will often need [`useMemo`](https://react.dev/reference/react/useMemo#skipping-re-rendering-of-components) and [`useCallback`](https://react.dev/reference/react/useCallback#skipping-re-rendering-of-components) together with `memo`.

There is no benefit to wrapping a component in `memo` in other cases. There is no significant harm to doing that either, so some teams choose to not think about individual cases, and memoize as much as possible. The downside of this approach is that code becomes less readable. Also, not all memoization is effective: a single value that’s “always new” is enough to break memoization for an entire component.

**In practice, you can make a lot of memoization unnecessary by following a few principles:**

1. When a component visually wraps other components, let it [accept JSX as children.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render.
2. Prefer local state and don’t [lift state up](https://react.dev/learn/sharing-state-between-components) any further than necessary. For example, don’t keep transient state like forms and whether an item is hovered at the top of your tree or in a global state library.
3. Keep your [rendering logic pure.](https://react.dev/learn/keeping-components-pure) If re-rendering a component causes a problem or produces some noticeable visual artifact, it’s a bug in your component! Fix the bug instead of adding memoization.
4. Avoid [unnecessary Effects that update state.](https://react.dev/learn/you-might-not-need-an-effect) Most performance problems in React apps are caused by chains of updates originating from Effects that cause your components to render over and over.
5. Try to [remove unnecessary dependencies from your Effects.](https://react.dev/learn/removing-effect-dependencies) For example, instead of memoization, it’s often simpler to move some object or a function inside an Effect or outside the component.

If a specific interaction still feels laggy, [use the React Developer Tools profiler](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) to see which components would benefit the most from memoization, and add memoization where needed. These principles make your components easier to debug and understand, so it’s good to follow them in any case. In the long term, we’re researching [doing granular memoization automatically](https://www.youtube.com/watch?v=lGEMwh32soc) to solve this once and for all.

---

### Updating a memoized component using state

Even when a component is memoized, it will still re-render when its own state changes. Memoization only has to do with props that are passed to the component from its parent.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { memo, useState } from 'react';

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}

const Greeting = memo(function Greeting({ name }) {
  console.log('Greeting was rendered at', new Date().toLocaleTimeString());
  const [greeting, setGreeting] = useState('Hello');
  return (
    <>
      <h3>{greeting}{name && ', '}{name}!</h3>
      <GreetingSelector value={greeting} onChange={setGreeting} />
    </>
  );
});

function GreetingSelector({ value, onChange }) {
  return (
    <>
      <label>
        <input
          type="radio"
          checked={value === 'Hello'}
          onChange={e => onChange('Hello')}
        />
        Regular greeting
      </label>
      <label>
        <input
          type="radio"
          checked={value === 'Hello and welcome'}
          onChange={e => onChange('Hello and welcome')}
        />
        Enthusiastic greeting
      </label>
    </>
  );
}
```

Show more

If you set a state variable to its current value, React will skip re-rendering your component even without `memo`. You may still see your component function being called an extra time, but the result will be discarded.

---

### Updating a memoized component using a context

Even when a component is memoized, it will still re-render when a context that it’s using changes. Memoization only has to do with props that are passed to the component from its parent.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext, memo, useContext, useState } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  const [theme, setTheme] = useState('dark');

  function handleClick() {
    setTheme(theme === 'dark' ? 'light' : 'dark');
  }

  return (
    <ThemeContext value={theme}>
      <button onClick={handleClick}>
        Switch theme
      </button>
      <Greeting name="Taylor" />
    </ThemeContext>
  );
}

const Greeting = memo(function Greeting({ name }) {
  console.log("Greeting was rendered at", new Date().toLocaleTimeString());
  const theme = useContext(ThemeContext);
  return (
    <h3 className={theme}>Hello, {name}!</h3>
  );
});
```

Show more

To make your component re-render only when a *part* of some context changes, split your component in two. Read what you need from the context in the outer component, and pass it down to a memoized child as a prop.

---

### Minimizing props changes

When you use `memo`, your component re-renders whenever any prop is not *shallowly equal* to what it was previously. This means that React compares every prop in your component with its previous value using the [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) comparison. Note that `Object.is(3, 3)` is `true`, but `Object.is({}, {})` is `false`.

To get the most out of `memo`, minimize the times that the props change. For example, if the prop is an object, prevent the parent component from re-creating that object every time by using [`useMemo`:](https://react.dev/reference/react/useMemo)

```
function Page() {

const [name, setName] = useState('Taylor');

const [age, setAge] = useState(42);

const person = useMemo(

() => ({ name, age }),

[name, age]

);

return <Profile person={person} />;

}

const Profile = memo(function Profile({ person }) {

// ...

});
```

A better way to minimize props changes is to make sure the component accepts the minimum necessary information in its props. For example, it could accept individual values instead of a whole object:

```
function Page() {

const [name, setName] = useState('Taylor');

const [age, setAge] = useState(42);

return <Profile name={name} age={age} />;

}

const Profile = memo(function Profile({ name, age }) {

// ...

});
```

Even individual values can sometimes be projected to ones that change less frequently. For example, here a component accepts a boolean indicating the presence of a value rather than the value itself:

```
function GroupsLanding({ person }) {

const hasGroups = person.groups !== null;

return <CallToAction hasGroups={hasGroups} />;

}

const CallToAction = memo(function CallToAction({ hasGroups }) {

// ...

});
```

When you need to pass a function to memoized component, either declare it outside your component so that it never changes, or [`useCallback`](https://react.dev/reference/react/useCallback#skipping-re-rendering-of-components) to cache its definition between re-renders.

---

### Specifying a custom comparison function

In rare cases it may be infeasible to minimize the props changes of a memoized component. In that case, you can provide a custom comparison function, which React will use to compare the old and new props instead of using shallow equality. This function is passed as a second argument to `memo`. It should return `true` only if the new props would result in the same output as the old props; otherwise it should return `false`.

```
const Chart = memo(function Chart({ dataPoints }) {

// ...

}, arePropsEqual);

function arePropsEqual(oldProps, newProps) {

return (

oldProps.dataPoints.length === newProps.dataPoints.length &&

oldProps.dataPoints.every((oldPoint, index) => {

const newPoint = newProps.dataPoints[index];

return oldPoint.x === newPoint.x && oldPoint.y === newPoint.y;

})

);

}
```

If you do this, use the Performance panel in your browser developer tools to make sure that your comparison function is actually faster than re-rendering the component. You might be surprised.

When you do performance measurements, make sure that React is running in the production mode.

### Pitfall

If you provide a custom `arePropsEqual` implementation, **you must compare every prop, including functions.** Functions often [close over](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures) the props and state of parent components. If you return `true` when `oldProps.onClick !== newProps.onClick`, your component will keep “seeing” the props and state from a previous render inside its `onClick` handler, leading to very confusing bugs.

Avoid doing deep equality checks inside `arePropsEqual` unless you are 100% sure that the data structure you’re working with has a known limited depth. **Deep equality checks can become incredibly slow** and can freeze your app for many seconds if someone changes the data structure later.

---

### Do I still need React.memo if I use React Compiler?

When you enable [React Compiler](https://react.dev/learn/react-compiler), you typically don’t need `React.memo` anymore. The compiler automatically optimizes component re-rendering for you.

Here’s how it works:

**Without React Compiler**, you need `React.memo` to prevent unnecessary re-renders:

```
// Parent re-renders every second

function Parent() {

const [seconds, setSeconds] = useState(0);

useEffect(() => {

const interval = setInterval(() => {

setSeconds(s => s + 1);

}, 1000);

return () => clearInterval(interval);

}, []);

return (

<>

<h1>Seconds: {seconds}</h1>

<ExpensiveChild name="John" />

</>

);

}

// Without memo, this re-renders every second even though props don't change

const ExpensiveChild = memo(function ExpensiveChild({ name }) {

console.log('ExpensiveChild rendered');

return <div>Hello, {name}!</div>;

});
```

**With React Compiler enabled**, the same optimization happens automatically:

```
// No memo needed - compiler prevents re-renders automatically

function ExpensiveChild({ name }) {

console.log('ExpensiveChild rendered');

return <div>Hello, {name}!</div>;

}
```

Here’s the key part of what the React Compiler generates:

```
function Parent() {

const $ = _c(7);

const [seconds, setSeconds] = useState(0);

// ... other code ...

let t3;

if ($[4] === Symbol.for("react.memo_cache_sentinel")) {

t3 = <ExpensiveChild name="John" />;

$[4] = t3;

} else {

t3 = $[4];

}

// ... return statement ...

}
```

Notice the highlighted lines: The compiler wraps `<ExpensiveChild name="John" />` in a cache check. Since the `name` prop is always `"John"`, this JSX is created once and reused on every parent re-render. This is exactly what `React.memo` does - it prevents the child from re-rendering when its props haven’t changed.

The React Compiler automatically:

1. Tracks that the `name` prop passed to `ExpensiveChild` hasn’t changed
2. Reuses the previously created JSX for `<ExpensiveChild name="John" />`
3. Skips re-rendering `ExpensiveChild` entirely

This means **you can safely remove `React.memo` from your components when using React Compiler**. The compiler provides the same optimization automatically, making your code cleaner and easier to maintain.

### Note

The compiler’s optimization is actually more comprehensive than `React.memo`. It also memoizes intermediate values and expensive computations within your components, similar to combining `React.memo` with `useMemo` throughout your component tree.

---

## Troubleshooting

### My component re-renders when a prop is an object, array, or function

React compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, [simplify props or memoize props in the parent component](https://react.dev/reference/react/memo#minimizing-props-changes).

[Previouslazy](https://react.dev/reference/react/lazy)[NextstartTransition](https://react.dev/reference/react/startTransition)

---

---


# startTransition – React

URL: https://react.dev/reference/react/startTransition

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# startTransition

`startTransition` lets you render a part of the UI in the background.

```
startTransition(action)
```

* [Reference](https://react.dev/reference/react/startTransition#reference) 
  + [`startTransition(action)`](https://react.dev/reference/react/startTransition#starttransition)
* [Usage](https://react.dev/reference/react/startTransition#usage) 
  + [Marking a state update as a non-blocking Transition](https://react.dev/reference/react/startTransition#marking-a-state-update-as-a-non-blocking-transition)

---

## Reference

### `startTransition(action)`

The `startTransition` function lets you mark a state update as a Transition.

```
import { startTransition } from 'react';

function TabContainer() {

const [tab, setTab] = useState('about');

function selectTab(nextTab) {

startTransition(() => {

setTab(nextTab);

});

}

// ...

}
```

[See more examples below.](https://react.dev/reference/react/startTransition#usage)

#### Parameters

* `action`: A function that updates some state by calling one or more [`set` functions](https://react.dev/reference/react/useState#setstate). React calls `action` immediately with no parameters and marks all state updates scheduled synchronously during the `action` function call as Transitions. Any async calls awaited in the `action` will be included in the transition, but currently require wrapping any `set` functions after the `await` in an additional `startTransition` (see [Troubleshooting](https://react.dev/reference/react/useTransition#react-doesnt-treat-my-state-update-after-await-as-a-transition)). State updates marked as Transitions will be [non-blocking](https://react.dev/reference/react/startTransition#marking-a-state-update-as-a-non-blocking-transition) and [will not display unwanted loading indicators.](https://react.dev/reference/react/useTransition#preventing-unwanted-loading-indicators).

#### Returns

`startTransition` does not return anything.

#### Caveats

* `startTransition` does not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you need [`useTransition`](https://react.dev/reference/react/useTransition) instead.
* You can wrap an update into a Transition only if you have access to the `set` function of that state. If you want to start a Transition in response to some prop or a custom Hook return value, try [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue) instead.
* The function you pass to `startTransition` is called immediately, marking all state updates that happen while it executes as Transitions. If you try to perform state updates in a `setTimeout`, for example, they won’t be marked as Transitions.
* You must wrap any state updates after any async requests in another `startTransition` to mark them as Transitions. This is a known limitation that we will fix in the future (see [Troubleshooting](https://react.dev/reference/react/useTransition#react-doesnt-treat-my-state-update-after-await-as-a-transition)).
* A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update.
* Transition updates can’t be used to control text inputs.
* If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that may be removed in a future release.

---

## Usage

### Marking a state update as a non-blocking Transition

You can mark a state update as a *Transition* by wrapping it in a `startTransition` call:

```
import { startTransition } from 'react';

function TabContainer() {

const [tab, setTab] = useState('about');

function selectTab(nextTab) {

startTransition(() => {

setTab(nextTab);

});

}

// ...

}
```

Transitions let you keep the user interface updates responsive even on slow devices.

With a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish.

### Note

`startTransition` is very similar to [`useTransition`](https://react.dev/reference/react/useTransition), except that it does not provide the `isPending` flag to track whether a Transition is ongoing. You can call `startTransition` when `useTransition` is not available. For example, `startTransition` works outside components, such as from a data library.

[Learn about Transitions and see examples on the `useTransition` page.](https://react.dev/reference/react/useTransition)

[Previousmemo](https://react.dev/reference/react/memo)[Nextuse](https://react.dev/reference/react/use)

---

---


# use – React

URL: https://react.dev/reference/react/use

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# use

`use` is a React API that lets you read the value of a resource like a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or [context](https://react.dev/learn/passing-data-deeply-with-context).

```
const value = use(resource);
```

* [Reference](https://react.dev/reference/react/use#reference) 
  + [`use(resource)`](https://react.dev/reference/react/use#use)
* [Usage](https://react.dev/reference/react/use#usage) 
  + [Reading context with `use`](https://react.dev/reference/react/use#reading-context-with-use)
  + [Streaming data from the server to the client](https://react.dev/reference/react/use#streaming-data-from-server-to-client)
  + [Dealing with rejected Promises](https://react.dev/reference/react/use#dealing-with-rejected-promises)
* [Troubleshooting](https://react.dev/reference/react/use#troubleshooting) 
  + [“Suspense Exception: This is not a real error!”](https://react.dev/reference/react/use#suspense-exception-error)

---

## Reference

### `use(resource)`

Call `use` in your component to read the value of a resource like a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or [context](https://react.dev/learn/passing-data-deeply-with-context).

```
import { use } from 'react';

function MessageComponent({ messagePromise }) {

const message = use(messagePromise);

const theme = use(ThemeContext);

// ...
```

Unlike React Hooks, `use` can be called within loops and conditional statements like `if`. Like React Hooks, the function that calls `use` must be a Component or Hook.

When called with a Promise, the `use` API integrates with [`Suspense`](https://react.dev/reference/react/Suspense) and [Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary). The component calling `use` *suspends* while the Promise passed to `use` is pending. If the component that calls `use` is wrapped in a Suspense boundary, the fallback will be displayed. Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by the `use` API. If the Promise passed to `use` is rejected, the fallback of the nearest Error Boundary will be displayed.

[See more examples below.](https://react.dev/reference/react/use#usage)

#### Parameters

* `resource`: this is the source of the data you want to read a value from. A resource can be a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or a [context](https://react.dev/learn/passing-data-deeply-with-context).

#### Returns

The `use` API returns the value that was read from the resource like the resolved value of a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or [context](https://react.dev/learn/passing-data-deeply-with-context).

#### Caveats

* The `use` API must be called inside a Component or a Hook.
* When fetching data in a [Server Component](https://react.dev/reference/rsc/server-components), prefer `async` and `await` over `use`. `async` and `await` pick up rendering from the point where `await` was invoked, whereas `use` re-renders the component after the data is resolved.
* Prefer creating Promises in [Server Components](https://react.dev/reference/rsc/server-components) and passing them to [Client Components](https://react.dev/reference/rsc/use-client) over creating Promises in Client Components. Promises created in Client Components are recreated on every render. Promises passed from a Server Component to a Client Component are stable across re-renders. [See this example](https://react.dev/reference/react/use#streaming-data-from-server-to-client).

---

## Usage

### Reading context with `use`

When a [context](https://react.dev/learn/passing-data-deeply-with-context) is passed to `use`, it works similarly to [`useContext`](https://react.dev/reference/react/useContext). While `useContext` must be called at the top level of your component, `use` can be called inside conditionals like `if` and loops like `for`. `use` is preferred over `useContext` because it is more flexible.

```
import { use } from 'react';

function Button() {

const theme = use(ThemeContext);

// ...
```

`use` returns the context value for the context you passed. To determine the context value, React searches the component tree and finds **the closest context provider above** for that particular context.

To pass context to a `Button`, wrap it or one of its parent components into the corresponding context provider.

```
function MyPage() {

return (

<ThemeContext value="dark">

<Form />

</ThemeContext>

);

}

function Form() {

// ... renders buttons inside ...

}
```

It doesn’t matter how many layers of components there are between the provider and the `Button`. When a `Button` *anywhere* inside of `Form` calls `use(ThemeContext)`, it will receive `"dark"` as the value.

Unlike [`useContext`](https://react.dev/reference/react/useContext), `use` can be called in conditionals and loops like `if`.

```
function HorizontalRule({ show }) {

if (show) {

const theme = use(ThemeContext);

return <hr className={theme} />;

}

return false;

}
```

`use` is called from inside a `if` statement, allowing you to conditionally read values from a Context.

### Pitfall

Like `useContext`, `use(context)` always looks for the closest context provider *above* the component that calls it. It searches upwards and **does not** consider context providers in the component from which you’re calling `use(context)`.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext, use } from 'react';

const ThemeContext = createContext(null);

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button show={true}>Sign up</Button>
      <Button show={false}>Log in</Button>
    </Panel>
  );
}

function Panel({ title, children }) {
  const theme = use(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ show, children }) {
  if (show) {
    const theme = use(ThemeContext);
    const className = 'button-' + theme;
    return (
      <button className={className}>
        {children}
      </button>
    );
  }
  return false
}
```

Show more

### Streaming data from the server to the client

Data can be streamed from the server to the client by passing a Promise as a prop from a Server Component to a Client Component.

```
import { fetchMessage } from './lib.js';

import { Message } from './message.js';

export default function App() {

const messagePromise = fetchMessage();

return (

<Suspense fallback={<p>waiting for message...</p>}>

<Message messagePromise={messagePromise} />

</Suspense>

);

}
```

The Client Component then takes the Promise it received as a prop and passes it to the `use` API. This allows the Client Component to read the value from the Promise that was initially created by the Server Component.

```
// message.js

'use client';

import { use } from 'react';

export function Message({ messagePromise }) {

const messageContent = use(messagePromise);

return <p>Here is the message: {messageContent}</p>;

}
```

Because `Message` is wrapped in [`Suspense`](https://react.dev/reference/react/Suspense), the fallback will be displayed until the Promise is resolved. When the Promise is resolved, the value will be read by the `use` API and the `Message` component will replace the Suspense fallback.

message.js

message.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
"use client";

import { use, Suspense } from "react";

function Message({ messagePromise }) {
  const messageContent = use(messagePromise);
  return <p>Here is the message: {messageContent}</p>;
}

export function MessageContainer({ messagePromise }) {
  return (
    <Suspense fallback={<p>⌛Downloading message...</p>}>
      <Message messagePromise={messagePromise} />
    </Suspense>
  );
}
```

Show more

### Note

When passing a Promise from a Server Component to a Client Component, its resolved value must be serializable to pass between server and client. Data types like functions aren’t serializable and cannot be the resolved value of such a Promise.

##### Deep Dive

#### Should I resolve a Promise in a Server or Client Component?

Show Details

A Promise can be passed from a Server Component to a Client Component and resolved in the Client Component with the `use` API. You can also resolve the Promise in a Server Component with `await` and pass the required data to the Client Component as a prop.

```
export default async function App() {

const messageContent = await fetchMessage();

return <Message messageContent={messageContent} />

}
```

But using `await` in a [Server Component](https://react.dev/reference/rsc/server-components) will block its rendering until the `await` statement is finished. Passing a Promise from a Server Component to a Client Component prevents the Promise from blocking the rendering of the Server Component.

### Dealing with rejected Promises

In some cases a Promise passed to `use` could be rejected. You can handle rejected Promises by either:

1. [Displaying an error to users with an Error Boundary.](https://react.dev/reference/react/use#displaying-an-error-to-users-with-error-boundary)
2. [Providing an alternative value with `Promise.catch`](https://react.dev/reference/react/use#providing-an-alternative-value-with-promise-catch)

### Pitfall

`use` cannot be called in a try-catch block. Instead of a try-catch block [wrap your component in an Error Boundary](https://react.dev/reference/react/use#displaying-an-error-to-users-with-error-boundary), or [provide an alternative value to use with the Promise’s `.catch` method](https://react.dev/reference/react/use#providing-an-alternative-value-with-promise-catch).

#### Displaying an error to users with an Error Boundary

If you’d like to display an error to your users when a Promise is rejected, you can use an [Error Boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary). To use an Error Boundary, wrap the component where you are calling the `use` API in an Error Boundary. If the Promise passed to `use` is rejected the fallback for the Error Boundary will be displayed.

message.js

message.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
"use client";

import { use, Suspense } from "react";
import { ErrorBoundary } from "react-error-boundary";

export function MessageContainer({ messagePromise }) {
  return (
    <ErrorBoundary fallback={<p>⚠️Something went wrong</p>}>
      <Suspense fallback={<p>⌛Downloading message...</p>}>
        <Message messagePromise={messagePromise} />
      </Suspense>
    </ErrorBoundary>
  );
}

function Message({ messagePromise }) {
  const content = use(messagePromise);
  return <p>Here is the message: {content}</p>;
}
```

Show more

#### Providing an alternative value with `Promise.catch`

If you’d like to provide an alternative value when the Promise passed to `use` is rejected you can use the Promise’s [`catch`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch) method.

```
import { Message } from './message.js';

export default function App() {

const messagePromise = new Promise((resolve, reject) => {

reject();

}).catch(() => {

return "no new message found.";

});

return (

<Suspense fallback={<p>waiting for message...</p>}>

<Message messagePromise={messagePromise} />

</Suspense>

);

}
```

To use the Promise’s `catch` method, call `catch` on the Promise object. `catch` takes a single argument: a function that takes an error message as an argument. Whatever is returned by the function passed to `catch` will be used as the resolved value of the Promise.

---

## Troubleshooting

### “Suspense Exception: This is not a real error!”

You are either calling `use` outside of a React Component or Hook function, or calling `use` in a try–catch block. If you are calling `use` inside a try–catch block, wrap your component in an Error Boundary, or call the Promise’s `catch` to catch the error and resolve the Promise with another value. [See these examples](https://react.dev/reference/react/use#dealing-with-rejected-promises).

If you are calling `use` outside a React Component or Hook function, move the `use` call to a React Component or Hook function.

```
function MessageComponent({messagePromise}) {

function download() {

// ❌ the function calling `use` is not a Component or Hook

const message = use(messagePromise);

// ...
```

Instead, call `use` outside any component closures, where the function that calls `use` is a Component or Hook.

```
function MessageComponent({messagePromise}) {

// ✅ `use` is being called from a component.

const message = use(messagePromise);

// ...
```

[PreviousstartTransition](https://react.dev/reference/react/startTransition)[Nextexperimental\_taintObjectReference](https://react.dev/reference/react/experimental_taintObjectReference)

---

---


# experimental_taintObjectReference – React

URL: https://react.dev/reference/react/experimental_taintObjectReference

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# experimental\_taintObjectReference - This feature is available in the latest Experimental version of React

### Experimental Feature

**This API is experimental and is not available in a stable version of React yet.**

You can try it by upgrading React packages to the most recent experimental version:

* `react@experimental`
* `react-dom@experimental`
* `eslint-plugin-react-hooks@experimental`

Experimental versions of React may contain bugs. Don’t use them in production.

This API is only available inside React Server Components.

`taintObjectReference` lets you prevent a specific object instance from being passed to a Client Component like a `user` object.

```
experimental_taintObjectReference(message, object);
```

To prevent passing a key, hash or token, see [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue).

* [Reference](https://react.dev/reference/react/experimental_taintObjectReference#reference) 
  + [`taintObjectReference(message, object)`](https://react.dev/reference/react/experimental_taintObjectReference#taintobjectreference)
* [Usage](https://react.dev/reference/react/experimental_taintObjectReference#usage) 
  + [Prevent user data from unintentionally reaching the client](https://react.dev/reference/react/experimental_taintObjectReference#prevent-user-data-from-unintentionally-reaching-the-client)

---

## Reference

### `taintObjectReference(message, object)`

Call `taintObjectReference` with an object to register it with React as something that should not be allowed to be passed to the Client as is:

```
import {experimental_taintObjectReference} from 'react';

experimental_taintObjectReference(

'Do not pass ALL environment variables to the client.',

process.env

);
```

[See more examples below.](https://react.dev/reference/react/experimental_taintObjectReference#usage)

#### Parameters

* `message`: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component.
* `object`: The object to be tainted. Functions and class instances can be passed to `taintObjectReference` as `object`. Functions and classes are already blocked from being passed to Client Components but the React’s default error message will be replaced by what you defined in `message`. When a specific instance of a Typed Array is passed to `taintObjectReference` as `object`, any other copies of the Typed Array will not be tainted.

#### Returns

`experimental_taintObjectReference` returns `undefined`.

#### Caveats

* Recreating or cloning a tainted object creates a new untainted object which may contain sensitive data. For example, if you have a tainted `user` object, `const userInfo = {name: user.name, ssn: user.ssn}` or `{...user}` will create new objects which are not tainted. `taintObjectReference` only protects against simple mistakes when the object is passed through to a Client Component unchanged.

### Pitfall

**Do not rely on just tainting for security.** Tainting an object doesn’t prevent leaking of every possible derived value. For example, the clone of a tainted object will create a new untainted object. Using data from a tainted object (e.g. `{secret: taintedObj.secret}`) will create a new value or object that is not tainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.

---

## Usage

### Prevent user data from unintentionally reaching the client

A Client Component should never accept objects that carry sensitive data. Ideally, the data fetching functions should not expose data that the current user should not have access to. Sometimes mistakes happen during refactoring. To protect against these mistakes happening down the line we can “taint” the user object in our data API.

```
import {experimental_taintObjectReference} from 'react';

export async function getUser(id) {

const user = await db`SELECT * FROM users WHERE id = ${id}`;

experimental_taintObjectReference(

'Do not pass the entire user object to the client. ' +

'Instead, pick off the specific properties you need for this use case.',

user,

);

return user;

}
```

Now whenever anyone tries to pass this object to a Client Component, an error will be thrown with the passed in error message instead.

##### Deep Dive

#### Protecting against leaks in data fetching

Show Details

If you’re running a Server Components environment that has access to sensitive data, you have to be careful not to pass objects straight through:

```
// api.js

export async function getUser(id) {

const user = await db`SELECT * FROM users WHERE id = ${id}`;

return user;

}
```

```
import { getUser } from 'api.js';

import { InfoCard } from 'components.js';

export async function Profile(props) {

const user = await getUser(props.userId);

// DO NOT DO THIS

return <InfoCard user={user} />;

}
```

```
// components.js

"use client";

export async function InfoCard({ user }) {

return <div>{user.name}</div>;

}
```

Ideally, the `getUser` should not expose data that the current user should not have access to. To prevent passing the `user` object to a Client Component down the line we can “taint” the user object:

```
// api.js

import {experimental_taintObjectReference} from 'react';

export async function getUser(id) {

const user = await db`SELECT * FROM users WHERE id = ${id}`;

experimental_taintObjectReference(

'Do not pass the entire user object to the client. ' +

'Instead, pick off the specific properties you need for this use case.',

user,

);

return user;

}
```

Now if anyone tries to pass the `user` object to a Client Component, an error will be thrown with the passed in error message.

[Previoususe](https://react.dev/reference/react/use)[Nextexperimental\_taintUniqueValue](https://react.dev/reference/react/experimental_taintUniqueValue)

---

---


# experimental_taintUniqueValue – React

URL: https://react.dev/reference/react/experimental_taintUniqueValue

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react/apis)

# experimental\_taintUniqueValue - This feature is available in the latest Experimental version of React

### Experimental Feature

**This API is experimental and is not available in a stable version of React yet.**

You can try it by upgrading React packages to the most recent experimental version:

* `react@experimental`
* `react-dom@experimental`
* `eslint-plugin-react-hooks@experimental`

Experimental versions of React may contain bugs. Don’t use them in production.

This API is only available inside [React Server Components](https://react.dev/reference/rsc/use-client).

`taintUniqueValue` lets you prevent unique values from being passed to Client Components like passwords, keys, or tokens.

```
taintUniqueValue(errMessage, lifetime, value)
```

To prevent passing an object containing sensitive data, see [`taintObjectReference`](https://react.dev/reference/react/experimental_taintObjectReference).

* [Reference](https://react.dev/reference/react/experimental_taintUniqueValue#reference) 
  + [`taintUniqueValue(message, lifetime, value)`](https://react.dev/reference/react/experimental_taintUniqueValue#taintuniquevalue)
* [Usage](https://react.dev/reference/react/experimental_taintUniqueValue#usage) 
  + [Prevent a token from being passed to Client Components](https://react.dev/reference/react/experimental_taintUniqueValue#prevent-a-token-from-being-passed-to-client-components)

---

## Reference

### `taintUniqueValue(message, lifetime, value)`

Call `taintUniqueValue` with a password, token, key or hash to register it with React as something that should not be allowed to be passed to the Client as is:

```
import {experimental_taintUniqueValue} from 'react';

experimental_taintUniqueValue(

'Do not pass secret keys to the client.',

process,

process.env.SECRET_KEY

);
```

[See more examples below.](https://react.dev/reference/react/experimental_taintUniqueValue#usage)

#### Parameters

* `message`: The message you want to display if `value` is passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if `value` is passed to a Client Component.
* `lifetime`: Any object that indicates how long `value` should be tainted. `value` will be blocked from being sent to any Client Component while this object still exists. For example, passing `globalThis` blocks the value for the lifetime of an app. `lifetime` is typically an object whose properties contains `value`.
* `value`: A string, bigint or TypedArray. `value` must be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password. `value` will be blocked from being sent to any Client Component.

#### Returns

`experimental_taintUniqueValue` returns `undefined`.

#### Caveats

* Deriving new values from tainted values can compromise tainting protection. New values created by uppercasing tainted values, concatenating tainted string values into a larger string, converting tainted values to base64, substringing tainted values, and other similar transformations are not tainted unless you explicitly call `taintUniqueValue` on these newly created values.
* Do not use `taintUniqueValue` to protect low-entropy values such as PIN codes or phone numbers. If any value in a request is controlled by an attacker, they could infer which value is tainted by enumerating all possible values of the secret.

---

## Usage

### Prevent a token from being passed to Client Components

To ensure that sensitive information such as passwords, session tokens, or other unique values do not inadvertently get passed to Client Components, the `taintUniqueValue` function provides a layer of protection. When a value is tainted, any attempt to pass it to a Client Component will result in an error.

The `lifetime` argument defines the duration for which the value remains tainted. For values that should remain tainted indefinitely, objects like [`globalThis`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis) or `process` can serve as the `lifetime` argument. These objects have a lifespan that spans the entire duration of your app’s execution.

```
import {experimental_taintUniqueValue} from 'react';

experimental_taintUniqueValue(

'Do not pass a user password to the client.',

globalThis,

process.env.SECRET_KEY

);
```

If the tainted value’s lifespan is tied to a object, the `lifetime` should be the object that encapsulates the value. This ensures the tainted value remains protected for the lifetime of the encapsulating object.

```
import {experimental_taintUniqueValue} from 'react';

export async function getUser(id) {

const user = await db`SELECT * FROM users WHERE id = ${id}`;

experimental_taintUniqueValue(

'Do not pass a user session token to the client.',

user,

user.session.token

);

return user;

}
```

In this example, the `user` object serves as the `lifetime` argument. If this object gets stored in a global cache or is accessible by another request, the session token remains tainted.

### Pitfall

**Do not rely solely on tainting for security.** Tainting a value doesn’t block every possible derived value. For example, creating a new value by upper casing a tainted string will not taint the new value.

```
import {experimental_taintUniqueValue} from 'react';

const password = 'correct horse battery staple';

experimental_taintUniqueValue(

'Do not pass the password to the client.',

globalThis,

password

);

const uppercasePassword = password.toUpperCase() // `uppercasePassword` is not tainted
```

In this example, the constant `password` is tainted. Then `password` is used to create a new value `uppercasePassword` by calling the `toUpperCase` method on `password`. The newly created `uppercasePassword` is not tainted.

Other similar ways of deriving new values from tainted values like concatenating it into a larger string, converting it to base64, or returning a substring create untained values.

Tainting only protects against simple mistakes like explicitly passing secret values to the client. Mistakes in calling the `taintUniqueValue` like using a global store outside of React, without the corresponding lifetime object, can cause the tainted value to become untainted. Tainting is a layer of protection; a secure app will have multiple layers of protection, well designed APIs, and isolation patterns.

##### Deep Dive

#### Using `server-only` and `taintUniqueValue` to prevent leaking secrets

Show Details

If you’re running a Server Components environment that has access to private keys or passwords such as database passwords, you have to be careful not to pass that to a Client Component.

```
export async function Dashboard(props) {

// DO NOT DO THIS

return <Overview password={process.env.API_PASSWORD} />;

}
```

```
"use client";

import {useEffect} from '...'

export async function Overview({ password }) {

useEffect(() => {

const headers = { Authorization: password };

fetch(url, { headers }).then(...);

}, [password]);

...

}
```

This example would leak the secret API token to the client. If this API token can be used to access data this particular user shouldn’t have access to, it could lead to a data breach.

Ideally, secrets like this are abstracted into a single helper file that can only be imported by trusted data utilities on the server. The helper can even be tagged with [`server-only`](https://www.npmjs.com/package/server-only) to ensure that this file isn’t imported on the client.

```
import "server-only";

export function fetchAPI(url) {

const headers = { Authorization: process.env.API_PASSWORD };

return fetch(url, { headers });

}
```

Sometimes mistakes happen during refactoring and not all of your colleagues might know about this.
To protect against this mistakes happening down the line we can “taint” the actual password:

```
import "server-only";

import {experimental_taintUniqueValue} from 'react';

experimental_taintUniqueValue(

'Do not pass the API token password to the client. ' +

'Instead do all fetches on the server.'

process,

process.env.API_PASSWORD

);
```

Now whenever anyone tries to pass this password to a Client Component, or send the password to a Client Component with a Server Function, an error will be thrown with message you defined when you called `taintUniqueValue`.

---

[Previousexperimental\_taintObjectReference](https://react.dev/reference/react/experimental_taintObjectReference)

---

---


# Built-in React DOM Hooks – React

URL: https://react.dev/reference/react-dom/hooks

[API Reference](https://react.dev/reference/react)

# Built-in React DOM Hooks

The `react-dom` package contains Hooks that are only supported for web applications (which run in the browser DOM environment). These Hooks are not supported in non-browser environments like iOS, Android, or Windows applications. If you are looking for Hooks that are supported in web browsers *and other environments* see [the React Hooks page](https://react.dev/reference/react/hooks). This page lists all the Hooks in the `react-dom` package.

---

## Form Hooks

*Forms* let you create interactive controls for submitting information. To manage forms in your components, use one of these Hooks:

* [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus) allows you to make updates to the UI based on the status of a form.

```
function Form({ action }) {

async function increment(n) {

return n + 1;

}

const [count, incrementFormAction] = useActionState(increment, 0);

return (

<form action={action}>

<button formAction={incrementFormAction}>Count: {count}</button>

<Button />

</form>

);

}

function Button() {

const { pending } = useFormStatus();

return (

<button disabled={pending} type="submit">

Submit

</button>

);

}
```

[NextuseFormStatus](https://react.dev/reference/react-dom/hooks/useFormStatus)

---

---


# useFormStatus – React

URL: https://react.dev/reference/react-dom/hooks/useFormStatus

[API Reference](https://react.dev/reference/react)

[Hooks](https://react.dev/reference/react-dom/hooks)

# useFormStatus

`useFormStatus` is a Hook that gives you status information of the last form submission.

```
const { pending, data, method, action } = useFormStatus();
```

* [Reference](https://react.dev/reference/react-dom/hooks/useFormStatus#reference) 
  + [`useFormStatus()`](https://react.dev/reference/react-dom/hooks/useFormStatus#use-form-status)
* [Usage](https://react.dev/reference/react-dom/hooks/useFormStatus#usage) 
  + [Display a pending state during form submission](https://react.dev/reference/react-dom/hooks/useFormStatus#display-a-pending-state-during-form-submission)
  + [Read the form data being submitted](https://react.dev/reference/react-dom/hooks/useFormStatus#read-form-data-being-submitted)
* [Troubleshooting](https://react.dev/reference/react-dom/hooks/useFormStatus#troubleshooting) 
  + [`status.pending` is never `true`](https://react.dev/reference/react-dom/hooks/useFormStatus#pending-is-never-true)

---

## Reference

### `useFormStatus()`

The `useFormStatus` Hook provides status information of the last form submission.

```
import { useFormStatus } from "react-dom";

import action from './actions';

function Submit() {

const status = useFormStatus();

return <button disabled={status.pending}>Submit</button>

}

export default function App() {

return (

<form action={action}>

<Submit />

</form>

);

}
```

To get status information, the `Submit` component must be rendered within a `<form>`. The Hook returns information like the `pending` property which tells you if the form is actively submitting.

In the above example, `Submit` uses this information to disable `<button>` presses while the form is submitting.

[See more examples below.](https://react.dev/reference/react-dom/hooks/useFormStatus#usage)

#### Parameters

`useFormStatus` does not take any parameters.

#### Returns

A `status` object with the following properties:

* `pending`: A boolean. If `true`, this means the parent `<form>` is pending submission. Otherwise, `false`.
* `data`: An object implementing the [`FormData interface`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) that contains the data the parent `<form>` is submitting. If there is no active submission or no parent `<form>`, it will be `null`.
* `method`: A string value of either `'get'` or `'post'`. This represents whether the parent `<form>` is submitting with either a `GET` or `POST` [HTTP method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods). By default, a `<form>` will use the `GET` method and can be specified by the [`method`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#method) property.

* `action`: A reference to the function passed to the `action` prop on the parent `<form>`. If there is no parent `<form>`, the property is `null`. If there is a URI value provided to the `action` prop, or no `action` prop specified, `status.action` will be `null`.

#### Caveats

* The `useFormStatus` Hook must be called from a component that is rendered inside a `<form>`.
* `useFormStatus` will only return status information for a parent `<form>`. It will not return status information for any `<form>` rendered in that same component or children components.

---

## Usage

### Display a pending state during form submission

To display a pending state while a form is submitting, you can call the `useFormStatus` Hook in a component rendered in a `<form>` and read the `pending` property returned.

Here, we use the `pending` property to indicate the form is submitting.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useFormStatus } from "react-dom";
import { submitForm } from "./actions.js";

function Submit() {
  const { pending } = useFormStatus();
  return (
    <button type="submit" disabled={pending}>
      {pending ? "Submitting..." : "Submit"}
    </button>
  );
}

function Form({ action }) {
  return (
    <form action={action}>
      <Submit />
    </form>
  );
}

export default function App() {
  return <Form action={submitForm} />;
}
```

Show more

### Pitfall

##### `useFormStatus` will not return status information for a `<form>` rendered in the same component.

The `useFormStatus` Hook only returns status information for a parent `<form>` and not for any `<form>` rendered in the same component calling the Hook, or child components.

```
function Form() {

// 🚩 `pending` will never be true

// useFormStatus does not track the form rendered in this component

const { pending } = useFormStatus();

return <form action={submit}></form>;

}
```

Instead call `useFormStatus` from inside a component that is located inside `<form>`.

```
function Submit() {

// ✅ `pending` will be derived from the form that wraps the Submit component

const { pending } = useFormStatus();

return <button disabled={pending}>...</button>;

}

function Form() {

// This is the <form> `useFormStatus` tracks

return (

<form action={submit}>

<Submit />

</form>

);

}
```

### Read the form data being submitted

You can use the `data` property of the status information returned from `useFormStatus` to display what data is being submitted by the user.

Here, we have a form where users can request a username. We can use `useFormStatus` to display a temporary status message confirming what username they have requested.

UsernameForm.jsApp.js

UsernameForm.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {useState, useMemo, useRef} from 'react';
import {useFormStatus} from 'react-dom';

export default function UsernameForm() {
  const {pending, data} = useFormStatus();

  return (
    <div>
      <h3>Request a Username: </h3>
      <input type="text" name="username" disabled={pending}/>
      <button type="submit" disabled={pending}>
        Submit
      </button>
      <br />
      <p>{data ? `Requesting ${data?.get("username")}...`: ''}</p>
    </div>
  );
}
```

Show more

---

## Troubleshooting

### `status.pending` is never `true`

`useFormStatus` will only return status information for a parent `<form>`.

If the component that calls `useFormStatus` is not nested in a `<form>`, `status.pending` will always return `false`. Verify `useFormStatus` is called in a component that is a child of a `<form>` element.

`useFormStatus` will not track the status of a `<form>` rendered in the same component. See [Pitfall](https://react.dev/reference/react-dom/hooks/useFormStatus#useformstatus-will-not-return-status-information-for-a-form-rendered-in-the-same-component) for more details.

[PreviousHooks](https://react.dev/reference/react-dom/hooks)[NextComponents](https://react.dev/reference/react-dom/components)

---

---


# Common components (e.g. <div>) – React

URL: https://react.dev/reference/react-dom/components/common

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# Common components (e.g. <div>)

All built-in browser components, such as [`<div>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div), support some common props and events.

* [Reference](https://react.dev/reference/react-dom/components/common#reference) 
  + [Common components (e.g. `<div>`)](https://react.dev/reference/react-dom/components/common#common)
  + [`ref` callback function](https://react.dev/reference/react-dom/components/common#ref-callback)
  + [React event object](https://react.dev/reference/react-dom/components/common#react-event-object)
  + [`AnimationEvent` handler function](https://react.dev/reference/react-dom/components/common#animationevent-handler)
  + [`ClipboardEvent` handler function](https://react.dev/reference/react-dom/components/common#clipboadevent-handler)
  + [`CompositionEvent` handler function](https://react.dev/reference/react-dom/components/common#compositionevent-handler)
  + [`DragEvent` handler function](https://react.dev/reference/react-dom/components/common#dragevent-handler)
  + [`FocusEvent` handler function](https://react.dev/reference/react-dom/components/common#focusevent-handler)
  + [`Event` handler function](https://react.dev/reference/react-dom/components/common#event-handler)
  + [`InputEvent` handler function](https://react.dev/reference/react-dom/components/common#inputevent-handler)
  + [`KeyboardEvent` handler function](https://react.dev/reference/react-dom/components/common#keyboardevent-handler)
  + [`MouseEvent` handler function](https://react.dev/reference/react-dom/components/common#mouseevent-handler)
  + [`PointerEvent` handler function](https://react.dev/reference/react-dom/components/common#pointerevent-handler)
  + [`TouchEvent` handler function](https://react.dev/reference/react-dom/components/common#touchevent-handler)
  + [`TransitionEvent` handler function](https://react.dev/reference/react-dom/components/common#transitionevent-handler)
  + [`UIEvent` handler function](https://react.dev/reference/react-dom/components/common#uievent-handler)
  + [`WheelEvent` handler function](https://react.dev/reference/react-dom/components/common#wheelevent-handler)
* [Usage](https://react.dev/reference/react-dom/components/common#usage) 
  + [Applying CSS styles](https://react.dev/reference/react-dom/components/common#applying-css-styles)
  + [Manipulating a DOM node with a ref](https://react.dev/reference/react-dom/components/common#manipulating-a-dom-node-with-a-ref)
  + [Dangerously setting the inner HTML](https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html)
  + [Handling mouse events](https://react.dev/reference/react-dom/components/common#handling-mouse-events)
  + [Handling pointer events](https://react.dev/reference/react-dom/components/common#handling-pointer-events)
  + [Handling focus events](https://react.dev/reference/react-dom/components/common#handling-focus-events)
  + [Handling keyboard events](https://react.dev/reference/react-dom/components/common#handling-keyboard-events)

---

## Reference

### Common components (e.g. `<div>`)

```
<div className="wrapper">Some content</div>
```

[See more examples below.](https://react.dev/reference/react-dom/components/common#usage)

#### Props

These special React props are supported for all built-in components:

* `children`: A React node (an element, a string, a number, [a portal,](https://react.dev/reference/react-dom/createPortal) an empty node like `null`, `undefined` and booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify the `children` prop implicitly by nesting tags like `<div><span /></div>`.
* `dangerouslySetInnerHTML`: An object of the form `{ __html: '<p>some html</p>' }` with a raw HTML string inside. Overrides the [`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) property of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn’t trusted (for example, if it’s based on user data), you risk introducing an [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) vulnerability. [Read more about using `dangerouslySetInnerHTML`.](https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html)
* `ref`: A ref object from [`useRef`](https://react.dev/reference/react/useRef) or [`createRef`](https://react.dev/reference/react/createRef), or a [`ref` callback function,](https://react.dev/reference/react-dom/components/common#ref-callback) or a string for [legacy refs.](https://reactjs.org/docs/refs-and-the-dom.html#legacy-api-string-refs) Your ref will be filled with the DOM element for this node. [Read more about manipulating the DOM with refs.](https://react.dev/reference/react-dom/components/common#manipulating-a-dom-node-with-a-ref)
* `suppressContentEditableWarning`: A boolean. If `true`, suppresses the warning that React shows for elements that both have `children` and `contentEditable={true}` (which normally do not work together). Use this if you’re building a text input library that manages the `contentEditable` content manually.
* `suppressHydrationWarning`: A boolean. If you use [server rendering,](https://react.dev/reference/react-dom/server) normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you set `suppressHydrationWarning` to `true`, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don’t overuse it. [Read about suppressing hydration errors.](https://react.dev/reference/react-dom/client/hydrateRoot#suppressing-unavoidable-hydration-mismatch-errors)
* `style`: An object with CSS styles, for example `{ fontWeight: 'bold', margin: 20 }`. Similarly to the DOM [`style`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style) property, the CSS property names need to be written as `camelCase`, for example `fontWeight` instead of `font-weight`. You can pass strings or numbers as values. If you pass a number, like `width: 100`, React will automatically append `px` (“pixels”) to the value unless it’s a [unitless property.](https://github.com/facebook/react/blob/81d4ee9ca5c405dce62f64e61506b8e155f38d8d/packages/react-dom-bindings/src/shared/CSSProperty.js#L8-L57) We recommend using `style` only for dynamic styles where you don’t know the style values ahead of time. In other cases, applying plain CSS classes with `className` is more efficient. [Read more about `className` and `style`.](https://react.dev/reference/react-dom/components/common#applying-css-styles)

These standard DOM props are also supported for all built-in components:

* [`accessKey`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/accesskey): A string. Specifies a keyboard shortcut for the element. [Not generally recommended.](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/accesskey#accessibility_concerns)
* [`aria-*`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes): ARIA attributes let you specify the accessibility tree information for this element. See [ARIA attributes](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes) for a complete reference. In React, all ARIA attribute names are exactly the same as in HTML.
* [`autoCapitalize`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autocapitalize): A string. Specifies whether and how the user input should be capitalized.
* [`className`](https://developer.mozilla.org/en-US/docs/Web/API/Element/className): A string. Specifies the element’s CSS class name. [Read more about applying CSS styles.](https://react.dev/reference/react-dom/components/common#applying-css-styles)
* [`contentEditable`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable): A boolean. If `true`, the browser lets the user edit the rendered element directly. This is used to implement rich text input libraries like [Lexical.](https://lexical.dev/) React warns if you try to pass React children to an element with `contentEditable={true}` because React will not be able to update its content after user edits.
* [`data-*`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/data-*): Data attributes let you attach some string data to the element, for example `data-fruit="banana"`. In React, they are not commonly used because you would usually read data from props or state instead.
* [`dir`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/dir): Either `'ltr'` or `'rtl'`. Specifies the text direction of the element.
* [`draggable`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/draggable): A boolean. Specifies whether the element is draggable. Part of [HTML Drag and Drop API.](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API)
* [`enterKeyHint`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/enterKeyHint): A string. Specifies which action to present for the enter key on virtual keyboards.
* [`htmlFor`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/htmlFor): A string. For [`<label>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label) and [`<output>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/output), lets you [associate the label with some control.](https://react.dev/reference/react-dom/components/input#providing-a-label-for-an-input) Same as [`for` HTML attribute.](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/for) React uses the standard DOM property names (`htmlFor`) instead of HTML attribute names.
* [`hidden`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/hidden): A boolean or a string. Specifies whether the element should be hidden.
* [`id`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id): A string. Specifies a unique identifier for this element, which can be used to find it later or connect it with other elements. Generate it with [`useId`](https://react.dev/reference/react/useId) to avoid clashes between multiple instances of the same component.
* [`is`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/is): A string. If specified, the component will behave like a [custom element.](https://react.dev/reference/react-dom/components#custom-html-elements)
* [`inputMode`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/inputmode): A string. Specifies what kind of keyboard to display (for example, text, number or telephone).
* [`itemProp`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemprop): A string. Specifies which property the element represents for structured data crawlers.
* [`lang`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang): A string. Specifies the language of the element.
* [`onAnimationEnd`](https://developer.mozilla.org/en-US/docs/Web/API/Element/animationend_event): An [`AnimationEvent` handler](https://react.dev/reference/react-dom/components/common#animationevent-handler) function. Fires when a CSS animation completes.
* `onAnimationEndCapture`: A version of `onAnimationEnd` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onAnimationIteration`](https://developer.mozilla.org/en-US/docs/Web/API/Element/animationiteration_event): An [`AnimationEvent` handler](https://react.dev/reference/react-dom/components/common#animationevent-handler) function. Fires when an iteration of a CSS animation ends, and another one begins.
* `onAnimationIterationCapture`: A version of `onAnimationIteration` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onAnimationStart`](https://developer.mozilla.org/en-US/docs/Web/API/Element/animationstart_event): An [`AnimationEvent` handler](https://react.dev/reference/react-dom/components/common#animationevent-handler) function. Fires when a CSS animation starts.
* `onAnimationStartCapture`: `onAnimationStart`, but fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onAuxClick`](https://developer.mozilla.org/en-US/docs/Web/API/Element/auxclick_event): A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when a non-primary pointer button was clicked.
* `onAuxClickCapture`: A version of `onAuxClick` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* `onBeforeInput`: An [`InputEvent` handler](https://react.dev/reference/react-dom/components/common#inputevent-handler) function. Fires before the value of an editable element is modified. React does *not* yet use the native [`beforeinput`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/beforeinput_event) event, and instead attempts to polyfill it using other events.
* `onBeforeInputCapture`: A version of `onBeforeInput` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* `onBlur`: A [`FocusEvent` handler](https://react.dev/reference/react-dom/components/common#focusevent-handler) function. Fires when an element lost focus. Unlike the built-in browser [`blur`](https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event) event, in React the `onBlur` event bubbles.
* `onBlurCapture`: A version of `onBlur` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onClick`](https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event): A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when the primary button was clicked on the pointing device.
* `onClickCapture`: A version of `onClick` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onCompositionStart`](https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionstart_event): A [`CompositionEvent` handler](https://react.dev/reference/react-dom/components/common#compositionevent-handler) function. Fires when an [input method editor](https://developer.mozilla.org/en-US/docs/Glossary/Input_method_editor) starts a new composition session.
* `onCompositionStartCapture`: A version of `onCompositionStart` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onCompositionEnd`](https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionend_event): A [`CompositionEvent` handler](https://react.dev/reference/react-dom/components/common#compositionevent-handler) function. Fires when an [input method editor](https://developer.mozilla.org/en-US/docs/Glossary/Input_method_editor) completes or cancels a composition session.
* `onCompositionEndCapture`: A version of `onCompositionEnd` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onCompositionUpdate`](https://developer.mozilla.org/en-US/docs/Web/API/Element/compositionupdate_event): A [`CompositionEvent` handler](https://react.dev/reference/react-dom/components/common#compositionevent-handler) function. Fires when an [input method editor](https://developer.mozilla.org/en-US/docs/Glossary/Input_method_editor) receives a new character.
* `onCompositionUpdateCapture`: A version of `onCompositionUpdate` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onContextMenu`](https://developer.mozilla.org/en-US/docs/Web/API/Element/contextmenu_event): A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when the user tries to open a context menu.
* `onContextMenuCapture`: A version of `onContextMenu` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onCopy`](https://developer.mozilla.org/en-US/docs/Web/API/Element/copy_event): A [`ClipboardEvent` handler](https://react.dev/reference/react-dom/components/common#clipboardevent-handler) function. Fires when the user tries to copy something into the clipboard.
* `onCopyCapture`: A version of `onCopy` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onCut`](https://developer.mozilla.org/en-US/docs/Web/API/Element/cut_event): A [`ClipboardEvent` handler](https://react.dev/reference/react-dom/components/common#clipboardevent-handler) function. Fires when the user tries to cut something into the clipboard.
* `onCutCapture`: A version of `onCut` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* `onDoubleClick`: A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when the user clicks twice. Corresponds to the browser [`dblclick` event.](https://developer.mozilla.org/en-US/docs/Web/API/Element/dblclick_event)
* `onDoubleClickCapture`: A version of `onDoubleClick` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onDrag`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/drag_event): A [`DragEvent` handler](https://react.dev/reference/react-dom/components/common#dragevent-handler) function. Fires while the user is dragging something.
* `onDragCapture`: A version of `onDrag` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onDragEnd`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dragend_event): A [`DragEvent` handler](https://react.dev/reference/react-dom/components/common#dragevent-handler) function. Fires when the user stops dragging something.
* `onDragEndCapture`: A version of `onDragEnd` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onDragEnter`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dragenter_event): A [`DragEvent` handler](https://react.dev/reference/react-dom/components/common#dragevent-handler) function. Fires when the dragged content enters a valid drop target.
* `onDragEnterCapture`: A version of `onDragEnter` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onDragOver`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dragover_event): A [`DragEvent` handler](https://react.dev/reference/react-dom/components/common#dragevent-handler) function. Fires on a valid drop target while the dragged content is dragged over it. You must call `e.preventDefault()` here to allow dropping.
* `onDragOverCapture`: A version of `onDragOver` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onDragStart`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dragstart_event): A [`DragEvent` handler](https://react.dev/reference/react-dom/components/common#dragevent-handler) function. Fires when the user starts dragging an element.
* `onDragStartCapture`: A version of `onDragStart` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onDrop`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/drop_event): A [`DragEvent` handler](https://react.dev/reference/react-dom/components/common#dragevent-handler) function. Fires when something is dropped on a valid drop target.
* `onDropCapture`: A version of `onDrop` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* `onFocus`: A [`FocusEvent` handler](https://react.dev/reference/react-dom/components/common#focusevent-handler) function. Fires when an element receives focus. Unlike the built-in browser [`focus`](https://developer.mozilla.org/en-US/docs/Web/API/Element/focus_event) event, in React the `onFocus` event bubbles.
* `onFocusCapture`: A version of `onFocus` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onGotPointerCapture`](https://developer.mozilla.org/en-US/docs/Web/API/Element/gotpointercapture_event): A [`PointerEvent` handler](https://react.dev/reference/react-dom/components/common#pointerevent-handler) function. Fires when an element programmatically captures a pointer.
* `onGotPointerCaptureCapture`: A version of `onGotPointerCapture` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onKeyDown`](https://developer.mozilla.org/en-US/docs/Web/API/Element/keydown_event): A [`KeyboardEvent` handler](https://react.dev/reference/react-dom/components/common#keyboardevent-handler) function. Fires when a key is pressed.
* `onKeyDownCapture`: A version of `onKeyDown` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onKeyPress`](https://developer.mozilla.org/en-US/docs/Web/API/Element/keypress_event): A [`KeyboardEvent` handler](https://react.dev/reference/react-dom/components/common#keyboardevent-handler) function. Deprecated. Use `onKeyDown` or `onBeforeInput` instead.
* `onKeyPressCapture`: A version of `onKeyPress` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onKeyUp`](https://developer.mozilla.org/en-US/docs/Web/API/Element/keyup_event): A [`KeyboardEvent` handler](https://react.dev/reference/react-dom/components/common#keyboardevent-handler) function. Fires when a key is released.
* `onKeyUpCapture`: A version of `onKeyUp` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onLostPointerCapture`](https://developer.mozilla.org/en-US/docs/Web/API/Element/lostpointercapture_event): A [`PointerEvent` handler](https://react.dev/reference/react-dom/components/common#pointerevent-handler) function. Fires when an element stops capturing a pointer.
* `onLostPointerCaptureCapture`: A version of `onLostPointerCapture` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onMouseDown`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mousedown_event): A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when the pointer is pressed down.
* `onMouseDownCapture`: A version of `onMouseDown` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onMouseEnter`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event): A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when the pointer moves inside an element. Does not have a capture phase. Instead, `onMouseLeave` and `onMouseEnter` propagate from the element being left to the one being entered.
* [`onMouseLeave`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseleave_event): A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when the pointer moves outside an element. Does not have a capture phase. Instead, `onMouseLeave` and `onMouseEnter` propagate from the element being left to the one being entered.
* [`onMouseMove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event): A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when the pointer changes coordinates.
* `onMouseMoveCapture`: A version of `onMouseMove` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onMouseOut`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseout_event): A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when the pointer moves outside an element, or if it moves into a child element.
* `onMouseOutCapture`: A version of `onMouseOut` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onMouseUp`](https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseup_event): A [`MouseEvent` handler](https://react.dev/reference/react-dom/components/common#mouseevent-handler) function. Fires when the pointer is released.
* `onMouseUpCapture`: A version of `onMouseUp` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onPointerCancel`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointercancel_event): A [`PointerEvent` handler](https://react.dev/reference/react-dom/components/common#pointerevent-handler) function. Fires when the browser cancels a pointer interaction.
* `onPointerCancelCapture`: A version of `onPointerCancel` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onPointerDown`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerdown_event): A [`PointerEvent` handler](https://react.dev/reference/react-dom/components/common#pointerevent-handler) function. Fires when a pointer becomes active.
* `onPointerDownCapture`: A version of `onPointerDown` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onPointerEnter`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerenter_event): A [`PointerEvent` handler](https://react.dev/reference/react-dom/components/common#pointerevent-handler) function. Fires when a pointer moves inside an element. Does not have a capture phase. Instead, `onPointerLeave` and `onPointerEnter` propagate from the element being left to the one being entered.
* [`onPointerLeave`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerleave_event): A [`PointerEvent` handler](https://react.dev/reference/react-dom/components/common#pointerevent-handler) function. Fires when a pointer moves outside an element. Does not have a capture phase. Instead, `onPointerLeave` and `onPointerEnter` propagate from the element being left to the one being entered.
* [`onPointerMove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointermove_event): A [`PointerEvent` handler](https://react.dev/reference/react-dom/components/common#pointerevent-handler) function. Fires when a pointer changes coordinates.
* `onPointerMoveCapture`: A version of `onPointerMove` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onPointerOut`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerout_event): A [`PointerEvent` handler](https://react.dev/reference/react-dom/components/common#pointerevent-handler) function. Fires when a pointer moves outside an element, if the pointer interaction is cancelled, and [a few other reasons.](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerout_event)
* `onPointerOutCapture`: A version of `onPointerOut` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onPointerUp`](https://developer.mozilla.org/en-US/docs/Web/API/Element/pointerup_event): A [`PointerEvent` handler](https://react.dev/reference/react-dom/components/common#pointerevent-handler) function. Fires when a pointer is no longer active.
* `onPointerUpCapture`: A version of `onPointerUp` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onPaste`](https://developer.mozilla.org/en-US/docs/Web/API/Element/paste_event): A [`ClipboardEvent` handler](https://react.dev/reference/react-dom/components/common#clipboardevent-handler) function. Fires when the user tries to paste something from the clipboard.
* `onPasteCapture`: A version of `onPaste` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onScroll`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scroll_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when an element has been scrolled. This event does not bubble.
* `onScrollCapture`: A version of `onScroll` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onSelect`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires after the selection inside an editable element like an input changes. React extends the `onSelect` event to work for `contentEditable={true}` elements as well. In addition, React extends it to fire for empty selection and on edits (which may affect the selection).
* `onSelectCapture`: A version of `onSelect` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onTouchCancel`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchcancel_event): A [`TouchEvent` handler](https://react.dev/reference/react-dom/components/common#touchevent-handler) function. Fires when the browser cancels a touch interaction.
* `onTouchCancelCapture`: A version of `onTouchCancel` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onTouchEnd`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchend_event): A [`TouchEvent` handler](https://react.dev/reference/react-dom/components/common#touchevent-handler) function. Fires when one or more touch points are removed.
* `onTouchEndCapture`: A version of `onTouchEnd` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onTouchMove`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchmove_event): A [`TouchEvent` handler](https://react.dev/reference/react-dom/components/common#touchevent-handler) function. Fires one or more touch points are moved.
* `onTouchMoveCapture`: A version of `onTouchMove` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onTouchStart`](https://developer.mozilla.org/en-US/docs/Web/API/Element/touchstart_event): A [`TouchEvent` handler](https://react.dev/reference/react-dom/components/common#touchevent-handler) function. Fires when one or more touch points are placed.
* `onTouchStartCapture`: A version of `onTouchStart` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onTransitionEnd`](https://developer.mozilla.org/en-US/docs/Web/API/Element/transitionend_event): A [`TransitionEvent` handler](https://react.dev/reference/react-dom/components/common#transitionevent-handler) function. Fires when a CSS transition completes.
* `onTransitionEndCapture`: A version of `onTransitionEnd` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onWheel`](https://developer.mozilla.org/en-US/docs/Web/API/Element/wheel_event): A [`WheelEvent` handler](https://react.dev/reference/react-dom/components/common#wheelevent-handler) function. Fires when the user rotates a wheel button.
* `onWheelCapture`: A version of `onWheel` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`role`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles): A string. Specifies the element role explicitly for assistive technologies.
* [`slot`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles): A string. Specifies the slot name when using shadow DOM. In React, an equivalent pattern is typically achieved by passing JSX as props, for example `<Layout left={<Sidebar />} right={<Content />} />`.
* [`spellCheck`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/spellcheck): A boolean or null. If explicitly set to `true` or `false`, enables or disables spellchecking.
* [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex): A number. Overrides the default Tab button behavior. [Avoid using values other than `-1` and `0`.](https://www.tpgi.com/using-the-tabindex-attribute/)
* [`title`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/title): A string. Specifies the tooltip text for the element.
* [`translate`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/translate): Either `'yes'` or `'no'`. Passing `'no'` excludes the element content from being translated.

You can also pass custom attributes as props, for example `mycustomprop="someValue"`. This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start with `on`. The value will be converted to a string. If you pass `null` or `undefined`, the custom attribute will be removed.

These events fire only for the [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) elements:

* [`onReset`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/reset_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when a form gets reset.
* `onResetCapture`: A version of `onReset` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onSubmit`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when a form gets submitted.
* `onSubmitCapture`: A version of `onSubmit` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)

These events fire only for the [`<dialog>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog) elements. Unlike browser events, they bubble in React:

* [`onCancel`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/cancel_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the user tries to dismiss the dialog.
* `onCancelCapture`: A version of `onCancel` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onClose`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/close_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when a dialog has been closed.
* `onCloseCapture`: A version of `onClose` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)

These events fire only for the [`<details>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details) elements. Unlike browser events, they bubble in React:

* [`onToggle`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLDetailsElement/toggle_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the user toggles the details.
* `onToggleCapture`: A version of `onToggle` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)

These events fire for [`<img>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img), [`<iframe>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe), [`<object>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object), [`<embed>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed), [`<link>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link), and [SVG `<image>`](https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/SVG_Image_Tag) elements. Unlike browser events, they bubble in React:

* `onLoad`: An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the resource has loaded.
* `onLoadCapture`: A version of `onLoad` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onError`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/error_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the resource could not be loaded.
* `onErrorCapture`: A version of `onError` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)

These events fire for resources like [`<audio>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio) and [`<video>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video). Unlike browser events, they bubble in React:

* [`onAbort`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/abort_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the resource has not fully loaded, but not due to an error.
* `onAbortCapture`: A version of `onAbort` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onCanPlay`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplay_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when there’s enough data to start playing, but not enough to play to the end without buffering.
* `onCanPlayCapture`: A version of `onCanPlay` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onCanPlayThrough`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/canplaythrough_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when there’s enough data that it’s likely possible to start playing without buffering until the end.
* `onCanPlayThroughCapture`: A version of `onCanPlayThrough` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onDurationChange`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/durationchange_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the media duration has updated.
* `onDurationChangeCapture`: A version of `onDurationChange` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onEmptied`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/emptied_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the media has become empty.
* `onEmptiedCapture`: A version of `onEmptied` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onEncrypted`](https://w3c.github.io/encrypted-media/#dom-evt-encrypted): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the browser encounters encrypted media.
* `onEncryptedCapture`: A version of `onEncrypted` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onEnded`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/ended_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the playback stops because there’s nothing left to play.
* `onEndedCapture`: A version of `onEnded` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onError`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/error_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the resource could not be loaded.
* `onErrorCapture`: A version of `onError` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onLoadedData`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadeddata_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the current playback frame has loaded.
* `onLoadedDataCapture`: A version of `onLoadedData` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onLoadedMetadata`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadedmetadata_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when metadata has loaded.
* `onLoadedMetadataCapture`: A version of `onLoadedMetadata` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onLoadStart`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/loadstart_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the browser started loading the resource.
* `onLoadStartCapture`: A version of `onLoadStart` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onPause`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the media was paused.
* `onPauseCapture`: A version of `onPause` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onPlay`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the media is no longer paused.
* `onPlayCapture`: A version of `onPlay` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onPlaying`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/playing_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the media starts or restarts playing.
* `onPlayingCapture`: A version of `onPlaying` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onProgress`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/progress_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires periodically while the resource is loading.
* `onProgressCapture`: A version of `onProgress` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onRateChange`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/ratechange_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when playback rate changes.
* `onRateChangeCapture`: A version of `onRateChange` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* `onResize`: An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when video changes size.
* `onResizeCapture`: A version of `onResize` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onSeeked`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/seeked_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when a seek operation completes.
* `onSeekedCapture`: A version of `onSeeked` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onSeeking`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/seeking_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when a seek operation starts.
* `onSeekingCapture`: A version of `onSeeking` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onStalled`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/stalled_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the browser is waiting for data but it keeps not loading.
* `onStalledCapture`: A version of `onStalled` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onSuspend`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/suspend_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when loading the resource was suspended.
* `onSuspendCapture`: A version of `onSuspend` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onTimeUpdate`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/timeupdate_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the current playback time updates.
* `onTimeUpdateCapture`: A version of `onTimeUpdate` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onVolumeChange`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/volumechange_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the volume has changed.
* `onVolumeChangeCapture`: A version of `onVolumeChange` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onWaiting`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/waiting_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires when the playback stopped due to temporary lack of data.
* `onWaitingCapture`: A version of `onWaiting` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)

#### Caveats

* You cannot pass both `children` and `dangerouslySetInnerHTML` at the same time.
* Some events (like `onAbort` and `onLoad`) don’t bubble in the browser, but bubble in React.

---

### `ref` callback function

Instead of a ref object (like the one returned by [`useRef`](https://react.dev/reference/react/useRef#manipulating-the-dom-with-a-ref)), you may pass a function to the `ref` attribute.

```
<div ref={(node) => {

console.log('Attached', node);

return () => {

console.log('Clean up', node)

}

}}>
```

[See an example of using the `ref` callback.](https://react.dev/learn/manipulating-the-dom-with-refs#how-to-manage-a-list-of-refs-using-a-ref-callback)

When the `<div>` DOM node is added to the screen, React will call your `ref` callback with the DOM `node` as the argument. When that `<div>` DOM node is removed, React will call your the cleanup function returned from the callback.

React will also call your `ref` callback whenever you pass a *different* `ref` callback. In the above example, `(node) => { ... }` is a different function on every render. When your component re-renders, the *previous* function will be called with `null` as the argument, and the *next* function will be called with the DOM node.

#### Parameters

* `node`: A DOM node. React will pass you the DOM node when the ref gets attached. Unless you pass the same function reference for the `ref` callback on every render, the callback will get temporarily cleanup and re-create during every re-render of the component.

### Note

#### React 19 added cleanup functions for `ref` callbacks.

To support backwards compatibility, if a cleanup function is not returned from the `ref` callback, `node` will be called with `null` when the `ref` is detached. This behavior will be removed in a future version.

#### Returns

* **optional** `cleanup function`: When the `ref` is detached, React will call the cleanup function. If a function is not returned by the `ref` callback, React will call the callback again with `null` as the argument when the `ref` gets detached. This behavior will be removed in a future version.

#### Caveats

* When Strict Mode is on, React will **run one extra development-only setup+cleanup cycle** before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function.
* When you pass a *different* `ref` callback, React will call the *previous* callback’s cleanup function if provided. If no cleanup function is defined, the `ref` callback will be called with `null` as the argument. The *next* function will be called with the DOM node.

---

### React event object

Your event handlers will receive a *React event object.* It is also sometimes known as a “synthetic event”.

```
<button onClick={e => {

console.log(e); // React event object

}} />
```

It conforms to the same standard as the underlying DOM events, but fixes some browser inconsistencies.

Some React events do not map directly to the browser’s native events. For example in `onMouseLeave`, `e.nativeEvent` will point to a `mouseout` event. The specific mapping is not part of the public API and may change in the future. If you need the underlying browser event for some reason, read it from `e.nativeEvent`.

#### Properties

React event objects implement some of the standard [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) properties:

* [`bubbles`](https://developer.mozilla.org/en-US/docs/Web/API/Event/bubbles): A boolean. Returns whether the event bubbles through the DOM.
* [`cancelable`](https://developer.mozilla.org/en-US/docs/Web/API/Event/cancelable): A boolean. Returns whether the event can be canceled.
* [`currentTarget`](https://developer.mozilla.org/en-US/docs/Web/API/Event/currentTarget): A DOM node. Returns the node to which the current handler is attached in the React tree.
* [`defaultPrevented`](https://developer.mozilla.org/en-US/docs/Web/API/Event/defaultPrevented): A boolean. Returns whether `preventDefault` was called.
* [`eventPhase`](https://developer.mozilla.org/en-US/docs/Web/API/Event/eventPhase): A number. Returns which phase the event is currently in.
* [`isTrusted`](https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted): A boolean. Returns whether the event was initiated by user.
* [`target`](https://developer.mozilla.org/en-US/docs/Web/API/Event/target): A DOM node. Returns the node on which the event has occurred (which could be a distant child).
* [`timeStamp`](https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp): A number. Returns the time when the event occurred.

Additionally, React event objects provide these properties:

* `nativeEvent`: A DOM [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event). The original browser event object.

#### Methods

React event objects implement some of the standard [`Event`](https://developer.mozilla.org/en-US/docs/Web/API/Event) methods:

* [`preventDefault()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault): Prevents the default browser action for the event.
* [`stopPropagation()`](https://developer.mozilla.org/en-US/docs/Web/API/Event/stopPropagation): Stops the event propagation through the React tree.

Additionally, React event objects provide these methods:

* `isDefaultPrevented()`: Returns a boolean value indicating whether `preventDefault` was called.
* `isPropagationStopped()`: Returns a boolean value indicating whether `stopPropagation` was called.
* `persist()`: Not used with React DOM. With React Native, call this to read event’s properties after the event.
* `isPersistent()`: Not used with React DOM. With React Native, returns whether `persist` has been called.

#### Caveats

* The values of `currentTarget`, `eventPhase`, `target`, and `type` reflect the values your React code expects. Under the hood, React attaches event handlers at the root, but this is not reflected in React event objects. For example, `e.currentTarget` may not be the same as the underlying `e.nativeEvent.currentTarget`. For polyfilled events, `e.type` (React event type) may differ from `e.nativeEvent.type` (underlying type).

---

### `AnimationEvent` handler function

An event handler type for the [CSS animation](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations) events.

```
<div

onAnimationStart={e => console.log('onAnimationStart')}

onAnimationIteration={e => console.log('onAnimationIteration')}

onAnimationEnd={e => console.log('onAnimationEnd')}

/>
```

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`AnimationEvent`](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent) properties:
  + [`animationName`](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent/animationName)
  + [`elapsedTime`](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent/elapsedTime)
  + [`pseudoElement`](https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent/pseudoElement)

---

### `ClipboardEvent` handler function

An event handler type for the [Clipboard API](https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API) events.

```
<input

onCopy={e => console.log('onCopy')}

onCut={e => console.log('onCut')}

onPaste={e => console.log('onPaste')}

/>
```

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`ClipboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent) properties:

  + [`clipboardData`](https://developer.mozilla.org/en-US/docs/Web/API/ClipboardEvent/clipboardData)

---

### `CompositionEvent` handler function

An event handler type for the [input method editor (IME)](https://developer.mozilla.org/en-US/docs/Glossary/Input_method_editor) events.

```
<input

onCompositionStart={e => console.log('onCompositionStart')}

onCompositionUpdate={e => console.log('onCompositionUpdate')}

onCompositionEnd={e => console.log('onCompositionEnd')}

/>
```

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`CompositionEvent`](https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent) properties:
  + [`data`](https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent/data)

---

### `DragEvent` handler function

An event handler type for the [HTML Drag and Drop API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API) events.

```
<>

<div

draggable={true}

onDragStart={e => console.log('onDragStart')}

onDragEnd={e => console.log('onDragEnd')}

>

Drag source

</div>

<div

onDragEnter={e => console.log('onDragEnter')}

onDragLeave={e => console.log('onDragLeave')}

onDragOver={e => { e.preventDefault(); console.log('onDragOver'); }}

onDrop={e => console.log('onDrop')}

>

Drop target

</div>

</>
```

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`DragEvent`](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent) properties:

  + [`dataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DragEvent/dataTransfer)

  It also includes the inherited [`MouseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) properties:

  + [`altKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/altKey)
  + [`button`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button)
  + [`buttons`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons)
  + [`ctrlKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/ctrlKey)
  + [`clientX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX)
  + [`clientY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientY)
  + [`getModifierState(key)`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/getModifierState)
  + [`metaKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/metaKey)
  + [`movementX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX)
  + [`movementY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementY)
  + [`pageX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX)
  + [`pageY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageY)
  + [`relatedTarget`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/relatedTarget)
  + [`screenX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/screenX)
  + [`screenY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/screenY)
  + [`shiftKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/shiftKey)

  It also includes the inherited [`UIEvent`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent) properties:

  + [`detail`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail)
  + [`view`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view)

---

### `FocusEvent` handler function

An event handler type for the focus events.

```
<input

onFocus={e => console.log('onFocus')}

onBlur={e => console.log('onBlur')}

/>
```

[See an example.](https://react.dev/reference/react-dom/components/common#handling-focus-events)

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`FocusEvent`](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent) properties:

  + [`relatedTarget`](https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/relatedTarget)

  It also includes the inherited [`UIEvent`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent) properties:

  + [`detail`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail)
  + [`view`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view)

---

### `Event` handler function

An event handler type for generic events.

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with no additional properties.

---

### `InputEvent` handler function

An event handler type for the `onBeforeInput` event.

```
<input onBeforeInput={e => console.log('onBeforeInput')} />
```

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`InputEvent`](https://developer.mozilla.org/en-US/docs/Web/API/InputEvent) properties:
  + [`data`](https://developer.mozilla.org/en-US/docs/Web/API/InputEvent/data)

---

### `KeyboardEvent` handler function

An event handler type for keyboard events.

```
<input

onKeyDown={e => console.log('onKeyDown')}

onKeyUp={e => console.log('onKeyUp')}

/>
```

[See an example.](https://react.dev/reference/react-dom/components/common#handling-keyboard-events)

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`KeyboardEvent`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) properties:

  + [`altKey`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/altKey)
  + [`charCode`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/charCode)
  + [`code`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code)
  + [`ctrlKey`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/ctrlKey)
  + [`getModifierState(key)`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState)
  + [`key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key)
  + [`keyCode`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode)
  + [`locale`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/locale)
  + [`metaKey`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/metaKey)
  + [`location`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/location)
  + [`repeat`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat)
  + [`shiftKey`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/shiftKey)
  + [`which`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/which)

  It also includes the inherited [`UIEvent`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent) properties:

  + [`detail`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail)
  + [`view`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view)

---

### `MouseEvent` handler function

An event handler type for mouse events.

```
<div

onClick={e => console.log('onClick')}

onMouseEnter={e => console.log('onMouseEnter')}

onMouseOver={e => console.log('onMouseOver')}

onMouseDown={e => console.log('onMouseDown')}

onMouseUp={e => console.log('onMouseUp')}

onMouseLeave={e => console.log('onMouseLeave')}

/>
```

[See an example.](https://react.dev/reference/react-dom/components/common#handling-mouse-events)

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`MouseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) properties:

  + [`altKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/altKey)
  + [`button`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button)
  + [`buttons`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons)
  + [`ctrlKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/ctrlKey)
  + [`clientX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX)
  + [`clientY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientY)
  + [`getModifierState(key)`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/getModifierState)
  + [`metaKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/metaKey)
  + [`movementX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX)
  + [`movementY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementY)
  + [`pageX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX)
  + [`pageY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageY)
  + [`relatedTarget`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/relatedTarget)
  + [`screenX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/screenX)
  + [`screenY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/screenY)
  + [`shiftKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/shiftKey)

  It also includes the inherited [`UIEvent`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent) properties:

  + [`detail`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail)
  + [`view`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view)

---

### `PointerEvent` handler function

An event handler type for [pointer events.](https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events)

```
<div

onPointerEnter={e => console.log('onPointerEnter')}

onPointerMove={e => console.log('onPointerMove')}

onPointerDown={e => console.log('onPointerDown')}

onPointerUp={e => console.log('onPointerUp')}

onPointerLeave={e => console.log('onPointerLeave')}

/>
```

[See an example.](https://react.dev/reference/react-dom/components/common#handling-pointer-events)

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`PointerEvent`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent) properties:

  + [`height`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height)
  + [`isPrimary`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary)
  + [`pointerId`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId)
  + [`pointerType`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType)
  + [`pressure`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure)
  + [`tangentialPressure`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tangentialPressure)
  + [`tiltX`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX)
  + [`tiltY`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY)
  + [`twist`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/twist)
  + [`width`](https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width)

  It also includes the inherited [`MouseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) properties:

  + [`altKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/altKey)
  + [`button`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button)
  + [`buttons`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons)
  + [`ctrlKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/ctrlKey)
  + [`clientX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX)
  + [`clientY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientY)
  + [`getModifierState(key)`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/getModifierState)
  + [`metaKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/metaKey)
  + [`movementX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX)
  + [`movementY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementY)
  + [`pageX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX)
  + [`pageY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageY)
  + [`relatedTarget`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/relatedTarget)
  + [`screenX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/screenX)
  + [`screenY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/screenY)
  + [`shiftKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/shiftKey)

  It also includes the inherited [`UIEvent`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent) properties:

  + [`detail`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail)
  + [`view`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view)

---

### `TouchEvent` handler function

An event handler type for [touch events.](https://developer.mozilla.org/en-US/docs/Web/API/Touch_events)

```
<div

onTouchStart={e => console.log('onTouchStart')}

onTouchMove={e => console.log('onTouchMove')}

onTouchEnd={e => console.log('onTouchEnd')}

onTouchCancel={e => console.log('onTouchCancel')}

/>
```

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`TouchEvent`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent) properties:

  + [`altKey`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/altKey)
  + [`ctrlKey`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/ctrlKey)
  + [`changedTouches`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/changedTouches)
  + [`getModifierState(key)`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/getModifierState)
  + [`metaKey`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/metaKey)
  + [`shiftKey`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/shiftKey)
  + [`touches`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/touches)
  + [`targetTouches`](https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent/targetTouches)

  It also includes the inherited [`UIEvent`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent) properties:

  + [`detail`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail)
  + [`view`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view)

---

### `TransitionEvent` handler function

An event handler type for the CSS transition events.

```
<div

onTransitionEnd={e => console.log('onTransitionEnd')}

/>
```

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`TransitionEvent`](https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent) properties:
  + [`elapsedTime`](https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent/elapsedTime)
  + [`propertyName`](https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent/propertyName)
  + [`pseudoElement`](https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent/pseudoElement)

---

### `UIEvent` handler function

An event handler type for generic UI events.

```
<div

onScroll={e => console.log('onScroll')}

/>
```

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`UIEvent`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent) properties:
  + [`detail`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail)
  + [`view`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view)

---

### `WheelEvent` handler function

An event handler type for the `onWheel` event.

```
<div

onWheel={e => console.log('onWheel')}

/>
```

#### Parameters

* `e`: A [React event object](https://react.dev/reference/react-dom/components/common#react-event-object) with these extra [`WheelEvent`](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent) properties:

  + [`deltaMode`](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode)
  + [`deltaX`](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaX)
  + [`deltaY`](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaY)
  + [`deltaZ`](https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaZ)

  It also includes the inherited [`MouseEvent`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) properties:

  + [`altKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/altKey)
  + [`button`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button)
  + [`buttons`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons)
  + [`ctrlKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/ctrlKey)
  + [`clientX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientX)
  + [`clientY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/clientY)
  + [`getModifierState(key)`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/getModifierState)
  + [`metaKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/metaKey)
  + [`movementX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX)
  + [`movementY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementY)
  + [`pageX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageX)
  + [`pageY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/pageY)
  + [`relatedTarget`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/relatedTarget)
  + [`screenX`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/screenX)
  + [`screenY`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/screenY)
  + [`shiftKey`](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/shiftKey)

  It also includes the inherited [`UIEvent`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent) properties:

  + [`detail`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail)
  + [`view`](https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view)

---

## Usage

### Applying CSS styles

In React, you specify a CSS class with [`className`.](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) It works like the `class` attribute in HTML:

```
<img className="avatar" />
```

Then you write the CSS rules for it in a separate CSS file:

```
/* In your CSS */

.avatar {

border-radius: 50%;

}
```

React does not prescribe how you add CSS files. In the simplest case, you’ll add a [`<link>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link) tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project.

Sometimes, the style values depend on data. Use the `style` attribute to pass some styles dynamically:

```
<img

className="avatar"

style={{

width: user.imageSize,

height: user.imageSize

}}

/>
```

In the above example, `style={{}}` is not a special syntax, but a regular `{}` object inside the `style={ }` [JSX curly braces.](https://react.dev/learn/javascript-in-jsx-with-curly-braces) We recommend only using the `style` attribute when your styles depend on JavaScript variables.

App.jsAvatar.js

Avatar.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Avatar({ user }) {
  return (
    <img
      src={user.imageUrl}
      alt={'Photo of ' + user.name}
      className="avatar"
      style={{
        width: user.imageSize,
        height: user.imageSize
      }}
    />
  );
}
```

##### Deep Dive

#### How to apply multiple CSS classes conditionally?

Show Details

To apply CSS classes conditionally, you need to produce the `className` string yourself using JavaScript.

For example, `className={'row ' + (isSelected ? 'selected': '')}` will produce either `className="row"` or `className="row selected"` depending on whether `isSelected` is `true`.

To make this more readable, you can use a tiny helper library like [`classnames`:](https://github.com/JedWatson/classnames)

```
import cn from 'classnames';

function Row({ isSelected }) {

return (

<div className={cn('row', isSelected && 'selected')}>

...

</div>

);

}
```

It is especially convenient if you have multiple conditional classes:

```
import cn from 'classnames';

function Row({ isSelected, size }) {

return (

<div className={cn('row', {

selected: isSelected,

large: size === 'large',

small: size === 'small',

})}>

...

</div>

);

}
```

---

### Manipulating a DOM node with a ref

Sometimes, you’ll need to get the browser DOM node associated with a tag in JSX. For example, if you want to focus an `<input>` when a button is clicked, you need to call [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) on the browser `<input>` DOM node.

To obtain the browser DOM node for a tag, [declare a ref](https://react.dev/reference/react/useRef) and pass it as the `ref` attribute to that tag:

```
import { useRef } from 'react';

export default function Form() {

const inputRef = useRef(null);

// ...

return (

<input ref={inputRef} />

// ...
```

React will put the DOM node into `inputRef.current` after it’s been rendered to the screen.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

Show more

Read more about [manipulating DOM with refs](https://react.dev/learn/manipulating-the-dom-with-refs) and [check out more examples.](https://react.dev/reference/react/useRef#usage)

For more advanced use cases, the `ref` attribute also accepts a [callback function.](https://react.dev/reference/react-dom/components/common#ref-callback)

---

### Dangerously setting the inner HTML

You can pass a raw HTML string to an element like so:

```
const markup = { __html: '<p>some raw html</p>' };

return <div dangerouslySetInnerHTML={markup} />;
```

**This is dangerous. As with the underlying DOM [`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) property, you must exercise extreme caution! Unless the markup is coming from a completely trusted source, it is trivial to introduce an [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting) vulnerability this way.**

For example, if you use a Markdown library that converts Markdown to HTML, you trust that its parser doesn’t contain bugs, and the user only sees their own input, you can display the resulting HTML like this:

package.jsonApp.jsMarkdownPreview.js

MarkdownPreview.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Remarkable } from 'remarkable';

const md = new Remarkable();

function renderMarkdownToHTML(markdown) {
  // This is ONLY safe because the output HTML
  // is shown to the same user, and because you
  // trust this Markdown parser to not have bugs.
  const renderedHTML = md.render(markdown);
  return {__html: renderedHTML};
}

export default function MarkdownPreview({ markdown }) {
  const markup = renderMarkdownToHTML(markdown);
  return <div dangerouslySetInnerHTML={markup} />;
}
```

Show more

The `{__html}` object should be created as close to where the HTML is generated as possible, like the above example does in the `renderMarkdownToHTML` function. This ensures that all raw HTML being used in your code is explicitly marked as such, and that only variables that you expect to contain HTML are passed to `dangerouslySetInnerHTML`. It is not recommended to create the object inline like `<div dangerouslySetInnerHTML={{__html: markup}} />`.

To see why rendering arbitrary HTML is dangerous, replace the code above with this:

```
const post = {

// Imagine this content is stored in the database.

content: `<img src="" onerror='alert("you were hacked")'>`

};

export default function MarkdownPreview() {

// 🔴 SECURITY HOLE: passing untrusted input to dangerouslySetInnerHTML

const markup = { __html: post.content };

return <div dangerouslySetInnerHTML={markup} />;

}
```

The code embedded in the HTML will run. A hacker could use this security hole to steal user information or to perform actions on their behalf. **Only use `dangerouslySetInnerHTML` with trusted and sanitized data.**

---

### Handling mouse events

This example shows some common [mouse events](https://react.dev/reference/react-dom/components/common#mouseevent-handler) and when they fire.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function MouseExample() {
  return (
    <div
      onMouseEnter={e => console.log('onMouseEnter (parent)')}
      onMouseLeave={e => console.log('onMouseLeave (parent)')}
    >
      <button
        onClick={e => console.log('onClick (first button)')}
        onMouseDown={e => console.log('onMouseDown (first button)')}
        onMouseEnter={e => console.log('onMouseEnter (first button)')}
        onMouseLeave={e => console.log('onMouseLeave (first button)')}
        onMouseOver={e => console.log('onMouseOver (first button)')}
        onMouseUp={e => console.log('onMouseUp (first button)')}
      >
        First button
      </button>
      <button
        onClick={e => console.log('onClick (second button)')}
        onMouseDown={e => console.log('onMouseDown (second button)')}
        onMouseEnter={e => console.log('onMouseEnter (second button)')}
        onMouseLeave={e => console.log('onMouseLeave (second button)')}
        onMouseOver={e => console.log('onMouseOver (second button)')}
        onMouseUp={e => console.log('onMouseUp (second button)')}
      >
        Second button
      </button>
    </div>
  );
}
```

Show more

---

### Handling pointer events

This example shows some common [pointer events](https://react.dev/reference/react-dom/components/common#pointerevent-handler) and when they fire.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function PointerExample() {
  return (
    <div
      onPointerEnter={e => console.log('onPointerEnter (parent)')}
      onPointerLeave={e => console.log('onPointerLeave (parent)')}
      style={{ padding: 20, backgroundColor: '#ddd' }}
    >
      <div
        onPointerDown={e => console.log('onPointerDown (first child)')}
        onPointerEnter={e => console.log('onPointerEnter (first child)')}
        onPointerLeave={e => console.log('onPointerLeave (first child)')}
        onPointerMove={e => console.log('onPointerMove (first child)')}
        onPointerUp={e => console.log('onPointerUp (first child)')}
        style={{ padding: 20, backgroundColor: 'lightyellow' }}
      >
        First child
      </div>
      <div
        onPointerDown={e => console.log('onPointerDown (second child)')}
        onPointerEnter={e => console.log('onPointerEnter (second child)')}
        onPointerLeave={e => console.log('onPointerLeave (second child)')}
        onPointerMove={e => console.log('onPointerMove (second child)')}
        onPointerUp={e => console.log('onPointerUp (second child)')}
        style={{ padding: 20, backgroundColor: 'lightblue' }}
      >
        Second child
      </div>
    </div>
  );
}
```

Show more

---

### Handling focus events

In React, [focus events](https://react.dev/reference/react-dom/components/common#focusevent-handler) bubble. You can use the `currentTarget` and `relatedTarget` to differentiate if the focusing or blurring events originated from outside of the parent element. The example shows how to detect focusing a child, focusing the parent element, and how to detect focus entering or leaving the whole subtree.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function FocusExample() {
  return (
    <div
      tabIndex={1}
      onFocus={(e) => {
        if (e.currentTarget === e.target) {
          console.log('focused parent');
        } else {
          console.log('focused child', e.target.name);
        }
        if (!e.currentTarget.contains(e.relatedTarget)) {
          // Not triggered when swapping focus between children
          console.log('focus entered parent');
        }
      }}
      onBlur={(e) => {
        if (e.currentTarget === e.target) {
          console.log('unfocused parent');
        } else {
          console.log('unfocused child', e.target.name);
        }
        if (!e.currentTarget.contains(e.relatedTarget)) {
          // Not triggered when swapping focus between children
          console.log('focus left parent');
        }
      }}
    >
      <label>
        First name:
        <input name="firstName" />
      </label>
      <label>
        Last name:
        <input name="lastName" />
      </label>
    </div>
  );
}
```

Show more

---

### Handling keyboard events

This example shows some common [keyboard events](https://react.dev/reference/react-dom/components/common#keyboardevent-handler) and when they fire.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function KeyboardExample() {
  return (
    <label>
      First name:
      <input
        name="firstName"
        onKeyDown={e => console.log('onKeyDown:', e.key, e.code)}
        onKeyUp={e => console.log('onKeyUp:', e.key, e.code)}
      />
    </label>
  );
}
```

[PreviousComponents](https://react.dev/reference/react-dom/components)[Next<form>](https://react.dev/reference/react-dom/components/form)

---

---


# <form> – React

URL: https://react.dev/reference/react-dom/components/form

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <form>

The [built-in browser `<form>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) lets you create interactive controls for submitting information.

```
<form action={search}>

<input name="query" />

<button type="submit">Search</button>

</form>
```

* [Reference](https://react.dev/reference/react-dom/components/form#reference) 
  + [`<form>`](https://react.dev/reference/react-dom/components/form#form)
* [Usage](https://react.dev/reference/react-dom/components/form#usage) 
  + [Handle form submission on the client](https://react.dev/reference/react-dom/components/form#handle-form-submission-on-the-client)
  + [Handle form submission with a Server Function](https://react.dev/reference/react-dom/components/form#handle-form-submission-with-a-server-function)
  + [Display a pending state during form submission](https://react.dev/reference/react-dom/components/form#display-a-pending-state-during-form-submission)
  + [Optimistically updating form data](https://react.dev/reference/react-dom/components/form#optimistically-updating-form-data)
  + [Handling form submission errors](https://react.dev/reference/react-dom/components/form#handling-form-submission-errors)
  + [Display a form submission error without JavaScript](https://react.dev/reference/react-dom/components/form#display-a-form-submission-error-without-javascript)
  + [Handling multiple submission types](https://react.dev/reference/react-dom/components/form#handling-multiple-submission-types)

---

## Reference

### `<form>`

To create interactive controls for submitting information, render the [built-in browser `<form>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form).

```
<form action={search}>

<input name="query" />

<button type="submit">Search</button>

</form>
```

[See more examples below.](https://react.dev/reference/react-dom/components/form#usage)

#### Props

`<form>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

[`action`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#action): a URL or function. When a URL is passed to `action` the form will behave like the HTML form component. When a function is passed to `action` the function will handle the form submission in a Transition following [the Action prop pattern](https://react.dev/reference/react/useTransition#exposing-action-props-from-components). The function passed to `action` may be async and will be called with a single argument containing the [form data](https://developer.mozilla.org/en-US/docs/Web/API/FormData) of the submitted form. The `action` prop can be overridden by a `formAction` attribute on a `<button>`, `<input type="submit">`, or `<input type="image">` component.

#### Caveats

* When a function is passed to `action` or `formAction` the HTTP method will be POST regardless of value of the `method` prop.

---

## Usage

### Handle form submission on the client

Pass a function to the `action` prop of form to run the function when the form is submitted. [`formData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) will be passed to the function as an argument so you can access the data submitted by the form. This differs from the conventional [HTML action](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#action), which only accepts URLs. After the `action` function succeeds, all uncontrolled field elements in the form are reset.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Search() {
  function search(formData) {
    const query = formData.get("query");
    alert(`You searched for '${query}'`);
  }
  return (
    <form action={search}>
      <input name="query" />
      <button type="submit">Search</button>
    </form>
  );
}
```

### Handle form submission with a Server Function

Render a `<form>` with an input and submit button. Pass a Server Function (a function marked with [`'use server'`](https://react.dev/reference/rsc/use-server)) to the `action` prop of form to run the function when the form is submitted.

Passing a Server Function to `<form action>` allow users to submit forms without JavaScript enabled or before the code has loaded. This is beneficial to users who have a slow connection, device, or have JavaScript disabled and is similar to the way forms work when a URL is passed to the `action` prop.

You can use hidden form fields to provide data to the `<form>`’s action. The Server Function will be called with the hidden form field data as an instance of [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

```
import { updateCart } from './lib.js';

function AddToCart({productId}) {

async function addToCart(formData) {

'use server'

const productId = formData.get('productId')

await updateCart(productId)

}

return (

<form action={addToCart}>

<input type="hidden" name="productId" value={productId} />

<button type="submit">Add to Cart</button>

</form>

);

}
```

In lieu of using hidden form fields to provide data to the `<form>`’s action, you can call the `bind` method to supply it with extra arguments. This will bind a new argument (`productId`) to the function in addition to the `formData` that is passed as an argument to the function.

```
import { updateCart } from './lib.js';

function AddToCart({productId}) {

async function addToCart(productId, formData) {

"use server";

await updateCart(productId)

}

const addProductToCart = addToCart.bind(null, productId);

return (

<form action={addProductToCart}>

<button type="submit">Add to Cart</button>

</form>

);

}
```

When `<form>` is rendered by a [Server Component](https://react.dev/reference/rsc/use-client), and a [Server Function](https://react.dev/reference/rsc/server-functions) is passed to the `<form>`’s `action` prop, the form is [progressively enhanced](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement).

### Display a pending state during form submission

To display a pending state when a form is being submitted, you can call the `useFormStatus` Hook in a component rendered in a `<form>` and read the `pending` property returned.

Here, we use the `pending` property to indicate the form is submitting.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useFormStatus } from "react-dom";
import { submitForm } from "./actions.js";

function Submit() {
  const { pending } = useFormStatus();
  return (
    <button type="submit" disabled={pending}>
      {pending ? "Submitting..." : "Submit"}
    </button>
  );
}

function Form({ action }) {
  return (
    <form action={action}>
      <Submit />
    </form>
  );
}

export default function App() {
  return <Form action={submitForm} />;
}
```

Show more

To learn more about the `useFormStatus` Hook see the [reference documentation](https://react.dev/reference/react-dom/hooks/useFormStatus).

### Optimistically updating form data

The `useOptimistic` Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server’s response to reflect the changes, the interface is immediately updated with the expected outcome.

For example, when a user types a message into the form and hits the “Send” button, the `useOptimistic` Hook allows the message to immediately appear in the list with a “Sending…” label, even before the message is actually sent to a server. This “optimistic” approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the “Sending…” label is removed.

App.jsactions.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useOptimistic, useState, useRef } from "react";
import { deliverMessage } from "./actions.js";

function Thread({ messages, sendMessage }) {
  const formRef = useRef();
  async function formAction(formData) {
    addOptimisticMessage(formData.get("message"));
    formRef.current.reset();
    await sendMessage(formData);
  }
  const [optimisticMessages, addOptimisticMessage] = useOptimistic(
    messages,
    (state, newMessage) => [
      ...state,
      {
        text: newMessage,
        sending: true
      }
    ]
  );

  return (
    <>
      {optimisticMessages.map((message, index) => (
        <div key={index}>
          {message.text}
          {!!message.sending && <small> (Sending...)</small>}
        </div>
      ))}
      <form action={formAction} ref={formRef}>
        <input type="text" name="message" placeholder="Hello!" />
        <button type="submit">Send</button>
      </form>
    </>
  );
}

export default function App() {
  const [messages, setMessages] = useState([
    { text: "Hello there!", sending: false, key: 1 }
  ]);
  async function sendMessage(formData) {
    const sentMessage = await deliverMessage(formData.get("message"));
    setMessages((messages) => [...messages, { text: sentMessage }]);
  }
  return <Thread messages={messages} sendMessage={sendMessage} />;
}
```

Show more

### Handling form submission errors

In some cases the function called by a `<form>`’s `action` prop throws an error. You can handle these errors by wrapping `<form>` in an Error Boundary. If the function called by a `<form>`’s `action` prop throws an error, the fallback for the error boundary will be displayed.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { ErrorBoundary } from "react-error-boundary";

export default function Search() {
  function search() {
    throw new Error("search error");
  }
  return (
    <ErrorBoundary
      fallback={<p>There was an error while submitting the form</p>}
    >
      <form action={search}>
        <input name="query" />
        <button type="submit">Search</button>
      </form>
    </ErrorBoundary>
  );
}
```

Show more

### Display a form submission error without JavaScript

Displaying a form submission error message before the JavaScript bundle loads for progressive enhancement requires that:

1. `<form>` be rendered by a [Client Component](https://react.dev/reference/rsc/use-client)
2. the function passed to the `<form>`’s `action` prop be a [Server Function](https://react.dev/reference/rsc/server-functions)
3. the `useActionState` Hook be used to display the error message

`useActionState` takes two parameters: a [Server Function](https://react.dev/reference/rsc/server-functions) and an initial state. `useActionState` returns two values, a state variable and an action. The action returned by `useActionState` should be passed to the `action` prop of the form. The state variable returned by `useActionState` can be used to display an error message. The value returned by the Server Function passed to `useActionState` will be used to update the state variable.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useActionState } from "react";
import { signUpNewUser } from "./api";

export default function Page() {
  async function signup(prevState, formData) {
    "use server";
    const email = formData.get("email");
    try {
      await signUpNewUser(email);
      alert(`Added "${email}"`);
    } catch (err) {
      return err.toString();
    }
  }
  const [message, signupAction] = useActionState(signup, null);
  return (
    <>
      <h1>Signup for my newsletter</h1>
      <p>Signup with the same email twice to see an error</p>
      <form action={signupAction} id="signup-form">
        <label htmlFor="email">Email: </label>
        <input name="email" id="email" placeholder="react@example.com" />
        <button>Sign up</button>
        {!!message && <p>{message}</p>}
      </form>
    </>
  );
}
```

Show more

Learn more about updating state from a form action with the [`useActionState`](https://react.dev/reference/react/useActionState) docs

### Handling multiple submission types

Forms can be designed to handle multiple submission actions based on the button pressed by the user. Each button inside a form can be associated with a distinct action or behavior by setting the `formAction` prop.

When a user taps a specific button, the form is submitted, and a corresponding action, defined by that button’s attributes and action, is executed. For instance, a form might submit an article for review by default but have a separate button with `formAction` set to save the article as a draft.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function Search() {
  function publish(formData) {
    const content = formData.get("content");
    const button = formData.get("button");
    alert(`'${content}' was published with the '${button}' button`);
  }

  function save(formData) {
    const content = formData.get("content");
    alert(`Your draft of '${content}' has been saved!`);
  }

  return (
    <form action={publish}>
      <textarea name="content" rows={4} cols={40} />
      <br />
      <button type="submit" name="button" value="submit">Publish</button>
      <button formAction={save}>Save draft</button>
    </form>
  );
}
```

Show more

[PreviousCommon (e.g. <div>)](https://react.dev/reference/react-dom/components/common)[Next<input>](https://react.dev/reference/react-dom/components/input)

---

---


# <input> – React

URL: https://react.dev/reference/react-dom/components/input

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <input>

The [built-in browser `<input>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input) lets you render different kinds of form inputs.

```
<input />
```

* [Reference](https://react.dev/reference/react-dom/components/input#reference) 
  + [`<input>`](https://react.dev/reference/react-dom/components/input#input)
* [Usage](https://react.dev/reference/react-dom/components/input#usage) 
  + [Displaying inputs of different types](https://react.dev/reference/react-dom/components/input#displaying-inputs-of-different-types)
  + [Providing a label for an input](https://react.dev/reference/react-dom/components/input#providing-a-label-for-an-input)
  + [Providing an initial value for an input](https://react.dev/reference/react-dom/components/input#providing-an-initial-value-for-an-input)
  + [Reading the input values when submitting a form](https://react.dev/reference/react-dom/components/input#reading-the-input-values-when-submitting-a-form)
  + [Controlling an input with a state variable](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable)
  + [Optimizing re-rendering on every keystroke](https://react.dev/reference/react-dom/components/input#optimizing-re-rendering-on-every-keystroke)
* [Troubleshooting](https://react.dev/reference/react-dom/components/input#troubleshooting) 
  + [My text input doesn’t update when I type into it](https://react.dev/reference/react-dom/components/input#my-text-input-doesnt-update-when-i-type-into-it)
  + [My checkbox doesn’t update when I click on it](https://react.dev/reference/react-dom/components/input#my-checkbox-doesnt-update-when-i-click-on-it)
  + [My input caret jumps to the beginning on every keystroke](https://react.dev/reference/react-dom/components/input#my-input-caret-jumps-to-the-beginning-on-every-keystroke)
  + [I’m getting an error: “A component is changing an uncontrolled input to be controlled”](https://react.dev/reference/react-dom/components/input#im-getting-an-error-a-component-is-changing-an-uncontrolled-input-to-be-controlled)

---

## Reference

### `<input>`

To display an input, render the [built-in browser `<input>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input) component.

```
<input name="myInput" />
```

[See more examples below.](https://react.dev/reference/react-dom/components/input#usage)

#### Props

`<input>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

* [`formAction`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#formaction): A string or function. Overrides the parent `<form action>` for `type="submit"` and `type="image"`. When a URL is passed to `action` the form will behave like a standard HTML form. When a function is passed to `formAction` the function will handle the form submission. See [`<form action>`](https://react.dev/reference/react-dom/components/form#props).

You can [make an input controlled](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable) by passing one of these props:

* [`checked`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement#checked): A boolean. For a checkbox input or a radio button, controls whether it is selected.
* [`value`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement#value): A string. For a text input, controls its text. (For a radio button, specifies its form data.)

When you pass either of them, you must also pass an `onChange` handler that updates the passed value.

These `<input>` props are only relevant for uncontrolled inputs:

* [`defaultChecked`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement#defaultChecked): A boolean. Specifies [the initial value](https://react.dev/reference/react-dom/components/input#providing-an-initial-value-for-an-input) for `type="checkbox"` and `type="radio"` inputs.
* [`defaultValue`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement#defaultValue): A string. Specifies [the initial value](https://react.dev/reference/react-dom/components/input#providing-an-initial-value-for-an-input) for a text input.

These `<input>` props are relevant both for uncontrolled and controlled inputs:

* [`accept`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#accept): A string. Specifies which filetypes are accepted by a `type="file"` input.
* [`alt`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#alt): A string. Specifies the alternative image text for a `type="image"` input.
* [`capture`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#capture): A string. Specifies the media (microphone, video, or camera) captured by a `type="file"` input.
* [`autoComplete`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#autocomplete): A string. Specifies one of the possible [autocomplete behaviors.](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values)
* [`autoFocus`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#autofocus): A boolean. If `true`, React will focus the element on mount.
* [`dirname`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#dirname): A string. Specifies the form field name for the element’s directionality.
* [`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#disabled): A boolean. If `true`, the input will not be interactive and will appear dimmed.
* `children`: `<input>` does not accept children.
* [`form`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#form): A string. Specifies the `id` of the `<form>` this input belongs to. If omitted, it’s the closest parent form.
* [`formAction`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#formaction): A string. Overrides the parent `<form action>` for `type="submit"` and `type="image"`.
* [`formEnctype`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#formenctype): A string. Overrides the parent `<form enctype>` for `type="submit"` and `type="image"`.
* [`formMethod`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#formmethod): A string. Overrides the parent `<form method>` for `type="submit"` and `type="image"`.
* [`formNoValidate`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#formnovalidate): A string. Overrides the parent `<form noValidate>` for `type="submit"` and `type="image"`.
* [`formTarget`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#formtarget): A string. Overrides the parent `<form target>` for `type="submit"` and `type="image"`.
* [`height`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#height): A string. Specifies the image height for `type="image"`.
* [`list`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#list): A string. Specifies the `id` of the `<datalist>` with the autocomplete options.
* [`max`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#max): A number. Specifies the maximum value of numerical and datetime inputs.
* [`maxLength`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#maxlength): A number. Specifies the maximum length of text and other inputs.
* [`min`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#min): A number. Specifies the minimum value of numerical and datetime inputs.
* [`minLength`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#minlength): A number. Specifies the minimum length of text and other inputs.
* [`multiple`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#multiple): A boolean. Specifies whether multiple values are allowed for `<type="file"` and `type="email"`.
* [`name`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#name): A string. Specifies the name for this input that’s [submitted with the form.](https://react.dev/reference/react-dom/components/input#reading-the-input-values-when-submitting-a-form)
* `onChange`: An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Required for [controlled inputs.](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable) Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browser [`input` event.](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
* `onChangeCapture`: A version of `onChange` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onInput`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use `onChange` instead which works similarly.
* `onInputCapture`: A version of `onInput` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onInvalid`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/invalid_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires if an input fails validation on form submit. Unlike the built-in `invalid` event, the React `onInvalid` event bubbles.
* `onInvalidCapture`: A version of `onInvalid` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onSelect`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires after the selection inside the `<input>` changes. React extends the `onSelect` event to also fire for empty selection and on edits (which may affect the selection).
* `onSelectCapture`: A version of `onSelect` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`pattern`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#pattern): A string. Specifies the pattern that the `value` must match.
* [`placeholder`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#placeholder): A string. Displayed in a dimmed color when the input value is empty.
* [`readOnly`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#readonly): A boolean. If `true`, the input is not editable by the user.
* [`required`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#required): A boolean. If `true`, the value must be provided for the form to submit.
* [`size`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#size): A number. Similar to setting width, but the unit depends on the control.
* [`src`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#src): A string. Specifies the image source for a `type="image"` input.
* [`step`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#step): A positive number or an `'any'` string. Specifies the distance between valid values.
* [`type`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#type): A string. One of the [input types.](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types)
* [`width`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#width): A string. Specifies the image width for a `type="image"` input.

#### Caveats

* Checkboxes need `checked` (or `defaultChecked`), not `value` (or `defaultValue`).
* If a text input receives a string `value` prop, it will be [treated as controlled.](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable)
* If a checkbox or a radio button receives a boolean `checked` prop, it will be [treated as controlled.](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable)
* An input can’t be both controlled and uncontrolled at the same time.
* An input cannot switch between being controlled or uncontrolled over its lifetime.
* Every controlled input needs an `onChange` event handler that synchronously updates its backing value.

---

## Usage

### Displaying inputs of different types

To display an input, render an `<input>` component. By default, it will be a text input. You can pass `type="checkbox"` for a checkbox, `type="radio"` for a radio button, [or one of the other input types.](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function MyForm() {
  return (
    <>
      <label>
        Text input: <input name="myInput" />
      </label>
      <hr />
      <label>
        Checkbox: <input type="checkbox" name="myCheckbox" />
      </label>
      <hr />
      <p>
        Radio buttons:
        <label>
          <input type="radio" name="myRadio" value="option1" />
          Option 1
        </label>
        <label>
          <input type="radio" name="myRadio" value="option2" />
          Option 2
        </label>
        <label>
          <input type="radio" name="myRadio" value="option3" />
          Option 3
        </label>
      </p>
    </>
  );
}
```

Show more

---

### Providing a label for an input

Typically, you will place every `<input>` inside a [`<label>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label) tag. This tells the browser that this label is associated with that input. When the user clicks the label, the browser will automatically focus the input. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the associated input.

If you can’t nest `<input>` into a `<label>`, associate them by passing the same ID to `<input id>` and [`<label htmlFor>`.](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/htmlFor) To avoid conflicts between multiple instances of one component, generate such an ID with [`useId`.](https://react.dev/reference/react/useId)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useId } from 'react';

export default function Form() {
  const ageInputId = useId();
  return (
    <>
      <label>
        Your first name:
        <input name="firstName" />
      </label>
      <hr />
      <label htmlFor={ageInputId}>Your age:</label>
      <input id={ageInputId} name="age" type="number" />
    </>
  );
}
```

Show more

---

### Providing an initial value for an input

You can optionally specify the initial value for any input. Pass it as the `defaultValue` string for text inputs. Checkboxes and radio buttons should specify the initial value with the `defaultChecked` boolean instead.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function MyForm() {
  return (
    <>
      <label>
        Text input: <input name="myInput" defaultValue="Some initial value" />
      </label>
      <hr />
      <label>
        Checkbox: <input type="checkbox" name="myCheckbox" defaultChecked={true} />
      </label>
      <hr />
      <p>
        Radio buttons:
        <label>
          <input type="radio" name="myRadio" value="option1" />
          Option 1
        </label>
        <label>
          <input
            type="radio"
            name="myRadio"
            value="option2"
            defaultChecked={true} 
          />
          Option 2
        </label>
        <label>
          <input type="radio" name="myRadio" value="option3" />
          Option 3
        </label>
      </p>
    </>
  );
}
```

Show more

---

### Reading the input values when submitting a form

Add a [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) around your inputs with a [`<button type="submit">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) inside. It will call your `<form onSubmit>` event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling `e.preventDefault()`. Read the form data with [`new FormData(e.target)`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function MyForm() {
  function handleSubmit(e) {
    // Prevent the browser from reloading the page
    e.preventDefault();

    // Read the form data
    const form = e.target;
    const formData = new FormData(form);

    // You can pass formData as a fetch body directly:
    fetch('/some-api', { method: form.method, body: formData });

    // Or you can work with it as a plain object:
    const formJson = Object.fromEntries(formData.entries());
    console.log(formJson);
  }

  return (
    <form method="post" onSubmit={handleSubmit}>
      <label>
        Text input: <input name="myInput" defaultValue="Some initial value" />
      </label>
      <hr />
      <label>
        Checkbox: <input type="checkbox" name="myCheckbox" defaultChecked={true} />
      </label>
      <hr />
      <p>
        Radio buttons:
        <label><input type="radio" name="myRadio" value="option1" /> Option 1</label>
        <label><input type="radio" name="myRadio" value="option2" defaultChecked={true} /> Option 2</label>
        <label><input type="radio" name="myRadio" value="option3" /> Option 3</label>
      </p>
      <hr />
      <button type="reset">Reset form</button>
      <button type="submit">Submit form</button>
    </form>
  );
}
```

Show more

### Note

Give a `name` to every `<input>`, for example `<input name="firstName" defaultValue="Taylor" />`. The `name` you specified will be used as a key in the form data, for example `{ firstName: "Taylor" }`.

### Pitfall

By default, a `<button>` inside a `<form>` without a `type` attribute will submit it. This can be surprising! If you have your own custom `Button` React component, consider using [`<button type="button">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) instead of `<button>` (with no type). Then, to be explicit, use `<button type="submit">` for buttons that *are* supposed to submit the form.

---

### Controlling an input with a state variable

An input like `<input />` is *uncontrolled.* Even if you [pass an initial value](https://react.dev/reference/react-dom/components/input#providing-an-initial-value-for-an-input) like `<input defaultValue="Initial text" />`, your JSX only specifies the initial value. It does not control what the value should be right now.

**To render a *controlled* input, pass the `value` prop to it (or `checked` for checkboxes and radios).** React will force the input to always have the `value` you passed. Usually, you would do this by declaring a [state variable:](https://react.dev/reference/react/useState)

```
function Form() {

const [firstName, setFirstName] = useState(''); // Declare a state variable...

// ...

return (

<input

value={firstName} // ...force the input's value to match the state variable...

onChange={e => setFirstName(e.target.value)} // ... and update the state variable on any edits!

/>

);

}
```

A controlled input makes sense if you needed state anyway—for example, to re-render your UI on every edit:

```
function Form() {

const [firstName, setFirstName] = useState('');

return (

<>

<label>

First name:

<input value={firstName} onChange={e => setFirstName(e.target.value)} />

</label>

{firstName !== '' && <p>Your name is {firstName}.</p>}

...
```

It’s also useful if you want to offer multiple ways to adjust the input state (for example, by clicking a button):

```
function Form() {

// ...

const [age, setAge] = useState('');

const ageAsNumber = Number(age);

return (

<>

<label>

Age:

<input

value={age}

onChange={e => setAge(e.target.value)}

type="number"

/>

<button onClick={() => setAge(ageAsNumber + 10)}>

Add 10 years

</button>
```

The `value` you pass to controlled components should not be `undefined` or `null`. If you need the initial value to be empty (such as with the `firstName` field below), initialize your state variable to an empty string (`''`).

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Form() {
  const [firstName, setFirstName] = useState('');
  const [age, setAge] = useState('20');
  const ageAsNumber = Number(age);
  return (
    <>
      <label>
        First name:
        <input
          value={firstName}
          onChange={e => setFirstName(e.target.value)}
        />
      </label>
      <label>
        Age:
        <input
          value={age}
          onChange={e => setAge(e.target.value)}
          type="number"
        />
        <button onClick={() => setAge(ageAsNumber + 10)}>
          Add 10 years
        </button>
      </label>
      {firstName !== '' &&
        <p>Your name is {firstName}.</p>
      }
      {ageAsNumber > 0 &&
        <p>Your age is {ageAsNumber}.</p>
      }
    </>
  );
}
```

Show more

### Pitfall

**If you pass `value` without `onChange`, it will be impossible to type into the input.** When you control an input by passing some `value` to it, you *force* it to always have the value you passed. So if you pass a state variable as a `value` but forget to update that state variable synchronously during the `onChange` event handler, React will revert the input after every keystroke back to the `value` that you specified.

---

### Optimizing re-rendering on every keystroke

When you use a controlled input, you set the state on every keystroke. If the component containing your state re-renders a large tree, this can get slow. There’s a few ways you can optimize re-rendering performance.

For example, suppose you start with a form that re-renders all page content on every keystroke:

```
function App() {

const [firstName, setFirstName] = useState('');

return (

<>

<form>

<input value={firstName} onChange={e => setFirstName(e.target.value)} />

</form>

<PageContent />

</>

);

}
```

Since `<PageContent />` doesn’t rely on the input state, you can move the input state into its own component:

```
function App() {

return (

<>

<SignupForm />

<PageContent />

</>

);

}

function SignupForm() {

const [firstName, setFirstName] = useState('');

return (

<form>

<input value={firstName} onChange={e => setFirstName(e.target.value)} />

</form>

);

}
```

This significantly improves performance because now only `SignupForm` re-renders on every keystroke.

If there is no way to avoid re-rendering (for example, if `PageContent` depends on the search input’s value), [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue#deferring-re-rendering-for-a-part-of-the-ui) lets you keep the controlled input responsive even in the middle of a large re-render.

---

## Troubleshooting

### My text input doesn’t update when I type into it

If you render an input with `value` but no `onChange`, you will see an error in the console:

```
// 🔴 Bug: controlled text input with no onChange handler

<input value={something} />
```

Console

You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.

As the error message suggests, if you only wanted to [specify the *initial* value,](https://react.dev/reference/react-dom/components/input#providing-an-initial-value-for-an-input) pass `defaultValue` instead:

```
// ✅ Good: uncontrolled input with an initial value

<input defaultValue={something} />
```

If you want [to control this input with a state variable,](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable) specify an `onChange` handler:

```
// ✅ Good: controlled input with onChange

<input value={something} onChange={e => setSomething(e.target.value)} />
```

If the value is intentionally read-only, add a `readOnly` prop to suppress the error:

```
// ✅ Good: readonly controlled input without on change

<input value={something} readOnly={true} />
```

---

### My checkbox doesn’t update when I click on it

If you render a checkbox with `checked` but no `onChange`, you will see an error in the console:

```
// 🔴 Bug: controlled checkbox with no onChange handler

<input type="checkbox" checked={something} />
```

Console

You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.

As the error message suggests, if you only wanted to [specify the *initial* value,](https://react.dev/reference/react-dom/components/input#providing-an-initial-value-for-an-input) pass `defaultChecked` instead:

```
// ✅ Good: uncontrolled checkbox with an initial value

<input type="checkbox" defaultChecked={something} />
```

If you want [to control this checkbox with a state variable,](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable) specify an `onChange` handler:

```
// ✅ Good: controlled checkbox with onChange

<input type="checkbox" checked={something} onChange={e => setSomething(e.target.checked)} />
```

### Pitfall

You need to read `e.target.checked` rather than `e.target.value` for checkboxes.

If the checkbox is intentionally read-only, add a `readOnly` prop to suppress the error:

```
// ✅ Good: readonly controlled input without on change

<input type="checkbox" checked={something} readOnly={true} />
```

---

### My input caret jumps to the beginning on every keystroke

If you [control an input,](https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable) you must update its state variable to the input’s value from the DOM during `onChange`.

You can’t update it to something other than `e.target.value` (or `e.target.checked` for checkboxes):

```
function handleChange(e) {

// 🔴 Bug: updating an input to something other than e.target.value

setFirstName(e.target.value.toUpperCase());

}
```

You also can’t update it asynchronously:

```
function handleChange(e) {

// 🔴 Bug: updating an input asynchronously

setTimeout(() => {

setFirstName(e.target.value);

}, 100);

}
```

To fix your code, update it synchronously to `e.target.value`:

```
function handleChange(e) {

// ✅ Updating a controlled input to e.target.value synchronously

setFirstName(e.target.value);

}
```

If this doesn’t fix the problem, it’s possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentally [resetting state](https://react.dev/learn/preserving-and-resetting-state) on every re-render, for example if the input or one of its parents always receives a different `key` attribute, or if you nest component function definitions (which is not supported and causes the “inner” component to always be considered a different tree).

---

### I’m getting an error: “A component is changing an uncontrolled input to be controlled”

If you provide a `value` to the component, it must remain a string throughout its lifetime.

You cannot pass `value={undefined}` first and later pass `value="some string"` because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string `value`, not `null` or `undefined`.

If your `value` is coming from an API or a state variable, it might be initialized to `null` or `undefined`. In that case, either set it to an empty string (`''`) initially, or pass `value={someValue ?? ''}` to ensure `value` is a string.

Similarly, if you pass `checked` to a checkbox, ensure it’s always a boolean.

[Previous<form>](https://react.dev/reference/react-dom/components/form)[Next<option>](https://react.dev/reference/react-dom/components/option)

---

---


# <option> – React

URL: https://react.dev/reference/react-dom/components/option

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <option>

The [built-in browser `<option>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option) lets you render an option inside a [`<select>`](https://react.dev/reference/react-dom/components/select) box.

```
<select>

<option value="someOption">Some option</option>

<option value="otherOption">Other option</option>

</select>
```

* [Reference](https://react.dev/reference/react-dom/components/option#reference) 
  + [`<option>`](https://react.dev/reference/react-dom/components/option#option)
* [Usage](https://react.dev/reference/react-dom/components/option#usage) 
  + [Displaying a select box with options](https://react.dev/reference/react-dom/components/option#displaying-a-select-box-with-options)

---

## Reference

### `<option>`

The [built-in browser `<option>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option) lets you render an option inside a [`<select>`](https://react.dev/reference/react-dom/components/select) box.

```
<select>

<option value="someOption">Some option</option>

<option value="otherOption">Other option</option>

</select>
```

[See more examples below.](https://react.dev/reference/react-dom/components/option#usage)

#### Props

`<option>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

Additionally, `<option>` supports these props:

* [`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option#disabled): A boolean. If `true`, the option will not be selectable and will appear dimmed.
* [`label`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option#label): A string. Specifies the meaning of the option. If not specified, the text inside the option is used.
* [`value`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option#value): The value to be used [when submitting the parent `<select>` in a form](https://react.dev/reference/react-dom/components/select#reading-the-select-box-value-when-submitting-a-form) if this option is selected.

#### Caveats

* React does not support the `selected` attribute on `<option>`. Instead, pass this option’s `value` to the parent [`<select defaultValue>`](https://react.dev/reference/react-dom/components/select#providing-an-initially-selected-option) for an uncontrolled select box, or [`<select value>`](https://react.dev/reference/react-dom/components/select#controlling-a-select-box-with-a-state-variable) for a controlled select.

---

## Usage

### Displaying a select box with options

Render a `<select>` with a list of `<option>` components inside to display a select box. Give each `<option>` a `value` representing the data to be submitted with the form.

[Read more about displaying a `<select>` with a list of `<option>` components.](https://react.dev/reference/react-dom/components/select)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function FruitPicker() {
  return (
    <label>
      Pick a fruit:
      <select name="selectedFruit">
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
      </select>
    </label>
  );
}
```

[Previous<input>](https://react.dev/reference/react-dom/components/input)[Next<progress>](https://react.dev/reference/react-dom/components/progress)

---

---


# <progress> – React

URL: https://react.dev/reference/react-dom/components/progress

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <progress>

The [built-in browser `<progress>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress) lets you render a progress indicator.

```
<progress value={0.5} />
```

* [Reference](https://react.dev/reference/react-dom/components/progress#reference) 
  + [`<progress>`](https://react.dev/reference/react-dom/components/progress#progress)
* [Usage](https://react.dev/reference/react-dom/components/progress#usage) 
  + [Controlling a progress indicator](https://react.dev/reference/react-dom/components/progress#controlling-a-progress-indicator)

---

## Reference

### `<progress>`

To display a progress indicator, render the [built-in browser `<progress>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress) component.

```
<progress value={0.5} />
```

[See more examples below.](https://react.dev/reference/react-dom/components/progress#usage)

#### Props

`<progress>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

Additionally, `<progress>` supports these props:

* [`max`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress#max): A number. Specifies the maximum `value`. Defaults to `1`.
* [`value`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/progress#value): A number between `0` and `max`, or `null` for indeterminate progress. Specifies how much was done.

---

## Usage

### Controlling a progress indicator

To display a progress indicator, render a `<progress>` component. You can pass a number `value` between `0` and the `max` value you specify. If you don’t pass a `max` value, it will assumed to be `1` by default.

If the operation is not ongoing, pass `value={null}` to put the progress indicator into an indeterminate state.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function App() {
  return (
    <>
      <progress value={0} />
      <progress value={0.5} />
      <progress value={0.7} />
      <progress value={75} max={100} />
      <progress value={1} />
      <progress value={null} />
    </>
  );
}
```

[Previous<option>](https://react.dev/reference/react-dom/components/option)[Next<select>](https://react.dev/reference/react-dom/components/select)

---

---


# <select> – React

URL: https://react.dev/reference/react-dom/components/select

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <select>

The [built-in browser `<select>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select) lets you render a select box with options.

```
<select>

<option value="someOption">Some option</option>

<option value="otherOption">Other option</option>

</select>
```

* [Reference](https://react.dev/reference/react-dom/components/select#reference) 
  + [`<select>`](https://react.dev/reference/react-dom/components/select#select)
* [Usage](https://react.dev/reference/react-dom/components/select#usage) 
  + [Displaying a select box with options](https://react.dev/reference/react-dom/components/select#displaying-a-select-box-with-options)
  + [Providing a label for a select box](https://react.dev/reference/react-dom/components/select#providing-a-label-for-a-select-box)
  + [Providing an initially selected option](https://react.dev/reference/react-dom/components/select#providing-an-initially-selected-option)
  + [Enabling multiple selection](https://react.dev/reference/react-dom/components/select#enabling-multiple-selection)
  + [Reading the select box value when submitting a form](https://react.dev/reference/react-dom/components/select#reading-the-select-box-value-when-submitting-a-form)
  + [Controlling a select box with a state variable](https://react.dev/reference/react-dom/components/select#controlling-a-select-box-with-a-state-variable)

---

## Reference

### `<select>`

To display a select box, render the [built-in browser `<select>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select) component.

```
<select>

<option value="someOption">Some option</option>

<option value="otherOption">Other option</option>

</select>
```

[See more examples below.](https://react.dev/reference/react-dom/components/select#usage)

#### Props

`<select>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

You can [make a select box controlled](https://react.dev/reference/react-dom/components/select#controlling-a-select-box-with-a-state-variable) by passing a `value` prop:

* `value`: A string (or an array of strings for [`multiple={true}`](https://react.dev/reference/react-dom/components/select#enabling-multiple-selection)). Controls which option is selected. Every value string match the `value` of some `<option>` nested inside the `<select>`.

When you pass `value`, you must also pass an `onChange` handler that updates the passed value.

If your `<select>` is uncontrolled, you may pass the `defaultValue` prop instead:

* `defaultValue`: A string (or an array of strings for [`multiple={true}`](https://react.dev/reference/react-dom/components/select#enabling-multiple-selection)). Specifies [the initially selected option.](https://react.dev/reference/react-dom/components/select#providing-an-initially-selected-option)

These `<select>` props are relevant both for uncontrolled and controlled select boxes:

* [`autoComplete`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#autocomplete): A string. Specifies one of the possible [autocomplete behaviors.](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete#values)
* [`autoFocus`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#autofocus): A boolean. If `true`, React will focus the element on mount.
* `children`: `<select>` accepts [`<option>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/option), [`<optgroup>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/optgroup), and [`<datalist>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/datalist) components as children. You can also pass your own components as long as they eventually render one of the allowed components. If you pass your own components that eventually render `<option>` tags, each `<option>` you render must have a `value`.
* [`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#disabled): A boolean. If `true`, the select box will not be interactive and will appear dimmed.
* [`form`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#form): A string. Specifies the `id` of the `<form>` this select box belongs to. If omitted, it’s the closest parent form.
* [`multiple`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#multiple): A boolean. If `true`, the browser allows [multiple selection.](https://react.dev/reference/react-dom/components/select#enabling-multiple-selection)
* [`name`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#name): A string. Specifies the name for this select box that’s [submitted with the form.](https://react.dev/reference/react-dom/components/select#reading-the-select-box-value-when-submitting-a-form)
* `onChange`: An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Required for [controlled select boxes.](https://react.dev/reference/react-dom/components/select#controlling-a-select-box-with-a-state-variable) Fires immediately when the user picks a different option. Behaves like the browser [`input` event.](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
* `onChangeCapture`: A version of `onChange` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onInput`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use `onChange` instead which works similarly.
* `onInputCapture`: A version of `onInput` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onInvalid`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/invalid_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires if an input fails validation on form submit. Unlike the built-in `invalid` event, the React `onInvalid` event bubbles.
* `onInvalidCapture`: A version of `onInvalid` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`required`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#required): A boolean. If `true`, the value must be provided for the form to submit.
* [`size`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/select#size): A number. For `multiple={true}` selects, specifies the preferred number of initially visible items.

#### Caveats

* Unlike in HTML, passing a `selected` attribute to `<option>` is not supported. Instead, use [`<select defaultValue>`](https://react.dev/reference/react-dom/components/select#providing-an-initially-selected-option) for uncontrolled select boxes and [`<select value>`](https://react.dev/reference/react-dom/components/select#controlling-a-select-box-with-a-state-variable) for controlled select boxes.
* If a select box receives a `value` prop, it will be [treated as controlled.](https://react.dev/reference/react-dom/components/select#controlling-a-select-box-with-a-state-variable)
* A select box can’t be both controlled and uncontrolled at the same time.
* A select box cannot switch between being controlled or uncontrolled over its lifetime.
* Every controlled select box needs an `onChange` event handler that synchronously updates its backing value.

---

## Usage

### Displaying a select box with options

Render a `<select>` with a list of `<option>` components inside to display a select box. Give each `<option>` a `value` representing the data to be submitted with the form.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function FruitPicker() {
  return (
    <label>
      Pick a fruit:
      <select name="selectedFruit">
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
      </select>
    </label>
  );
}
```

---

### Providing a label for a select box

Typically, you will place every `<select>` inside a [`<label>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label) tag. This tells the browser that this label is associated with that select box. When the user clicks the label, the browser will automatically focus the select box. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the select box.

If you can’t nest `<select>` into a `<label>`, associate them by passing the same ID to `<select id>` and [`<label htmlFor>`.](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/htmlFor) To avoid conflicts between multiple instances of one component, generate such an ID with [`useId`.](https://react.dev/reference/react/useId)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useId } from 'react';

export default function Form() {
  const vegetableSelectId = useId();
  return (
    <>
      <label>
        Pick a fruit:
        <select name="selectedFruit">
          <option value="apple">Apple</option>
          <option value="banana">Banana</option>
          <option value="orange">Orange</option>
        </select>
      </label>
      <hr />
      <label htmlFor={vegetableSelectId}>
        Pick a vegetable:
      </label>
      <select id={vegetableSelectId} name="selectedVegetable">
        <option value="cucumber">Cucumber</option>
        <option value="corn">Corn</option>
        <option value="tomato">Tomato</option>
      </select>
    </>
  );
}
```

Show more

---

### Providing an initially selected option

By default, the browser will select the first `<option>` in the list. To select a different option by default, pass that `<option>`’s `value` as the `defaultValue` to the `<select>` element.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function FruitPicker() {
  return (
    <label>
      Pick a fruit:
      <select name="selectedFruit" defaultValue="orange">
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
      </select>
    </label>
  );
}
```

### Pitfall

Unlike in HTML, passing a `selected` attribute to an individual `<option>` is not supported.

---

### Enabling multiple selection

Pass `multiple={true}` to the `<select>` to let the user select multiple options. In that case, if you also specify `defaultValue` to choose the initially selected options, it must be an array.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function FruitPicker() {
  return (
    <label>
      Pick some fruits:
      <select
        name="selectedFruit"
        defaultValue={['orange', 'banana']}
        multiple={true}
      >
        <option value="apple">Apple</option>
        <option value="banana">Banana</option>
        <option value="orange">Orange</option>
      </select>
    </label>
  );
}
```

Show more

---

### Reading the select box value when submitting a form

Add a [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) around your select box with a [`<button type="submit">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) inside. It will call your `<form onSubmit>` event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling `e.preventDefault()`. Read the form data with [`new FormData(e.target)`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function EditPost() {
  function handleSubmit(e) {
    // Prevent the browser from reloading the page
    e.preventDefault();
    // Read the form data
    const form = e.target;
    const formData = new FormData(form);
    // You can pass formData as a fetch body directly:
    fetch('/some-api', { method: form.method, body: formData });
    // You can generate a URL out of it, as the browser does by default:
    console.log(new URLSearchParams(formData).toString());
    // You can work with it as a plain object.
    const formJson = Object.fromEntries(formData.entries());
    console.log(formJson); // (!) This doesn't include multiple select values
    // Or you can get an array of name-value pairs.
    console.log([...formData.entries()]);
  }

  return (
    <form method="post" onSubmit={handleSubmit}>
      <label>
        Pick your favorite fruit:
        <select name="selectedFruit" defaultValue="orange">
          <option value="apple">Apple</option>
          <option value="banana">Banana</option>
          <option value="orange">Orange</option>
        </select>
      </label>
      <label>
        Pick all your favorite vegetables:
        <select
          name="selectedVegetables"
          multiple={true}
          defaultValue={['corn', 'tomato']}
        >
          <option value="cucumber">Cucumber</option>
          <option value="corn">Corn</option>
          <option value="tomato">Tomato</option>
        </select>
      </label>
      <hr />
      <button type="reset">Reset</button>
      <button type="submit">Submit</button>
    </form>
  );
}
```

Show more

### Note

Give a `name` to your `<select>`, for example `<select name="selectedFruit" />`. The `name` you specified will be used as a key in the form data, for example `{ selectedFruit: "orange" }`.

If you use `<select multiple={true}>`, the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) you’ll read from the form will include each selected value as a separate name-value pair. Look closely at the console logs in the example above.

### Pitfall

By default, *any* `<button>` inside a `<form>` will submit it. This can be surprising! If you have your own custom `Button` React component, consider returning [`<button type="button">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/button) instead of `<button>`. Then, to be explicit, use `<button type="submit">` for buttons that *are* supposed to submit the form.

---

### Controlling a select box with a state variable

A select box like `<select />` is *uncontrolled.* Even if you [pass an initially selected value](https://react.dev/reference/react-dom/components/select#providing-an-initially-selected-option) like `<select defaultValue="orange" />`, your JSX only specifies the initial value, not the value right now.

**To render a *controlled* select box, pass the `value` prop to it.** React will force the select box to always have the `value` you passed. Typically, you will control a select box by declaring a [state variable:](https://react.dev/reference/react/useState)

```
function FruitPicker() {

const [selectedFruit, setSelectedFruit] = useState('orange'); // Declare a state variable...

// ...

return (

<select

value={selectedFruit} // ...force the select's value to match the state variable...

onChange={e => setSelectedFruit(e.target.value)} // ... and update the state variable on any change!

>

<option value="apple">Apple</option>

<option value="banana">Banana</option>

<option value="orange">Orange</option>

</select>

);

}
```

This is useful if you want to re-render some part of the UI in response to every selection.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function FruitPicker() {
  const [selectedFruit, setSelectedFruit] = useState('orange');
  const [selectedVegs, setSelectedVegs] = useState(['corn', 'tomato']);
  return (
    <>
      <label>
        Pick a fruit:
        <select
          value={selectedFruit}
          onChange={e => setSelectedFruit(e.target.value)}
        >
          <option value="apple">Apple</option>
          <option value="banana">Banana</option>
          <option value="orange">Orange</option>
        </select>
      </label>
      <hr />
      <label>
        Pick all your favorite vegetables:
        <select
          multiple={true}
          value={selectedVegs}
          onChange={e => {
            const options = [...e.target.selectedOptions];
            const values = options.map(option => option.value);
            setSelectedVegs(values);
          }}
        >
          <option value="cucumber">Cucumber</option>
          <option value="corn">Corn</option>
          <option value="tomato">Tomato</option>
        </select>
      </label>
      <hr />
      <p>Your favorite fruit: {selectedFruit}</p>
      <p>Your favorite vegetables: {selectedVegs.join(', ')}</p>
    </>
  );
}
```

Show more

### Pitfall

**If you pass `value` without `onChange`, it will be impossible to select an option.** When you control a select box by passing some `value` to it, you *force* it to always have the value you passed. So if you pass a state variable as a `value` but forget to update that state variable synchronously during the `onChange` event handler, React will revert the select box after every keystroke back to the `value` that you specified.

Unlike in HTML, passing a `selected` attribute to an individual `<option>` is not supported.

[Previous<progress>](https://react.dev/reference/react-dom/components/progress)[Next<textarea>](https://react.dev/reference/react-dom/components/textarea)

---

---


# <textarea> – React

URL: https://react.dev/reference/react-dom/components/textarea

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <textarea>

The [built-in browser `<textarea>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea) lets you render a multiline text input.

```
<textarea />
```

* [Reference](https://react.dev/reference/react-dom/components/textarea#reference) 
  + [`<textarea>`](https://react.dev/reference/react-dom/components/textarea#textarea)
* [Usage](https://react.dev/reference/react-dom/components/textarea#usage) 
  + [Displaying a text area](https://react.dev/reference/react-dom/components/textarea#displaying-a-text-area)
  + [Providing a label for a text area](https://react.dev/reference/react-dom/components/textarea#providing-a-label-for-a-text-area)
  + [Providing an initial value for a text area](https://react.dev/reference/react-dom/components/textarea#providing-an-initial-value-for-a-text-area)
  + [Reading the text area value when submitting a form](https://react.dev/reference/react-dom/components/textarea#reading-the-text-area-value-when-submitting-a-form)
  + [Controlling a text area with a state variable](https://react.dev/reference/react-dom/components/textarea#controlling-a-text-area-with-a-state-variable)
* [Troubleshooting](https://react.dev/reference/react-dom/components/textarea#troubleshooting) 
  + [My text area doesn’t update when I type into it](https://react.dev/reference/react-dom/components/textarea#my-text-area-doesnt-update-when-i-type-into-it)
  + [My text area caret jumps to the beginning on every keystroke](https://react.dev/reference/react-dom/components/textarea#my-text-area-caret-jumps-to-the-beginning-on-every-keystroke)
  + [I’m getting an error: “A component is changing an uncontrolled input to be controlled”](https://react.dev/reference/react-dom/components/textarea#im-getting-an-error-a-component-is-changing-an-uncontrolled-input-to-be-controlled)

---

## Reference

### `<textarea>`

To display a text area, render the [built-in browser `<textarea>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea) component.

```
<textarea name="postContent" />
```

[See more examples below.](https://react.dev/reference/react-dom/components/textarea#usage)

#### Props

`<textarea>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

You can [make a text area controlled](https://react.dev/reference/react-dom/components/textarea#controlling-a-text-area-with-a-state-variable) by passing a `value` prop:

* `value`: A string. Controls the text inside the text area.

When you pass `value`, you must also pass an `onChange` handler that updates the passed value.

If your `<textarea>` is uncontrolled, you may pass the `defaultValue` prop instead:

* `defaultValue`: A string. Specifies [the initial value](https://react.dev/reference/react-dom/components/textarea#providing-an-initial-value-for-a-text-area) for a text area.

These `<textarea>` props are relevant both for uncontrolled and controlled text areas:

* [`autoComplete`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#autocomplete): Either `'on'` or `'off'`. Specifies the autocomplete behavior.
* [`autoFocus`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#autofocus): A boolean. If `true`, React will focus the element on mount.
* `children`: `<textarea>` does not accept children. To set the initial value, use `defaultValue`.
* [`cols`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#cols): A number. Specifies the default width in average character widths. Defaults to `20`.
* [`disabled`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#disabled): A boolean. If `true`, the input will not be interactive and will appear dimmed.
* [`form`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#form): A string. Specifies the `id` of the `<form>` this input belongs to. If omitted, it’s the closest parent form.
* [`maxLength`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#maxlength): A number. Specifies the maximum length of text.
* [`minLength`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#minlength): A number. Specifies the minimum length of text.
* [`name`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#name): A string. Specifies the name for this input that’s [submitted with the form.](https://react.dev/reference/react-dom/components/textarea#reading-the-textarea-value-when-submitting-a-form)
* `onChange`: An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Required for [controlled text areas.](https://react.dev/reference/react-dom/components/textarea#controlling-a-text-area-with-a-state-variable) Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browser [`input` event.](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event)
* `onChangeCapture`: A version of `onChange` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onInput`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use `onChange` instead which works similarly.
* `onInputCapture`: A version of `onInput` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onInvalid`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/invalid_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires if an input fails validation on form submit. Unlike the built-in `invalid` event, the React `onInvalid` event bubbles.
* `onInvalidCapture`: A version of `onInvalid` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`onSelect`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLTextAreaElement/select_event): An [`Event` handler](https://react.dev/reference/react-dom/components/common#event-handler) function. Fires after the selection inside the `<textarea>` changes. React extends the `onSelect` event to also fire for empty selection and on edits (which may affect the selection).
* `onSelectCapture`: A version of `onSelect` that fires in the [capture phase.](https://react.dev/learn/responding-to-events#capture-phase-events)
* [`placeholder`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#placeholder): A string. Displayed in a dimmed color when the text area value is empty.
* [`readOnly`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#readonly): A boolean. If `true`, the text area is not editable by the user.
* [`required`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#required): A boolean. If `true`, the value must be provided for the form to submit.
* [`rows`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#rows): A number. Specifies the default height in average character heights. Defaults to `2`.
* [`wrap`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#wrap): Either `'hard'`, `'soft'`, or `'off'`. Specifies how the text should be wrapped when submitting a form.

#### Caveats

* Passing children like `<textarea>something</textarea>` is not allowed. [Use `defaultValue` for initial content.](https://react.dev/reference/react-dom/components/textarea#providing-an-initial-value-for-a-text-area)
* If a text area receives a string `value` prop, it will be [treated as controlled.](https://react.dev/reference/react-dom/components/textarea#controlling-a-text-area-with-a-state-variable)
* A text area can’t be both controlled and uncontrolled at the same time.
* A text area cannot switch between being controlled or uncontrolled over its lifetime.
* Every controlled text area needs an `onChange` event handler that synchronously updates its backing value.

---

## Usage

### Displaying a text area

Render `<textarea>` to display a text area. You can specify its default size with the [`rows`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#rows) and [`cols`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#cols) attributes, but by default the user will be able to resize it. To disable resizing, you can specify `resize: none` in the CSS.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function NewPost() {
  return (
    <label>
      Write your post:
      <textarea name="postContent" rows={4} cols={40} />
    </label>
  );
}
```

---

### Providing a label for a text area

Typically, you will place every `<textarea>` inside a [`<label>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/label) tag. This tells the browser that this label is associated with that text area. When the user clicks the label, the browser will focus the text area. It’s also essential for accessibility: a screen reader will announce the label caption when the user focuses the text area.

If you can’t nest `<textarea>` into a `<label>`, associate them by passing the same ID to `<textarea id>` and [`<label htmlFor>`.](https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement/htmlFor) To avoid conflicts between instances of one component, generate such an ID with [`useId`.](https://react.dev/reference/react/useId)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useId } from 'react';

export default function Form() {
  const postTextAreaId = useId();
  return (
    <>
      <label htmlFor={postTextAreaId}>
        Write your post:
      </label>
      <textarea
        id={postTextAreaId}
        name="postContent"
        rows={4}
        cols={40}
      />
    </>
  );
}
```

Show more

---

### Providing an initial value for a text area

You can optionally specify the initial value for the text area. Pass it as the `defaultValue` string.

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function EditPost() {
  return (
    <label>
      Edit your post:
      <textarea
        name="postContent"
        defaultValue="I really enjoyed biking yesterday!"
        rows={4}
        cols={40}
      />
    </label>
  );
}
```

### Pitfall

Unlike in HTML, passing initial text like `<textarea>Some content</textarea>` is not supported.

---

### Reading the text area value when submitting a form

Add a [`<form>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) around your textarea with a [`<button type="submit">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button) inside. It will call your `<form onSubmit>` event handler. By default, the browser will send the form data to the current URL and refresh the page. You can override that behavior by calling `e.preventDefault()`. Read the form data with [`new FormData(e.target)`](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function EditPost() {
  function handleSubmit(e) {
    // Prevent the browser from reloading the page
    e.preventDefault();

    // Read the form data
    const form = e.target;
    const formData = new FormData(form);

    // You can pass formData as a fetch body directly:
    fetch('/some-api', { method: form.method, body: formData });

    // Or you can work with it as a plain object:
    const formJson = Object.fromEntries(formData.entries());
    console.log(formJson);
  }

  return (
    <form method="post" onSubmit={handleSubmit}>
      <label>
        Post title: <input name="postTitle" defaultValue="Biking" />
      </label>
      <label>
        Edit your post:
        <textarea
          name="postContent"
          defaultValue="I really enjoyed biking yesterday!"
          rows={4}
          cols={40}
        />
      </label>
      <hr />
      <button type="reset">Reset edits</button>
      <button type="submit">Save post</button>
    </form>
  );
}
```

Show more

### Note

Give a `name` to your `<textarea>`, for example `<textarea name="postContent" />`. The `name` you specified will be used as a key in the form data, for example `{ postContent: "Your post" }`.

### Pitfall

By default, *any* `<button>` inside a `<form>` will submit it. This can be surprising! If you have your own custom `Button` React component, consider returning [`<button type="button">`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/button) instead of `<button>`. Then, to be explicit, use `<button type="submit">` for buttons that *are* supposed to submit the form.

---

### Controlling a text area with a state variable

A text area like `<textarea />` is *uncontrolled.* Even if you [pass an initial value](https://react.dev/reference/react-dom/components/textarea#providing-an-initial-value-for-a-text-area) like `<textarea defaultValue="Initial text" />`, your JSX only specifies the initial value, not the value right now.

**To render a *controlled* text area, pass the `value` prop to it.** React will force the text area to always have the `value` you passed. Typically, you will control a text area by declaring a [state variable:](https://react.dev/reference/react/useState)

```
function NewPost() {

const [postContent, setPostContent] = useState(''); // Declare a state variable...

// ...

return (

<textarea

value={postContent} // ...force the input's value to match the state variable...

onChange={e => setPostContent(e.target.value)} // ... and update the state variable on any edits!

/>

);

}
```

This is useful if you want to re-render some part of the UI in response to every keystroke.

package.jsonApp.jsMarkdownPreview.js

package.json

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
{
  "dependencies": {
    "react": "latest",
    "react-dom": "latest",
    "react-scripts": "latest",
    "remarkable": "2.0.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject"
  },
  "devDependencies": {}
}
```

### Pitfall

**If you pass `value` without `onChange`, it will be impossible to type into the text area.** When you control a text area by passing some `value` to it, you *force* it to always have the value you passed. So if you pass a state variable as a `value` but forget to update that state variable synchronously during the `onChange` event handler, React will revert the text area after every keystroke back to the `value` that you specified.

---

## Troubleshooting

### My text area doesn’t update when I type into it

If you render a text area with `value` but no `onChange`, you will see an error in the console:

```
// 🔴 Bug: controlled text area with no onChange handler

<textarea value={something} />
```

Console

You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.

As the error message suggests, if you only wanted to [specify the *initial* value,](https://react.dev/reference/react-dom/components/textarea#providing-an-initial-value-for-a-text-area) pass `defaultValue` instead:

```
// ✅ Good: uncontrolled text area with an initial value

<textarea defaultValue={something} />
```

If you want [to control this text area with a state variable,](https://react.dev/reference/react-dom/components/textarea#controlling-a-text-area-with-a-state-variable) specify an `onChange` handler:

```
// ✅ Good: controlled text area with onChange

<textarea value={something} onChange={e => setSomething(e.target.value)} />
```

If the value is intentionally read-only, add a `readOnly` prop to suppress the error:

```
// ✅ Good: readonly controlled text area without on change

<textarea value={something} readOnly={true} />
```

---

### My text area caret jumps to the beginning on every keystroke

If you [control a text area,](https://react.dev/reference/react-dom/components/textarea#controlling-a-text-area-with-a-state-variable) you must update its state variable to the text area’s value from the DOM during `onChange`.

You can’t update it to something other than `e.target.value`:

```
function handleChange(e) {

// 🔴 Bug: updating an input to something other than e.target.value

setFirstName(e.target.value.toUpperCase());

}
```

You also can’t update it asynchronously:

```
function handleChange(e) {

// 🔴 Bug: updating an input asynchronously

setTimeout(() => {

setFirstName(e.target.value);

}, 100);

}
```

To fix your code, update it synchronously to `e.target.value`:

```
function handleChange(e) {

// ✅ Updating a controlled input to e.target.value synchronously

setFirstName(e.target.value);

}
```

If this doesn’t fix the problem, it’s possible that the text area gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentally [resetting state](https://react.dev/learn/preserving-and-resetting-state) on every re-render. For example, this can happen if the text area or one of its parents always receives a different `key` attribute, or if you nest component definitions (which is not allowed in React and causes the “inner” component to remount on every render).

---

### I’m getting an error: “A component is changing an uncontrolled input to be controlled”

If you provide a `value` to the component, it must remain a string throughout its lifetime.

You cannot pass `value={undefined}` first and later pass `value="some string"` because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string `value`, not `null` or `undefined`.

If your `value` is coming from an API or a state variable, it might be initialized to `null` or `undefined`. In that case, either set it to an empty string (`''`) initially, or pass `value={someValue ?? ''}` to ensure `value` is a string.

[Previous<select>](https://react.dev/reference/react-dom/components/select)[Next<link>](https://react.dev/reference/react-dom/components/link)

---

---


# <link> – React

URL: https://react.dev/reference/react-dom/components/link

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <link>

The [built-in browser `<link>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link) lets you use external resources such as stylesheets or annotate the document with link metadata.

```
<link rel="icon" href="favicon.ico" />
```

* [Reference](https://react.dev/reference/react-dom/components/link#reference) 
  + [`<link>`](https://react.dev/reference/react-dom/components/link#link)
* [Usage](https://react.dev/reference/react-dom/components/link#usage) 
  + [Linking to related resources](https://react.dev/reference/react-dom/components/link#linking-to-related-resources)
  + [Linking to a stylesheet](https://react.dev/reference/react-dom/components/link#linking-to-a-stylesheet)
  + [Controlling stylesheet precedence](https://react.dev/reference/react-dom/components/link#controlling-stylesheet-precedence)
  + [Deduplicated stylesheet rendering](https://react.dev/reference/react-dom/components/link#deduplicated-stylesheet-rendering)
  + [Annotating specific items within the document with links](https://react.dev/reference/react-dom/components/link#annotating-specific-items-within-the-document-with-links)

---

## Reference

### `<link>`

To link to external resources such as stylesheets, fonts, and icons, or to annotate the document with link metadata, render the [built-in browser `<link>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link). You can render `<link>` from any component and React will [in most cases](https://react.dev/reference/react-dom/components/link#special-rendering-behavior) place the corresponding DOM element in the document head.

```
<link rel="icon" href="favicon.ico" />
```

[See more examples below.](https://react.dev/reference/react-dom/components/link#usage)

#### Props

`<link>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

* `rel`: a string, required. Specifies the [relationship to the resource](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel). React [treats links with `rel="stylesheet"` differently](https://react.dev/reference/react-dom/components/link#special-rendering-behavior) from other links.

These props apply when `rel="stylesheet"`:

* `precedence`: a string. Tells React where to rank the `<link>` DOM node relative to others in the document `<head>`, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are `<link>` or inline `<style>` tags or loaded using [`preinit`](https://react.dev/reference/react-dom/preinit) functions.
* `media`: a string. Restricts the stylesheet to a certain [media query](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries).
* `title`: a string. Specifies the name of an [alternative stylesheet](https://developer.mozilla.org/en-US/docs/Web/CSS/Alternative_style_sheets).

These props apply when `rel="stylesheet"` but disable React’s [special treatment of stylesheets](https://react.dev/reference/react-dom/components/link#special-rendering-behavior):

* `disabled`: a boolean. Disables the stylesheet.
* `onError`: a function. Called when the stylesheet fails to load.
* `onLoad`: a function. Called when the stylesheet finishes being loaded.

These props apply when `rel="preload"` or `rel="modulepreload"`:

* `as`: a string. The type of resource. Its possible values are `audio`, `document`, `embed`, `fetch`, `font`, `image`, `object`, `script`, `style`, `track`, `video`, `worker`.
* `imageSrcSet`: a string. Applicable only when `as="image"`. Specifies the [source set of the image](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images).
* `imageSizes`: a string. Applicable only when `as="image"`. Specifies the [sizes of the image](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images).

These props apply when `rel="icon"` or `rel="apple-touch-icon"`:

* `sizes`: a string. The [sizes of the icon](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images).

These props apply in all cases:

* `href`: a string. The URL of the linked resource.
* `crossOrigin`: a string. The [CORS policy](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) to use. Its possible values are `anonymous` and `use-credentials`. It is required when `as` is set to `"fetch"`.
* `referrerPolicy`: a string. The [Referrer header](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#referrerpolicy) to send when fetching. Its possible values are `no-referrer-when-downgrade` (the default), `no-referrer`, `origin`, `origin-when-cross-origin`, and `unsafe-url`.
* `fetchPriority`: a string. Suggests a relative priority for fetching the resource. The possible values are `auto` (the default), `high`, and `low`.
* `hrefLang`: a string. The language of the linked resource.
* `integrity`: a string. A cryptographic hash of the resource, to [verify its authenticity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity).
* `type`: a string. The MIME type of the linked resource.

Props that are **not recommended** for use with React:

* `blocking`: a string. If set to `"render"`, instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.

#### Special rendering behavior

React will always place the DOM element corresponding to the `<link>` component within the document’s `<head>`, regardless of where in the React tree it is rendered. The `<head>` is the only valid place for `<link>` to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render `<link>` components itself.

There are a few exceptions to this:

* If the `<link>` has a `rel="stylesheet"` prop, then it has to also have a `precedence` prop to get this special behavior. This is because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the `precedence` prop. If the `precedence` prop is omitted, there is no special behavior.
* If the `<link>` has an [`itemProp`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemprop) prop, there is no special behavior, because in this case it doesn’t apply to the document but instead represents metadata about a specific part of the page.
* If the `<link>` has an `onLoad` or `onError` prop, because in that case you are managing the loading of the linked resource manually within your React component.

#### Special behavior for stylesheets

In addition, if the `<link>` is to a stylesheet (namely, it has `rel="stylesheet"` in its props), React treats it specially in the following ways:

* The component that renders `<link>` will [suspend](https://react.dev/reference/react/Suspense) while the stylesheet is loading.
* If multiple components render links to the same stylesheet, React will de-duplicate them and only put a single link into the DOM. Two links are considered the same if they have the same `href` prop.

There are two exception to this special behavior:

* If the link doesn’t have a `precedence` prop, there is no special behavior, because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the `precedence` prop.
* If you supply any of the `onLoad`, `onError`, or `disabled` props, there is no special behavior, because these props indicate that you are managing the loading of the stylesheet manually within your component.

This special treatment comes with two caveats:

* React will ignore changes to props after the link has been rendered. (React will issue a warning in development if this happens.)
* React may leave the link in the DOM even after the component that rendered it has been unmounted.

---

## Usage

### Linking to related resources

You can annotate the document with links to related resources such as an icon, canonical URL, or pingback. React will place this metadata within the document `<head>` regardless of where in the React tree it is rendered.

App.jsShowRenderedHTML.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function BlogPage() {
  return (
    <ShowRenderedHTML>
      <link rel="icon" href="favicon.ico" />
      <link rel="pingback" href="http://www.example.com/xmlrpc.php" />
      <h1>My Blog</h1>
      <p>...</p>
    </ShowRenderedHTML>
  );
}
```

### Linking to a stylesheet

If a component depends on a certain stylesheet in order to be displayed correctly, you can render a link to that stylesheet within the component. Your component will [suspend](https://react.dev/reference/react/Suspense) while the stylesheet is loading. You must supply the `precedence` prop, which tells React where to place this stylesheet relative to others — stylesheets with higher precedence can override those with lower precedence.

### Note

When you want to use a stylesheet, it can be beneficial to call the [preinit](https://react.dev/reference/react-dom/preinit) function. Calling this function may allow the browser to start fetching the stylesheet earlier than if you just render a `<link>` component, for example by sending an [HTTP Early Hints response](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).

App.jsShowRenderedHTML.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function SiteMapPage() {
  return (
    <ShowRenderedHTML>
      <link rel="stylesheet" href="sitemap.css" precedence="medium" />
      <p>...</p>
    </ShowRenderedHTML>
  );
}
```

### Controlling stylesheet precedence

Stylesheets can conflict with each other, and when they do, the browser goes with the one that comes later in the document. React lets you control the order of stylesheets with the `precedence` prop. In this example, three components render stylesheets, and the ones with the same precedence are grouped together in the `<head>`.

App.jsShowRenderedHTML.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function HomePage() {
  return (
    <ShowRenderedHTML>
      <FirstComponent />
      <SecondComponent />
      <ThirdComponent/>
      ...
    </ShowRenderedHTML>
  );
}

function FirstComponent() {
  return <link rel="stylesheet" href="first.css" precedence="first" />;
}

function SecondComponent() {
  return <link rel="stylesheet" href="second.css" precedence="second" />;
}

function ThirdComponent() {
  return <link rel="stylesheet" href="third.css" precedence="first" />;
}
```

Show more

Note the `precedence` values themselves are arbitrary and their naming is up to you. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”.

### Deduplicated stylesheet rendering

If you render the same stylesheet from multiple components, React will place only a single `<link>` in the document head.

App.jsShowRenderedHTML.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function HomePage() {
  return (
    <ShowRenderedHTML>
      <Component />
      <Component />
      ...
    </ShowRenderedHTML>
  );
}

function Component() {
  return <link rel="stylesheet" href="styles.css" precedence="medium" />;
}
```

### Annotating specific items within the document with links

You can use the `<link>` component with the `itemProp` prop to annotate specific items within the document with links to related resources. In this case, React will *not* place these annotations within the document `<head>` but will place them like any other React component.

```
<section itemScope>

<h3>Annotating specific items</h3>

<link itemProp="author" href="http://example.com/" />

<p>...</p>

</section>
```

[Previous<textarea>](https://react.dev/reference/react-dom/components/textarea)[Next<meta>](https://react.dev/reference/react-dom/components/meta)

---

---


# <meta> – React

URL: https://react.dev/reference/react-dom/components/meta

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <meta>

The [built-in browser `<meta>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta) lets you add metadata to the document.

```
<meta name="keywords" content="React, JavaScript, semantic markup, html" />
```

* [Reference](https://react.dev/reference/react-dom/components/meta#reference) 
  + [`<meta>`](https://react.dev/reference/react-dom/components/meta#meta)
* [Usage](https://react.dev/reference/react-dom/components/meta#usage) 
  + [Annotating the document with metadata](https://react.dev/reference/react-dom/components/meta#annotating-the-document-with-metadata)
  + [Annotating specific items within the document with metadata](https://react.dev/reference/react-dom/components/meta#annotating-specific-items-within-the-document-with-metadata)

---

## Reference

### `<meta>`

To add document metadata, render the [built-in browser `<meta>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta). You can render `<meta>` from any component and React will always place the corresponding DOM element in the document head.

```
<meta name="keywords" content="React, JavaScript, semantic markup, html" />
```

[See more examples below.](https://react.dev/reference/react-dom/components/meta#usage)

#### Props

`<meta>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

It should have *exactly one* of the following props: `name`, `httpEquiv`, `charset`, `itemProp`. The `<meta>` component does something different depending on which of these props is specified.

* `name`: a string. Specifies the [kind of metadata](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta/name) to be attached to the document.
* `charset`: a string. Specifies the character set used by the document. The only valid value is `"utf-8"`.
* `httpEquiv`: a string. Specifies a directive for processing the document.
* `itemProp`: a string. Specifies metadata about a particular item within the document rather than the document as a whole.
* `content`: a string. Specifies the metadata to be attached when used with the `name` or `itemProp` props or the behavior of the directive when used with the `httpEquiv` prop.

#### Special rendering behavior

React will always place the DOM element corresponding to the `<meta>` component within the document’s `<head>`, regardless of where in the React tree it is rendered. The `<head>` is the only valid place for `<meta>` to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render `<meta>` components itself.

There is one exception to this: if `<meta>` has an [`itemProp`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemprop) prop, there is no special behavior, because in this case it doesn’t represent metadata about the document but rather metadata about a specific part of the page.

---

## Usage

### Annotating the document with metadata

You can annotate the document with metadata such as keywords, a summary, or the author’s name. React will place this metadata within the document `<head>` regardless of where in the React tree it is rendered.

```
<meta name="author" content="John Smith" />

<meta name="keywords" content="React, JavaScript, semantic markup, html" />

<meta name="description" content="API reference for the <meta> component in React DOM" />
```

You can render the `<meta>` component from any component. React will put a `<meta>` DOM node in the document `<head>`.

App.jsShowRenderedHTML.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function SiteMapPage() {
  return (
    <ShowRenderedHTML>
      <meta name="keywords" content="React" />
      <meta name="description" content="A site map for the React website" />
      <h1>Site Map</h1>
      <p>...</p>
    </ShowRenderedHTML>
  );
}
```

### Annotating specific items within the document with metadata

You can use the `<meta>` component with the `itemProp` prop to annotate specific items within the document with metadata. In this case, React will *not* place these annotations within the document `<head>` but will place them like any other React component.

```
<section itemScope>

<h3>Annotating specific items</h3>

<meta itemProp="description" content="API reference for using <meta> with itemProp" />

<p>...</p>

</section>
```

[Previous<link>](https://react.dev/reference/react-dom/components/link)[Next<script>](https://react.dev/reference/react-dom/components/script)

---

---


# <script> – React

URL: https://react.dev/reference/react-dom/components/script

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <script>

The [built-in browser `<script>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script) lets you add a script to your document.

```
<script> alert("hi!") </script>
```

* [Reference](https://react.dev/reference/react-dom/components/script#reference) 
  + [`<script>`](https://react.dev/reference/react-dom/components/script#script)
* [Usage](https://react.dev/reference/react-dom/components/script#usage) 
  + [Rendering an external script](https://react.dev/reference/react-dom/components/script#rendering-an-external-script)
  + [Rendering an inline script](https://react.dev/reference/react-dom/components/script#rendering-an-inline-script)

---

## Reference

### `<script>`

To add inline or external scripts to your document, render the [built-in browser `<script>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script). You can render `<script>` from any component and React will [in certain cases](https://react.dev/reference/react-dom/components/script#special-rendering-behavior) place the corresponding DOM element in the document head and de-duplicate identical scripts.

```
<script> alert("hi!") </script>

<script src="script.js" />
```

[See more examples below.](https://react.dev/reference/react-dom/components/script#usage)

#### Props

`<script>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

It should have *either* `children` or a `src` prop.

* `children`: a string. The source code of an inline script.
* `src`: a string. The URL of an external script.

Other supported props:

* `async`: a boolean. Allows the browser to defer execution of the script until the rest of the document has been processed — the preferred behavior for performance.
* `crossOrigin`: a string. The [CORS policy](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) to use. Its possible values are `anonymous` and `use-credentials`.
* `fetchPriority`: a string. Lets the browser rank scripts in priority when fetching multiple scripts at the same time. Can be `"high"`, `"low"`, or `"auto"` (the default).
* `integrity`: a string. A cryptographic hash of the script, to [verify its authenticity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity).
* `noModule`: a boolean. Disables the script in browsers that support ES modules — allowing for a fallback script for browsers that do not.
* `nonce`: a string. A cryptographic [nonce to allow the resource](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) when using a strict Content Security Policy.
* `referrer`: a string. Says [what Referer header to send](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#referrerpolicy) when fetching the script and any resources that the script fetches in turn.
* `type`: a string. Says whether the script is a [classic script, ES module, or import map](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type).

Props that disable React’s [special treatment of scripts](https://react.dev/reference/react-dom/components/script#special-rendering-behavior):

* `onError`: a function. Called when the script fails to load.
* `onLoad`: a function. Called when the script finishes being loaded.

Props that are **not recommended** for use with React:

* `blocking`: a string. If set to `"render"`, instructs the browser not to render the page until the scriptsheet is loaded. React provides more fine-grained control using Suspense.
* `defer`: a string. Prevents the browser from executing the script until the document is done loading. Not compatible with streaming server-rendered components. Use the `async` prop instead.

#### Special rendering behavior

React can move `<script>` components to the document’s `<head>` and de-duplicate identical scripts.

To opt into this behavior, provide the `src` and `async={true}` props. React will de-duplicate scripts if they have the same `src`. The `async` prop must be true to allow scripts to be safely moved.

This special treatment comes with two caveats:

* React will ignore changes to props after the script has been rendered. (React will issue a warning in development if this happens.)
* React may leave the script in the DOM even after the component that rendered it has been unmounted. (This has no effect as scripts just execute once when they are inserted into the DOM.)

---

## Usage

### Rendering an external script

If a component depends on certain scripts in order to be displayed correctly, you can render a `<script>` within the component.
However, the component might be committed before the script has finished loading.
You can start depending on the script content once the `load` event is fired e.g. by using the `onLoad` prop.

React will de-duplicate scripts that have the same `src`, inserting only one of them into the DOM even if multiple components render it.

App.jsShowRenderedHTML.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import ShowRenderedHTML from './ShowRenderedHTML.js';

function Map({lat, long}) {
  return (
    <>
      <script async src="map-api.js" onLoad={() => console.log('script loaded')} />
      <div id="map" data-lat={lat} data-long={long} />
    </>
  );
}

export default function Page() {
  return (
    <ShowRenderedHTML>
      <Map />
    </ShowRenderedHTML>
  );
}
```

Show more

### Note

When you want to use a script, it can be beneficial to call the [preinit](https://react.dev/reference/react-dom/preinit) function. Calling this function may allow the browser to start fetching the script earlier than if you just render a `<script>` component, for example by sending an [HTTP Early Hints response](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103).

### Rendering an inline script

To include an inline script, render the `<script>` component with the script source code as its children. Inline scripts are not de-duplicated or moved to the document `<head>`.

App.jsShowRenderedHTML.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import ShowRenderedHTML from './ShowRenderedHTML.js';

function Tracking() {
  return (
    <script>
      ga('send', 'pageview');
    </script>
  );
}

export default function Page() {
  return (
    <ShowRenderedHTML>
      <h1>My Website</h1>
      <Tracking />
      <p>Welcome</p>
    </ShowRenderedHTML>
  );
}
```

Show more

[Previous<meta>](https://react.dev/reference/react-dom/components/meta)[Next<style>](https://react.dev/reference/react-dom/components/style)

---

---


# <style> – React

URL: https://react.dev/reference/react-dom/components/style

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <style>

The [built-in browser `<style>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style) lets you add inline CSS stylesheets to your document.

```
<style>{` p { color: red; } `}</style>
```

* [Reference](https://react.dev/reference/react-dom/components/style#reference) 
  + [`<style>`](https://react.dev/reference/react-dom/components/style#style)
* [Usage](https://react.dev/reference/react-dom/components/style#usage) 
  + [Rendering an inline CSS stylesheet](https://react.dev/reference/react-dom/components/style#rendering-an-inline-css-stylesheet)

---

## Reference

### `<style>`

To add inline styles to your document, render the [built-in browser `<style>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style). You can render `<style>` from any component and React will [in certain cases](https://react.dev/reference/react-dom/components/style#special-rendering-behavior) place the corresponding DOM element in the document head and de-duplicate identical styles.

```
<style>{` p { color: red; } `}</style>
```

[See more examples below.](https://react.dev/reference/react-dom/components/style#usage)

#### Props

`<style>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

* `children`: a string, required. The contents of the stylesheet.
* `precedence`: a string. Tells React where to rank the `<style>` DOM node relative to others in the document `<head>`, which determines which stylesheet can override the other. React will infer that precedence values it discovers first are “lower” and precedence values it discovers later are “higher”. Many style systems can work fine using a single precedence value because style rules are atomic. Stylesheets with the same precedence go together whether they are `<link>` or inline `<style>` tags or loaded using [`preinit`](https://react.dev/reference/react-dom/preinit) functions.
* `href`: a string. Allows React to [de-duplicate styles](https://react.dev/reference/react-dom/components/style#special-rendering-behavior) that have the same `href`.
* `media`: a string. Restricts the stylesheet to a certain [media query](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_media_queries/Using_media_queries).
* `nonce`: a string. A cryptographic [nonce to allow the resource](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) when using a strict Content Security Policy.
* `title`: a string. Specifies the name of an [alternative stylesheet](https://developer.mozilla.org/en-US/docs/Web/CSS/Alternative_style_sheets).

Props that are **not recommended** for use with React:

* `blocking`: a string. If set to `"render"`, instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense.

#### Special rendering behavior

React can move `<style>` components to the document’s `<head>`, de-duplicate identical stylesheets, and [suspend](https://react.dev/reference/react/Suspense) while the stylesheet is loading.

To opt into this behavior, provide the `href` and `precedence` props. React will de-duplicate styles if they have the same `href`. The precedence prop tells React where to rank the `<style>` DOM node relative to others in the document `<head>`, which determines which stylesheet can override the other.

This special treatment comes with three caveats:

* React will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.)
* React will drop all extraneous props when using the `precedence` prop (beyond `href` and `precedence`).
* React may leave the style in the DOM even after the component that rendered it has been unmounted.

---

## Usage

### Rendering an inline CSS stylesheet

If a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component.

The `href` prop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the same `href`.
If you supply a `precedence` prop, React will reorder inline stylesheets based on the order these values appear in the component tree.

Inline stylesheets will not trigger Suspense boundaries while they’re loading.
Even if they load async resources like fonts or images.

App.jsShowRenderedHTML.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import ShowRenderedHTML from './ShowRenderedHTML.js';
import { useId } from 'react';

function PieChart({data, colors}) {
  const id = useId();
  const stylesheet = colors.map((color, index) =>
    `#${id} .color-${index}: \{ color: "${color}"; \}`
  ).join();
  return (
    <>
      <style href={"PieChart-" + JSON.stringify(colors)} precedence="medium">
        {stylesheet}
      </style>
      <svg id={id}>
        …
      </svg>
    </>
  );
}

export default function App() {
  return (
    <ShowRenderedHTML>
      <PieChart data="..." colors={['red', 'green', 'blue']} />
    </ShowRenderedHTML>
  );
}
```

Show more

[Previous<script>](https://react.dev/reference/react-dom/components/script)[Next<title>](https://react.dev/reference/react-dom/components/title)

---

---


# <title> – React

URL: https://react.dev/reference/react-dom/components/title

[API Reference](https://react.dev/reference/react)

[Components](https://react.dev/reference/react-dom/components)

# <title>

The [built-in browser `<title>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title) lets you specify the title of the document.

```
<title>My Blog</title>
```

* [Reference](https://react.dev/reference/react-dom/components/title#reference) 
  + [`<title>`](https://react.dev/reference/react-dom/components/title#title)
* [Usage](https://react.dev/reference/react-dom/components/title#usage) 
  + [Set the document title](https://react.dev/reference/react-dom/components/title#set-the-document-title)
  + [Use variables in the title](https://react.dev/reference/react-dom/components/title#use-variables-in-the-title)

---

## Reference

### `<title>`

To specify the title of the document, render the [built-in browser `<title>` component](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title). You can render `<title>` from any component and React will always place the corresponding DOM element in the document head.

```
<title>My Blog</title>
```

[See more examples below.](https://react.dev/reference/react-dom/components/title#usage)

#### Props

`<title>` supports all [common element props.](https://react.dev/reference/react-dom/components/common#common-props)

* `children`: `<title>` accepts only text as a child. This text will become the title of the document. You can also pass your own components as long as they only render text.

#### Special rendering behavior

React will always place the DOM element corresponding to the `<title>` component within the document’s `<head>`, regardless of where in the React tree it is rendered. The `<head>` is the only valid place for `<title>` to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render its `<title>` itself.

There are two exception to this:

* If `<title>` is within an `<svg>` component, then there is no special behavior, because in this context it doesn’t represent the document’s title but rather is an [accessibility annotation for that SVG graphic](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/title).
* If the `<title>` has an [`itemProp`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/itemprop) prop, there is no special behavior, because in this case it doesn’t represent the document’s title but rather metadata about a specific part of the page.

### Pitfall

Only render a single `<title>` at a time. If more than one component renders a `<title>` tag at the same time, React will place all of those titles in the document head. When this happens, the behavior of browsers and search engines is undefined.

---

## Usage

### Set the document title

Render the `<title>` component from any component with text as its children. React will put a `<title>` DOM node in the document `<head>`.

App.jsShowRenderedHTML.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import ShowRenderedHTML from './ShowRenderedHTML.js';

export default function ContactUsPage() {
  return (
    <ShowRenderedHTML>
      <title>My Site: Contact Us</title>
      <h1>Contact Us</h1>
      <p>Email us at support@example.com</p>
    </ShowRenderedHTML>
  );
}
```

### Use variables in the title

The children of the `<title>` component must be a single string of text. (Or a single number or a single object with a `toString` method.) It might not be obvious, but using JSX curly braces like this:

```
<title>Results page {pageNumber}</title> // 🔴 Problem: This is not a single string
```

… actually causes the `<title>` component to get a two-element array as its children (the string `"Results page"` and the value of `pageNumber`). This will cause an error. Instead, use string interpolation to pass `<title>` a single string:

```
<title>{`Results page ${pageNumber}`}</title>
```

[Previous<style>](https://react.dev/reference/react-dom/components/style)[NextAPIs](https://react.dev/reference/react-dom)

---

---


# createPortal – React

URL: https://react.dev/reference/react-dom/createPortal

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# createPortal

`createPortal` lets you render some children into a different part of the DOM.

```
<div>

<SomeComponent />

{createPortal(children, domNode, key?)}

</div>
```

* [Reference](https://react.dev/reference/react-dom/createPortal#reference) 
  + [`createPortal(children, domNode, key?)`](https://react.dev/reference/react-dom/createPortal#createportal)
* [Usage](https://react.dev/reference/react-dom/createPortal#usage) 
  + [Rendering to a different part of the DOM](https://react.dev/reference/react-dom/createPortal#rendering-to-a-different-part-of-the-dom)
  + [Rendering a modal dialog with a portal](https://react.dev/reference/react-dom/createPortal#rendering-a-modal-dialog-with-a-portal)
  + [Rendering React components into non-React server markup](https://react.dev/reference/react-dom/createPortal#rendering-react-components-into-non-react-server-markup)
  + [Rendering React components into non-React DOM nodes](https://react.dev/reference/react-dom/createPortal#rendering-react-components-into-non-react-dom-nodes)

---

## Reference

### `createPortal(children, domNode, key?)`

To create a portal, call `createPortal`, passing some JSX, and the DOM node where it should be rendered:

```
import { createPortal } from 'react-dom';

// ...

<div>

<p>This child is placed in the parent div.</p>

{createPortal(

<p>This child is placed in the document body.</p>,

document.body

)}

</div>
```

[See more examples below.](https://react.dev/reference/react-dom/createPortal#usage)

A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree.

#### Parameters

* `children`: Anything that can be rendered with React, such as a piece of JSX (e.g. `<div />` or `<SomeComponent />`), a [Fragment](https://react.dev/reference/react/Fragment) (`<>...</>`), a string or a number, or an array of these.
* `domNode`: Some DOM node, such as those returned by `document.getElementById()`. The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.
* **optional** `key`: A unique string or number to be used as the portal’s [key.](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)

#### Returns

`createPortal` returns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the provided `children` inside the provided `domNode`.

#### Caveats

* Events from portals propagate according to the React tree rather than the DOM tree. For example, if you click inside a portal, and the portal is wrapped in `<div onClick>`, that `onClick` handler will fire. If this causes issues, either stop the event propagation from inside the portal, or move the portal itself up in the React tree.

---

## Usage

### Rendering to a different part of the DOM

*Portals* let your components render some of their children into a different place in the DOM. This lets a part of your component “escape” from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page.

To create a portal, render the result of `createPortal` with some JSX and the DOM node where it should go:

```
import { createPortal } from 'react-dom';

function MyComponent() {

return (

<div style={{ border: '2px solid black' }}>

<p>This child is placed in the parent div.</p>

{createPortal(

<p>This child is placed in the document body.</p>,

document.body

)}

</div>

);

}
```

React will put the DOM nodes for the JSX you passed inside of the DOM node you provided.

Without a portal, the second `<p>` would be placed inside the parent `<div>`, but the portal “teleported” it into the [`document.body`:](https://developer.mozilla.org/en-US/docs/Web/API/Document/body)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createPortal } from 'react-dom';

export default function MyComponent() {
  return (
    <div style={{ border: '2px solid black' }}>
      <p>This child is placed in the parent div.</p>
      {createPortal(
        <p>This child is placed in the document body.</p>,
        document.body
      )}
    </div>
  );
}
```

Notice how the second paragraph visually appears outside the parent `<div>` with the border. If you inspect the DOM structure with developer tools, you’ll see that the second `<p>` got placed directly into the `<body>`:

```
<body>

<div id="root">

...

<div style="border: 2px solid black">

<p>This child is placed inside the parent div.</p>

</div>

...

</div>

<p>This child is placed in the document body.</p>

</body>
```

A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events still bubble up from children to parents according to the React tree.

---

### Rendering a modal dialog with a portal

You can use a portal to create a modal dialog that floats above the rest of the page, even if the component that summons the dialog is inside a container with `overflow: hidden` or other styles that interfere with the dialog.

In this example, the two containers have styles that disrupt the modal dialog, but the one rendered into a portal is unaffected because, in the DOM, the modal is not contained within the parent JSX elements.

App.jsNoPortalExample.jsPortalExample.jsModalContent.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import NoPortalExample from './NoPortalExample';
import PortalExample from './PortalExample';

export default function App() {
  return (
    <>
      <div className="clipping-container">
        <NoPortalExample  />
      </div>
      <div className="clipping-container">
        <PortalExample />
      </div>
    </>
  );
}
```

### Pitfall

It’s important to make sure that your app is accessible when using portals. For instance, you may need to manage keyboard focus so that the user can move the focus in and out of the portal in a natural way.

Follow the [WAI-ARIA Modal Authoring Practices](https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal) when creating modals. If you use a community package, ensure that it is accessible and follows these guidelines.

---

### Rendering React components into non-React server markup

Portals can be useful if your React root is only part of a static or server-rendered page that isn’t built with React. For example, if your page is built with a server framework like Rails, you can create areas of interactivity within static areas such as sidebars. Compared with having [multiple separate React roots,](https://react.dev/reference/react-dom/client/createRoot#rendering-a-page-partially-built-with-react) portals let you treat the app as a single React tree with shared state even though its parts render to different parts of the DOM.

index.jsindex.htmlApp.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createPortal } from 'react-dom';

const sidebarContentEl = document.getElementById('sidebar-content');

export default function App() {
  return (
    <>
      <MainContent />
      {createPortal(
        <SidebarContent />,
        sidebarContentEl
      )}
    </>
  );
}

function MainContent() {
  return <p>This part is rendered by React</p>;
}

function SidebarContent() {
  return <p>This part is also rendered by React!</p>;
}
```

Show more

---

### Rendering React components into non-React DOM nodes

You can also use a portal to manage the content of a DOM node that’s managed outside of React. For example, suppose you’re integrating with a non-React map widget and you want to render React content inside a popup. To do this, declare a `popupContainer` state variable to store the DOM node you’re going to render into:

```
const [popupContainer, setPopupContainer] = useState(null);
```

When you create the third-party widget, store the DOM node returned by the widget so you can render into it:

```
useEffect(() => {

if (mapRef.current === null) {

const map = createMapWidget(containerRef.current);

mapRef.current = map;

const popupDiv = addPopupToMapWidget(map);

setPopupContainer(popupDiv);

}

}, []);
```

This lets you use `createPortal` to render React content into `popupContainer` once it becomes available:

```
return (

<div style={{ width: 250, height: 250 }} ref={containerRef}>

{popupContainer !== null && createPortal(

<p>Hello from React!</p>,

popupContainer

)}

</div>

);
```

Here is a complete example you can play with:

App.jsmap-widget.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { createMapWidget, addPopupToMapWidget } from './map-widget.js';

export default function Map() {
  const containerRef = useRef(null);
  const mapRef = useRef(null);
  const [popupContainer, setPopupContainer] = useState(null);

  useEffect(() => {
    if (mapRef.current === null) {
      const map = createMapWidget(containerRef.current);
      mapRef.current = map;
      const popupDiv = addPopupToMapWidget(map);
      setPopupContainer(popupDiv);
    }
  }, []);

  return (
    <div style={{ width: 250, height: 250 }} ref={containerRef}>
      {popupContainer !== null && createPortal(
        <p>Hello from React!</p>,
        popupContainer
      )}
    </div>
  );
}
```

Show more

[PreviousAPIs](https://react.dev/reference/react-dom)[NextflushSync](https://react.dev/reference/react-dom/flushSync)

---

---


# flushSync – React

URL: https://react.dev/reference/react-dom/flushSync

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# flushSync

### Pitfall

Using `flushSync` is uncommon and can hurt the performance of your app.

`flushSync` lets you force React to flush any updates inside the provided callback synchronously. This ensures that the DOM is updated immediately.

```
flushSync(callback)
```

* [Reference](https://react.dev/reference/react-dom/flushSync#reference) 
  + [`flushSync(callback)`](https://react.dev/reference/react-dom/flushSync#flushsync)
* [Usage](https://react.dev/reference/react-dom/flushSync#usage) 
  + [Flushing updates for third-party integrations](https://react.dev/reference/react-dom/flushSync#flushing-updates-for-third-party-integrations)
* [Troubleshooting](https://react.dev/reference/react-dom/flushSync#troubleshooting) 
  + [I’m getting an error: “flushSync was called from inside a lifecycle method”](https://react.dev/reference/react-dom/flushSync#im-getting-an-error-flushsync-was-called-from-inside-a-lifecycle-method)

---

## Reference

### `flushSync(callback)`

Call `flushSync` to force React to flush any pending work and update the DOM synchronously.

```
import { flushSync } from 'react-dom';

flushSync(() => {

setSomething(123);

});
```

Most of the time, `flushSync` can be avoided. Use `flushSync` as last resort.

[See more examples below.](https://react.dev/reference/react-dom/flushSync#usage)

#### Parameters

* `callback`: A function. React will immediately call this callback and flush any updates it contains synchronously. It may also flush any pending updates, or Effects, or updates inside of Effects. If an update suspends as a result of this `flushSync` call, the fallbacks may be re-shown.

#### Returns

`flushSync` returns `undefined`.

#### Caveats

* `flushSync` can significantly hurt performance. Use sparingly.
* `flushSync` may force pending Suspense boundaries to show their `fallback` state.
* `flushSync` may run pending Effects and synchronously apply any updates they contain before returning.
* `flushSync` may flush updates outside the callback when necessary to flush the updates inside the callback. For example, if there are pending updates from a click, React may flush those before flushing the updates inside the callback.

---

## Usage

### Flushing updates for third-party integrations

When integrating with third-party code such as browser APIs or UI libraries, it may be necessary to force React to flush updates. Use `flushSync` to force React to flush any state updates inside the callback synchronously:

```
flushSync(() => {

setSomething(123);

});

// By this line, the DOM is updated.
```

This ensures that, by the time the next line of code runs, React has already updated the DOM.

**Using `flushSync` is uncommon, and using it often can significantly hurt the performance of your app.** If your app only uses React APIs, and does not integrate with third-party libraries, `flushSync` should be unnecessary.

However, it can be helpful for integrating with third-party code like browser APIs.

Some browser APIs expect results inside of callbacks to be written to the DOM synchronously, by the end of the callback, so the browser can do something with the rendered DOM. In most cases, React handles this for you automatically. But in some cases it may be necessary to force a synchronous update.

For example, the browser `onbeforeprint` API allows you to change the page immediately before the print dialog opens. This is useful for applying custom print styles that allow the document to display better for printing. In the example below, you use `flushSync` inside of the `onbeforeprint` callback to immediately “flush” the React state to the DOM. Then, by the time the print dialog opens, `isPrinting` displays “yes”:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { flushSync } from 'react-dom';

export default function PrintApp() {
  const [isPrinting, setIsPrinting] = useState(false);

  useEffect(() => {
    function handleBeforePrint() {
      flushSync(() => {
        setIsPrinting(true);
      })
    }

    function handleAfterPrint() {
      setIsPrinting(false);
    }

    window.addEventListener('beforeprint', handleBeforePrint);
    window.addEventListener('afterprint', handleAfterPrint);
    return () => {
      window.removeEventListener('beforeprint', handleBeforePrint);
      window.removeEventListener('afterprint', handleAfterPrint);
    }
  }, []);

  return (
    <>
      <h1>isPrinting: {isPrinting ? 'yes' : 'no'}</h1>
      <button onClick={() => window.print()}>
        Print
      </button>
    </>
  );
}
```

Show more

Without `flushSync`, the print dialog will display `isPrinting` as “no”. This is because React batches the updates asynchronously and the print dialog is displayed before the state is updated.

### Pitfall

`flushSync` can significantly hurt performance, and may unexpectedly force pending Suspense boundaries to show their fallback state.

Most of the time, `flushSync` can be avoided, so use `flushSync` as a last resort.

---

## Troubleshooting

### I’m getting an error: “flushSync was called from inside a lifecycle method”

React cannot `flushSync` in the middle of a render. If you do, it will noop and warn:

Console

Warning: flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.

This includes calling `flushSync` inside:

* rendering a component.
* `useLayoutEffect` or `useEffect` hooks.
* Class component lifecycle methods.

For example, calling `flushSync` in an Effect will noop and warn:

```
import { useEffect } from 'react';

import { flushSync } from 'react-dom';

function MyComponent() {

useEffect(() => {

// 🚩 Wrong: calling flushSync inside an effect

flushSync(() => {

setSomething(newValue);

});

}, []);

return <div>{/* ... */}</div>;

}
```

To fix this, you usually want to move the `flushSync` call to an event:

```
function handleClick() {

// ✅ Correct: flushSync in event handlers is safe

flushSync(() => {

setSomething(newValue);

});

}
```

If it’s difficult to move to an event, you can defer `flushSync` in a microtask:

```
useEffect(() => {

// ✅ Correct: defer flushSync to a microtask

queueMicrotask(() => {

flushSync(() => {

setSomething(newValue);

});

});

}, []);
```

This will allow the current render to finish and schedule another syncronous render to flush the updates.

### Pitfall

`flushSync` can significantly hurt performance, but this particular pattern is even worse for performance. Exhaust all other options before calling `flushSync` in a microtask as an escape hatch.

[PreviouscreatePortal](https://react.dev/reference/react-dom/createPortal)[Nextpreconnect](https://react.dev/reference/react-dom/preconnect)

---

---


# preconnect – React

URL: https://react.dev/reference/react-dom/preconnect

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# preconnect

`preconnect` lets you eagerly connect to a server that you expect to load resources from.

```
preconnect("https://example.com");
```

* [Reference](https://react.dev/reference/react-dom/preconnect#reference) 
  + [`preconnect(href)`](https://react.dev/reference/react-dom/preconnect#preconnect)
* [Usage](https://react.dev/reference/react-dom/preconnect#usage) 
  + [Preconnecting when rendering](https://react.dev/reference/react-dom/preconnect#preconnecting-when-rendering)
  + [Preconnecting in an event handler](https://react.dev/reference/react-dom/preconnect#preconnecting-in-an-event-handler)

---

## Reference

### `preconnect(href)`

To preconnect to a host, call the `preconnect` function from `react-dom`.

```
import { preconnect } from 'react-dom';

function AppRoot() {

preconnect("https://example.com");

// ...

}
```

[See more examples below.](https://react.dev/reference/react-dom/preconnect#usage)

The `preconnect` function provides the browser with a hint that it should open a connection to the given server. If the browser chooses to do so, this can speed up the loading of resources from that server.

#### Parameters

* `href`: a string. The URL of the server you want to connect to.

#### Returns

`preconnect` returns nothing.

#### Caveats

* Multiple calls to `preconnect` with the same server have the same effect as a single call.
* In the browser, you can call `preconnect` in any situation: while rendering a component, in an Effect, in an event handler, and so on.
* In server-side rendering or when rendering Server Components, `preconnect` only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.
* If you know the specific resources you’ll need, you can call [other functions](https://react.dev/reference/react-dom#resource-preloading-apis) instead that will start loading the resources right away.
* There is no benefit to preconnecting to the same server the webpage itself is hosted from because it’s already been connected to by the time the hint would be given.

---

## Usage

### Preconnecting when rendering

Call `preconnect` when rendering a component if you know that its children will load external resources from that host.

```
import { preconnect } from 'react-dom';

function AppRoot() {

preconnect("https://example.com");

return ...;

}
```

### Preconnecting in an event handler

Call `preconnect` in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```
import { preconnect } from 'react-dom';

function CallToAction() {

const onClick = () => {

preconnect('http://example.com');

startWizard();

}

return (

<button onClick={onClick}>Start Wizard</button>

);

}
```

[PreviousflushSync](https://react.dev/reference/react-dom/flushSync)[NextprefetchDNS](https://react.dev/reference/react-dom/prefetchDNS)

---

---


# prefetchDNS – React

URL: https://react.dev/reference/react-dom/prefetchDNS

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# prefetchDNS

`prefetchDNS` lets you eagerly look up the IP of a server that you expect to load resources from.

```
prefetchDNS("https://example.com");
```

* [Reference](https://react.dev/reference/react-dom/prefetchDNS#reference) 
  + [`prefetchDNS(href)`](https://react.dev/reference/react-dom/prefetchDNS#prefetchdns)
* [Usage](https://react.dev/reference/react-dom/prefetchDNS#usage) 
  + [Prefetching DNS when rendering](https://react.dev/reference/react-dom/prefetchDNS#prefetching-dns-when-rendering)
  + [Prefetching DNS in an event handler](https://react.dev/reference/react-dom/prefetchDNS#prefetching-dns-in-an-event-handler)

---

## Reference

### `prefetchDNS(href)`

To look up a host, call the `prefetchDNS` function from `react-dom`.

```
import { prefetchDNS } from 'react-dom';

function AppRoot() {

prefetchDNS("https://example.com");

// ...

}
```

[See more examples below.](https://react.dev/reference/react-dom/prefetchDNS#usage)

The prefetchDNS function provides the browser with a hint that it should look up the IP address of a given server. If the browser chooses to do so, this can speed up the loading of resources from that server.

#### Parameters

* `href`: a string. The URL of the server you want to connect to.

#### Returns

`prefetchDNS` returns nothing.

#### Caveats

* Multiple calls to `prefetchDNS` with the same server have the same effect as a single call.
* In the browser, you can call `prefetchDNS` in any situation: while rendering a component, in an Effect, in an event handler, and so on.
* In server-side rendering or when rendering Server Components, `prefetchDNS` only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.
* If you know the specific resources you’ll need, you can call [other functions](https://react.dev/reference/react-dom#resource-preloading-apis) instead that will start loading the resources right away.
* There is no benefit to prefetching the same server the webpage itself is hosted from because it’s already been looked up by the time the hint would be given.
* Compared with [`preconnect`](https://react.dev/reference/react-dom/preconnect), `prefetchDNS` may be better if you are speculatively connecting to a large number of domains, in which case the overhead of preconnections might outweigh the benefit.

---

## Usage

### Prefetching DNS when rendering

Call `prefetchDNS` when rendering a component if you know that its children will load external resources from that host.

```
import { prefetchDNS } from 'react-dom';

function AppRoot() {

prefetchDNS("https://example.com");

return ...;

}
```

### Prefetching DNS in an event handler

Call `prefetchDNS` in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```
import { prefetchDNS } from 'react-dom';

function CallToAction() {

const onClick = () => {

prefetchDNS('http://example.com');

startWizard();

}

return (

<button onClick={onClick}>Start Wizard</button>

);

}
```

[Previouspreconnect](https://react.dev/reference/react-dom/preconnect)[Nextpreinit](https://react.dev/reference/react-dom/preinit)

---

---


# preinit – React

URL: https://react.dev/reference/react-dom/preinit

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# preinit

### Note

[React-based frameworks](https://react.dev/learn/creating-a-react-app) frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.

`preinit` lets you eagerly fetch and evaluate a stylesheet or external script.

```
preinit("https://example.com/script.js", {as: "script"});
```

* [Reference](https://react.dev/reference/react-dom/preinit#reference) 
  + [`preinit(href, options)`](https://react.dev/reference/react-dom/preinit#preinit)
* [Usage](https://react.dev/reference/react-dom/preinit#usage) 
  + [Preiniting when rendering](https://react.dev/reference/react-dom/preinit#preiniting-when-rendering)
  + [Preiniting in an event handler](https://react.dev/reference/react-dom/preinit#preiniting-in-an-event-handler)

---

## Reference

### `preinit(href, options)`

To preinit a script or stylesheet, call the `preinit` function from `react-dom`.

```
import { preinit } from 'react-dom';

function AppRoot() {

preinit("https://example.com/script.js", {as: "script"});

// ...

}
```

[See more examples below.](https://react.dev/reference/react-dom/preinit#usage)

The `preinit` function provides the browser with a hint that it should start downloading and executing the given resource, which can save time. Scripts that you `preinit` are executed when they finish downloading. Stylesheets that you preinit are inserted into the document, which causes them to go into effect right away.

#### Parameters

* `href`: a string. The URL of the resource you want to download and execute.
* `options`: an object. It contains the following properties:
  + `as`: a required string. The type of resource. Its possible values are `script` and `style`.
  + `precedence`: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values are `reset`, `low`, `medium`, `high`.
  + `crossOrigin`: a string. The [CORS policy](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) to use. Its possible values are `anonymous` and `use-credentials`.
  + `integrity`: a string. A cryptographic hash of the resource, to [verify its authenticity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity).
  + `nonce`: a string. A cryptographic [nonce to allow the resource](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) when using a strict Content Security Policy.
  + `fetchPriority`: a string. Suggests a relative priority for fetching the resource. The possible values are `auto` (the default), `high`, and `low`.

#### Returns

`preinit` returns nothing.

#### Caveats

* Multiple calls to `preinit` with the same `href` have the same effect as a single call.
* In the browser, you can call `preinit` in any situation: while rendering a component, in an Effect, in an event handler, and so on.
* In server-side rendering or when rendering Server Components, `preinit` only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

---

## Usage

### Preiniting when rendering

Call `preinit` when rendering a component if you know that it or its children will use a specific resource, and you’re OK with the resource being evaluated and thereby taking effect immediately upon being downloaded.

#### Examples of preiniting

1. Preiniting an external script 2. Preiniting a stylesheet

#### Example 1 of 2: Preiniting an external script

```
import { preinit } from 'react-dom';

function AppRoot() {

preinit("https://example.com/script.js", {as: "script"});

return ...;

}
```

If you want the browser to download the script but not to execute it right away, use [`preload`](https://react.dev/reference/react-dom/preload) instead. If you want to load an ESM module, use [`preinitModule`](https://react.dev/reference/react-dom/preinitModule).

Next Example

### Preiniting in an event handler

Call `preinit` in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```
import { preinit } from 'react-dom';

function CallToAction() {

const onClick = () => {

preinit("https://example.com/wizardStyles.css", {as: "style"});

startWizard();

}

return (

<button onClick={onClick}>Start Wizard</button>

);

}
```

[PreviousprefetchDNS](https://react.dev/reference/react-dom/prefetchDNS)[NextpreinitModule](https://react.dev/reference/react-dom/preinitModule)

---

---


# preinitModule – React

URL: https://react.dev/reference/react-dom/preinitModule

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# preinitModule

### Note

[React-based frameworks](https://react.dev/learn/creating-a-react-app) frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.

`preinitModule` lets you eagerly fetch and evaluate an ESM module.

```
preinitModule("https://example.com/module.js", {as: "script"});
```

* [Reference](https://react.dev/reference/react-dom/preinitModule#reference) 
  + [`preinitModule(href, options)`](https://react.dev/reference/react-dom/preinitModule#preinitmodule)
* [Usage](https://react.dev/reference/react-dom/preinitModule#usage) 
  + [Preloading when rendering](https://react.dev/reference/react-dom/preinitModule#preloading-when-rendering)
  + [Preloading in an event handler](https://react.dev/reference/react-dom/preinitModule#preloading-in-an-event-handler)

---

## Reference

### `preinitModule(href, options)`

To preinit an ESM module, call the `preinitModule` function from `react-dom`.

```
import { preinitModule } from 'react-dom';

function AppRoot() {

preinitModule("https://example.com/module.js", {as: "script"});

// ...

}
```

[See more examples below.](https://react.dev/reference/react-dom/preinitModule#usage)

The `preinitModule` function provides the browser with a hint that it should start downloading and executing the given module, which can save time. Modules that you `preinit` are executed when they finish downloading.

#### Parameters

* `href`: a string. The URL of the module you want to download and execute.
* `options`: an object. It contains the following properties:
  + `as`: a required string. It must be `'script'`.
  + `crossOrigin`: a string. The [CORS policy](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) to use. Its possible values are `anonymous` and `use-credentials`.
  + `integrity`: a string. A cryptographic hash of the module, to [verify its authenticity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity).
  + `nonce`: a string. A cryptographic [nonce to allow the module](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) when using a strict Content Security Policy.

#### Returns

`preinitModule` returns nothing.

#### Caveats

* Multiple calls to `preinitModule` with the same `href` have the same effect as a single call.
* In the browser, you can call `preinitModule` in any situation: while rendering a component, in an Effect, in an event handler, and so on.
* In server-side rendering or when rendering Server Components, `preinitModule` only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

---

## Usage

### Preloading when rendering

Call `preinitModule` when rendering a component if you know that it or its children will use a specific module and you’re OK with the module being evaluated and thereby taking effect immediately upon being downloaded.

```
import { preinitModule } from 'react-dom';

function AppRoot() {

preinitModule("https://example.com/module.js", {as: "script"});

return ...;

}
```

If you want the browser to download the module but not to execute it right away, use [`preloadModule`](https://react.dev/reference/react-dom/preloadModule) instead. If you want to preinit a script that isn’t an ESM module, use [`preinit`](https://react.dev/reference/react-dom/preinit).

### Preloading in an event handler

Call `preinitModule` in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```
import { preinitModule } from 'react-dom';

function CallToAction() {

const onClick = () => {

preinitModule("https://example.com/module.js", {as: "script"});

startWizard();

}

return (

<button onClick={onClick}>Start Wizard</button>

);

}
```

[Previouspreinit](https://react.dev/reference/react-dom/preinit)[Nextpreload](https://react.dev/reference/react-dom/preload)

---

---


# preload – React

URL: https://react.dev/reference/react-dom/preload

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# preload

### Note

[React-based frameworks](https://react.dev/learn/creating-a-react-app) frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.

`preload` lets you eagerly fetch a resource such as a stylesheet, font, or external script that you expect to use.

```
preload("https://example.com/font.woff2", {as: "font"});
```

* [Reference](https://react.dev/reference/react-dom/preload#reference) 
  + [`preload(href, options)`](https://react.dev/reference/react-dom/preload#preload)
* [Usage](https://react.dev/reference/react-dom/preload#usage) 
  + [Preloading when rendering](https://react.dev/reference/react-dom/preload#preloading-when-rendering)
  + [Preloading in an event handler](https://react.dev/reference/react-dom/preload#preloading-in-an-event-handler)

---

## Reference

### `preload(href, options)`

To preload a resource, call the `preload` function from `react-dom`.

```
import { preload } from 'react-dom';

function AppRoot() {

preload("https://example.com/font.woff2", {as: "font"});

// ...

}
```

[See more examples below.](https://react.dev/reference/react-dom/preload#usage)

The `preload` function provides the browser with a hint that it should start downloading the given resource, which can save time.

#### Parameters

* `href`: a string. The URL of the resource you want to download.
* `options`: an object. It contains the following properties:
  + `as`: a required string. The type of resource. Its [possible values](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#as) are `audio`, `document`, `embed`, `fetch`, `font`, `image`, `object`, `script`, `style`, `track`, `video`, `worker`.
  + `crossOrigin`: a string. The [CORS policy](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) to use. Its possible values are `anonymous` and `use-credentials`. It is required when `as` is set to `"fetch"`.
  + `referrerPolicy`: a string. The [Referrer header](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#referrerpolicy) to send when fetching. Its possible values are `no-referrer-when-downgrade` (the default), `no-referrer`, `origin`, `origin-when-cross-origin`, and `unsafe-url`.
  + `integrity`: a string. A cryptographic hash of the resource, to [verify its authenticity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity).
  + `type`: a string. The MIME type of the resource.
  + `nonce`: a string. A cryptographic [nonce to allow the resource](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) when using a strict Content Security Policy.
  + `fetchPriority`: a string. Suggests a relative priority for fetching the resource. The possible values are `auto` (the default), `high`, and `low`.
  + `imageSrcSet`: a string. For use only with `as: "image"`. Specifies the [source set of the image](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images).
  + `imageSizes`: a string. For use only with `as: "image"`. Specifies the [sizes of the image](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images).

#### Returns

`preload` returns nothing.

#### Caveats

* Multiple equivalent calls to `preload` have the same effect as a single call. Calls to `preload` are considered equivalent according to the following rules:
  + Two calls are equivalent if they have the same `href`, except:
  + If `as` is set to `image`, two calls are equivalent if they have the same `href`, `imageSrcSet`, and `imageSizes`.
* In the browser, you can call `preload` in any situation: while rendering a component, in an Effect, in an event handler, and so on.
* In server-side rendering or when rendering Server Components, `preload` only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

---

## Usage

### Preloading when rendering

Call `preload` when rendering a component if you know that it or its children will use a specific resource.

#### Examples of preloading

1. Preloading an external script 2. Preloading a stylesheet 3. Preloading a font 4. Preloading an image

#### Example 1 of 4: Preloading an external script

```
import { preload } from 'react-dom';

function AppRoot() {

preload("https://example.com/script.js", {as: "script"});

return ...;

}
```

If you want the browser to start executing the script immediately (rather than just downloading it), use [`preinit`](https://react.dev/reference/react-dom/preinit) instead. If you want to load an ESM module, use [`preloadModule`](https://react.dev/reference/react-dom/preloadModule).

Next Example

### Preloading in an event handler

Call `preload` in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```
import { preload } from 'react-dom';

function CallToAction() {

const onClick = () => {

preload("https://example.com/wizardStyles.css", {as: "style"});

startWizard();

}

return (

<button onClick={onClick}>Start Wizard</button>

);

}
```

[PreviouspreinitModule](https://react.dev/reference/react-dom/preinitModule)[NextpreloadModule](https://react.dev/reference/react-dom/preloadModule)

---

---


# preloadModule – React

URL: https://react.dev/reference/react-dom/preloadModule

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# preloadModule

### Note

[React-based frameworks](https://react.dev/learn/creating-a-react-app) frequently handle resource loading for you, so you might not have to call this API yourself. Consult your framework’s documentation for details.

`preloadModule` lets you eagerly fetch an ESM module that you expect to use.

```
preloadModule("https://example.com/module.js", {as: "script"});
```

* [Reference](https://react.dev/reference/react-dom/preloadModule#reference) 
  + [`preloadModule(href, options)`](https://react.dev/reference/react-dom/preloadModule#preloadmodule)
* [Usage](https://react.dev/reference/react-dom/preloadModule#usage) 
  + [Preloading when rendering](https://react.dev/reference/react-dom/preloadModule#preloading-when-rendering)
  + [Preloading in an event handler](https://react.dev/reference/react-dom/preloadModule#preloading-in-an-event-handler)

---

## Reference

### `preloadModule(href, options)`

To preload an ESM module, call the `preloadModule` function from `react-dom`.

```
import { preloadModule } from 'react-dom';

function AppRoot() {

preloadModule("https://example.com/module.js", {as: "script"});

// ...

}
```

[See more examples below.](https://react.dev/reference/react-dom/preloadModule#usage)

The `preloadModule` function provides the browser with a hint that it should start downloading the given module, which can save time.

#### Parameters

* `href`: a string. The URL of the module you want to download.
* `options`: an object. It contains the following properties:
  + `as`: a required string. It must be `'script'`.
  + `crossOrigin`: a string. The [CORS policy](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin) to use. Its possible values are `anonymous` and `use-credentials`.
  + `integrity`: a string. A cryptographic hash of the module, to [verify its authenticity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity).
  + `nonce`: a string. A cryptographic [nonce to allow the module](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/nonce) when using a strict Content Security Policy.

#### Returns

`preloadModule` returns nothing.

#### Caveats

* Multiple calls to `preloadModule` with the same `href` have the same effect as a single call.
* In the browser, you can call `preloadModule` in any situation: while rendering a component, in an Effect, in an event handler, and so on.
* In server-side rendering or when rendering Server Components, `preloadModule` only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.

---

## Usage

### Preloading when rendering

Call `preloadModule` when rendering a component if you know that it or its children will use a specific module.

```
import { preloadModule } from 'react-dom';

function AppRoot() {

preloadModule("https://example.com/module.js", {as: "script"});

return ...;

}
```

If you want the browser to start executing the module immediately (rather than just downloading it), use [`preinitModule`](https://react.dev/reference/react-dom/preinitModule) instead. If you want to load a script that isn’t an ESM module, use [`preload`](https://react.dev/reference/react-dom/preload).

### Preloading in an event handler

Call `preloadModule` in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

```
import { preloadModule } from 'react-dom';

function CallToAction() {

const onClick = () => {

preloadModule("https://example.com/module.js", {as: "script"});

startWizard();

}

return (

<button onClick={onClick}>Start Wizard</button>

);

}
```

[Previouspreload](https://react.dev/reference/react-dom/preload)[NextClient APIs](https://react.dev/reference/react-dom/client)

---

---


# createRoot – React

URL: https://react.dev/reference/react-dom/client/createRoot

[API Reference](https://react.dev/reference/react)

[Client APIs](https://react.dev/reference/react-dom/client)

# createRoot

`createRoot` lets you create a root to display React components inside a browser DOM node.

```
const root = createRoot(domNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/client/createRoot#reference) 
  + [`createRoot(domNode, options?)`](https://react.dev/reference/react-dom/client/createRoot#createroot)
  + [`root.render(reactNode)`](https://react.dev/reference/react-dom/client/createRoot#root-render)
  + [`root.unmount()`](https://react.dev/reference/react-dom/client/createRoot#root-unmount)
* [Usage](https://react.dev/reference/react-dom/client/createRoot#usage) 
  + [Rendering an app fully built with React](https://react.dev/reference/react-dom/client/createRoot#rendering-an-app-fully-built-with-react)
  + [Rendering a page partially built with React](https://react.dev/reference/react-dom/client/createRoot#rendering-a-page-partially-built-with-react)
  + [Updating a root component](https://react.dev/reference/react-dom/client/createRoot#updating-a-root-component)
  + [Error logging in production](https://react.dev/reference/react-dom/client/createRoot#error-logging-in-production)
* [Troubleshooting](https://react.dev/reference/react-dom/client/createRoot#troubleshooting) 
  + [I’ve created a root, but nothing is displayed](https://react.dev/reference/react-dom/client/createRoot#ive-created-a-root-but-nothing-is-displayed)
  + [I’m getting an error: “You passed a second argument to root.render”](https://react.dev/reference/react-dom/client/createRoot#im-getting-an-error-you-passed-a-second-argument-to-root-render)
  + [I’m getting an error: “Target container is not a DOM element”](https://react.dev/reference/react-dom/client/createRoot#im-getting-an-error-target-container-is-not-a-dom-element)
  + [I’m getting an error: “Functions are not valid as a React child.”](https://react.dev/reference/react-dom/client/createRoot#im-getting-an-error-functions-are-not-valid-as-a-react-child)
  + [My server-rendered HTML gets re-created from scratch](https://react.dev/reference/react-dom/client/createRoot#my-server-rendered-html-gets-re-created-from-scratch)

---

## Reference

### `createRoot(domNode, options?)`

Call `createRoot` to create a React root for displaying content inside a browser DOM element.

```
import { createRoot } from 'react-dom/client';

const domNode = document.getElementById('root');

const root = createRoot(domNode);
```

React will create a root for the `domNode`, and take over managing the DOM inside it. After you’ve created a root, you need to call [`root.render`](https://react.dev/reference/react-dom/client/createRoot#root-render) to display a React component inside of it:

```
root.render(<App />);
```

An app fully built with React will usually only have one `createRoot` call for its root component. A page that uses “sprinkles” of React for parts of the page may have as many separate roots as needed.

[See more examples below.](https://react.dev/reference/react-dom/client/createRoot#usage)

#### Parameters

* `domNode`: A [DOM element.](https://developer.mozilla.org/en-US/docs/Web/API/Element) React will create a root for this DOM element and allow you to call functions on the root, such as `render` to display rendered React content.
* **optional** `options`: An object with options for this React root.

  + **optional** `onCaughtError`: Callback called when React catches an error in an Error Boundary. Called with the `error` caught by the Error Boundary, and an `errorInfo` object containing the `componentStack`.
  + **optional** `onUncaughtError`: Callback called when an error is thrown and not caught by an Error Boundary. Called with the `error` that was thrown, and an `errorInfo` object containing the `componentStack`.
  + **optional** `onRecoverableError`: Callback called when React automatically recovers from errors. Called with an `error` React throws, and an `errorInfo` object containing the `componentStack`. Some recoverable errors may include the original error cause as `error.cause`.
  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page.

#### Returns

`createRoot` returns an object with two methods: [`render`](https://react.dev/reference/react-dom/client/createRoot#root-render) and [`unmount`.](https://react.dev/reference/react-dom/client/createRoot#root-unmount)

#### Caveats

* If your app is server-rendered, using `createRoot()` is not supported. Use [`hydrateRoot()`](https://react.dev/reference/react-dom/client/hydrateRoot) instead.
* You’ll likely have only one `createRoot` call in your app. If you use a framework, it might do this call for you.
* When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), use [`createPortal`](https://react.dev/reference/react-dom/createPortal) instead of `createRoot`.

---

### `root.render(reactNode)`

Call `root.render` to display a piece of [JSX](https://react.dev/learn/writing-markup-with-jsx) (“React node”) into the React root’s browser DOM node.

```
root.render(<App />);
```

React will display `<App />` in the `root`, and take over managing the DOM inside it.

[See more examples below.](https://react.dev/reference/react-dom/client/createRoot#usage)

#### Parameters

* `reactNode`: A *React node* that you want to display. This will usually be a piece of JSX like `<App />`, but you can also pass a React element constructed with [`createElement()`](https://react.dev/reference/react/createElement), a string, a number, `null`, or `undefined`.

#### Returns

`root.render` returns `undefined`.

#### Caveats

* The first time you call `root.render`, React will clear all the existing HTML content inside the React root before rendering the React component into it.
* If your root’s DOM node contains HTML generated by React on the server or during the build, use [`hydrateRoot()`](https://react.dev/reference/react-dom/client/hydrateRoot) instead, which attaches the event handlers to the existing HTML.
* If you call `render` on the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by [“matching it up”](https://react.dev/learn/preserving-and-resetting-state) with the previously rendered tree. Calling `render` on the same root again is similar to calling the [`set` function](https://react.dev/reference/react/useState#setstate) on the root component: React avoids unnecessary DOM updates.
* Although rendering is synchronous once it starts, `root.render(...)` is not. This means code after `root.render()` may run before any effects (`useLayoutEffect`, `useEffect`) of that specific render are fired. This is usually fine and rarely needs adjustment. In rare cases where effect timing matters, you can wrap `root.render(...)` in [`flushSync`](https://react.dev/reference/react-dom/flushSync) to ensure the initial render runs fully synchronously.

  ```
  const root = createRoot(document.getElementById('root'));

  root.render(<App />);

  // 🚩 The HTML will not include the rendered <App /> yet:

  console.log(document.body.innerHTML);
  ```

---

### `root.unmount()`

Call `root.unmount` to destroy a rendered tree inside a React root.

```
root.unmount();
```

An app fully built with React will usually not have any calls to `root.unmount`.

This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to “stop” managing the removed root’s content by calling `root.unmount`. Otherwise, the components inside the removed root won’t know to clean up and free up global resources like subscriptions.

Calling `root.unmount` will unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree.

#### Parameters

`root.unmount` does not accept any parameters.

#### Returns

`root.unmount` returns `undefined`.

#### Caveats

* Calling `root.unmount` will unmount all the components in the tree and “detach” React from the root DOM node.
* Once you call `root.unmount` you cannot call `root.render` again on the same root. Attempting to call `root.render` on an unmounted root will throw a “Cannot update an unmounted root” error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted.

---

## Usage

### Rendering an app fully built with React

If your app is fully built with React, create a single root for your entire app.

```
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'));

root.render(<App />);
```

Usually, you only need to run this code once at startup. It will:

1. Find the browser DOM node defined in your HTML.
2. Display the React component for your app inside.

index.jsindex.htmlApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRoot } from 'react-dom/client';
import App from './App.js';
import './styles.css';

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

**If your app is fully built with React, you shouldn’t need to create any more roots, or to call [`root.render`](https://react.dev/reference/react-dom/client/createRoot#root-render) again.**

From this point on, React will manage the DOM of your entire app. To add more components, [nest them inside the `App` component.](https://react.dev/learn/importing-and-exporting-components) When you need to update the UI, each of your components can do this by [using state.](https://react.dev/reference/react/useState) When you need to display extra content like a modal or a tooltip outside the DOM node, [render it with a portal.](https://react.dev/reference/react-dom/createPortal)

### Note

When your HTML is empty, the user sees a blank page until the app’s JavaScript code loads and runs:

```
<div id="root"></div>
```

This can feel very slow! To solve this, you can generate the initial HTML from your components [on the server or during the build.](https://react.dev/reference/react-dom/server) Then your visitors can read text, see images, and click links before any of the JavaScript code loads. We recommend [using a framework](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) that does this optimization out of the box. Depending on when it runs, this is called *server-side rendering (SSR)* or *static site generation (SSG).*

### Pitfall

**Apps using server rendering or static generation must call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) instead of `createRoot`.** React will then *hydrate* (reuse) the DOM nodes from your HTML instead of destroying and re-creating them.

---

### Rendering a page partially built with React

If your page [isn’t fully built with React](https://react.dev/learn/add-react-to-an-existing-project#using-react-for-a-part-of-your-existing-page), you can call `createRoot` multiple times to create a root for each top-level piece of UI managed by React. You can display different content in each root by calling [`root.render`.](https://react.dev/reference/react-dom/client/createRoot#root-render)

Here, two different React components are rendered into two DOM nodes defined in the `index.html` file:

index.jsindex.htmlComponents.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import './styles.css';
import { createRoot } from 'react-dom/client';
import { Comments, Navigation } from './Components.js';

const navDomNode = document.getElementById('navigation');
const navRoot = createRoot(navDomNode); 
navRoot.render(<Navigation />);

const commentDomNode = document.getElementById('comments');
const commentRoot = createRoot(commentDomNode); 
commentRoot.render(<Comments />);
```

You could also create a new DOM node with [`document.createElement()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement) and add it to the document manually.

```
const domNode = document.createElement('div');

const root = createRoot(domNode);

root.render(<Comment />);

document.body.appendChild(domNode); // You can add it anywhere in the document
```

To remove the React tree from the DOM node and clean up all the resources used by it, call [`root.unmount`.](https://react.dev/reference/react-dom/client/createRoot#root-unmount)

```
root.unmount();
```

This is mostly useful if your React components are inside an app written in a different framework.

---

### Updating a root component

You can call `render` more than once on the same root. As long as the component tree structure matches up with what was previously rendered, React will [preserve the state.](https://react.dev/learn/preserving-and-resetting-state) Notice how you can type in the input, which means that the updates from repeated `render` calls every second in this example are not destructive:

index.jsApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = createRoot(document.getElementById('root'));

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);
```

It is uncommon to call `render` multiple times. Usually, your components will [update state](https://react.dev/reference/react/useState) instead.

### Error logging in production

By default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options `onUncaughtError`, `onCaughtError` and `onRecoverableError`:

```
import { createRoot } from "react-dom/client";

import { reportCaughtError } from "./reportError";

const container = document.getElementById("root");

const root = createRoot(container, {

onCaughtError: (error, errorInfo) => {

if (error.message !== "Known error") {

reportCaughtError({

error,

componentStack: errorInfo.componentStack,

});

}

},

});
```

The onCaughtError option is a function called with two arguments:

1. The error that was thrown.
2. An errorInfo object that contains the componentStack of the error.

Together with `onUncaughtError` and `onRecoverableError`, you can can implement your own error reporting system:

index.jsreportError.jsApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRoot } from "react-dom/client";
import App from "./App.js";
import {
  onCaughtErrorProd,
  onRecoverableErrorProd,
  onUncaughtErrorProd,
} from "./reportError";

const container = document.getElementById("root");
const root = createRoot(container, {
  // Keep in mind to remove these options in development to leverage
  // React's default handlers or implement your own overlay for development.
  // The handlers are only specfied unconditionally here for demonstration purposes.
  onCaughtError: onCaughtErrorProd,
  onRecoverableError: onRecoverableErrorProd,
  onUncaughtError: onUncaughtErrorProd,
});
root.render(<App />);
```

Show more

## Troubleshooting

### I’ve created a root, but nothing is displayed

Make sure you haven’t forgotten to actually *render* your app into the root:

```
import { createRoot } from 'react-dom/client';

import App from './App.js';

const root = createRoot(document.getElementById('root'));

root.render(<App />);
```

Until you do that, nothing is displayed.

---

### I’m getting an error: “You passed a second argument to root.render”

A common mistake is to pass the options for `createRoot` to `root.render(...)`:

Console

Warning: You passed a second argument to root.render(…) but it only accepts one argument.

To fix, pass the root options to `createRoot(...)`, not `root.render(...)`:

```
// 🚩 Wrong: root.render only takes one argument.

root.render(App, {onUncaughtError});

// ✅ Correct: pass options to createRoot.

const root = createRoot(container, {onUncaughtError});

root.render(<App />);
```

---

### I’m getting an error: “Target container is not a DOM element”

This error means that whatever you’re passing to `createRoot` is not a DOM node.

If you’re not sure what’s happening, try logging it:

```
const domNode = document.getElementById('root');

console.log(domNode); // ???

const root = createRoot(domNode);

root.render(<App />);
```

For example, if `domNode` is `null`, it means that [`getElementById`](https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById) returned `null`. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it:

1. The ID you’re looking for might differ from the ID you used in the HTML file. Check for typos!
2. Your bundle’s `<script>` tag cannot “see” any DOM nodes that appear *after* it in the HTML.

Another common way to get this error is to write `createRoot(<App />)` instead of `createRoot(domNode)`.

---

### I’m getting an error: “Functions are not valid as a React child.”

This error means that whatever you’re passing to `root.render` is not a React component.

This may happen if you call `root.render` with `Component` instead of `<Component />`:

```
// 🚩 Wrong: App is a function, not a Component.

root.render(App);

// ✅ Correct: <App /> is a component.

root.render(<App />);
```

Or if you pass a function to `root.render`, instead of the result of calling it:

```
// 🚩 Wrong: createApp is a function, not a component.

root.render(createApp);

// ✅ Correct: call createApp to return a component.

root.render(createApp());
```

---

### My server-rendered HTML gets re-created from scratch

If your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and calling `root.render` deletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input.

Server-rendered apps must use [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) instead of `createRoot`:

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(

document.getElementById('root'),

<App />

);
```

Note that its API is different. In particular, usually there will be no further `root.render` call.

[PreviousClient APIs](https://react.dev/reference/react-dom/client)[NexthydrateRoot](https://react.dev/reference/react-dom/client/hydrateRoot)

---

---


# hydrateRoot – React

URL: https://react.dev/reference/react-dom/client/hydrateRoot

[API Reference](https://react.dev/reference/react)

[Client APIs](https://react.dev/reference/react-dom/client)

# hydrateRoot

`hydrateRoot` lets you display React components inside a browser DOM node whose HTML content was previously generated by [`react-dom/server`.](https://react.dev/reference/react-dom/server)

```
const root = hydrateRoot(domNode, reactNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/client/hydrateRoot#reference) 
  + [`hydrateRoot(domNode, reactNode, options?)`](https://react.dev/reference/react-dom/client/hydrateRoot#hydrateroot)
  + [`root.render(reactNode)`](https://react.dev/reference/react-dom/client/hydrateRoot#root-render)
  + [`root.unmount()`](https://react.dev/reference/react-dom/client/hydrateRoot#root-unmount)
* [Usage](https://react.dev/reference/react-dom/client/hydrateRoot#usage) 
  + [Hydrating server-rendered HTML](https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-server-rendered-html)
  + [Hydrating an entire document](https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-an-entire-document)
  + [Suppressing unavoidable hydration mismatch errors](https://react.dev/reference/react-dom/client/hydrateRoot#suppressing-unavoidable-hydration-mismatch-errors)
  + [Handling different client and server content](https://react.dev/reference/react-dom/client/hydrateRoot#handling-different-client-and-server-content)
  + [Updating a hydrated root component](https://react.dev/reference/react-dom/client/hydrateRoot#updating-a-hydrated-root-component)
  + [Error logging in production](https://react.dev/reference/react-dom/client/hydrateRoot#error-logging-in-production)
* [Troubleshooting](https://react.dev/reference/react-dom/client/hydrateRoot#troubleshooting) 
  + [I’m getting an error: “You passed a second argument to root.render”](https://react.dev/reference/react-dom/client/hydrateRoot#im-getting-an-error-you-passed-a-second-argument-to-root-render)

---

## Reference

### `hydrateRoot(domNode, reactNode, options?)`

Call `hydrateRoot` to “attach” React to existing HTML that was already rendered by React in a server environment.

```
import { hydrateRoot } from 'react-dom/client';

const domNode = document.getElementById('root');

const root = hydrateRoot(domNode, reactNode);
```

React will attach to the HTML that exists inside the `domNode`, and take over managing the DOM inside it. An app fully built with React will usually only have one `hydrateRoot` call with its root component.

[See more examples below.](https://react.dev/reference/react-dom/client/hydrateRoot#usage)

#### Parameters

* `domNode`: A [DOM element](https://developer.mozilla.org/en-US/docs/Web/API/Element) that was rendered as the root element on the server.
* `reactNode`: The “React node” used to render the existing HTML. This will usually be a piece of JSX like `<App />` which was rendered with a `ReactDOM Server` method such as `renderToPipeableStream(<App />)`.
* **optional** `options`: An object with options for this React root.

  + **optional** `onCaughtError`: Callback called when React catches an error in an Error Boundary. Called with the `error` caught by the Error Boundary, and an `errorInfo` object containing the `componentStack`.
  + **optional** `onUncaughtError`: Callback called when an error is thrown and not caught by an Error Boundary. Called with the `error` that was thrown and an `errorInfo` object containing the `componentStack`.
  + **optional** `onRecoverableError`: Callback called when React automatically recovers from errors. Called with the `error` React throws, and an `errorInfo` object containing the `componentStack`. Some recoverable errors may include the original error cause as `error.cause`.
  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.

#### Returns

`hydrateRoot` returns an object with two methods: [`render`](https://react.dev/reference/react-dom/client/hydrateRoot#root-render) and [`unmount`.](https://react.dev/reference/react-dom/client/hydrateRoot#root-unmount)

#### Caveats

* `hydrateRoot()` expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them.
* In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.
* You’ll likely have only one `hydrateRoot` call in your app. If you use a framework, it might do this call for you.
* If your app is client-rendered with no HTML rendered already, using `hydrateRoot()` is not supported. Use [`createRoot()`](https://react.dev/reference/react-dom/client/createRoot) instead.

---

### `root.render(reactNode)`

Call `root.render` to update a React component inside a hydrated React root for a browser DOM element.

```
root.render(<App />);
```

React will update `<App />` in the hydrated `root`.

[See more examples below.](https://react.dev/reference/react-dom/client/hydrateRoot#usage)

#### Parameters

* `reactNode`: A “React node” that you want to update. This will usually be a piece of JSX like `<App />`, but you can also pass a React element constructed with [`createElement()`](https://react.dev/reference/react/createElement), a string, a number, `null`, or `undefined`.

#### Returns

`root.render` returns `undefined`.

#### Caveats

* If you call `root.render` before the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.

---

### `root.unmount()`

Call `root.unmount` to destroy a rendered tree inside a React root.

```
root.unmount();
```

An app fully built with React will usually not have any calls to `root.unmount`.

This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to “stop” managing the removed root’s content by calling `root.unmount`. Otherwise, the components inside the removed root won’t clean up and free up resources like subscriptions.

Calling `root.unmount` will unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree.

#### Parameters

`root.unmount` does not accept any parameters.

#### Returns

`root.unmount` returns `undefined`.

#### Caveats

* Calling `root.unmount` will unmount all the components in the tree and “detach” React from the root DOM node.
* Once you call `root.unmount` you cannot call `root.render` again on the root. Attempting to call `root.render` on an unmounted root will throw a “Cannot update an unmounted root” error.

---

## Usage

### Hydrating server-rendered HTML

If your app’s HTML was generated by [`react-dom/server`](https://react.dev/reference/react-dom/client/createRoot), you need to *hydrate* it on the client.

```
import { hydrateRoot } from 'react-dom/client';

hydrateRoot(document.getElementById('root'), <App />);
```

This will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.

To hydrate your app, React will “attach” your components’ logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.

index.jsindex.htmlApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import './styles.css';
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(
  document.getElementById('root'),
  <App />
);
```

You shouldn’t need to call `hydrateRoot` again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will [use state](https://react.dev/reference/react/useState) instead.

### Pitfall

The React tree you pass to `hydrateRoot` needs to produce **the same output** as it did on the server.

This is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client.

The most common causes leading to hydration errors include:

* Extra whitespace (like newlines) around the React-generated HTML inside the root node.
* Using checks like `typeof window !== 'undefined'` in your rendering logic.
* Using browser-only APIs like [`window.matchMedia`](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your rendering logic.
* Rendering different data on the server and the client.

React recovers from some hydration errors, but **you must fix them like other bugs.** In the best case, they’ll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements.

---

### Hydrating an entire document

Apps fully built with React can render the entire document as JSX, including the [`<html>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html) tag:

```
function App() {

return (

<html>

<head>

<meta charSet="utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/styles.css"></link>

<title>My app</title>

</head>

<body>

<Router />

</body>

</html>

);

}
```

To hydrate the entire document, pass the [`document`](https://developer.mozilla.org/en-US/docs/Web/API/Window/document) global as the first argument to `hydrateRoot`:

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App />);
```

---

### Suppressing unavoidable hydration mismatch errors

If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.

To silence hydration warnings on an element, add `suppressHydrationWarning={true}`:

index.jsindex.htmlApp.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function App() {
  return (
    <h1 suppressHydrationWarning={true}>
      Current Date: {new Date().toLocaleDateString()}
    </h1>
  );
}
```

This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. React will **not** attempt to patch mismatched text content.

---

### Handling different client and server content

If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a [state variable](https://react.dev/reference/react/useState) like `isClient`, which you can set to `true` in an [Effect](https://react.dev/reference/react/useEffect):

index.jsindex.htmlApp.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from "react";

export default function App() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return (
    <h1>
      {isClient ? 'Is Client' : 'Is Server'}
    </h1>
  );
}
```

This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.

### Pitfall

This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user.

---

### Updating a hydrated root component

After the root has finished hydrating, you can call [`root.render`](https://react.dev/reference/react-dom/client/hydrateRoot#root-render) to update the root React component. **Unlike with [`createRoot`](https://react.dev/reference/react-dom/client/createRoot), you don’t usually need to do this because the initial content was already rendered as HTML.**

If you call `root.render` at some point after hydration, and the component tree structure matches up with what was previously rendered, React will [preserve the state.](https://react.dev/learn/preserving-and-resetting-state) Notice how you can type in the input, which means that the updates from repeated `render` calls every second in this example are not destructive:

index.jsindex.htmlApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { hydrateRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = hydrateRoot(
  document.getElementById('root'),
  <App counter={0} />
);

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);
```

It is uncommon to call [`root.render`](https://react.dev/reference/react-dom/client/hydrateRoot#root-render) on a hydrated root. Usually, you’ll [update state](https://react.dev/reference/react/useState) inside one of the components instead.

### Error logging in production

By default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options `onUncaughtError`, `onCaughtError` and `onRecoverableError`:

```
import { hydrateRoot } from "react-dom/client";

import App from "./App.js";

import { reportCaughtError } from "./reportError";

const container = document.getElementById("root");

const root = hydrateRoot(container, <App />, {

onCaughtError: (error, errorInfo) => {

if (error.message !== "Known error") {

reportCaughtError({

error,

componentStack: errorInfo.componentStack,

});

}

},

});
```

The onCaughtError option is a function called with two arguments:

1. The error that was thrown.
2. An errorInfo object that contains the componentStack of the error.

Together with `onUncaughtError` and `onRecoverableError`, you can implement your own error reporting system:

index.jsreportError.jsApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import {
  onCaughtErrorProd,
  onRecoverableErrorProd,
  onUncaughtErrorProd,
} from "./reportError";

const container = document.getElementById("root");
hydrateRoot(container, <App />, {
  // Keep in mind to remove these options in development to leverage
  // React's default handlers or implement your own overlay for development.
  // The handlers are only specfied unconditionally here for demonstration purposes.
  onCaughtError: onCaughtErrorProd,
  onRecoverableError: onRecoverableErrorProd,
  onUncaughtError: onUncaughtErrorProd,
});
```

Show more

## Troubleshooting

### I’m getting an error: “You passed a second argument to root.render”

A common mistake is to pass the options for `hydrateRoot` to `root.render(...)`:

Console

Warning: You passed a second argument to root.render(…) but it only accepts one argument.

To fix, pass the root options to `hydrateRoot(...)`, not `root.render(...)`:

```
// 🚩 Wrong: root.render only takes one argument.

root.render(App, {onUncaughtError});

// ✅ Correct: pass options to createRoot.

const root = hydrateRoot(container, <App />, {onUncaughtError});
```

[PreviouscreateRoot](https://react.dev/reference/react-dom/client/createRoot)[NextServer APIs](https://react.dev/reference/react-dom/server)

---

---


# renderToPipeableStream – React

URL: https://react.dev/reference/react-dom/server/renderToPipeableStream

[API Reference](https://react.dev/reference/react)

[Server APIs](https://react.dev/reference/react-dom/server)

# renderToPipeableStream

`renderToPipeableStream` renders a React tree to a pipeable [Node.js Stream.](https://nodejs.org/api/stream.html)

```
const { pipe, abort } = renderToPipeableStream(reactNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/server/renderToPipeableStream#reference) 
  + [`renderToPipeableStream(reactNode, options?)`](https://react.dev/reference/react-dom/server/renderToPipeableStream#rendertopipeablestream)
* [Usage](https://react.dev/reference/react-dom/server/renderToPipeableStream#usage) 
  + [Rendering a React tree as HTML to a Node.js Stream](https://react.dev/reference/react-dom/server/renderToPipeableStream#rendering-a-react-tree-as-html-to-a-nodejs-stream)
  + [Streaming more content as it loads](https://react.dev/reference/react-dom/server/renderToPipeableStream#streaming-more-content-as-it-loads)
  + [Specifying what goes into the shell](https://react.dev/reference/react-dom/server/renderToPipeableStream#specifying-what-goes-into-the-shell)
  + [Logging crashes on the server](https://react.dev/reference/react-dom/server/renderToPipeableStream#logging-crashes-on-the-server)
  + [Recovering from errors inside the shell](https://react.dev/reference/react-dom/server/renderToPipeableStream#recovering-from-errors-inside-the-shell)
  + [Recovering from errors outside the shell](https://react.dev/reference/react-dom/server/renderToPipeableStream#recovering-from-errors-outside-the-shell)
  + [Setting the status code](https://react.dev/reference/react-dom/server/renderToPipeableStream#setting-the-status-code)
  + [Handling different errors in different ways](https://react.dev/reference/react-dom/server/renderToPipeableStream#handling-different-errors-in-different-ways)
  + [Waiting for all content to load for crawlers and static generation](https://react.dev/reference/react-dom/server/renderToPipeableStream#waiting-for-all-content-to-load-for-crawlers-and-static-generation)
  + [Aborting server rendering](https://react.dev/reference/react-dom/server/renderToPipeableStream#aborting-server-rendering)

### Note

This API is specific to Node.js. Environments with [Web Streams,](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) like Deno and modern edge runtimes, should use [`renderToReadableStream`](https://react.dev/reference/react-dom/server/renderToReadableStream) instead.

---

## Reference

### `renderToPipeableStream(reactNode, options?)`

Call `renderToPipeableStream` to render your React tree as HTML into a [Node.js Stream.](https://nodejs.org/api/stream.html#writable-streams)

```
import { renderToPipeableStream } from 'react-dom/server';

const { pipe } = renderToPipeableStream(<App />, {

bootstrapScripts: ['/main.js'],

onShellReady() {

response.setHeader('content-type', 'text/html');

pipe(response);

}

});
```

On the client, call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](https://react.dev/reference/react-dom/server/renderToPipeableStream#usage)

#### Parameters

* `reactNode`: A React node you want to render to HTML. For example, a JSX element like `<App />`. It is expected to represent the entire document, so the `App` component should render the `<html>` tag.
* **optional** `options`: An object with streaming options.

  + **optional** `bootstrapScriptContent`: If specified, this string will be placed in an inline `<script>` tag.
  + **optional** `bootstrapScripts`: An array of string URLs for the `<script>` tags to emit on the page. Use this to include the `<script>` that calls [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot) Omit it if you don’t want to run React on the client at all.
  + **optional** `bootstrapModules`: Like `bootstrapScripts`, but emits [`<script type="module">`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) instead.
  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot#parameters)
  + **optional** `namespaceURI`: A string with the root [namespace URI](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS#important_namespace_uris) for the stream. Defaults to regular HTML. Pass `'http://www.w3.org/2000/svg'` for SVG or `'http://www.w3.org/1998/Math/MathML'` for MathML.
  + **optional** `nonce`: A [`nonce`](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#nonce) string to allow scripts for [`script-src` Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src).
  + **optional** `onAllReady`: A callback that fires when all rendering is complete, including both the [shell](https://react.dev/reference/react-dom/server/renderToPipeableStream#specifying-what-goes-into-the-shell) and all additional [content.](https://react.dev/reference/react-dom/server/renderToPipeableStream#streaming-more-content-as-it-loads) You can use this instead of `onShellReady` [for crawlers and static generation.](https://react.dev/reference/react-dom/server/renderToPipeableStream#waiting-for-all-content-to-load-for-crawlers-and-static-generation) If you start streaming here, you won’t get any progressive loading. The stream will contain the final HTML.
  + **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/server/renderToPipeableStream#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/server/renderToPipeableStream#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/server/renderToPipeableStream#logging-crashes-on-the-server) make sure that you still call `console.error`. You can also use it to [adjust the status code](https://react.dev/reference/react-dom/server/renderToPipeableStream#setting-the-status-code) before the shell is emitted.
  + **optional** `onShellReady`: A callback that fires right after the [initial shell](https://react.dev/reference/react-dom/server/renderToPipeableStream#specifying-what-goes-into-the-shell) has been rendered. You can [set the status code](https://react.dev/reference/react-dom/server/renderToPipeableStream#setting-the-status-code) and call `pipe` here to start streaming. React will [stream the additional content](https://react.dev/reference/react-dom/server/renderToPipeableStream#streaming-more-content-as-it-loads) after the shell along with the inline `<script>` tags that replace the HTML loading fallbacks with the content.
  + **optional** `onShellError`: A callback that fires if there was an error rendering the initial shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neither `onShellReady` nor `onAllReady` will get called, so you can [output a fallback HTML shell.](https://react.dev/reference/react-dom/server/renderToPipeableStream#recovering-from-errors-inside-the-shell)
  + **optional** `progressiveChunkSize`: The number of bytes in a chunk. [Read more about the default heuristic.](https://github.com/facebook/react/blob/14c2be8dac2d5482fda8a0906a31d239df8551fc/packages/react-server/src/ReactFizzServer.js#L210-L225)

#### Returns

`renderToPipeableStream` returns an object with two methods:

* `pipe` outputs the HTML into the provided [Writable Node.js Stream.](https://nodejs.org/api/stream.html#writable-streams) Call `pipe` in `onShellReady` if you want to enable streaming, or in `onAllReady` for crawlers and static generation.
* `abort` lets you [abort server rendering](https://react.dev/reference/react-dom/server/renderToPipeableStream#aborting-server-rendering) and render the rest on the client.

---

## Usage

### Rendering a React tree as HTML to a Node.js Stream

Call `renderToPipeableStream` to render your React tree as HTML into a [Node.js Stream:](https://nodejs.org/api/stream.html#writable-streams)

```
import { renderToPipeableStream } from 'react-dom/server';

// The route handler syntax depends on your backend framework

app.use('/', (request, response) => {

const { pipe } = renderToPipeableStream(<App />, {

bootstrapScripts: ['/main.js'],

onShellReady() {

response.setHeader('content-type', 'text/html');

pipe(response);

}

});

});
```

Along with the root component, you need to provide a list of bootstrap `<script>` paths. Your root component should return **the entire document including the root `<html>` tag.**

For example, it might look like this:

```
export default function App() {

return (

<html>

<head>

<meta charSet="utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/styles.css"></link>

<title>My app</title>

</head>

<body>

<Router />

</body>

</html>

);

}
```

React will inject the [doctype](https://developer.mozilla.org/en-US/docs/Glossary/Doctype) and your bootstrap `<script>` tags into the resulting HTML stream:

```
<!DOCTYPE html>

<html>

<!-- ... HTML from your components ... -->

</html>

<script src="/main.js" async=""></script>
```

On the client, your bootstrap script should [hydrate the entire `document` with a call to `hydrateRoot`:](https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-an-entire-document)

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App />);
```

This will attach event listeners to the server-generated HTML and make it interactive.

##### Deep Dive

#### Reading CSS and JS asset paths from the build output

Show Details

The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of `styles.css` you might end up with `styles.123456.css`. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.

However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding `"/styles.css"` into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:

```
export default function App({ assetMap }) {

return (

<html>

<head>

...

<link rel="stylesheet" href={assetMap['styles.css']}></link>

...

</head>

...

</html>

);

}
```

On the server, render `<App assetMap={assetMap} />` and pass your `assetMap` with the asset URLs:

```
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.

const assetMap = {

'styles.css': '/styles.123456.css',

'main.js': '/main.123456.js'

};

app.use('/', (request, response) => {

const { pipe } = renderToPipeableStream(<App assetMap={assetMap} />, {

bootstrapScripts: [assetMap['main.js']],

onShellReady() {

response.setHeader('content-type', 'text/html');

pipe(response);

}

});

});
```

Since your server is now rendering `<App assetMap={assetMap} />`, you need to render it with `assetMap` on the client too to avoid hydration errors. You can serialize and pass `assetMap` to the client like this:

```
// You'd need to get this JSON from your build tooling.

const assetMap = {

'styles.css': '/styles.123456.css',

'main.js': '/main.123456.js'

};

app.use('/', (request, response) => {

const { pipe } = renderToPipeableStream(<App assetMap={assetMap} />, {

// Careful: It's safe to stringify() this because this data isn't user-generated.

bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,

bootstrapScripts: [assetMap['main.js']],

onShellReady() {

response.setHeader('content-type', 'text/html');

pipe(response);

}

});

});
```

In the example above, the `bootstrapScriptContent` option adds an extra inline `<script>` tag that sets the global `window.assetMap` variable on the client. This lets the client code read the same `assetMap`:

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App assetMap={window.assetMap} />);
```

Both client and server render `App` with the same `assetMap` prop, so there are no hydration errors.

---

### Streaming more content as it loads

Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Posts />

</ProfileLayout>

);

}
```

Imagine that loading data for `<Posts />` takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this, [wrap `Posts` in a `<Suspense>` boundary:](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading)

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</ProfileLayout>

);

}
```

This tells React to start streaming the HTML before `Posts` loads its data. React will send the HTML for the loading fallback (`PostsGlimmer`) first, and then, when `Posts` finishes loading its data, React will send the remaining HTML along with an inline `<script>` tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with the `PostsGlimmer`, later replaced by the `Posts`.

You can further [nest `<Suspense>` boundaries](https://react.dev/reference/react/Suspense#revealing-nested-content-as-it-loads) to create a more granular loading sequence:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Suspense fallback={<BigSpinner />}>

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</Suspense>

</ProfileLayout>

);

}
```

In this example, React can start streaming the page even earlier. Only `ProfileLayout` and `ProfileCover` must finish rendering first because they are not wrapped in any `<Suspense>` boundary. However, if `Sidebar`, `Friends`, or `Photos` need to load some data, React will send the HTML for the `BigSpinner` fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.

Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the `<script>` tags load.

[Read more about how streaming HTML works.](https://github.com/reactwg/react-18/discussions/37)

### Note

**Only Suspense-enabled data sources will activate the Suspense component.** They include:

* Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/getting-started/react-essentials)
* Lazy-loading component code with [`lazy`](https://react.dev/reference/react/lazy)
* Reading the value of a Promise with [`use`](https://react.dev/reference/react/use)

Suspense **does not** detect when data is fetched inside an Effect or event handler.

The exact way you would load data in the `Posts` component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

---

### Specifying what goes into the shell

The part of your app outside of any `<Suspense>` boundaries is called *the shell:*

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Suspense fallback={<BigSpinner />}>

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</Suspense>

</ProfileLayout>

);

}
```

It determines the earliest loading state that the user may see:

```
<ProfileLayout>

<ProfileCover />

<BigSpinner />

</ProfileLayout>
```

If you wrap the whole app into a `<Suspense>` boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the `<Suspense>` boundaries so that the shell feels *minimal but complete*—like a skeleton of the entire page layout.

The `onShellReady` callback fires when the entire shell has been rendered. Usually, you’ll start streaming then:

```
const { pipe } = renderToPipeableStream(<App />, {

bootstrapScripts: ['/main.js'],

onShellReady() {

response.setHeader('content-type', 'text/html');

pipe(response);

}

});
```

By the time `onShellReady` fires, components in nested `<Suspense>` boundaries might still be loading data.

---

### Logging crashes on the server

By default, all errors on the server are logged to console. You can override this behavior to log crash reports:

```
const { pipe } = renderToPipeableStream(<App />, {

bootstrapScripts: ['/main.js'],

onShellReady() {

response.setHeader('content-type', 'text/html');

pipe(response);

},

onError(error) {

console.error(error);

logServerCrashReport(error);

}

});
```

If you provide a custom `onError` implementation, don’t forget to also log errors to the console like above.

---

### Recovering from errors inside the shell

In this example, the shell contains `ProfileLayout`, `ProfileCover`, and `PostsGlimmer`:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</ProfileLayout>

);

}
```

If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Override `onShellError` to send a fallback HTML that doesn’t rely on server rendering as the last resort:

```
const { pipe } = renderToPipeableStream(<App />, {

bootstrapScripts: ['/main.js'],

onShellReady() {

response.setHeader('content-type', 'text/html');

pipe(response);

},

onShellError(error) {

response.statusCode = 500;

response.setHeader('content-type', 'text/html');

response.send('<h1>Something went wrong</h1>');

},

onError(error) {

console.error(error);

logServerCrashReport(error);

}

});
```

If there is an error while generating the shell, both `onError` and `onShellError` will fire. Use `onError` for error reporting and use `onShellError` to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.

---

### Recovering from errors outside the shell

In this example, the `<Posts />` component is wrapped in `<Suspense>` so it is *not* a part of the shell:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</ProfileLayout>

);

}
```

If an error happens in the `Posts` component or somewhere inside it, React will [try to recover from it:](https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content)

1. It will emit the loading fallback for the closest `<Suspense>` boundary (`PostsGlimmer`) into the HTML.
2. It will “give up” on trying to render the `Posts` content on the server anymore.
3. When the JavaScript code loads on the client, React will *retry* rendering `Posts` on the client.

If retrying rendering `Posts` on the client *also* fails, React will throw the error on the client. As with all the errors thrown during rendering, the [closest parent error boundary](https://react.dev/reference/react/Component#static-getderivedstatefromerror) determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.

If retrying rendering `Posts` on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server `onError` callback and the client [`onRecoverableError`](https://react.dev/reference/react-dom/client/hydrateRoot#hydrateroot) callbacks will fire so that you can get notified about the error.

---

### Setting the status code

Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.

By [dividing your app](https://react.dev/reference/react-dom/server/renderToPipeableStream#specifying-what-goes-into-the-shell) into the shell (above all `<Suspense>` boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, you’ll get the `onShellError` callback which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.

```
const { pipe } = renderToPipeableStream(<App />, {

bootstrapScripts: ['/main.js'],

onShellReady() {

response.statusCode = 200;

response.setHeader('content-type', 'text/html');

pipe(response);

},

onShellError(error) {

response.statusCode = 500;

response.setHeader('content-type', 'text/html');

response.send('<h1>Something went wrong</h1>');

},

onError(error) {

console.error(error);

logServerCrashReport(error);

}

});
```

If a component *outside* the shell (i.e. inside a `<Suspense>` boundary) throws an error, React will not stop rendering. This means that the `onError` callback will fire, but you will still get `onShellReady` instead of `onShellError`. This is because React will try to recover from that error on the client, [as described above.](https://react.dev/reference/react-dom/server/renderToPipeableStream#recovering-from-errors-outside-the-shell)

However, if you’d like, you can use the fact that something has errored to set the status code:

```
let didError = false;

const { pipe } = renderToPipeableStream(<App />, {

bootstrapScripts: ['/main.js'],

onShellReady() {

response.statusCode = didError ? 500 : 200;

response.setHeader('content-type', 'text/html');

pipe(response);

},

onShellError(error) {

response.statusCode = 500;

response.setHeader('content-type', 'text/html');

response.send('<h1>Something went wrong</h1>');

},

onError(error) {

didError = true;

console.error(error);

logServerCrashReport(error);

}

});
```

This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.

---

### Handling different errors in different ways

You can [create your own `Error` subclasses](https://javascript.info/custom-errors) and use the [`instanceof`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) operator to check which error is thrown. For example, you can define a custom `NotFoundError` and throw it from your component. Then your `onError`, `onShellReady`, and `onShellError` callbacks can do something different depending on the error type:

```
let didError = false;

let caughtError = null;

function getStatusCode() {

if (didError) {

if (caughtError instanceof NotFoundError) {

return 404;

} else {

return 500;

}

} else {

return 200;

}

}

const { pipe } = renderToPipeableStream(<App />, {

bootstrapScripts: ['/main.js'],

onShellReady() {

response.statusCode = getStatusCode();

response.setHeader('content-type', 'text/html');

pipe(response);

},

onShellError(error) {

response.statusCode = getStatusCode();

response.setHeader('content-type', 'text/html');

response.send('<h1>Something went wrong</h1>');

},

onError(error) {

didError = true;

caughtError = error;

console.error(error);

logServerCrashReport(error);

}

});
```

Keep in mind that once you emit the shell and start streaming, you can’t change the status code.

---

### Waiting for all content to load for crawlers and static generation

Streaming offers a better user experience because the user can see the content as it becomes available.

However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.

You can wait for all the content to load using the `onAllReady` callback:

```
let didError = false;

let isCrawler = // ... depends on your bot detection strategy ...

const { pipe } = renderToPipeableStream(<App />, {

bootstrapScripts: ['/main.js'],

onShellReady() {

if (!isCrawler) {

response.statusCode = didError ? 500 : 200;

response.setHeader('content-type', 'text/html');

pipe(response);

}

},

onShellError(error) {

response.statusCode = 500;

response.setHeader('content-type', 'text/html');

response.send('<h1>Something went wrong</h1>');

},

onAllReady() {

if (isCrawler) {

response.statusCode = didError ? 500 : 200;

response.setHeader('content-type', 'text/html');

pipe(response);

}

},

onError(error) {

didError = true;

console.error(error);

logServerCrashReport(error);

}

});
```

A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for *all* data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.

---

### Aborting server rendering

You can force the server rendering to “give up” after a timeout:

```
const { pipe, abort } = renderToPipeableStream(<App />, {

// ...

});

setTimeout(() => {

abort();

}, 10000);
```

React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.

[PreviousServer APIs](https://react.dev/reference/react-dom/server)[NextrenderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream)

---

---


# renderToReadableStream – React

URL: https://react.dev/reference/react-dom/server/renderToReadableStream

[API Reference](https://react.dev/reference/react)

[Server APIs](https://react.dev/reference/react-dom/server)

# renderToReadableStream

`renderToReadableStream` renders a React tree to a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

```
const stream = await renderToReadableStream(reactNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/server/renderToReadableStream#reference) 
  + [`renderToReadableStream(reactNode, options?)`](https://react.dev/reference/react-dom/server/renderToReadableStream#rendertoreadablestream)
* [Usage](https://react.dev/reference/react-dom/server/renderToReadableStream#usage) 
  + [Rendering a React tree as HTML to a Readable Web Stream](https://react.dev/reference/react-dom/server/renderToReadableStream#rendering-a-react-tree-as-html-to-a-readable-web-stream)
  + [Streaming more content as it loads](https://react.dev/reference/react-dom/server/renderToReadableStream#streaming-more-content-as-it-loads)
  + [Specifying what goes into the shell](https://react.dev/reference/react-dom/server/renderToReadableStream#specifying-what-goes-into-the-shell)
  + [Logging crashes on the server](https://react.dev/reference/react-dom/server/renderToReadableStream#logging-crashes-on-the-server)
  + [Recovering from errors inside the shell](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell)
  + [Recovering from errors outside the shell](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-outside-the-shell)
  + [Setting the status code](https://react.dev/reference/react-dom/server/renderToReadableStream#setting-the-status-code)
  + [Handling different errors in different ways](https://react.dev/reference/react-dom/server/renderToReadableStream#handling-different-errors-in-different-ways)
  + [Waiting for all content to load for crawlers and static generation](https://react.dev/reference/react-dom/server/renderToReadableStream#waiting-for-all-content-to-load-for-crawlers-and-static-generation)
  + [Aborting server rendering](https://react.dev/reference/react-dom/server/renderToReadableStream#aborting-server-rendering)

### Note

This API depends on [Web Streams.](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) For Node.js, use [`renderToPipeableStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream) instead.

---

## Reference

### `renderToReadableStream(reactNode, options?)`

Call `renderToReadableStream` to render your React tree as HTML into a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

```
import { renderToReadableStream } from 'react-dom/server';

async function handler(request) {

const stream = await renderToReadableStream(<App />, {

bootstrapScripts: ['/main.js']

});

return new Response(stream, {

headers: { 'content-type': 'text/html' },

});

}
```

On the client, call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](https://react.dev/reference/react-dom/server/renderToReadableStream#usage)

#### Parameters

* `reactNode`: A React node you want to render to HTML. For example, a JSX element like `<App />`. It is expected to represent the entire document, so the `App` component should render the `<html>` tag.
* **optional** `options`: An object with streaming options.

  + **optional** `bootstrapScriptContent`: If specified, this string will be placed in an inline `<script>` tag.
  + **optional** `bootstrapScripts`: An array of string URLs for the `<script>` tags to emit on the page. Use this to include the `<script>` that calls [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot) Omit it if you don’t want to run React on the client at all.
  + **optional** `bootstrapModules`: Like `bootstrapScripts`, but emits [`<script type="module">`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) instead.
  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot#parameters)
  + **optional** `namespaceURI`: A string with the root [namespace URI](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS#important_namespace_uris) for the stream. Defaults to regular HTML. Pass `'http://www.w3.org/2000/svg'` for SVG or `'http://www.w3.org/1998/Math/MathML'` for MathML.
  + **optional** `nonce`: A [`nonce`](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#nonce) string to allow scripts for [`script-src` Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src).
  + **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/server/renderToReadableStream#logging-crashes-on-the-server) make sure that you still call `console.error`. You can also use it to [adjust the status code](https://react.dev/reference/react-dom/server/renderToReadableStream#setting-the-status-code) before the shell is emitted.
  + **optional** `progressiveChunkSize`: The number of bytes in a chunk. [Read more about the default heuristic.](https://github.com/facebook/react/blob/14c2be8dac2d5482fda8a0906a31d239df8551fc/packages/react-server/src/ReactFizzServer.js#L210-L225)
  + **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort server rendering](https://react.dev/reference/react-dom/server/renderToReadableStream#aborting-server-rendering) and render the rest on the client.

#### Returns

`renderToReadableStream` returns a Promise:

* If rendering the [shell](https://react.dev/reference/react-dom/server/renderToReadableStream#specifying-what-goes-into-the-shell) is successful, that Promise will resolve to a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)
* If rendering the shell fails, the Promise will be rejected. [Use this to output a fallback shell.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell)

The returned stream has an additional property:

* `allReady`: A Promise that resolves when all rendering is complete, including both the [shell](https://react.dev/reference/react-dom/server/renderToReadableStream#specifying-what-goes-into-the-shell) and all additional [content.](https://react.dev/reference/react-dom/server/renderToReadableStream#streaming-more-content-as-it-loads) You can `await stream.allReady` before returning a response [for crawlers and static generation.](https://react.dev/reference/react-dom/server/renderToReadableStream#waiting-for-all-content-to-load-for-crawlers-and-static-generation) If you do that, you won’t get any progressive loading. The stream will contain the final HTML.

---

## Usage

### Rendering a React tree as HTML to a Readable Web Stream

Call `renderToReadableStream` to render your React tree as HTML into a [Readable Web Stream:](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

```
import { renderToReadableStream } from 'react-dom/server';

async function handler(request) {

const stream = await renderToReadableStream(<App />, {

bootstrapScripts: ['/main.js']

});

return new Response(stream, {

headers: { 'content-type': 'text/html' },

});

}
```

Along with the root component, you need to provide a list of bootstrap `<script>` paths. Your root component should return **the entire document including the root `<html>` tag.**

For example, it might look like this:

```
export default function App() {

return (

<html>

<head>

<meta charSet="utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/styles.css"></link>

<title>My app</title>

</head>

<body>

<Router />

</body>

</html>

);

}
```

React will inject the [doctype](https://developer.mozilla.org/en-US/docs/Glossary/Doctype) and your bootstrap `<script>` tags into the resulting HTML stream:

```
<!DOCTYPE html>

<html>

<!-- ... HTML from your components ... -->

</html>

<script src="/main.js" async=""></script>
```

On the client, your bootstrap script should [hydrate the entire `document` with a call to `hydrateRoot`:](https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-an-entire-document)

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App />);
```

This will attach event listeners to the server-generated HTML and make it interactive.

##### Deep Dive

#### Reading CSS and JS asset paths from the build output

Show Details

The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of `styles.css` you might end up with `styles.123456.css`. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.

However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding `"/styles.css"` into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:

```
export default function App({ assetMap }) {

return (

<html>

<head>

<title>My app</title>

<link rel="stylesheet" href={assetMap['styles.css']}></link>

</head>

...

</html>

);

}
```

On the server, render `<App assetMap={assetMap} />` and pass your `assetMap` with the asset URLs:

```
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.

const assetMap = {

'styles.css': '/styles.123456.css',

'main.js': '/main.123456.js'

};

async function handler(request) {

const stream = await renderToReadableStream(<App assetMap={assetMap} />, {

bootstrapScripts: [assetMap['/main.js']]

});

return new Response(stream, {

headers: { 'content-type': 'text/html' },

});

}
```

Since your server is now rendering `<App assetMap={assetMap} />`, you need to render it with `assetMap` on the client too to avoid hydration errors. You can serialize and pass `assetMap` to the client like this:

```
// You'd need to get this JSON from your build tooling.

const assetMap = {

'styles.css': '/styles.123456.css',

'main.js': '/main.123456.js'

};

async function handler(request) {

const stream = await renderToReadableStream(<App assetMap={assetMap} />, {

// Careful: It's safe to stringify() this because this data isn't user-generated.

bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,

bootstrapScripts: [assetMap['/main.js']],

});

return new Response(stream, {

headers: { 'content-type': 'text/html' },

});

}
```

In the example above, the `bootstrapScriptContent` option adds an extra inline `<script>` tag that sets the global `window.assetMap` variable on the client. This lets the client code read the same `assetMap`:

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App assetMap={window.assetMap} />);
```

Both client and server render `App` with the same `assetMap` prop, so there are no hydration errors.

---

### Streaming more content as it loads

Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Posts />

</ProfileLayout>

);

}
```

Imagine that loading data for `<Posts />` takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this, [wrap `Posts` in a `<Suspense>` boundary:](https://react.dev/reference/react/Suspense#displaying-a-fallback-while-content-is-loading)

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</ProfileLayout>

);

}
```

This tells React to start streaming the HTML before `Posts` loads its data. React will send the HTML for the loading fallback (`PostsGlimmer`) first, and then, when `Posts` finishes loading its data, React will send the remaining HTML along with an inline `<script>` tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with the `PostsGlimmer`, later replaced by the `Posts`.

You can further [nest `<Suspense>` boundaries](https://react.dev/reference/react/Suspense#revealing-nested-content-as-it-loads) to create a more granular loading sequence:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Suspense fallback={<BigSpinner />}>

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</Suspense>

</ProfileLayout>

);

}
```

In this example, React can start streaming the page even earlier. Only `ProfileLayout` and `ProfileCover` must finish rendering first because they are not wrapped in any `<Suspense>` boundary. However, if `Sidebar`, `Friends`, or `Photos` need to load some data, React will send the HTML for the `BigSpinner` fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible.

Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the `<script>` tags load.

[Read more about how streaming HTML works.](https://github.com/reactwg/react-18/discussions/37)

### Note

**Only Suspense-enabled data sources will activate the Suspense component.** They include:

* Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/getting-started/react-essentials)
* Lazy-loading component code with [`lazy`](https://react.dev/reference/react/lazy)
* Reading the value of a Promise with [`use`](https://react.dev/reference/react/use)

Suspense **does not** detect when data is fetched inside an Effect or event handler.

The exact way you would load data in the `Posts` component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

---

### Specifying what goes into the shell

The part of your app outside of any `<Suspense>` boundaries is called *the shell:*

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Suspense fallback={<BigSpinner />}>

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</Suspense>

</ProfileLayout>

);

}
```

It determines the earliest loading state that the user may see:

```
<ProfileLayout>

<ProfileCover />

<BigSpinner />

</ProfileLayout>
```

If you wrap the whole app into a `<Suspense>` boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the `<Suspense>` boundaries so that the shell feels *minimal but complete*—like a skeleton of the entire page layout.

The async call to `renderToReadableStream` will resolve to a `stream` as soon as the entire shell has been rendered. Usually, you’ll start streaming then by creating and returning a response with that `stream`:

```
async function handler(request) {

const stream = await renderToReadableStream(<App />, {

bootstrapScripts: ['/main.js']

});

return new Response(stream, {

headers: { 'content-type': 'text/html' },

});

}
```

By the time the `stream` is returned, components in nested `<Suspense>` boundaries might still be loading data.

---

### Logging crashes on the server

By default, all errors on the server are logged to console. You can override this behavior to log crash reports:

```
async function handler(request) {

const stream = await renderToReadableStream(<App />, {

bootstrapScripts: ['/main.js'],

onError(error) {

console.error(error);

logServerCrashReport(error);

}

});

return new Response(stream, {

headers: { 'content-type': 'text/html' },

});

}
```

If you provide a custom `onError` implementation, don’t forget to also log errors to the console like above.

---

### Recovering from errors inside the shell

In this example, the shell contains `ProfileLayout`, `ProfileCover`, and `PostsGlimmer`:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</ProfileLayout>

);

}
```

If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Wrap your `renderToReadableStream` call in a `try...catch` to send a fallback HTML that doesn’t rely on server rendering as the last resort:

```
async function handler(request) {

try {

const stream = await renderToReadableStream(<App />, {

bootstrapScripts: ['/main.js'],

onError(error) {

console.error(error);

logServerCrashReport(error);

}

});

return new Response(stream, {

headers: { 'content-type': 'text/html' },

});

} catch (error) {

return new Response('<h1>Something went wrong</h1>', {

status: 500,

headers: { 'content-type': 'text/html' },

});

}

}
```

If there is an error while generating the shell, both `onError` and your `catch` block will fire. Use `onError` for error reporting and use the `catch` block to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only.

---

### Recovering from errors outside the shell

In this example, the `<Posts />` component is wrapped in `<Suspense>` so it is *not* a part of the shell:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</ProfileLayout>

);

}
```

If an error happens in the `Posts` component or somewhere inside it, React will [try to recover from it:](https://react.dev/reference/react/Suspense#providing-a-fallback-for-server-errors-and-client-only-content)

1. It will emit the loading fallback for the closest `<Suspense>` boundary (`PostsGlimmer`) into the HTML.
2. It will “give up” on trying to render the `Posts` content on the server anymore.
3. When the JavaScript code loads on the client, React will *retry* rendering `Posts` on the client.

If retrying rendering `Posts` on the client *also* fails, React will throw the error on the client. As with all the errors thrown during rendering, the [closest parent error boundary](https://react.dev/reference/react/Component#static-getderivedstatefromerror) determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable.

If retrying rendering `Posts` on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server `onError` callback and the client [`onRecoverableError`](https://react.dev/reference/react-dom/client/hydrateRoot#hydrateroot) callbacks will fire so that you can get notified about the error.

---

### Setting the status code

Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code.

By [dividing your app](https://react.dev/reference/react-dom/server/renderToReadableStream#specifying-what-goes-into-the-shell) into the shell (above all `<Suspense>` boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, your `catch` block will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.

```
async function handler(request) {

try {

const stream = await renderToReadableStream(<App />, {

bootstrapScripts: ['/main.js'],

onError(error) {

console.error(error);

logServerCrashReport(error);

}

});

return new Response(stream, {

status: 200,

headers: { 'content-type': 'text/html' },

});

} catch (error) {

return new Response('<h1>Something went wrong</h1>', {

status: 500,

headers: { 'content-type': 'text/html' },

});

}

}
```

If a component *outside* the shell (i.e. inside a `<Suspense>` boundary) throws an error, React will not stop rendering. This means that the `onError` callback will fire, but your code will continue running without getting into the `catch` block. This is because React will try to recover from that error on the client, [as described above.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-outside-the-shell)

However, if you’d like, you can use the fact that something has errored to set the status code:

```
async function handler(request) {

try {

let didError = false;

const stream = await renderToReadableStream(<App />, {

bootstrapScripts: ['/main.js'],

onError(error) {

didError = true;

console.error(error);

logServerCrashReport(error);

}

});

return new Response(stream, {

status: didError ? 500 : 200,

headers: { 'content-type': 'text/html' },

});

} catch (error) {

return new Response('<h1>Something went wrong</h1>', {

status: 500,

headers: { 'content-type': 'text/html' },

});

}

}
```

This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell.

---

### Handling different errors in different ways

You can [create your own `Error` subclasses](https://javascript.info/custom-errors) and use the [`instanceof`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof) operator to check which error is thrown. For example, you can define a custom `NotFoundError` and throw it from your component. Then you can save the error in `onError` and do something different before returning the response depending on the error type:

```
async function handler(request) {

let didError = false;

let caughtError = null;

function getStatusCode() {

if (didError) {

if (caughtError instanceof NotFoundError) {

return 404;

} else {

return 500;

}

} else {

return 200;

}

}

try {

const stream = await renderToReadableStream(<App />, {

bootstrapScripts: ['/main.js'],

onError(error) {

didError = true;

caughtError = error;

console.error(error);

logServerCrashReport(error);

}

});

return new Response(stream, {

status: getStatusCode(),

headers: { 'content-type': 'text/html' },

});

} catch (error) {

return new Response('<h1>Something went wrong</h1>', {

status: getStatusCode(),

headers: { 'content-type': 'text/html' },

});

}

}
```

Keep in mind that once you emit the shell and start streaming, you can’t change the status code.

---

### Waiting for all content to load for crawlers and static generation

Streaming offers a better user experience because the user can see the content as it becomes available.

However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively.

You can wait for all the content to load by awaiting the `stream.allReady` Promise:

```
async function handler(request) {

try {

let didError = false;

const stream = await renderToReadableStream(<App />, {

bootstrapScripts: ['/main.js'],

onError(error) {

didError = true;

console.error(error);

logServerCrashReport(error);

}

});

let isCrawler = // ... depends on your bot detection strategy ...

if (isCrawler) {

await stream.allReady;

}

return new Response(stream, {

status: didError ? 500 : 200,

headers: { 'content-type': 'text/html' },

});

} catch (error) {

return new Response('<h1>Something went wrong</h1>', {

status: 500,

headers: { 'content-type': 'text/html' },

});

}

}
```

A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for *all* data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too.

---

### Aborting server rendering

You can force the server rendering to “give up” after a timeout:

```
async function handler(request) {

try {

const controller = new AbortController();

setTimeout(() => {

controller.abort();

}, 10000);

const stream = await renderToReadableStream(<App />, {

signal: controller.signal,

bootstrapScripts: ['/main.js'],

onError(error) {

didError = true;

console.error(error);

logServerCrashReport(error);

}

});

// ...
```

React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client.

[PreviousrenderToPipeableStream](https://react.dev/reference/react-dom/server/renderToPipeableStream)[NextrenderToStaticMarkup](https://react.dev/reference/react-dom/server/renderToStaticMarkup)

---

---


# renderToStaticMarkup – React

URL: https://react.dev/reference/react-dom/server/renderToStaticMarkup

[API Reference](https://react.dev/reference/react)

[Server APIs](https://react.dev/reference/react-dom/server)

# renderToStaticMarkup

`renderToStaticMarkup` renders a non-interactive React tree to an HTML string.

```
const html = renderToStaticMarkup(reactNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/server/renderToStaticMarkup#reference) 
  + [`renderToStaticMarkup(reactNode, options?)`](https://react.dev/reference/react-dom/server/renderToStaticMarkup#rendertostaticmarkup)
* [Usage](https://react.dev/reference/react-dom/server/renderToStaticMarkup#usage) 
  + [Rendering a non-interactive React tree as HTML to a string](https://react.dev/reference/react-dom/server/renderToStaticMarkup#rendering-a-non-interactive-react-tree-as-html-to-a-string)

---

## Reference

### `renderToStaticMarkup(reactNode, options?)`

On the server, call `renderToStaticMarkup` to render your app to HTML.

```
import { renderToStaticMarkup } from 'react-dom/server';

const html = renderToStaticMarkup(<Page />);
```

It will produce non-interactive HTML output of your React components.

[See more examples below.](https://react.dev/reference/react-dom/server/renderToStaticMarkup#usage)

#### Parameters

* `reactNode`: A React node you want to render to HTML. For example, a JSX node like `<Page />`.
* **optional** `options`: An object for server render.
  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page.

#### Returns

An HTML string.

#### Caveats

* `renderToStaticMarkup` output cannot be hydrated.
* `renderToStaticMarkup` has limited Suspense support. If a component suspends, `renderToStaticMarkup` immediately sends its fallback as HTML.
* `renderToStaticMarkup` works in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser, [get the HTML by rendering it into a DOM node.](https://react.dev/reference/react-dom/server/renderToString#removing-rendertostring-from-the-client-code)

---

## Usage

### Rendering a non-interactive React tree as HTML to a string

Call `renderToStaticMarkup` to render your app to an HTML string which you can send with your server response:

```
import { renderToStaticMarkup } from 'react-dom/server';

// The route handler syntax depends on your backend framework

app.use('/', (request, response) => {

const html = renderToStaticMarkup(<Page />);

response.send(html);

});
```

This will produce the initial non-interactive HTML output of your React components.

### Pitfall

This method renders **non-interactive HTML that cannot be hydrated.** This is useful if you want to use React as a simple static page generator, or if you’re rendering completely static content like emails.

Interactive apps should use [`renderToString`](https://react.dev/reference/react-dom/server/renderToString) on the server and [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) on the client.

[PreviousrenderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream)[NextrenderToString](https://react.dev/reference/react-dom/server/renderToString)

---

---


# renderToString – React

URL: https://react.dev/reference/react-dom/server/renderToString

[API Reference](https://react.dev/reference/react)

[Server APIs](https://react.dev/reference/react-dom/server)

# renderToString

### Pitfall

`renderToString` does not support streaming or waiting for data. [See the alternatives.](https://react.dev/reference/react-dom/server/renderToString#alternatives)

`renderToString` renders a React tree to an HTML string.

```
const html = renderToString(reactNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/server/renderToString#reference) 
  + [`renderToString(reactNode, options?)`](https://react.dev/reference/react-dom/server/renderToString#rendertostring)
* [Usage](https://react.dev/reference/react-dom/server/renderToString#usage) 
  + [Rendering a React tree as HTML to a string](https://react.dev/reference/react-dom/server/renderToString#rendering-a-react-tree-as-html-to-a-string)
* [Alternatives](https://react.dev/reference/react-dom/server/renderToString#alternatives) 
  + [Migrating from `renderToString` to a streaming render on the server](https://react.dev/reference/react-dom/server/renderToString#migrating-from-rendertostring-to-a-streaming-method-on-the-server)
  + [Migrating from `renderToString` to a static prerender on the server](https://react.dev/reference/react-dom/server/renderToString#migrating-from-rendertostring-to-a-static-prerender-on-the-server)
  + [Removing `renderToString` from the client code](https://react.dev/reference/react-dom/server/renderToString#removing-rendertostring-from-the-client-code)
* [Troubleshooting](https://react.dev/reference/react-dom/server/renderToString#troubleshooting) 
  + [When a component suspends, the HTML always contains a fallback](https://react.dev/reference/react-dom/server/renderToString#when-a-component-suspends-the-html-always-contains-a-fallback)

---

## Reference

### `renderToString(reactNode, options?)`

On the server, call `renderToString` to render your app to HTML.

```
import { renderToString } from 'react-dom/server';

const html = renderToString(<App />);
```

On the client, call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](https://react.dev/reference/react-dom/server/renderToString#usage)

#### Parameters

* `reactNode`: A React node you want to render to HTML. For example, a JSX node like `<App />`.
* **optional** `options`: An object for server render.

  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot#parameters)

#### Returns

An HTML string.

#### Caveats

* `renderToString` has limited Suspense support. If a component suspends, `renderToString` immediately sends its fallback as HTML.
* `renderToString` works in the browser, but using it in the client code is [not recommended.](https://react.dev/reference/react-dom/server/renderToString#removing-rendertostring-from-the-client-code)

---

## Usage

### Rendering a React tree as HTML to a string

Call `renderToString` to render your app to an HTML string which you can send with your server response:

```
import { renderToString } from 'react-dom/server';

// The route handler syntax depends on your backend framework

app.use('/', (request, response) => {

const html = renderToString(<App />);

response.send(html);

});
```

This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to *hydrate* that server-generated HTML and make it interactive.

### Pitfall

`renderToString` does not support streaming or waiting for data. [See the alternatives.](https://react.dev/reference/react-dom/server/renderToString#alternatives)

---

## Alternatives

### Migrating from `renderToString` to a streaming render on the server

`renderToString` returns a string immediately, so it does not support streaming content as it loads.

When possible, we recommend using these fully-featured alternatives:

* If you use Node.js, use [`renderToPipeableStream`.](https://react.dev/reference/react-dom/server/renderToPipeableStream)
* If you use Deno or a modern edge runtime with [Web Streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API), use [`renderToReadableStream`.](https://react.dev/reference/react-dom/server/renderToReadableStream)

You can continue using `renderToString` if your server environment does not support streams.

---

### Migrating from `renderToString` to a static prerender on the server

`renderToString` returns a string immediately, so it does not support waiting for data to load for static HTML generation.

We recommend using these fully-featured alternatives:

* If you use Node.js, use [`prerenderToNodeStream`.](https://react.dev/reference/react-dom/static/prerenderToNodeStream)
* If you use Deno or a modern edge runtime with [Web Streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API), use [`prerender`.](https://react.dev/reference/react-dom/static/prerender)

You can continue using `renderToString` if your static site generation environment does not support streams.

---

### Removing `renderToString` from the client code

Sometimes, `renderToString` is used on the client to convert some component to HTML.

```
// 🚩 Unnecessary: using renderToString on the client

import { renderToString } from 'react-dom/server';

const html = renderToString(<MyIcon />);

console.log(html); // For example, "<svg>...</svg>"
```

Importing `react-dom/server` **on the client** unnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, use [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) and read HTML from the DOM:

```
import { createRoot } from 'react-dom/client';

import { flushSync } from 'react-dom';

const div = document.createElement('div');

const root = createRoot(div);

flushSync(() => {

root.render(<MyIcon />);

});

console.log(div.innerHTML); // For example, "<svg>...</svg>"
```

The [`flushSync`](https://react.dev/reference/react-dom/flushSync) call is necessary so that the DOM is updated before reading its [`innerHTML`](https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML) property.

---

## Troubleshooting

### When a component suspends, the HTML always contains a fallback

`renderToString` does not fully support Suspense.

If some component suspends (for example, because it’s defined with [`lazy`](https://react.dev/reference/react/lazy) or fetches data), `renderToString` will not wait for its content to resolve. Instead, `renderToString` will find the closest [`<Suspense>`](https://react.dev/reference/react/Suspense) boundary above it and render its `fallback` prop in the HTML. The content will not appear until the client code loads.

To solve this, use one of the [recommended streaming solutions.](https://react.dev/reference/react-dom/server/renderToString#alternatives) For server side rendering, they can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads. For static site generation, they can wait for all the content to resolve before generating the static HTML.

[PreviousrenderToStaticMarkup](https://react.dev/reference/react-dom/server/renderToStaticMarkup)[Nextresume](https://react.dev/reference/react-dom/server/resume)

---

---


# resume – React

URL: https://react.dev/reference/react-dom/server/resume

[API Reference](https://react.dev/reference/react)

[Server APIs](https://react.dev/reference/react-dom/server)

# resume

`resume` streams a pre-rendered React tree to a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

```
const stream = await resume(reactNode, postponedState, options?)
```

* [Reference](https://react.dev/reference/react-dom/server/resume#reference) 
  + [`resume(node, postponedState, options?)`](https://react.dev/reference/react-dom/server/resume#resume)
* [Usage](https://react.dev/reference/react-dom/server/resume#usage) 
  + [Resuming a prerender](https://react.dev/reference/react-dom/server/resume#resuming-a-prerender)
  + [Further reading](https://react.dev/reference/react-dom/server/resume#further-reading)

### Note

This API depends on [Web Streams.](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) For Node.js, use [`resumeToNodeStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream) instead.

---

## Reference

### `resume(node, postponedState, options?)`

Call `resume` to resume rendering a pre-rendered React tree as HTML into a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)

```
import { resume } from 'react-dom/server';

import {getPostponedState} from './storage';

async function handler(request, writable) {

const postponed = await getPostponedState(request);

const resumeStream = await resume(<App />, postponed);

return resumeStream.pipeTo(writable)

}
```

[See more examples below.](https://react.dev/reference/react-dom/server/resume#usage)

#### Parameters

* `reactNode`: The React node you called `prerender` with. For example, a JSX element like `<App />`. It is expected to represent the entire document, so the `App` component should render the `<html>` tag.
* `postponedState`: The opaque `postpone` object returned from a [prerender API](https://react.dev/reference/react-dom/static/index), loaded from wherever you stored it (e.g. redis, a file, or S3).
* **optional** `options`: An object with streaming options.
  + **optional** `nonce`: A [`nonce`](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#nonce) string to allow scripts for [`script-src` Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src).
  + **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort server rendering](https://react.dev/reference/react-dom/server/resume#aborting-server-rendering) and render the rest on the client.
  + **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/server/renderToReadableStream#logging-crashes-on-the-server) make sure that you still call `console.error`.

#### Returns

`resume` returns a Promise:

* If `resume` successfully produced a [shell](https://react.dev/reference/react-dom/server/renderToReadableStream#specifying-what-goes-into-the-shell), that Promise will resolve to a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream) that can be piped to a [Writable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream).
* If an error happens in the shell, the Promise will reject with that error.

The returned stream has an additional property:

* `allReady`: A Promise that resolves when all rendering is complete. You can `await stream.allReady` before returning a response [for crawlers and static generation.](https://react.dev/reference/react-dom/server/renderToReadableStream#waiting-for-all-content-to-load-for-crawlers-and-static-generation) If you do that, you won’t get any progressive loading. The stream will contain the final HTML.

#### Caveats

* `resume` does not accept options for `bootstrapScripts`, `bootstrapScriptContent`, or `bootstrapModules`. Instead, you need to pass these options to the `prerender` call that generates the `postponedState`. You can also inject bootstrap content into the writable stream manually.
* `resume` does not accept `identifierPrefix` since the prefix needs to be the same in both `prerender` and `resume`.
* Since `nonce` cannot be provided to prerender, you should only provide `nonce` to `resume` if you’re not providing scripts to prerender.
* `resume` re-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.

## Usage

### Resuming a prerender

index.jsindex.htmldemo-helpers.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {
  flushReadableStreamToFrame,
  getUser,
  Postponed,
  sleep,
} from "./demo-helpers";
import { StrictMode, Suspense, use, useEffect } from "react";
import { prerender } from "react-dom/static";
import { resume } from "react-dom/server";
import { hydrateRoot } from "react-dom/client";

function Header() {
  return <header>Me and my descendants can be prerendered</header>;
}

const { promise: cookies, resolve: resolveCookies } = Promise.withResolvers();

function Main() {
  const { sessionID } = use(cookies);
  const user = getUser(sessionID);

  useEffect(() => {
    console.log("reached interactivity!");
  }, []);

  return (
    <main>
      Hello, {user.name}!
      <button onClick={() => console.log("hydrated!")}>
        Clicking me requires hydration.
      </button>
    </main>
  );
}

function Shell({ children }) {
  // In a real app, this is where you would put your html and body.
  // We're just using tags here we can include in an existing body for demonstration purposes
  return (
    <html>
      <body>{children}</body>
    </html>
  );
}

function App() {
  return (
    <Shell>
      <Suspense fallback="loading header">
        <Header />
      </Suspense>
      <Suspense fallback="loading main">
        <Main />
      </Suspense>
    </Shell>
  );
}

async function main(frame) {
  // Layer 1
  const controller = new AbortController();
  const prerenderedApp = prerender(<App />, {
    signal: controller.signal,
    onError(error) {
      if (error instanceof Postponed) {
      } else {
        console.error(error);
      }
    },
  });
  // We're immediately aborting in a macrotask.
  // Any data fetching that's not available synchronously, or in a microtask, will not have finished.
  setTimeout(() => {
    controller.abort(new Postponed());
  });

  const { prelude, postponed } = await prerenderedApp;
  await flushReadableStreamToFrame(prelude, frame);

  // Layer 2
  // Just waiting here for demonstration purposes.
  // In a real app, the prelude and postponed state would've been serialized in Layer 1 and Layer would deserialize them.
  // The prelude content could be flushed immediated as plain HTML while
  // React is continuing to render from where the prerender left off.
  await sleep(2000);

  // You would get the cookies from the incoming HTTP request
  resolveCookies({ sessionID: "abc" });

  const stream = await resume(<App />, postponed);

  await flushReadableStreamToFrame(stream, frame);

  // Layer 3
  // Just waiting here for demonstration purposes.
  await sleep(2000);

  hydrateRoot(frame.contentWindow.document, <App />);
}

main(document.getElementById("container"));
```

Show more

### Further reading

Resuming behaves like `renderToReadableStream`. For more examples, check out the [usage section of `renderToReadableStream`](https://react.dev/reference/react-dom/server/renderToReadableStream#usage).
The [usage section of `prerender`](https://react.dev/reference/react-dom/static/prerender#usage) includes examples of how to use `prerender` specifically.

[PreviousrenderToString](https://react.dev/reference/react-dom/server/renderToString)[NextresumeToPipeableStream](https://react.dev/reference/react-dom/server/resumeToPipeableStream)

---

---


# resumeToPipeableStream – React

URL: https://react.dev/reference/react-dom/server/resumeToPipeableStream

[API Reference](https://react.dev/reference/react)

[Server APIs](https://react.dev/reference/react-dom/server)

# resumeToPipeableStream

`resumeToPipeableStream` streams a pre-rendered React tree to a pipeable [Node.js Stream.](https://nodejs.org/api/stream.html)

```
const {pipe, abort} = await resumeToPipeableStream(reactNode, postponedState, options?)
```

* [Reference](https://react.dev/reference/react-dom/server/resumeToPipeableStream#reference) 
  + [`resumeToPipeableStream(node, postponed, options?)`](https://react.dev/reference/react-dom/server/resumeToPipeableStream#resume-to-pipeable-stream)
* [Usage](https://react.dev/reference/react-dom/server/resumeToPipeableStream#usage) 
  + [Further reading](https://react.dev/reference/react-dom/server/resumeToPipeableStream#further-reading)

### Note

This API is specific to Node.js. Environments with [Web Streams,](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) like Deno and modern edge runtimes, should use [`resume`](https://react.dev/reference/react-dom/server/renderToReadableStream) instead.

---

## Reference

### `resumeToPipeableStream(node, postponed, options?)`

Call `resume` to resume rendering a pre-rendered React tree as HTML into a [Node.js Stream.](https://nodejs.org/api/stream.html#writable-streams)

```
import { resume } from 'react-dom/server';

import {getPostponedState} from './storage';

async function handler(request, response) {

const postponed = await getPostponedState(request);

const {pipe} = resumeToPipeableStream(<App />, postponed, {

onShellReady: () => {

pipe(response);

}

});

}
```

[See more examples below.](https://react.dev/reference/react-dom/server/resumeToPipeableStream#usage)

#### Parameters

* `reactNode`: The React node you called `prerender` with. For example, a JSX element like `<App />`. It is expected to represent the entire document, so the `App` component should render the `<html>` tag.
* `postponedState`: The opaque `postpone` object returned from a [prerender API](https://react.dev/reference/react-dom/static/index), loaded from wherever you stored it (e.g. redis, a file, or S3).
* **optional** `options`: An object with streaming options.
  + **optional** `nonce`: A [`nonce`](http://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#nonce) string to allow scripts for [`script-src` Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/script-src).
  + **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort server rendering](https://react.dev/reference/react-dom/server/resumeToPipeableStream#aborting-server-rendering) and render the rest on the client.
  + **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/server/renderToReadableStream#logging-crashes-on-the-server) make sure that you still call `console.error`.
  + **optional** `onShellReady`: A callback that fires right after the [shell](https://react.dev/reference/react-dom/server/resumeToPipeableStream#specifying-what-goes-into-the-shell) has finished. You can call `pipe` here to start streaming. React will [stream the additional content](https://react.dev/reference/react-dom/server/resumeToPipeableStream#streaming-more-content-as-it-loads) after the shell along with the inline `<script>` tags that replace the HTML loading fallbacks with the content.
  + **optional** `onShellError`: A callback that fires if there was an error rendering the shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neither `onShellReady` nor `onAllReady` will get called, so you can [output a fallback HTML shell](https://react.dev/reference/react-dom/server/resumeToPipeableStream#recovering-from-errors-inside-the-shell) or use the prelude.

#### Returns

`resume` returns an object with two methods:

* `pipe` outputs the HTML into the provided [Writable Node.js Stream.](https://nodejs.org/api/stream.html#writable-streams) Call `pipe` in `onShellReady` if you want to enable streaming, or in `onAllReady` for crawlers and static generation.
* `abort` lets you [abort server rendering](https://react.dev/reference/react-dom/server/resumeToPipeableStream#aborting-server-rendering) and render the rest on the client.

#### Caveats

* `resumeToPipeableStream` does not accept options for `bootstrapScripts`, `bootstrapScriptContent`, or `bootstrapModules`. Instead, you need to pass these options to the `prerender` call that generates the `postponedState`. You can also inject bootstrap content into the writable stream manually.
* `resumeToPipeableStream` does not accept `identifierPrefix` since the prefix needs to be the same in both `prerender` and `resumeToPipeableStream`.
* Since `nonce` cannot be provided to prerender, you should only provide `nonce` to `resumeToPipeableStream` if you’re not providing scripts to prerender.
* `resumeToPipeableStream` re-renders from the root until it finds a component that was not fully pre-rendered. Only fully prerendered Components (the Component and its children finished prerendering) are skipped entirely.

## Usage

### Further reading

Resuming behaves like `renderToReadableStream`. For more examples, check out the [usage section of `renderToReadableStream`](https://react.dev/reference/react-dom/server/renderToReadableStream#usage).
The [usage section of `prerender`](https://react.dev/reference/react-dom/static/prerender#usage) includes examples of how to use `prerenderToNodeStream` specifically.

[Previousresume](https://react.dev/reference/react-dom/server/resume)[NextStatic APIs](https://react.dev/reference/react-dom/static)

---

---


# Static React DOM APIs – React

URL: https://react.dev/reference/react-dom/static

[API Reference](https://react.dev/reference/react)

# Static React DOM APIs

The `react-dom/static` APIs let you generate static HTML for React components. They have limited functionality compared to the streaming APIs. A [framework](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) may call them for you. Most of your components don’t need to import or use them.

---

## Static APIs for Web Streams

These methods are only available in the environments with [Web Streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API), which includes browsers, Deno, and some modern edge runtimes:

* [`prerender`](https://react.dev/reference/react-dom/static/prerender) renders a React tree to static HTML with a [Readable Web Stream.](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream)
* Experimental only [`resumeAndPrerender`](https://react.dev/reference/react-dom/static/resumeAndPrerender) continues a prerendered React tree to static HTML with a [Readable Web Stream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream).

Node.js also includes these methods for compatibility, but they are not recommended due to worse performance. Use the [dedicated Node.js APIs](https://react.dev/reference/react-dom/static#static-apis-for-nodejs-streams) instead.

---

## Static APIs for Node.js Streams

These methods are only available in the environments with [Node.js Streams](https://nodejs.org/api/stream.html):

* [`prerenderToNodeStream`](https://react.dev/reference/react-dom/static/prerenderToNodeStream) renders a React tree to static HTML with a [Node.js Stream.](https://nodejs.org/api/stream.html)
* Experimental only [`resumeAndPrerenderToNodeStream`](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream) continues a prerendered React tree to static HTML with a [Node.js Stream.](https://nodejs.org/api/stream.html)

[PreviousresumeToPipeableStream](https://react.dev/reference/react-dom/server/resumeToPipeableStream)[Nextprerender](https://react.dev/reference/react-dom/static/prerender)

---

---


# prerender – React

URL: https://react.dev/reference/react-dom/static/prerender

[API Reference](https://react.dev/reference/react)

[Static APIs](https://react.dev/reference/react-dom/static)

# prerender

`prerender` renders a React tree to a static HTML string using a [Web Stream](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API).

```
const {prelude, postponed} = await prerender(reactNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/static/prerender#reference) 
  + [`prerender(reactNode, options?)`](https://react.dev/reference/react-dom/static/prerender#prerender)
* [Usage](https://react.dev/reference/react-dom/static/prerender#usage) 
  + [Rendering a React tree to a stream of static HTML](https://react.dev/reference/react-dom/static/prerender#rendering-a-react-tree-to-a-stream-of-static-html)
  + [Rendering a React tree to a string of static HTML](https://react.dev/reference/react-dom/static/prerender#rendering-a-react-tree-to-a-string-of-static-html)
  + [Waiting for all data to load](https://react.dev/reference/react-dom/static/prerender#waiting-for-all-data-to-load)
  + [Aborting prerendering](https://react.dev/reference/react-dom/static/prerender#aborting-prerendering)
* [Troubleshooting](https://react.dev/reference/react-dom/static/prerender#troubleshooting) 
  + [My stream doesn’t start until the entire app is rendered](https://react.dev/reference/react-dom/static/prerender#my-stream-doesnt-start-until-the-entire-app-is-rendered)

### Note

This API depends on [Web Streams.](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) For Node.js, use [`prerenderToNodeStream`](https://react.dev/reference/react-dom/static/prerenderToNodeStream) instead.

---

## Reference

### `prerender(reactNode, options?)`

Call `prerender` to render your app to static HTML.

```
import { prerender } from 'react-dom/static';

async function handler(request, response) {

const {prelude} = await prerender(<App />, {

bootstrapScripts: ['/main.js']

});

return new Response(prelude, {

headers: { 'content-type': 'text/html' },

});

}
```

On the client, call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](https://react.dev/reference/react-dom/static/prerender#usage)

#### Parameters

* `reactNode`: A React node you want to render to HTML. For example, a JSX node like `<App />`. It is expected to represent the entire document, so the App component should render the `<html>` tag.
* **optional** `options`: An object with static generation options.

  + **optional** `bootstrapScriptContent`: If specified, this string will be placed in an inline `<script>` tag.
  + **optional** `bootstrapScripts`: An array of string URLs for the `<script>` tags to emit on the page. Use this to include the `<script>` that calls [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot) Omit it if you don’t want to run React on the client at all.
  + **optional** `bootstrapModules`: Like `bootstrapScripts`, but emits [`<script type="module">`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) instead.
  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot#parameters)
  + **optional** `namespaceURI`: A string with the root [namespace URI](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS#important_namespace_uris) for the stream. Defaults to regular HTML. Pass `'http://www.w3.org/2000/svg'` for SVG or `'http://www.w3.org/1998/Math/MathML'` for MathML.
  + **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/server/renderToReadableStream#logging-crashes-on-the-server) make sure that you still call `console.error`. You can also use it to [adjust the status code](https://react.dev/reference/react-dom/server/renderToReadableStream#setting-the-status-code) before the shell is emitted.
  + **optional** `progressiveChunkSize`: The number of bytes in a chunk. [Read more about the default heuristic.](https://github.com/facebook/react/blob/14c2be8dac2d5482fda8a0906a31d239df8551fc/packages/react-server/src/ReactFizzServer.js#L210-L225)
  + **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort prerendering](https://react.dev/reference/react-dom/static/prerender#aborting-prerendering) and render the rest on the client.

#### Returns

`prerender` returns a Promise:

* If rendering the is successful, the Promise will resolve to an object containing:
  + `prelude`: a [Web Stream](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
  + `postponed`: a JSON-serializeable, opaque object that can be passed to [`resume`](https://react.dev/reference/react-dom/server/resume) if `prerender` did not finish. Otherwise `null` indicating that the `prelude` contains all the content and no resume is necessary.
* If rendering fails, the Promise will be rejected. [Use this to output a fallback shell.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell)

#### Caveats

`nonce` is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP) it would be inappropriate and insecure to include the nonce value in the prerender itself.

### Note

### When should I use `prerender`?

The static `prerender` API is used for static server-side generation (SSG). Unlike `renderToString`, `prerender` waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like [renderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream).

`prerender` can be aborted and later either continued with `resumeAndPrerender` or resumed with `resume` to support partial pre-rendering.

---

## Usage

### Rendering a React tree to a stream of static HTML

Call `prerender` to render your React tree to static HTML into a [Readable Web Stream:](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream):

```
import { prerender } from 'react-dom/static';

async function handler(request) {

const {prelude} = await prerender(<App />, {

bootstrapScripts: ['/main.js']

});

return new Response(prelude, {

headers: { 'content-type': 'text/html' },

});

}
```

Along with the root component, you need to provide a list of bootstrap `<script>` paths. Your root component should return **the entire document including the root `<html>` tag.**

For example, it might look like this:

```
export default function App() {

return (

<html>

<head>

<meta charSet="utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/styles.css"></link>

<title>My app</title>

</head>

<body>

<Router />

</body>

</html>

);

}
```

React will inject the [doctype](https://developer.mozilla.org/en-US/docs/Glossary/Doctype) and your bootstrap `<script>` tags into the resulting HTML stream:

```
<!DOCTYPE html>

<html>

<!-- ... HTML from your components ... -->

</html>

<script src="/main.js" async=""></script>
```

On the client, your bootstrap script should [hydrate the entire `document` with a call to `hydrateRoot`:](https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-an-entire-document)

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App />);
```

This will attach event listeners to the static server-generated HTML and make it interactive.

##### Deep Dive

#### Reading CSS and JS asset paths from the build output

Show Details

The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of `styles.css` you might end up with `styles.123456.css`. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.

However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding `"/styles.css"` into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:

```
export default function App({ assetMap }) {

return (

<html>

<head>

<title>My app</title>

<link rel="stylesheet" href={assetMap['styles.css']}></link>

</head>

...

</html>

);

}
```

On the server, render `<App assetMap={assetMap} />` and pass your `assetMap` with the asset URLs:

```
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.

const assetMap = {

'styles.css': '/styles.123456.css',

'main.js': '/main.123456.js'

};

async function handler(request) {

const {prelude} = await prerender(<App assetMap={assetMap} />, {

bootstrapScripts: [assetMap['/main.js']]

});

return new Response(prelude, {

headers: { 'content-type': 'text/html' },

});

}
```

Since your server is now rendering `<App assetMap={assetMap} />`, you need to render it with `assetMap` on the client too to avoid hydration errors. You can serialize and pass `assetMap` to the client like this:

```
// You'd need to get this JSON from your build tooling.

const assetMap = {

'styles.css': '/styles.123456.css',

'main.js': '/main.123456.js'

};

async function handler(request) {

const {prelude} = await prerender(<App assetMap={assetMap} />, {

// Careful: It's safe to stringify() this because this data isn't user-generated.

bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,

bootstrapScripts: [assetMap['/main.js']],

});

return new Response(prelude, {

headers: { 'content-type': 'text/html' },

});

}
```

In the example above, the `bootstrapScriptContent` option adds an extra inline `<script>` tag that sets the global `window.assetMap` variable on the client. This lets the client code read the same `assetMap`:

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App assetMap={window.assetMap} />);
```

Both client and server render `App` with the same `assetMap` prop, so there are no hydration errors.

---

### Rendering a React tree to a string of static HTML

Call `prerender` to render your app to a static HTML string:

```
import { prerender } from 'react-dom/static';

async function renderToString() {

const {prelude} = await prerender(<App />, {

bootstrapScripts: ['/main.js']

});

const reader = prelude.getReader();

let content = '';

while (true) {

const {done, value} = await reader.read();

if (done) {

return content;

}

content += Buffer.from(value).toString('utf8');

}

}
```

This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to *hydrate* that server-generated HTML and make it interactive.

---

### Waiting for all data to load

`prerender` waits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</ProfileLayout>

);

}
```

Imagine that `<Posts />` needs to load some data, which takes some time. Ideally, you’d want wait for the posts to finish so it’s included in the HTML. To do this, you can use Suspense to suspend on the data, and `prerender` will wait for the suspended content to finish before resolving to the static HTML.

### Note

**Only Suspense-enabled data sources will activate the Suspense component.** They include:

* Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/getting-started/react-essentials)
* Lazy-loading component code with [`lazy`](https://react.dev/reference/react/lazy)
* Reading the value of a Promise with [`use`](https://react.dev/reference/react/use)

Suspense **does not** detect when data is fetched inside an Effect or event handler.

The exact way you would load data in the `Posts` component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

---

### Aborting prerendering

You can force the prerender to “give up” after a timeout:

```
async function renderToString() {

const controller = new AbortController();

setTimeout(() => {

controller.abort()

}, 10000);

try {

// the prelude will contain all the HTML that was prerendered

// before the controller aborted.

const {prelude} = await prerender(<App />, {

signal: controller.signal,

});

//...
```

Any Suspense boundaries with incomplete children will be included in the prelude in the fallback state.

This can be used for partial prerendering together with [`resume`](https://react.dev/reference/react-dom/server/resume) or [`resumeAndPrerender`](https://react.dev/reference/react-dom/static/resumeAndPrerender).

## Troubleshooting

### My stream doesn’t start until the entire app is rendered

The `prerender` response waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.

To stream content as it loads, use a streaming server render API like [renderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream).

[PreviousStatic APIs](https://react.dev/reference/react-dom/static)[NextprerenderToNodeStream](https://react.dev/reference/react-dom/static/prerenderToNodeStream)

---

---


# prerenderToNodeStream – React

URL: https://react.dev/reference/react-dom/static/prerenderToNodeStream

[API Reference](https://react.dev/reference/react)

[Static APIs](https://react.dev/reference/react-dom/static)

# prerenderToNodeStream

`prerenderToNodeStream` renders a React tree to a static HTML string using a [Node.js Stream.](https://nodejs.org/api/stream.html)

```
const {prelude, postponed} = await prerenderToNodeStream(reactNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/static/prerenderToNodeStream#reference) 
  + [`prerenderToNodeStream(reactNode, options?)`](https://react.dev/reference/react-dom/static/prerenderToNodeStream#prerender)
* [Usage](https://react.dev/reference/react-dom/static/prerenderToNodeStream#usage) 
  + [Rendering a React tree to a stream of static HTML](https://react.dev/reference/react-dom/static/prerenderToNodeStream#rendering-a-react-tree-to-a-stream-of-static-html)
  + [Rendering a React tree to a string of static HTML](https://react.dev/reference/react-dom/static/prerenderToNodeStream#rendering-a-react-tree-to-a-string-of-static-html)
  + [Waiting for all data to load](https://react.dev/reference/react-dom/static/prerenderToNodeStream#waiting-for-all-data-to-load)
  + [Aborting prerendering](https://react.dev/reference/react-dom/static/prerenderToNodeStream#aborting-prerendering)
* [Troubleshooting](https://react.dev/reference/react-dom/static/prerenderToNodeStream#troubleshooting) 
  + [My stream doesn’t start until the entire app is rendered](https://react.dev/reference/react-dom/static/prerenderToNodeStream#my-stream-doesnt-start-until-the-entire-app-is-rendered)

### Note

This API is specific to Node.js. Environments with [Web Streams,](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) like Deno and modern edge runtimes, should use [`prerender`](https://react.dev/reference/react-dom/static/prerender) instead.

---

## Reference

### `prerenderToNodeStream(reactNode, options?)`

Call `prerenderToNodeStream` to render your app to static HTML.

```
import { prerenderToNodeStream } from 'react-dom/static';

// The route handler syntax depends on your backend framework

app.use('/', async (request, response) => {

const { prelude } = await prerenderToNodeStream(<App />, {

bootstrapScripts: ['/main.js'],

});

response.setHeader('Content-Type', 'text/plain');

prelude.pipe(response);

});
```

On the client, call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](https://react.dev/reference/react-dom/static/prerenderToNodeStream#usage)

#### Parameters

* `reactNode`: A React node you want to render to HTML. For example, a JSX node like `<App />`. It is expected to represent the entire document, so the App component should render the `<html>` tag.
* **optional** `options`: An object with static generation options.

  + **optional** `bootstrapScriptContent`: If specified, this string will be placed in an inline `<script>` tag.
  + **optional** `bootstrapScripts`: An array of string URLs for the `<script>` tags to emit on the page. Use this to include the `<script>` that calls [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot) Omit it if you don’t want to run React on the client at all.
  + **optional** `bootstrapModules`: Like `bootstrapScripts`, but emits [`<script type="module">`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) instead.
  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot#parameters)
  + **optional** `namespaceURI`: A string with the root [namespace URI](https://developer.mozilla.org/en-US/docs/Web/API/Document/createElementNS#important_namespace_uris) for the stream. Defaults to regular HTML. Pass `'http://www.w3.org/2000/svg'` for SVG or `'http://www.w3.org/1998/Math/MathML'` for MathML.
  + **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/server/renderToPipeableStream#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/server/renderToPipeableStream#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/server/renderToPipeableStream#logging-crashes-on-the-server) make sure that you still call `console.error`. You can also use it to [adjust the status code](https://react.dev/reference/react-dom/server/renderToPipeableStream#setting-the-status-code) before the shell is emitted.
  + **optional** `progressiveChunkSize`: The number of bytes in a chunk. [Read more about the default heuristic.](https://github.com/facebook/react/blob/14c2be8dac2d5482fda8a0906a31d239df8551fc/packages/react-server/src/ReactFizzServer.js#L210-L225)
  + **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort prerendering](https://react.dev/reference/react-dom/static/prerenderToNodeStream#aborting-prerendering) and render the rest on the client.

#### Returns

`prerenderToNodeStream` returns a Promise:

* If rendering the is successful, the Promise will resolve to an object containing:
  + `prelude`: a [Node.js Stream.](https://nodejs.org/api/stream.html) of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
  + `postponed`: a JSON-serializeable, opaque object that can be passed to [`resumeToPipeableStream`](https://react.dev/reference/react-dom/server/resumeToPipeableStream) if `prerenderToNodeStream` did not finish. Otherwise `null` indicating that the `prelude` contains all the content and no resume is necessary.
* If rendering fails, the Promise will be rejected. [Use this to output a fallback shell.](https://react.dev/reference/react-dom/server/renderToPipeableStream#recovering-from-errors-inside-the-shell)

#### Caveats

`nonce` is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP) it would be inappropriate and insecure to include the nonce value in the prerender itself.

### Note

### When should I use `prerenderToNodeStream`?

The static `prerenderToNodeStream` API is used for static server-side generation (SSG). Unlike `renderToString`, `prerenderToNodeStream` waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like [renderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream).

`prerenderToNodeStream` can be aborted and resumed later with `resumeToPipeableStream` to support partial pre-rendering.

---

## Usage

### Rendering a React tree to a stream of static HTML

Call `prerenderToNodeStream` to render your React tree to static HTML into a [Node.js Stream](https://nodejs.org/api/stream.html):

```
import { prerenderToNodeStream } from 'react-dom/static';

// The route handler syntax depends on your backend framework

app.use('/', async (request, response) => {

const { prelude } = await prerenderToNodeStream(<App />, {

bootstrapScripts: ['/main.js'],

});

response.setHeader('Content-Type', 'text/plain');

prelude.pipe(response);

});
```

Along with the root component, you need to provide a list of bootstrap `<script>` paths. Your root component should return **the entire document including the root `<html>` tag.**

For example, it might look like this:

```
export default function App() {

return (

<html>

<head>

<meta charSet="utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/styles.css"></link>

<title>My app</title>

</head>

<body>

<Router />

</body>

</html>

);

}
```

React will inject the [doctype](https://developer.mozilla.org/en-US/docs/Glossary/Doctype) and your bootstrap `<script>` tags into the resulting HTML stream:

```
<!DOCTYPE html>

<html>

<!-- ... HTML from your components ... -->

</html>

<script src="/main.js" async=""></script>
```

On the client, your bootstrap script should [hydrate the entire `document` with a call to `hydrateRoot`:](https://react.dev/reference/react-dom/client/hydrateRoot#hydrating-an-entire-document)

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App />);
```

This will attach event listeners to the static server-generated HTML and make it interactive.

##### Deep Dive

#### Reading CSS and JS asset paths from the build output

Show Details

The final asset URLs (like JavaScript and CSS files) are often hashed after the build. For example, instead of `styles.css` you might end up with `styles.123456.css`. Hashing static asset filenames guarantees that every distinct build of the same asset will have a different filename. This is useful because it lets you safely enable long-term caching for static assets: a file with a certain name would never change content.

However, if you don’t know the asset URLs until after the build, there’s no way for you to put them in the source code. For example, hardcoding `"/styles.css"` into JSX like earlier wouldn’t work. To keep them out of your source code, your root component can read the real filenames from a map passed as a prop:

```
export default function App({ assetMap }) {

return (

<html>

<head>

<title>My app</title>

<link rel="stylesheet" href={assetMap['styles.css']}></link>

</head>

...

</html>

);

}
```

On the server, render `<App assetMap={assetMap} />` and pass your `assetMap` with the asset URLs:

```
// You'd need to get this JSON from your build tooling, e.g. read it from the build output.

const assetMap = {

'styles.css': '/styles.123456.css',

'main.js': '/main.123456.js'

};

app.use('/', async (request, response) => {

const { prelude } = await prerenderToNodeStream(<App />, {

bootstrapScripts: [assetMap['/main.js']]

});

response.setHeader('Content-Type', 'text/html');

prelude.pipe(response);

});
```

Since your server is now rendering `<App assetMap={assetMap} />`, you need to render it with `assetMap` on the client too to avoid hydration errors. You can serialize and pass `assetMap` to the client like this:

```
// You'd need to get this JSON from your build tooling.

const assetMap = {

'styles.css': '/styles.123456.css',

'main.js': '/main.123456.js'

};

app.use('/', async (request, response) => {

const { prelude } = await prerenderToNodeStream(<App />, {

// Careful: It's safe to stringify() this because this data isn't user-generated.

bootstrapScriptContent: `window.assetMap = ${JSON.stringify(assetMap)};`,

bootstrapScripts: [assetMap['/main.js']],

});

response.setHeader('Content-Type', 'text/html');

prelude.pipe(response);

});
```

In the example above, the `bootstrapScriptContent` option adds an extra inline `<script>` tag that sets the global `window.assetMap` variable on the client. This lets the client code read the same `assetMap`:

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App assetMap={window.assetMap} />);
```

Both client and server render `App` with the same `assetMap` prop, so there are no hydration errors.

---

### Rendering a React tree to a string of static HTML

Call `prerenderToNodeStream` to render your app to a static HTML string:

```
import { prerenderToNodeStream } from 'react-dom/static';

async function renderToString() {

const {prelude} = await prerenderToNodeStream(<App />, {

bootstrapScripts: ['/main.js']

});

return new Promise((resolve, reject) => {

let data = '';

prelude.on('data', chunk => {

data += chunk;

});

prelude.on('end', () => resolve(data));

prelude.on('error', reject);

});

}
```

This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to *hydrate* that server-generated HTML and make it interactive.

---

### Waiting for all data to load

`prerenderToNodeStream` waits for all data to load before finishing the static HTML generation and resolving. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

```
function ProfilePage() {

return (

<ProfileLayout>

<ProfileCover />

<Sidebar>

<Friends />

<Photos />

</Sidebar>

<Suspense fallback={<PostsGlimmer />}>

<Posts />

</Suspense>

</ProfileLayout>

);

}
```

Imagine that `<Posts />` needs to load some data, which takes some time. Ideally, you’d want wait for the posts to finish so it’s included in the HTML. To do this, you can use Suspense to suspend on the data, and `prerenderToNodeStream` will wait for the suspended content to finish before resolving to the static HTML.

### Note

**Only Suspense-enabled data sources will activate the Suspense component.** They include:

* Data fetching with Suspense-enabled frameworks like [Relay](https://relay.dev/docs/guided-tour/rendering/loading-states/) and [Next.js](https://nextjs.org/docs/getting-started/react-essentials)
* Lazy-loading component code with [`lazy`](https://react.dev/reference/react/lazy)
* Reading the value of a Promise with [`use`](https://react.dev/reference/react/use)

Suspense **does not** detect when data is fetched inside an Effect or event handler.

The exact way you would load data in the `Posts` component above depends on your framework. If you use a Suspense-enabled framework, you’ll find the details in its data fetching documentation.

Suspense-enabled data fetching without the use of an opinionated framework is not yet supported. The requirements for implementing a Suspense-enabled data source are unstable and undocumented. An official API for integrating data sources with Suspense will be released in a future version of React.

---

### Aborting prerendering

You can force the prerender to “give up” after a timeout:

```
async function renderToString() {

const controller = new AbortController();

setTimeout(() => {

controller.abort()

}, 10000);

try {

// the prelude will contain all the HTML that was prerendered

// before the controller aborted.

const {prelude} = await prerenderToNodeStream(<App />, {

signal: controller.signal,

});

//...
```

Any Suspense boundaries with incomplete children will be included in the prelude in the fallback state.

This can be used for partial prerendering together with [`resumeToPipeableStream`](https://react.dev/reference/react-dom/server/resumeToPipeableStream) or [`resumeAndPrerenderToNodeStream`](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream).

## Troubleshooting

### My stream doesn’t start until the entire app is rendered

The `prerenderToNodeStream` response waits for the entire app to finish rendering, including waiting for all Suspense boundaries to resolve, before resolving. It is designed for static site generation (SSG) ahead of time and does not support streaming more content as it loads.

To stream content as it loads, use a streaming server render API like [renderToPipeableStream](https://react.dev/reference/react-dom/server/renderToPipeableStream).

[Previousprerender](https://react.dev/reference/react-dom/static/prerender)[NextresumeAndPrerender](https://react.dev/reference/react-dom/static/resumeAndPrerender)

---

---


# resumeAndPrerender – React

URL: https://react.dev/reference/react-dom/static/resumeAndPrerender

[API Reference](https://react.dev/reference/react)

[Static APIs](https://react.dev/reference/react-dom/static)

# resumeAndPrerender

`resumeAndPrerender` continues a prerendered React tree to a static HTML string using a [Web Stream](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API).

```
const { prelude,postpone } = await resumeAndPrerender(reactNode, postponedState, options?)
```

* [Reference](https://react.dev/reference/react-dom/static/resumeAndPrerender#reference) 
  + [`resumeAndPrerender(reactNode, postponedState, options?)`](https://react.dev/reference/react-dom/static/resumeAndPrerender#resumeandprerender)
* [Usage](https://react.dev/reference/react-dom/static/resumeAndPrerender#usage) 
  + [Further reading](https://react.dev/reference/react-dom/static/resumeAndPrerender#further-reading)

### Note

This API depends on [Web Streams.](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) For Node.js, use [`resumeAndPrerenderToNodeStream`](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream) instead.

---

## Reference

### `resumeAndPrerender(reactNode, postponedState, options?)`

Call `resumeAndPrerender` to continue a prerendered React tree to a static HTML string.

```
import { resumeAndPrerender } from 'react-dom/static';

import { getPostponedState } from 'storage';

async function handler(request, response) {

const postponedState = getPostponedState(request);

const { prelude } = await resumeAndPrerender(<App />, postponedState, {

bootstrapScripts: ['/main.js']

});

return new Response(prelude, {

headers: { 'content-type': 'text/html' },

});

}
```

On the client, call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](https://react.dev/reference/react-dom/static/resumeAndPrerender#usage)

#### Parameters

* `reactNode`: The React node you called `prerender` (or a previous `resumeAndPrerender`) with. For example, a JSX element like `<App />`. It is expected to represent the entire document, so the `App` component should render the `<html>` tag.
* `postponedState`: The opaque `postpone` object returned from a [prerender API](https://react.dev/reference/react-dom/static/index), loaded from wherever you stored it (e.g. redis, a file, or S3).
* **optional** `options`: An object with streaming options.
  + **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort server rendering](https://react.dev/reference/react-dom/static/resumeAndPrerender#aborting-server-rendering) and render the rest on the client.
  + **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/static/resumeAndPrerender#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/static/resumeAndPrerender#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/static/resumeAndPrerender#logging-crashes-on-the-server) make sure that you still call `console.error`.

#### Returns

`prerender` returns a Promise:

* If rendering the is successful, the Promise will resolve to an object containing:
  + `prelude`: a [Web Stream](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
  + `postponed`: an JSON-serializeable, opaque object that can be passed to [`resume`](https://react.dev/reference/react-dom/server/resume) or [`resumeAndPrerender`](https://react.dev/reference/react-dom/static/resumeAndPrerender) if `prerender` is aborted.
* If rendering fails, the Promise will be rejected. [Use this to output a fallback shell.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell)

#### Caveats

`nonce` is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP) it would be inappropriate and insecure to include the nonce value in the prerender itself.

### Note

### When should I use `resumeAndPrerender`?

The static `resumeAndPrerender` API is used for static server-side generation (SSG). Unlike `renderToString`, `resumeAndPrerender` waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like [renderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream).

`resumeAndPrerender` can be aborted and later either continued with another `resumeAndPrerender` or resumed with `resume` to support partial pre-rendering.

---

## Usage

### Further reading

`resumeAndPrerender` behaves similarly to [`prerender`](https://react.dev/reference/react-dom/static/prerender) but can be used to continue a previously started prerendering process that was aborted.
For more information about resuming a prerendered tree, see the [resume documentation](https://react.dev/reference/react-dom/server/resume#resuming-a-prerender).

[PreviousprerenderToNodeStream](https://react.dev/reference/react-dom/static/prerenderToNodeStream)[NextresumeAndPrerenderToNodeStream](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream)

---

---


# resumeAndPrerenderToNodeStream – React

URL: https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream

[API Reference](https://react.dev/reference/react)

[Static APIs](https://react.dev/reference/react-dom/static)

# resumeAndPrerenderToNodeStream

`resumeAndPrerenderToNodeStream` continues a prerendered React tree to a static HTML string using a a [Node.js Stream.](https://nodejs.org/api/stream.html).

```
const {prelude, postponed} = await resumeAndPrerenderToNodeStream(reactNode, postponedState, options?)
```

* [Reference](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream#reference) 
  + [`resumeAndPrerenderToNodeStream(reactNode, postponedState, options?)`](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream#resumeandprerendertolnodestream)
* [Usage](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream#usage) 
  + [Further reading](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream#further-reading)

### Note

This API is specific to Node.js. Environments with [Web Streams,](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) like Deno and modern edge runtimes, should use [`prerender`](https://react.dev/reference/react-dom/static/prerender) instead.

---

## Reference

### `resumeAndPrerenderToNodeStream(reactNode, postponedState, options?)`

Call `resumeAndPrerenderToNodeStream` to continue a prerendered React tree to a static HTML string.

```
import { resumeAndPrerenderToNodeStream } from 'react-dom/static';

import { getPostponedState } from 'storage';

async function handler(request, writable) {

const postponedState = getPostponedState(request);

const { prelude } = await resumeAndPrerenderToNodeStream(<App />, JSON.parse(postponedState));

prelude.pipe(writable);

}
```

On the client, call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream#usage)

#### Parameters

* `reactNode`: The React node you called `prerender` (or a previous `resumeAndPrerenderToNodeStream`) with. For example, a JSX element like `<App />`. It is expected to represent the entire document, so the `App` component should render the `<html>` tag.
* `postponedState`: The opaque `postpone` object returned from a [prerender API](https://react.dev/reference/react-dom/static/index), loaded from wherever you stored it (e.g. redis, a file, or S3).
* **optional** `options`: An object with streaming options.
  + **optional** `signal`: An [abort signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) that lets you [abort server rendering](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream#aborting-server-rendering) and render the rest on the client.
  + **optional** `onError`: A callback that fires whenever there is a server error, whether [recoverable](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream#recovering-from-errors-outside-the-shell) or [not.](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream#recovering-from-errors-inside-the-shell) By default, this only calls `console.error`. If you override it to [log crash reports,](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream#logging-crashes-on-the-server) make sure that you still call `console.error`.

#### Returns

`resumeAndPrerenderToNodeStream` returns a Promise:

* If rendering the is successful, the Promise will resolve to an object containing:
  + `prelude`: a [Web Stream](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) of HTML. You can use this stream to send a response in chunks, or you can read the entire stream into a string.
  + `postponed`: an JSON-serializeable, opaque object that can be passed to [`resumeToNodeStream`](https://react.dev/reference/react-dom/server/resume) or [`resumeAndPrerenderToNodeStream`](https://react.dev/reference/react-dom/static/resumeAndPrerenderToNodeStream) if `resumeAndPrerenderToNodeStream` is aborted.
* If rendering fails, the Promise will be rejected. [Use this to output a fallback shell.](https://react.dev/reference/react-dom/server/renderToReadableStream#recovering-from-errors-inside-the-shell)

#### Caveats

`nonce` is not an available option when prerendering. Nonces must be unique per request and if you use nonces to secure your application with [CSP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/CSP) it would be inappropriate and insecure to include the nonce value in the prerender itself.

### Note

### When should I use `resumeAndPrerenderToNodeStream`?

The static `resumeAndPrerenderToNodeStream` API is used for static server-side generation (SSG). Unlike `renderToString`, `resumeAndPrerenderToNodeStream` waits for all data to load before resolving. This makes it suitable for generating static HTML for a full page, including data that needs to be fetched using Suspense. To stream content as it loads, use a streaming server-side render (SSR) API like [renderToReadableStream](https://react.dev/reference/react-dom/server/renderToReadableStream).

`resumeAndPrerenderToNodeStream` can be aborted and later either continued with another `resumeAndPrerenderToNodeStream` or resumed with `resume` to support partial pre-rendering.

---

## Usage

### Further reading

`resumeAndPrerenderToNodeStream` behaves similarly to [`prerender`](https://react.dev/reference/react-dom/static/prerender) but can be used to continue a previously started prerendering process that was aborted.
For more information about resuming a prerendered tree, see the [resume documentation](https://react.dev/reference/react-dom/server/resume#resuming-a-prerender).

[PreviousresumeAndPrerender](https://react.dev/reference/react-dom/static/resumeAndPrerender)

---

---


# compilationMode – React

URL: https://react.dev/reference/react-compiler/compilationMode

[API Reference](https://react.dev/reference/react)

[Configuration](https://react.dev/reference/react-compiler/configuration)

# compilationMode

The `compilationMode` option controls how the React Compiler selects which functions to compile.

```
{

compilationMode: 'infer' // or 'annotation', 'syntax', 'all'

}
```

* [Reference](https://react.dev/reference/react-compiler/compilationMode#reference) 
  + [`compilationMode`](https://react.dev/reference/react-compiler/compilationMode#compilationmode)
* [Usage](https://react.dev/reference/react-compiler/compilationMode#usage) 
  + [Default inference mode](https://react.dev/reference/react-compiler/compilationMode#default-inference-mode)
  + [Incremental adoption with annotation mode](https://react.dev/reference/react-compiler/compilationMode#incremental-adoption)
  + [Using Flow syntax mode](https://react.dev/reference/react-compiler/compilationMode#flow-syntax-mode)
  + [Opting out specific functions](https://react.dev/reference/react-compiler/compilationMode#opting-out)
* [Troubleshooting](https://react.dev/reference/react-compiler/compilationMode#troubleshooting) 
  + [Component not being compiled in infer mode](https://react.dev/reference/react-compiler/compilationMode#component-not-compiled-infer)

---

## Reference

### `compilationMode`

Controls the strategy for determining which functions the React Compiler will optimize.

#### Type

```
'infer' | 'syntax' | 'annotation' | 'all'
```

#### Default value

`'infer'`

#### Options

* **`'infer'`** (default): The compiler uses intelligent heuristics to identify React components and hooks:

  + Functions explicitly annotated with `"use memo"` directive
  + Functions that are named like components (PascalCase) or hooks (`use` prefix) AND create JSX and/or call other hooks
* **`'annotation'`**: Only compile functions explicitly marked with the `"use memo"` directive. Ideal for incremental adoption.
* **`'syntax'`**: Only compile components and hooks that use Flow’s [component](https://flow.org/en/docs/react/component-syntax/) and [hook](https://flow.org/en/docs/react/hook-syntax/) syntax.
* **`'all'`**: Compile all top-level functions. Not recommended as it may compile non-React functions.

#### Caveats

* The `'infer'` mode requires functions to follow React naming conventions to be detected
* Using `'all'` mode may negatively impact performance by compiling utility functions
* The `'syntax'` mode requires Flow and won’t work with TypeScript
* Regardless of mode, functions with `"use no memo"` directive are always skipped

---

## Usage

### Default inference mode

The default `'infer'` mode works well for most codebases that follow React conventions:

```
{

compilationMode: 'infer'

}
```

With this mode, these functions will be compiled:

```
// ✅ Compiled: Named like a component + returns JSX

function Button(props) {

return <button>{props.label}</button>;

}

// ✅ Compiled: Named like a hook + calls hooks

function useCounter() {

const [count, setCount] = useState(0);

return [count, setCount];

}

// ✅ Compiled: Explicit directive

function expensiveCalculation(data) {

"use memo";

return data.reduce(/* ... */);

}

// ❌ Not compiled: Not a component/hook pattern

function calculateTotal(items) {

return items.reduce((a, b) => a + b, 0);

}
```

### Incremental adoption with annotation mode

For gradual migration, use `'annotation'` mode to only compile marked functions:

```
{

compilationMode: 'annotation'

}
```

Then explicitly mark functions to compile:

```
// Only this function will be compiled

function ExpensiveList(props) {

"use memo";

return (

<ul>

{props.items.map(item => (

<li key={item.id}>{item.name}</li>

))}

</ul>

);

}

// This won't be compiled without the directive

function NormalComponent(props) {

return <div>{props.content}</div>;

}
```

### Using Flow syntax mode

If your codebase uses Flow instead of TypeScript:

```
{

compilationMode: 'syntax'

}
```

Then use Flow’s component syntax:

```
// Compiled: Flow component syntax

component Button(label: string) {

return <button>{label}</button>;

}

// Compiled: Flow hook syntax

hook useCounter(initial: number) {

const [count, setCount] = useState(initial);

return [count, setCount];

}

// Not compiled: Regular function syntax

function helper(data) {

return process(data);

}
```

### Opting out specific functions

Regardless of compilation mode, use `"use no memo"` to skip compilation:

```
function ComponentWithSideEffects() {

"use no memo"; // Prevent compilation

// This component has side effects that shouldn't be memoized

logToAnalytics('component_rendered');

return <div>Content</div>;

}
```

---

## Troubleshooting

### Component not being compiled in infer mode

In `'infer'` mode, ensure your component follows React conventions:

```
// ❌ Won't be compiled: lowercase name

function button(props) {

return <button>{props.label}</button>;

}

// ✅ Will be compiled: PascalCase name

function Button(props) {

return <button>{props.label}</button>;

}

// ❌ Won't be compiled: doesn't create JSX or call hooks

function useData() {

return window.localStorage.getItem('data');

}

// ✅ Will be compiled: calls a hook

function useData() {

const [data] = useState(() => window.localStorage.getItem('data'));

return data;

}
```

[PreviousConfiguration](https://react.dev/reference/react-compiler/configuration)[Nextgating](https://react.dev/reference/react-compiler/gating)

---

---


# gating – React

URL: https://react.dev/reference/react-compiler/gating

[API Reference](https://react.dev/reference/react)

[Configuration](https://react.dev/reference/react-compiler/configuration)

# gating

The `gating` option enables conditional compilation, allowing you to control when optimized code is used at runtime.

```
{

gating: {

source: 'my-feature-flags',

importSpecifierName: 'shouldUseCompiler'

}

}
```

* [Reference](https://react.dev/reference/react-compiler/gating#reference) 
  + [`gating`](https://react.dev/reference/react-compiler/gating#gating)
* [Usage](https://react.dev/reference/react-compiler/gating#usage) 
  + [Basic feature flag setup](https://react.dev/reference/react-compiler/gating#basic-setup)
* [Troubleshooting](https://react.dev/reference/react-compiler/gating#troubleshooting) 
  + [Feature flag not working](https://react.dev/reference/react-compiler/gating#flag-not-working)
  + [Import errors](https://react.dev/reference/react-compiler/gating#import-errors)

---

## Reference

### `gating`

Configures runtime feature flag gating for compiled functions.

#### Type

```
{

source: string;

importSpecifierName: string;

} | null
```

#### Default value

`null`

#### Properties

* **`source`**: Module path to import the feature flag from
* **`importSpecifierName`**: Name of the exported function to import

#### Caveats

* The gating function must return a boolean
* Both compiled and original versions increase bundle size
* The import is added to every file with compiled functions

---

## Usage

### Basic feature flag setup

1. Create a feature flag module:

```
// src/utils/feature-flags.js

export function shouldUseCompiler() {

// your logic here

return getFeatureFlag('react-compiler-enabled');

}
```

2. Configure the compiler:

```
{

gating: {

source: './src/utils/feature-flags',

importSpecifierName: 'shouldUseCompiler'

}

}
```

3. The compiler generates gated code:

```
// Input

function Button(props) {

return <button>{props.label}</button>;

}

// Output (simplified)

import { shouldUseCompiler } from './src/utils/feature-flags';

const Button = shouldUseCompiler()

? function Button_optimized(props) { /* compiled version */ }

: function Button_original(props) { /* original version */ };
```

Note that the gating function is evaluated once at module time, so once the JS bundle has been parsed and evaluated the choice of component stays static for the rest of the browser session.

---

## Troubleshooting

### Feature flag not working

Verify your flag module exports the correct function:

```
// ❌ Wrong: Default export

export default function shouldUseCompiler() {

return true;

}

// ✅ Correct: Named export matching importSpecifierName

export function shouldUseCompiler() {

return true;

}
```

### Import errors

Ensure the source path is correct:

```
// ❌ Wrong: Relative to babel.config.js

{

source: './src/flags',

importSpecifierName: 'flag'

}

// ✅ Correct: Module resolution path

{

source: '@myapp/feature-flags',

importSpecifierName: 'flag'

}

// ✅ Also correct: Absolute path from project root

{

source: './src/utils/flags',

importSpecifierName: 'flag'

}
```

[PreviouscompilationMode](https://react.dev/reference/react-compiler/compilationMode)[Nextlogger](https://react.dev/reference/react-compiler/logger)

---

---


# logger – React

URL: https://react.dev/reference/react-compiler/logger

[API Reference](https://react.dev/reference/react)

[Configuration](https://react.dev/reference/react-compiler/configuration)

# logger

The `logger` option provides custom logging for React Compiler events during compilation.

```
{

logger: {

logEvent(filename, event) {

console.log(`[Compiler] ${event.kind}: ${filename}`);

}

}

}
```

* [Reference](https://react.dev/reference/react-compiler/logger#reference) 
  + [`logger`](https://react.dev/reference/react-compiler/logger#logger)
* [Usage](https://react.dev/reference/react-compiler/logger#usage) 
  + [Basic logging](https://react.dev/reference/react-compiler/logger#basic-logging)
  + [Detailed error logging](https://react.dev/reference/react-compiler/logger#detailed-error-logging)

---

## Reference

### `logger`

Configures custom logging to track compiler behavior and debug issues.

#### Type

```
{

logEvent: (filename: string | null, event: LoggerEvent) => void;

} | null
```

#### Default value

`null`

#### Methods

* **`logEvent`**: Called for each compiler event with the filename and event details

#### Event types

* **`CompileSuccess`**: Function successfully compiled
* **`CompileError`**: Function skipped due to errors
* **`CompileDiagnostic`**: Non-fatal diagnostic information
* **`CompileSkip`**: Function skipped for other reasons
* **`PipelineError`**: Unexpected compilation error
* **`Timing`**: Performance timing information

#### Caveats

* Event structure may change between versions
* Large codebases generate many log entries

---

## Usage

### Basic logging

Track compilation success and failures:

```
{

logger: {

logEvent(filename, event) {

switch (event.kind) {

case 'CompileSuccess': {

console.log(`✅ Compiled: ${filename}`);

break;

}

case 'CompileError': {

console.log(`❌ Skipped: ${filename}`);

break;

}

default: {}

}

}

}

}
```

### Detailed error logging

Get specific information about compilation failures:

```
{

logger: {

logEvent(filename, event) {

if (event.kind === 'CompileError') {

console.error(`\nCompilation failed: ${filename}`);

console.error(`Reason: ${event.detail.reason}`);

if (event.detail.description) {

console.error(`Details: ${event.detail.description}`);

}

if (event.detail.loc) {

const { line, column } = event.detail.loc.start;

console.error(`Location: Line ${line}, Column ${column}`);

}

if (event.detail.suggestions) {

console.error('Suggestions:', event.detail.suggestions);

}

}

}

}

}
```

[Previousgating](https://react.dev/reference/react-compiler/gating)[NextpanicThreshold](https://react.dev/reference/react-compiler/panicThreshold)

---

---


# panicThreshold – React

URL: https://react.dev/reference/react-compiler/panicThreshold

[API Reference](https://react.dev/reference/react)

[Configuration](https://react.dev/reference/react-compiler/configuration)

# panicThreshold

The `panicThreshold` option controls how the React Compiler handles errors during compilation.

```
{

panicThreshold: 'none' // Recommended

}
```

* [Reference](https://react.dev/reference/react-compiler/panicThreshold#reference) 
  + [`panicThreshold`](https://react.dev/reference/react-compiler/panicThreshold#panicthreshold)
* [Usage](https://react.dev/reference/react-compiler/panicThreshold#usage) 
  + [Production configuration (recommended)](https://react.dev/reference/react-compiler/panicThreshold#production-configuration)
  + [Development debugging](https://react.dev/reference/react-compiler/panicThreshold#development-debugging)

---

## Reference

### `panicThreshold`

Determines whether compilation errors should fail the build or skip optimization.

#### Type

```
'none' | 'critical_errors' | 'all_errors'
```

#### Default value

`'none'`

#### Options

* **`'none'`** (default, recommended): Skip components that can’t be compiled and continue building
* **`'critical_errors'`**: Fail the build only on critical compiler errors
* **`'all_errors'`**: Fail the build on any compiler diagnostic

#### Caveats

* Production builds should always use `'none'`
* Build failures prevent your application from building
* The compiler automatically detects and skips problematic code with `'none'`
* Higher thresholds are only useful during development for debugging

---

## Usage

### Production configuration (recommended)

For production builds, always use `'none'`. This is the default value:

```
{

panicThreshold: 'none'

}
```

This ensures:

* Your build never fails due to compiler issues
* Components that can’t be optimized run normally
* Maximum components get optimized
* Stable production deployments

### Development debugging

Temporarily use stricter thresholds to find issues:

```
const isDevelopment = process.env.NODE_ENV === 'development';

{

panicThreshold: isDevelopment ? 'critical_errors' : 'none',

logger: {

logEvent(filename, event) {

if (isDevelopment && event.kind === 'CompileError') {

// ...

}

}

}

}
```

[Previouslogger](https://react.dev/reference/react-compiler/logger)[Nexttarget](https://react.dev/reference/react-compiler/target)

---

---


# target – React

URL: https://react.dev/reference/react-compiler/target

[API Reference](https://react.dev/reference/react)

[Configuration](https://react.dev/reference/react-compiler/configuration)

# target

The `target` option specifies which React version the compiler should generate code for.

```
{

target: '19' // or '18', '17'

}
```

* [Reference](https://react.dev/reference/react-compiler/target#reference) 
  + [`target`](https://react.dev/reference/react-compiler/target#target)
* [Usage](https://react.dev/reference/react-compiler/target#usage) 
  + [Targeting React 19 (default)](https://react.dev/reference/react-compiler/target#targeting-react-19)
  + [Targeting React 17 or 18](https://react.dev/reference/react-compiler/target#targeting-react-17-or-18)
* [Troubleshooting](https://react.dev/reference/react-compiler/target#troubleshooting) 
  + [Runtime errors about missing compiler runtime](https://react.dev/reference/react-compiler/target#missing-runtime)
  + [Runtime package not working](https://react.dev/reference/react-compiler/target#runtime-not-working)
  + [Checking compiled output](https://react.dev/reference/react-compiler/target#checking-output)

---

## Reference

### `target`

Configures the React version compatibility for the compiled output.

#### Type

```
'17' | '18' | '19'
```

#### Default value

`'19'`

#### Valid values

* **`'19'`**: Target React 19 (default). No additional runtime required.
* **`'18'`**: Target React 18. Requires `react-compiler-runtime` package.
* **`'17'`**: Target React 17. Requires `react-compiler-runtime` package.

#### Caveats

* Always use string values, not numbers (e.g., `'17'` not `17`)
* Don’t include patch versions (e.g., use `'18'` not `'18.2.0'`)
* React 19 includes built-in compiler runtime APIs
* React 17 and 18 require installing `react-compiler-runtime@latest`

---

## Usage

### Targeting React 19 (default)

For React 19, no special configuration is needed:

```
{

// defaults to target: '19'

}
```

The compiler will use React 19’s built-in runtime APIs:

```
// Compiled output uses React 19's native APIs

import { c as _c } from 'react/compiler-runtime';
```

### Targeting React 17 or 18

For React 17 and React 18 projects, you need two steps:

1. Install the runtime package:

```
npm install react-compiler-runtime@latest
```

2. Configure the target:

```
// For React 18

{

target: '18'

}

// For React 17

{

target: '17'

}
```

The compiler will use the polyfill runtime for both versions:

```
// Compiled output uses the polyfill

import { c as _c } from 'react-compiler-runtime';
```

---

## Troubleshooting

### Runtime errors about missing compiler runtime

If you see errors like “Cannot find module ‘react/compiler-runtime’“:

1. Check your React version:

   ```
   npm why react
   ```
2. If using React 17 or 18, install the runtime:

   ```
   npm install react-compiler-runtime@latest
   ```
3. Ensure your target matches your React version:

   ```
   {

   target: '18' // Must match your React major version

   }
   ```

### Runtime package not working

Ensure the runtime package is:

1. Installed in your project (not globally)
2. Listed in your `package.json` dependencies
3. The correct version (`@latest` tag)
4. Not in `devDependencies` (it’s needed at runtime)

### Checking compiled output

To verify the correct runtime is being used, note the different import (`react/compiler-runtime` for builtin, `react-compiler-runtime` standalone package for 17/18):

```
// For React 19 (built-in runtime)

import { c } from 'react/compiler-runtime'

//                      ^

// For React 17/18 (polyfill runtime)

import { c } from 'react-compiler-runtime'

//                      ^
```

[PreviouspanicThreshold](https://react.dev/reference/react-compiler/panicThreshold)[NextDirectives](https://react.dev/reference/react-compiler/directives)

---

---


# 'use memo' directive – React

URL: https://react.dev/reference/react-compiler/directives/use-memo

[API Reference](https://react.dev/reference/react)

[Directives](https://react.dev/reference/react-compiler/directives)

# use memo

`"use memo"` marks a function for React Compiler optimization.

### Note

In most cases, you don’t need `"use memo"`. It’s primarily needed in `annotation` mode where you must explicitly mark functions for optimization. In `infer` mode, the compiler automatically detects components and hooks by their naming patterns (PascalCase for components, `use` prefix for hooks). If a component or hook isn’t being compiled in `infer` mode, you should fix its naming convention rather than forcing compilation with `"use memo"`.

* [Reference](https://react.dev/reference/react-compiler/directives/use-memo#reference) 
  + [`"use memo"`](https://react.dev/reference/react-compiler/directives/use-memo#use-memo)
  + [How `"use memo"` marks functions for optimization](https://react.dev/reference/react-compiler/directives/use-memo#how-use-memo-marks)
  + [When to use `"use memo"`](https://react.dev/reference/react-compiler/directives/use-memo#when-to-use)
* [Usage](https://react.dev/reference/react-compiler/directives/use-memo#usage) 
  + [Working with different compilation modes](https://react.dev/reference/react-compiler/directives/use-memo#compilation-modes)
* [Troubleshooting](https://react.dev/reference/react-compiler/directives/use-memo#troubleshooting) 
  + [Verifying optimization](https://react.dev/reference/react-compiler/directives/use-memo#verifying-optimization)
  + [See also](https://react.dev/reference/react-compiler/directives/use-memo#see-also)

---

## Reference

### `"use memo"`

Add `"use memo"` at the beginning of a function to mark it for React Compiler optimization.

```
function MyComponent() {

"use memo";

// ...

}
```

When a function contains `"use memo"`, the React Compiler will analyze and optimize it during build time. The compiler will automatically memoize values and components to prevent unnecessary re-computations and re-renders.

#### Caveats

* `"use memo"` must be at the very beginning of a function body, before any imports or other code (comments are OK).
* The directive must be written with double or single quotes, not backticks.
* The directive must exactly match `"use memo"`.
* Only the first directive in a function is processed; additional directives are ignored.
* The effect of the directive depends on your [`compilationMode`](https://react.dev/reference/react-compiler/compilationMode) setting.

### How `"use memo"` marks functions for optimization

In a React app that uses the React Compiler, functions are analyzed at build time to determine if they can be optimized. By default, the compiler automatically infers which components to memoize, but this can depend on your [`compilationMode`](https://react.dev/reference/react-compiler/compilationMode) setting if you’ve set it.

`"use memo"` explicitly marks a function for optimization, overriding the default behavior:

* In `annotation` mode: Only functions with `"use memo"` are optimized
* In `infer` mode: The compiler uses heuristics, but `"use memo"` forces optimization
* In `all` mode: Everything is optimized by default, making `"use memo"` redundant

The directive creates a clear boundary in your codebase between optimized and non-optimized code, giving you fine-grained control over the compilation process.

### When to use `"use memo"`

You should consider using `"use memo"` when:

#### You’re using annotation mode

In `compilationMode: 'annotation'`, the directive is required for any function you want optimized:

```
// ✅ This component will be optimized

function OptimizedList() {

"use memo";

// ...

}

// ❌ This component won't be optimized

function SimpleWrapper() {

// ...

}
```

#### You’re gradually adopting React Compiler

Start with `annotation` mode and selectively optimize stable components:

```
// Start by optimizing leaf components

function Button({ onClick, children }) {

"use memo";

// ...

}

// Gradually move up the tree as you verify behavior

function ButtonGroup({ buttons }) {

"use memo";

// ...

}
```

---

## Usage

### Working with different compilation modes

The behavior of `"use memo"` changes based on your compiler configuration:

```
// babel.config.js

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

compilationMode: 'annotation' // or 'infer' or 'all'

}]

]

};
```

#### Annotation mode

```
// ✅ Optimized with "use memo"

function ProductCard({ product }) {

"use memo";

// ...

}

// ❌ Not optimized (no directive)

function ProductList({ products }) {

// ...

}
```

#### Infer mode (default)

```
// Automatically memoized because this is named like a Component

function ComplexDashboard({ data }) {

// ...

}

// Skipped: Is not named like a Component

function simpleDisplay({ text }) {

// ...

}
```

In `infer` mode, the compiler automatically detects components and hooks by their naming patterns (PascalCase for components, `use` prefix for hooks). If a component or hook isn’t being compiled in `infer` mode, you should fix its naming convention rather than forcing compilation with `"use memo"`.

---

## Troubleshooting

### Verifying optimization

To confirm your component is being optimized:

1. Check the compiled output in your build
2. Use React DevTools to check for Memo ✨ badge

### See also

* [`"use no memo"`](https://react.dev/reference/react-compiler/directives/use-no-memo) - Opt out of compilation
* [`compilationMode`](https://react.dev/reference/react-compiler/compilationMode) - Configure compilation behavior
* [React Compiler](https://react.dev/learn/react-compiler) - Getting started guide

[PreviousDirectives](https://react.dev/reference/react-compiler/directives)[Next"use no memo"](https://react.dev/reference/react-compiler/directives/use-no-memo)

---

---


# 'use no memo' directive – React

URL: https://react.dev/reference/react-compiler/directives/use-no-memo

[API Reference](https://react.dev/reference/react)

[Directives](https://react.dev/reference/react-compiler/directives)

# use no memo

`"use no memo"` prevents a function from being optimized by React Compiler.

* [Reference](https://react.dev/reference/react-compiler/directives/use-no-memo#reference) 
  + [`"use no memo"`](https://react.dev/reference/react-compiler/directives/use-no-memo#use-no-memo)
  + [How `"use no memo"` opts-out of optimization](https://react.dev/reference/react-compiler/directives/use-no-memo#how-use-no-memo-opts-out)
  + [When to use `"use no memo"`](https://react.dev/reference/react-compiler/directives/use-no-memo#when-to-use)
* [Usage](https://react.dev/reference/react-compiler/directives/use-no-memo#usage)
* [Troubleshooting](https://react.dev/reference/react-compiler/directives/use-no-memo#troubleshooting) 
  + [Directive not preventing compilation](https://react.dev/reference/react-compiler/directives/use-no-memo#not-preventing)
  + [Best practices](https://react.dev/reference/react-compiler/directives/use-no-memo#best-practices)
  + [See also](https://react.dev/reference/react-compiler/directives/use-no-memo#see-also)

---

## Reference

### `"use no memo"`

Add `"use no memo"` at the beginning of a function to prevent React Compiler optimization.

```
function MyComponent() {

"use no memo";

// ...

}
```

When a function contains `"use no memo"`, the React Compiler will skip it entirely during optimization. This is useful as a temporary escape hatch when debugging or when dealing with code that doesn’t work correctly with the compiler.

#### Caveats

* `"use no memo"` must be at the very beginning of a function body, before any imports or other code (comments are OK).
* The directive must be written with double or single quotes, not backticks.
* The directive must exactly match `"use no memo"` or its alias `"use no forget"`.
* This directive takes precedence over all compilation modes and other directives.
* It’s intended as a temporary debugging tool, not a permanent solution.

### How `"use no memo"` opts-out of optimization

React Compiler analyzes your code at build time to apply optimizations. `"use no memo"` creates an explicit boundary that tells the compiler to skip a function entirely.

This directive takes precedence over all other settings:

* In `all` mode: The function is skipped despite the global setting
* In `infer` mode: The function is skipped even if heuristics would optimize it

The compiler treats these functions as if the React Compiler wasn’t enabled, leaving them exactly as written.

### When to use `"use no memo"`

`"use no memo"` should be used sparingly and temporarily. Common scenarios include:

#### Debugging compiler issues

When you suspect the compiler is causing issues, temporarily disable optimization to isolate the problem:

```
function ProblematicComponent({ data }) {

"use no memo"; // TODO: Remove after fixing issue #123

// Rules of React violations that weren't statically detected

// ...

}
```

#### Third-party library integration

When integrating with libraries that might not be compatible with the compiler:

```
function ThirdPartyWrapper() {

"use no memo";

useThirdPartyHook(); // Has side effects that compiler might optimize incorrectly

// ...

}
```

---

## Usage

The `"use no memo"` directive is placed at the beginning of a function body to prevent React Compiler from optimizing that function:

```
function MyComponent() {

"use no memo";

// Function body

}
```

The directive can also be placed at the top of a file to affect all functions in that module:

```
"use no memo";

// All functions in this file will be skipped by the compiler
```

`"use no memo"` at the function level overrides the module level directive.

---

## Troubleshooting

### Directive not preventing compilation

If `"use no memo"` isn’t working:

```
// ❌ Wrong - directive after code

function Component() {

const data = getData();

"use no memo"; // Too late!

}

// ✅ Correct - directive first

function Component() {

"use no memo";

const data = getData();

}
```

Also check:

* Spelling - must be exactly `"use no memo"`
* Quotes - must use single or double quotes, not backticks

### Best practices

**Always document why** you’re disabling optimization:

```
// ✅ Good - clear explanation and tracking

function DataProcessor() {

"use no memo"; // TODO: Remove after fixing rule of react violation

// ...

}

// ❌ Bad - no explanation

function Mystery() {

"use no memo";

// ...

}
```

### See also

* [`"use memo"`](https://react.dev/reference/react-compiler/directives/use-memo) - Opt into compilation
* [React Compiler](https://react.dev/learn/react-compiler) - Getting started guide

[Previous"use memo"](https://react.dev/reference/react-compiler/directives/use-memo)[NextCompiling Libraries](https://react.dev/reference/react-compiler/compiling-libraries)

---

---


# React Performance tracks – React

URL: https://react.dev/reference/dev-tools/react-performance-tracks

[API Reference](https://react.dev/reference/react)

# React Performance tracks

React Performance tracks are specialized custom entries that appear on the Performance panel’s timeline in your browser developer tools.

These tracks are designed to provide developers with comprehensive insights into their React application’s performance by visualizing React-specific events and metrics alongside other critical data sources such as network requests, JavaScript execution, and event loop activity, all synchronized on a unified timeline within the Performance panel for a complete understanding of application behavior.

![React Performance Tracks](https://react.dev/images/docs/performance-tracks/overview.png)![React Performance Tracks](https://react.dev/images/docs/performance-tracks/overview.dark.png)

* [Usage](https://react.dev/reference/dev-tools/react-performance-tracks#usage) 
  + [Using profiling builds](https://react.dev/reference/dev-tools/react-performance-tracks#using-profiling-builds)
* [Tracks](https://react.dev/reference/dev-tools/react-performance-tracks#tracks) 
  + [Scheduler](https://react.dev/reference/dev-tools/react-performance-tracks#scheduler)
  + [Components](https://react.dev/reference/dev-tools/react-performance-tracks#components)
  + [Server](https://react.dev/reference/dev-tools/react-performance-tracks#server)

---

## Usage

React Performance tracks are only available in development and profiling builds of React:

* **Development**: enabled by default.
* **Profiling**: Only Scheduler tracks are enabled by default. The Components track only lists Components that are in subtrees wrapped with [`<Profiler>`](https://react.dev/reference/react/Profiler). If you have [React Developer Tools extension](https://react.dev/learn/react-developer-tools) enabled, all Components are included in the Components track even if they’re not wrapped in `<Profiler>`. Server tracks are not available in profiling builds.

If enabled, tracks should appear automatically in the traces you record with the Performance panel of browsers that provide [extensibility APIs](https://developer.chrome.com/docs/devtools/performance/extension).

### Pitfall

The profiling instrumentation that powers React Performance tracks adds some additional overhead, so it is disabled in production builds by default.
Server Components and Server Requests tracks are only available in development builds.

### Using profiling builds

In addition to production and development builds, React also includes a special profiling build.
To use profiling builds, you have to use `react-dom/profiling` instead of `react-dom/client`.
We recommend that you alias `react-dom/client` to `react-dom/profiling` at build time via bundler aliases instead of manually updating each `react-dom/client` import.
Your framework might have built-in support for enabling React’s profiling build.

---

## Tracks

### Scheduler

The Scheduler is an internal React concept used for managing tasks with different priorities. This track consists of 4 subtracks, each representing work of a specific priority:

* **Blocking** - The synchronous updates, which could’ve been initiated by user interactions.
* **Transition** - Non-blocking work that happens in the background, usually initiated via [`startTransition`](https://react.dev/reference/react/startTransition).
* **Suspense** - Work related to Suspense boundaries, such as displaying fallbacks or revealing content.
* **Idle** - The lowest priority work that is done when there are no other tasks with higher priority.

![Scheduler track](https://react.dev/images/docs/performance-tracks/scheduler.png)![Scheduler track](https://react.dev/images/docs/performance-tracks/scheduler.dark.png)

#### Renders

Every render pass consists of multiple phases that you can see on a timeline:

* **Update** - this is what caused a new render pass.
* **Render** - React renders the updated subtree by calling render functions of components. You can see the rendered components subtree on [Components track](https://react.dev/reference/dev-tools/react-performance-tracks#components), which follows the same color scheme.
* **Commit** - After rendering components, React will submit the changes to the DOM and run layout effects, like [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect).
* **Remaining Effects** - React runs passive effects of a rendered subtree. This usually happens after the paint, and this is when React runs hooks like [`useEffect`](https://react.dev/reference/react/useEffect). One known exception is user interactions, like clicks, or other discrete events. In this scenario, this phase could run before the paint.

![Scheduler track: updates](https://react.dev/images/docs/performance-tracks/scheduler-update.png)![Scheduler track: updates](https://react.dev/images/docs/performance-tracks/scheduler-update.dark.png)

[Learn more about renders and commits](https://react.dev/learn/render-and-commit).

#### Cascading updates

Cascading updates is one of the patterns for performance regressions. If an update was scheduled during a render pass, React could discard completed work and start a new pass.

In development builds, React can show you which Component scheduled a new update. This includes both general updates and cascading ones. You can see the enhanced stack trace by clicking on the “Cascading update” entry, which should also display the name of the method that scheduled an update.

![Scheduler track: cascading updates](https://react.dev/images/docs/performance-tracks/scheduler-cascading-update.png)![Scheduler track: cascading updates](https://react.dev/images/docs/performance-tracks/scheduler-cascading-update.dark.png)

[Learn more about Effects](https://react.dev/learn/you-might-not-need-an-effect).

### Components

The Components track visualizes the durations of React components. They are displayed as a flamegraph, where each entry represents the duration of the corresponding component render and all its descendant children components.

![Components track: render durations](https://react.dev/images/docs/performance-tracks/components-render.png)![Components track: render durations](https://react.dev/images/docs/performance-tracks/components-render.dark.png)

Similar to render durations, effect durations are also represented as a flamegraph, but with a different color scheme that aligns with the corresponding phase on the Scheduler track.

![Components track: effects durations](https://react.dev/images/docs/performance-tracks/components-effects.png)![Components track: effects durations](https://react.dev/images/docs/performance-tracks/components-effects.dark.png)

### Note

Unlike renders, not all effects are shown on the Components track by default.

To maintain performance and prevent UI clutter, React will only display those effects, which had a duration of 0.05ms or longer, or triggered an update.

Additional events may be displayed during the render and effects phases:

* Mount - A corresponding subtree of component renders or effects was mounted.
* Unmount - A corresponding subtree of component renders or effects was unmounted.
* Reconnect - Similar to Mount, but limited to cases when [`<Activity>`](https://react.dev/reference/react/Activity) is used.
* Disconnect - Similar to Unmount, but limited to cases when [`<Activity>`](https://react.dev/reference/react/Activity) is used.

#### Changed props

In development builds, when you click on a component render entry, you can inspect potential changes in props. You can use this information to identify unnecessary renders.

![Components track: changed props](https://react.dev/images/docs/performance-tracks/changed-props.png)![Components track: changed props](https://react.dev/images/docs/performance-tracks/changed-props.dark.png)

### Server

![React Server Performance Tracks](https://react.dev/images/docs/performance-tracks/server-overview.png)![React Server Performance Tracks](https://react.dev/images/docs/performance-tracks/server-overview.dark.png)

#### Server Requests

The Server Requests track visualized all Promises that eventually end up in a React Server Component. This includes any `async` operations like calling `fetch` or async Node.js file operations.

React will try to combine Promises that are started from inside third-party code into a single span representing the the duration of the entire operation blocking 1st party code.
For example, a third party library method called `getUser` that calls `fetch` internally multiple times will be represented as a single span called `getUser`, instead of showing multiple `fetch` spans.

Clicking on spans will show you a stack trace of where the Promise was created as well as a view of the value that the Promise resolved to, if available.

Rejected Promises are displayed as red with their rejected value.

#### Server Components

The Server Components tracks visualize the durations of React Server Components Promises they awaited. Timings are displayed as a flamegraph, where each entry represents the duration of the corresponding component render and all its descendant children components.

If you await a Promise, React will display duration of that Promise. To see all I/O operations, use the Server Requests track.

Different colors are used to indicate the duration of the component render. The darker the color, the longer the duration.

The Server Components track group will always contain a “Primary” track. If React is able to render Server Components concurrently, it will display addititional “Parallel” tracks.
If more than 8 Server Components are rendered concurrently, React will associate them with the last “Parallel” track instead of adding more tracks.

---

---


# eslint-plugin-react-hooks – React

URL: https://react.dev/reference/eslint-plugin-react-hooks

[API Reference](https://react.dev/reference/react)

# eslint-plugin-react-hooks - This feature is available in the latest RC version

`eslint-plugin-react-hooks` provides ESLint rules to enforce the [Rules of React](https://react.dev/reference/rules).

This plugin helps you catch violations of React’s rules at build time, ensuring your components and hooks follow React’s rules for correctness and performance. The lints cover both fundamental React patterns (exhaustive-deps and rules-of-hooks) and issues flagged by React Compiler. React Compiler diagnostics are automatically surfaced by this ESLint plugin, and can be used even if your app hasn’t adopted the compiler yet.

### Note

When the compiler reports a diagnostic, it means that the compiler was able to statically detect a pattern that is not supported or breaks the Rules of React. When it detects this, it **automatically** skips over those components and hooks, while keeping the rest of your app compiled. This ensures optimal coverage of safe optimizations that won’t break your app.

What this means for linting, is that you don’t need to fix all violations immediately. Address them at your own pace to gradually increase the number of optimized components.

## Recommended Rules

These rules are included in the `recommended` preset in `eslint-plugin-react-hooks`:

* [`exhaustive-deps`](https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps) - Validates that dependency arrays for React hooks contain all necessary dependencies
* [`rules-of-hooks`](https://react.dev/reference/eslint-plugin-react-hooks/lints/rules-of-hooks) - Validates that components and hooks follow the Rules of Hooks
* [`component-hook-factories`](https://react.dev/reference/eslint-plugin-react-hooks/lints/component-hook-factories) - Validates higher order functions defining nested components or hooks
* [`config`](https://react.dev/reference/eslint-plugin-react-hooks/lints/config) - Validates the compiler configuration options
* [`error-boundaries`](https://react.dev/reference/eslint-plugin-react-hooks/lints/error-boundaries) - Validates usage of Error Boundaries instead of try/catch for child errors
* [`gating`](https://react.dev/reference/eslint-plugin-react-hooks/lints/gating) - Validates configuration of gating mode
* [`globals`](https://react.dev/reference/eslint-plugin-react-hooks/lints/globals) - Validates against assignment/mutation of globals during render
* [`immutability`](https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability) - Validates against mutating props, state, and other immutable values
* [`incompatible-library`](https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library) - Validates against usage of libraries which are incompatible with memoization
* [`preserve-manual-memoization`](https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization) - Validates that existing manual memoization is preserved by the compiler
* [`purity`](https://react.dev/reference/eslint-plugin-react-hooks/lints/purity) - Validates that components/hooks are pure by checking known-impure functions
* [`refs`](https://react.dev/reference/eslint-plugin-react-hooks/lints/refs) - Validates correct usage of refs, not reading/writing during render
* [`set-state-in-effect`](https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect) - Validates against calling setState synchronously in an effect
* [`set-state-in-render`](https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render) - Validates against setting state during render
* [`static-components`](https://react.dev/reference/eslint-plugin-react-hooks/lints/static-components) - Validates that components are static, not recreated every render
* [`unsupported-syntax`](https://react.dev/reference/eslint-plugin-react-hooks/lints/unsupported-syntax) - Validates against syntax that React Compiler does not support
* [`use-memo`](https://react.dev/reference/eslint-plugin-react-hooks/lints/use-memo) - Validates usage of the `useMemo` hook without a return value

[Nextexhaustive-deps](https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps)

---

---


# exhaustive-deps – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# exhaustive-deps

Validates that dependency arrays for React hooks contain all necessary dependencies.

## Rule Details

React hooks like `useEffect`, `useMemo`, and `useCallback` accept dependency arrays. When a value referenced inside these hooks isn’t included in the dependency array, React won’t re-run the effect or recalculate the value when that dependency changes. This causes stale closures where the hook uses outdated values.

## Common Violations

This error often happens when you try to “trick” React about dependencies to control when an effect runs. Effects should synchronize your component with external systems. The dependency array tells React which values the effect uses, so React knows when to re-synchronize.

If you find yourself fighting with the linter, you likely need to restructure your code. See [Removing Effect Dependencies](https://react.dev/learn/removing-effect-dependencies) to learn how.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Missing dependency

useEffect(() => {

console.log(count);

}, []); // Missing 'count'

// ❌ Missing prop

useEffect(() => {

fetchUser(userId);

}, []); // Missing 'userId'

// ❌ Incomplete dependencies

useMemo(() => {

return items.sort(sortOrder);

}, [items]); // Missing 'sortOrder'
```

### Valid

Examples of correct code for this rule:

```
// ✅ All dependencies included

useEffect(() => {

console.log(count);

}, [count]);

// ✅ All dependencies included

useEffect(() => {

fetchUser(userId);

}, [userId]);
```

## Troubleshooting

### Adding a function dependency causes infinite loops

You have an effect, but you’re creating a new function on every render:

```
// ❌ Causes infinite loop

const logItems = () => {

console.log(items);

};

useEffect(() => {

logItems();

}, [logItems]); // Infinite loop!
```

In most cases, you don’t need the effect. Call the function where the action happens instead:

```
// ✅ Call it from the event handler

const logItems = () => {

console.log(items);

};

return <button onClick={logItems}>Log</button>;

// ✅ Or derive during render if there's no side effect

items.forEach(item => {

console.log(item);

});
```

If you genuinely need the effect (for example, to subscribe to something external), make the dependency stable:

```
// ✅ useCallback keeps the function reference stable

const logItems = useCallback(() => {

console.log(items);

}, [items]);

useEffect(() => {

logItems();

}, [logItems]);

// ✅ Or move the logic straight into the effect

useEffect(() => {

console.log(items);

}, [items]);
```

### Running an effect only once

You want to run an effect once on mount, but the linter complains about missing dependencies:

```
// ❌ Missing dependency

useEffect(() => {

sendAnalytics(userId);

}, []); // Missing 'userId'
```

Either include the dependency (recommended) or use a ref if you truly need to run once:

```
// ✅ Include dependency

useEffect(() => {

sendAnalytics(userId);

}, [userId]);

// ✅ Or use a ref guard inside an effect

const sent = useRef(false);

useEffect(() => {

if (sent.current) {

return;

}

sent.current = true;

sendAnalytics(userId);

}, [userId]);
```

## Options

You can configure custom effect hooks using shared ESLint settings (available in `eslint-plugin-react-hooks` 6.1.1 and later):

```
{

"settings": {

"react-hooks": {

"additionalEffectHooks": "(useMyEffect|useCustomEffect)"

}

}

}
```

* `additionalEffectHooks`: Regex pattern matching custom hooks that should be checked for exhaustive dependencies. This configuration is shared across all `react-hooks` rules.

For backward compatibility, this rule also accepts a rule-level option:

```
{

"rules": {

"react-hooks/exhaustive-deps": ["warn", {

"additionalHooks": "(useMyCustomHook|useAnotherHook)"

}]

}

}
```

* `additionalHooks`: Regex for hooks that should be checked for exhaustive dependencies. **Note:** If this rule-level option is specified, it takes precedence over the shared `settings` configuration.

[PreviousLints](https://react.dev/reference/eslint-plugin-react-hooks)[Nextrules-of-hooks](https://react.dev/reference/eslint-plugin-react-hooks/lints/rules-of-hooks)

---

---


# rules-of-hooks – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/rules-of-hooks

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# rules-of-hooks

Validates that components and hooks follow the [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks).

## Rule Details

React relies on the order in which hooks are called to correctly preserve state between renders. Each time your component renders, React expects the exact same hooks to be called in the exact same order. When hooks are called conditionally or in loops, React loses track of which state corresponds to which hook call, leading to bugs like state mismatches and “Rendered fewer/more hooks than expected” errors.

## Common Violations

These patterns violate the Rules of Hooks:

* **Hooks in conditions** (`if`/`else`, ternary, `&&`/`||`)
* **Hooks in loops** (`for`, `while`, `do-while`)
* **Hooks after early returns**
* **Hooks in callbacks/event handlers**
* **Hooks in async functions**
* **Hooks in class methods**
* **Hooks at module level**

### Note

### `use` hook

The `use` hook is different from other React hooks. You can call it conditionally and in loops:

```
// ✅ `use` can be conditional

if (shouldFetch) {

const data = use(fetchPromise);

}

// ✅ `use` can be in loops

for (const promise of promises) {

results.push(use(promise));

}
```

However, `use` still has restrictions:

* Can’t be wrapped in try/catch
* Must be called inside a component or hook

Learn more: [`use` API Reference](https://react.dev/reference/react/use)

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Hook in condition

if (isLoggedIn) {

const [user, setUser] = useState(null);

}

// ❌ Hook after early return

if (!data) return <Loading />;

const [processed, setProcessed] = useState(data);

// ❌ Hook in callback

<button onClick={() => {

const [clicked, setClicked] = useState(false);

}}/>

// ❌ `use` in try/catch

try {

const data = use(promise);

} catch (e) {

// error handling

}

// ❌ Hook at module level

const globalState = useState(0); // Outside component
```

### Valid

Examples of correct code for this rule:

```
function Component({ isSpecial, shouldFetch, fetchPromise }) {

// ✅ Hooks at top level

const [count, setCount] = useState(0);

const [name, setName] = useState('');

if (!isSpecial) {

return null;

}

if (shouldFetch) {

// ✅ `use` can be conditional

const data = use(fetchPromise);

return <div>{data}</div>;

}

return <div>{name}: {count}</div>;

}
```

## Troubleshooting

### I want to fetch data based on some condition

You’re trying to conditionally call useEffect:

```
// ❌ Conditional hook

if (isLoggedIn) {

useEffect(() => {

fetchUserData();

}, []);

}
```

Call the hook unconditionally, check condition inside:

```
// ✅ Condition inside hook

useEffect(() => {

if (isLoggedIn) {

fetchUserData();

}

}, [isLoggedIn]);
```

### Note

There are better ways to fetch data rather than in a useEffect. Consider using TanStack Query, useSWR, or React Router 6.4+ for data fetching. These solutions handle deduplicating requests, caching responses, and avoiding network waterfalls.

Learn more: [Fetching Data](https://react.dev/learn/synchronizing-with-effects#fetching-data)

### I need different state for different scenarios

You’re trying to conditionally initialize state:

```
// ❌ Conditional state

if (userType === 'admin') {

const [permissions, setPermissions] = useState(adminPerms);

} else {

const [permissions, setPermissions] = useState(userPerms);

}
```

Always call useState, conditionally set the initial value:

```
// ✅ Conditional initial value

const [permissions, setPermissions] = useState(

userType === 'admin' ? adminPerms : userPerms

);
```

## Options

You can configure custom effect hooks using shared ESLint settings (available in `eslint-plugin-react-hooks` 6.1.1 and later):

```
{

"settings": {

"react-hooks": {

"additionalEffectHooks": "(useMyEffect|useCustomEffect)"

}

}

}
```

* `additionalEffectHooks`: Regex pattern matching custom hooks that should be treated as effects. This allows `useEffectEvent` and similar event functions to be called from your custom effect hooks.

This shared configuration is used by both `rules-of-hooks` and `exhaustive-deps` rules, ensuring consistent behavior across all hook-related linting.

[Previousexhaustive-deps](https://react.dev/reference/eslint-plugin-react-hooks/lints/exhaustive-deps)[Nextcomponent-hook-factories](https://react.dev/reference/eslint-plugin-react-hooks/lints/component-hook-factories)

---

---


# component-hook-factories – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/component-hook-factories

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# component-hook-factories

Validates against higher order functions defining nested components or hooks. Components and hooks should be defined at the module level.

## Rule Details

Defining components or hooks inside other functions creates new instances on every call. React treats each as a completely different component, destroying and recreating the entire component tree, losing all state, and causing performance problems.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Factory function creating components

function createComponent(defaultValue) {

return function Component() {

// ...

};

}

// ❌ Component defined inside component

function Parent() {

function Child() {

// ...

}

return <Child />;

}

// ❌ Hook factory function

function createCustomHook(endpoint) {

return function useData() {

// ...

};

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ Component defined at module level

function Component({ defaultValue }) {

// ...

}

// ✅ Custom hook at module level

function useData(endpoint) {

// ...

}
```

## Troubleshooting

### I need dynamic component behavior

You might think you need a factory to create customized components:

```
// ❌ Wrong: Factory pattern

function makeButton(color) {

return function Button({children}) {

return (

<button style={{backgroundColor: color}}>

{children}

</button>

);

};

}

const RedButton = makeButton('red');

const BlueButton = makeButton('blue');
```

Pass [JSX as children](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) instead:

```
// ✅ Better: Pass JSX as children

function Button({color, children}) {

return (

<button style={{backgroundColor: color}}>

{children}

</button>

);

}

function App() {

return (

<>

<Button color="red">Red</Button>

<Button color="blue">Blue</Button>

</>

);

}
```

[Previousrules-of-hooks](https://react.dev/reference/eslint-plugin-react-hooks/lints/rules-of-hooks)[Nextconfig](https://react.dev/reference/eslint-plugin-react-hooks/lints/config)

---

---


# config – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/config

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# config

Validates the compiler [configuration options](https://react.dev/reference/react-compiler/configuration).

## Rule Details

React Compiler accepts various [configuration options](https://react.dev/reference/react-compiler/configuration) to control its behavior. This rule validates that your configuration uses correct option names and value types, preventing silent failures from typos or incorrect settings.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Unknown option name

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

compileMode: 'all' // Typo: should be compilationMode

}]

]

};

// ❌ Invalid option value

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

compilationMode: 'everything' // Invalid: use 'all' or 'infer'

}]

]

};
```

### Valid

Examples of correct code for this rule:

```
// ✅ Valid compiler configuration

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

compilationMode: 'infer',

panicThreshold: 'critical_errors'

}]

]

};
```

## Troubleshooting

### Configuration not working as expected

Your compiler configuration might have typos or incorrect values:

```
// ❌ Wrong: Common configuration mistakes

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

// Typo in option name

compilationMod: 'all',

// Wrong value type

panicThreshold: true,

// Unknown option

optimizationLevel: 'max'

}]

]

};
```

Check the [configuration documentation](https://react.dev/reference/react-compiler/configuration) for valid options:

```
// ✅ Better: Valid configuration

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

compilationMode: 'all', // or 'infer'

panicThreshold: 'none', // or 'critical_errors', 'all_errors'

// Only use documented options

}]

]

};
```

[Previouscomponent-hook-factories](https://react.dev/reference/eslint-plugin-react-hooks/lints/component-hook-factories)[Nexterror-boundaries](https://react.dev/reference/eslint-plugin-react-hooks/lints/error-boundaries)

---

---


# error-boundaries – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/error-boundaries

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# error-boundaries

Validates usage of Error Boundaries instead of try/catch for errors in child components.

## Rule Details

Try/catch blocks can’t catch errors that happen during React’s rendering process. Errors thrown in rendering methods or hooks bubble up through the component tree. Only [Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary) can catch these errors.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Try/catch won't catch render errors

function Parent() {

try {

return <ChildComponent />; // If this throws, catch won't help

} catch (error) {

return <div>Error occurred</div>;

}

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ Using error boundary

function Parent() {

return (

<ErrorBoundary>

<ChildComponent />

</ErrorBoundary>

);

}
```

## Troubleshooting

### Why is the linter telling me not to wrap `use` in `try`/`catch`?

The `use` hook doesn’t throw errors in the traditional sense, it suspends component execution. When `use` encounters a pending promise, it suspends the component and lets React show a fallback. Only Suspense and Error Boundaries can handle these cases. The linter warns against `try`/`catch` around `use` to prevent confusion as the `catch` block would never run.

```
// ❌ Try/catch around `use` hook

function Component({promise}) {

try {

const data = use(promise); // Won't catch - `use` suspends, not throws

return <div>{data}</div>;

} catch (error) {

return <div>Failed to load</div>; // Unreachable

}

}

// ✅ Error boundary catches `use` errors

function App() {

return (

<ErrorBoundary fallback={<div>Failed to load</div>}>

<Suspense fallback={<div>Loading...</div>}>

<DataComponent promise={fetchData()} />

</Suspense>

</ErrorBoundary>

);

}
```

[Previousconfig](https://react.dev/reference/eslint-plugin-react-hooks/lints/config)[Nextgating](https://react.dev/reference/eslint-plugin-react-hooks/lints/gating)

---

---


# gating – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/gating

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# gating

Validates configuration of [gating mode](https://react.dev/reference/react-compiler/gating).

## Rule Details

Gating mode lets you gradually adopt React Compiler by marking specific components for optimization. This rule ensures your gating configuration is valid so the compiler knows which components to process.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Missing required fields

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

gating: {

importSpecifierName: '__experimental_useCompiler'

// Missing 'source' field

}

}]

]

};

// ❌ Invalid gating type

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

gating: '__experimental_useCompiler' // Should be object

}]

]

};
```

### Valid

Examples of correct code for this rule:

```
// ✅ Complete gating configuration

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

gating: {

importSpecifierName: 'isCompilerEnabled', // exported function name

source: 'featureFlags' // module name

}

}]

]

};

// featureFlags.js

export function isCompilerEnabled() {

// ...

}

// ✅ No gating (compile everything)

module.exports = {

plugins: [

['babel-plugin-react-compiler', {

// No gating field - compiles all components

}]

]

};
```

[Previouserror-boundaries](https://react.dev/reference/eslint-plugin-react-hooks/lints/error-boundaries)[Nextglobals](https://react.dev/reference/eslint-plugin-react-hooks/lints/globals)

---

---


# globals – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/globals

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# globals

Validates against assignment/mutation of globals during render, part of ensuring that [side effects must run outside of render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render).

## Rule Details

Global variables exist outside React’s control. When you modify them during render, you break React’s assumption that rendering is pure. This can cause components to behave differently in development vs production, break Fast Refresh, and make your app impossible to optimize with features like React Compiler.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Global counter

let renderCount = 0;

function Component() {

renderCount++; // Mutating global

return <div>Count: {renderCount}</div>;

}

// ❌ Modifying window properties

function Component({userId}) {

window.currentUser = userId; // Global mutation

return <div>User: {userId}</div>;

}

// ❌ Global array push

const events = [];

function Component({event}) {

events.push(event); // Mutating global array

return <div>Events: {events.length}</div>;

}

// ❌ Cache manipulation

const cache = {};

function Component({id}) {

if (!cache[id]) {

cache[id] = fetchData(id); // Modifying cache during render

}

return <div>{cache[id]}</div>;

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ Use state for counters

function Component() {

const [clickCount, setClickCount] = useState(0);

const handleClick = () => {

setClickCount(c => c + 1);

};

return (

<button onClick={handleClick}>

Clicked: {clickCount} times

</button>

);

}

// ✅ Use context for global values

function Component() {

const user = useContext(UserContext);

return <div>User: {user.id}</div>;

}

// ✅ Synchronize external state with React

function Component({title}) {

useEffect(() => {

document.title = title; // OK in effect

}, [title]);

return <div>Page: {title}</div>;

}
```

[Previousgating](https://react.dev/reference/eslint-plugin-react-hooks/lints/gating)[Nextimmutability](https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability)

---

---


# immutability – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# immutability

Validates against mutating props, state, and other values that [are immutable](https://react.dev/reference/rules/components-and-hooks-must-be-pure#props-and-state-are-immutable).

## Rule Details

A component’s props and state are immutable snapshots. Never mutate them directly. Instead, pass new props down, and use the setter function from `useState`.

## Common Violations

### Invalid

```
// ❌ Array push mutation

function Component() {

const [items, setItems] = useState([1, 2, 3]);

const addItem = () => {

items.push(4); // Mutating!

setItems(items); // Same reference, no re-render

};

}

// ❌ Object property assignment

function Component() {

const [user, setUser] = useState({name: 'Alice'});

const updateName = () => {

user.name = 'Bob'; // Mutating!

setUser(user); // Same reference

};

}

// ❌ Sort without spreading

function Component() {

const [items, setItems] = useState([3, 1, 2]);

const sortItems = () => {

setItems(items.sort()); // sort mutates!

};

}
```

### Valid

```
// ✅ Create new array

function Component() {

const [items, setItems] = useState([1, 2, 3]);

const addItem = () => {

setItems([...items, 4]); // New array

};

}

// ✅ Create new object

function Component() {

const [user, setUser] = useState({name: 'Alice'});

const updateName = () => {

setUser({...user, name: 'Bob'}); // New object

};

}
```

## Troubleshooting

### I need to add items to an array

Mutating arrays with methods like `push()` won’t trigger re-renders:

```
// ❌ Wrong: Mutating the array

function TodoList() {

const [todos, setTodos] = useState([]);

const addTodo = (id, text) => {

todos.push({id, text});

setTodos(todos); // Same array reference!

};

return (

<ul>

{todos.map(todo => <li key={todo.id}>{todo.text}</li>)}

</ul>

);

}
```

Create a new array instead:

```
// ✅ Better: Create a new array

function TodoList() {

const [todos, setTodos] = useState([]);

const addTodo = (id, text) => {

setTodos([...todos, {id, text}]);

// Or: setTodos(todos => [...todos, {id: Date.now(), text}])

};

return (

<ul>

{todos.map(todo => <li key={todo.id}>{todo.text}</li>)}

</ul>

);

}
```

### I need to update nested objects

Mutating nested properties doesn’t trigger re-renders:

```
// ❌ Wrong: Mutating nested object

function UserProfile() {

const [user, setUser] = useState({

name: 'Alice',

settings: {

theme: 'light',

notifications: true

}

});

const toggleTheme = () => {

user.settings.theme = 'dark'; // Mutation!

setUser(user); // Same object reference

};

}
```

Spread at each level that needs updating:

```
// ✅ Better: Create new objects at each level

function UserProfile() {

const [user, setUser] = useState({

name: 'Alice',

settings: {

theme: 'light',

notifications: true

}

});

const toggleTheme = () => {

setUser({

...user,

settings: {

...user.settings,

theme: 'dark'

}

});

};

}
```

[Previousglobals](https://react.dev/reference/eslint-plugin-react-hooks/lints/globals)[Nextincompatible-library](https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library)

---

---


# incompatible-library – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# incompatible-library

Validates against usage of libraries which are incompatible with memoization (manual or automatic).

### Note

These libraries were designed before React’s memoization rules were fully documented. They made the correct choices at the time to optimize for ergonomic ways to keep components just the right amount of reactive as app state changes. While these legacy patterns worked, we have since discovered that it’s incompatible with React’s programming model. We will continue working with library authors to migrate these libraries to use patterns that follow the Rules of React.

## Rule Details

Some libraries use patterns that aren’t supported by React. When the linter detects usages of these APIs from a [known list](https://github.com/facebook/react/blob/main/compiler/packages/babel-plugin-react-compiler/src/HIR/DefaultModuleTypeProvider.ts), it flags them under this rule. This means that React Compiler can automatically skip over components that use these incompatible APIs, in order to avoid breaking your app.

```
// Example of how memoization breaks with these libraries

function Form() {

const { watch } = useForm();

// ❌ This value will never update, even when 'name' field changes

const name = useMemo(() => watch('name'), [watch]);

return <div>Name: {name}</div>; // UI appears "frozen"

}
```

React Compiler automatically memoizes values following the Rules of React. If something breaks with manual `useMemo`, it will also break the compiler’s automatic optimization. This rule helps identify these problematic patterns.

##### Deep Dive

#### Designing APIs that follow the Rules of React

Show Details

One question to think about when designing a library API or hook is whether calling the API can be safely memoized with `useMemo`. If it can’t, then both manual and React Compiler memoizations will break your user’s code.

For example, one such incompatible pattern is “interior mutability”. Interior mutability is when an object or function keeps its own hidden state that changes over time, even though the reference to it stays the same. Think of it like a box that looks the same on the outside but secretly rearranges its contents. React can’t tell anything changed because it only checks if you gave it a different box, not what’s inside. This breaks memoization, since React relies on the outer object (or function) changing if part of its value has changed.

As a rule of thumb, when designing React APIs, think about whether `useMemo` would break it:

```
function Component() {

const { someFunction } = useLibrary();

// it should always be safe to memoize functions like this

const result = useMemo(() => someFunction(), [someFunction]);

}
```

Instead, design APIs that return immutable state and use explicit update functions:

```
// ✅ Good: Return immutable state that changes reference when updated

function Component() {

const { field, updateField } = useLibrary();

// this is always safe to memo

const greeting = useMemo(() => `Hello, ${field.name}!`, [field.name]);

return (

<div>

<input

value={field.name}

onChange={(e) => updateField('name', e.target.value)}

/>

<p>{greeting}</p>

</div>

);

}
```

### Invalid

Examples of incorrect code for this rule:

```
// ❌ react-hook-form `watch`

function Component() {

const {watch} = useForm();

const value = watch('field'); // Interior mutability

return <div>{value}</div>;

}

// ❌ TanStack Table `useReactTable`

function Component({data}) {

const table = useReactTable({

data,

columns,

getCoreRowModel: getCoreRowModel(),

});

// table instance uses interior mutability

return <Table table={table} />;

}
```

### Pitfall

#### MobX

MobX patterns like `observer` also break memoization assumptions, but the linter does not yet detect them. If you rely on MobX and find that your app doesn’t work with React Compiler, you may need to use the `"use no memo" directive`.

```
// ❌ MobX `observer`

const Component = observer(() => {

const [timer] = useState(() => new Timer());

return <span>Seconds passed: {timer.secondsPassed}</span>;

});
```

### Valid

Examples of correct code for this rule:

```
// ✅ For react-hook-form, use `useWatch`:

function Component() {

const {register, control} = useForm();

const watchedValue = useWatch({

control,

name: 'field'

});

return (

<>

<input {...register('field')} />

<div>Current value: {watchedValue}</div>

</>

);

}
```

Some other libraries do not yet have alternative APIs that are compatible with React’s memoization model. If the linter doesn’t automatically skip over your components or hooks that call these APIs, please [file an issue](https://github.com/facebook/react/issues) so we can add it to the linter.

[Previousimmutability](https://react.dev/reference/eslint-plugin-react-hooks/lints/immutability)[Nextpreserve-manual-memoization](https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization)

---

---


# preserve-manual-memoization – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# preserve-manual-memoization

Validates that existing manual memoization is preserved by the compiler. React Compiler will only compile components and hooks if its inference [matches or exceeds the existing manual memoization](https://react.dev/learn/react-compiler/introduction#what-should-i-do-about-usememo-usecallback-and-reactmemo).

## Rule Details

React Compiler preserves your existing `useMemo`, `useCallback`, and `React.memo` calls. If you’ve manually memoized something, the compiler assumes you had a good reason and won’t remove it. However, incomplete dependencies prevent the compiler from understanding your code’s data flow and applying further optimizations.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Missing dependencies in useMemo

function Component({ data, filter }) {

const filtered = useMemo(

() => data.filter(filter),

[data] // Missing 'filter' dependency

);

return <List items={filtered} />;

}

// ❌ Missing dependencies in useCallback

function Component({ onUpdate, value }) {

const handleClick = useCallback(() => {

onUpdate(value);

}, [onUpdate]); // Missing 'value'

return <button onClick={handleClick}>Update</button>;

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ Complete dependencies

function Component({ data, filter }) {

const filtered = useMemo(

() => data.filter(filter),

[data, filter] // All dependencies included

);

return <List items={filtered} />;

}

// ✅ Or let the compiler handle it

function Component({ data, filter }) {

// No manual memoization needed

const filtered = data.filter(filter);

return <List items={filtered} />;

}
```

## Troubleshooting

### Should I remove my manual memoization?

You might wonder if React Compiler makes manual memoization unnecessary:

```
// Do I still need this?

function Component({items, sortBy}) {

const sorted = useMemo(() => {

return [...items].sort((a, b) => {

return a[sortBy] - b[sortBy];

});

}, [items, sortBy]);

return <List items={sorted} />;

}
```

You can safely remove it if using React Compiler:

```
// ✅ Better: Let the compiler optimize

function Component({items, sortBy}) {

const sorted = [...items].sort((a, b) => {

return a[sortBy] - b[sortBy];

});

return <List items={sorted} />;

}
```

[Previousincompatible-library](https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library)[Nextpurity](https://react.dev/reference/eslint-plugin-react-hooks/lints/purity)

---

---


# purity – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/purity

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# purity

Validates that [components/hooks are pure](https://react.dev/reference/rules/components-and-hooks-must-be-pure) by checking that they do not call known-impure functions.

## Rule Details

React components must be pure functions - given the same props, they should always return the same JSX. When components use functions like `Math.random()` or `Date.now()` during render, they produce different output each time, breaking React’s assumptions and causing bugs like hydration mismatches, incorrect memoization, and unpredictable behavior.

## Common Violations

In general, any API that returns a different value for the same inputs violates this rule. Usual examples include:

* `Math.random()`
* `Date.now()` / `new Date()`
* `crypto.randomUUID()`
* `performance.now()`

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Math.random() in render

function Component() {

const id = Math.random(); // Different every render

return <div key={id}>Content</div>;

}

// ❌ Date.now() for values

function Component() {

const timestamp = Date.now(); // Changes every render

return <div>Created at: {timestamp}</div>;

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ Stable IDs from initial state

function Component() {

const [id] = useState(() => crypto.randomUUID());

return <div key={id}>Content</div>;

}
```

## Troubleshooting

### I need to show the current time

Calling `Date.now()` during render makes your component impure:

```
// ❌ Wrong: Time changes every render

function Clock() {

return <div>Current time: {Date.now()}</div>;

}
```

Instead, [move the impure function outside of render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent):

```
function Clock() {

const [time, setTime] = useState(() => Date.now());

useEffect(() => {

const interval = setInterval(() => {

setTime(Date.now());

}, 1000);

return () => clearInterval(interval);

}, []);

return <div>Current time: {time}</div>;

}
```

[Previouspreserve-manual-memoization](https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization)[Nextrefs](https://react.dev/reference/eslint-plugin-react-hooks/lints/refs)

---

---


# refs – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/refs

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# refs

Validates correct usage of refs, not reading/writing during render. See the “pitfalls” section in [`useRef()` usage](https://react.dev/reference/react/useRef#usage).

## Rule Details

Refs hold values that aren’t used for rendering. Unlike state, changing a ref doesn’t trigger a re-render. Reading or writing `ref.current` during render breaks React’s expectations. Refs might not be initialized when you try to read them, and their values can be stale or inconsistent.

## How It Detects Refs

The lint only applies these rules to values it knows are refs. A value is inferred as a ref when the compiler sees any of the following patterns:

* Returned from `useRef()` or `React.createRef()`.

  ```
  const scrollRef = useRef(null);
  ```
* An identifier named `ref` or ending in `Ref` that reads from or writes to `.current`.

  ```
  buttonRef.current = node;
  ```
* Passed through a JSX `ref` prop (for example `<div ref={someRef} />`).

  ```
  <input ref={inputRef} />
  ```

Once something is marked as a ref, that inference follows the value through assignments, destructuring, or helper calls. This lets the lint surface violations even when `ref.current` is accessed inside another function that received the ref as an argument.

## Common Violations

* Reading `ref.current` during render
* Updating `refs` during render
* Using `refs` for values that should be state

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Reading ref during render

function Component() {

const ref = useRef(0);

const value = ref.current; // Don't read during render

return <div>{value}</div>;

}

// ❌ Modifying ref during render

function Component({value}) {

const ref = useRef(null);

ref.current = value; // Don't modify during render

return <div />;

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ Read ref in effects/handlers

function Component() {

const ref = useRef(null);

useEffect(() => {

if (ref.current) {

console.log(ref.current.offsetWidth); // OK in effect

}

});

return <div ref={ref} />;

}

// ✅ Use state for UI values

function Component() {

const [count, setCount] = useState(0);

return (

<button onClick={() => setCount(count + 1)}>

{count}

</button>

);

}

// ✅ Lazy initialization of ref value

function Component() {

const ref = useRef(null);

// Initialize only once on first use

if (ref.current === null) {

ref.current = expensiveComputation(); // OK - lazy initialization

}

const handleClick = () => {

console.log(ref.current); // Use the initialized value

};

return <button onClick={handleClick}>Click</button>;

}
```

## Troubleshooting

### The lint flagged my plain object with `.current`

The name heuristic intentionally treats `ref.current` and `fooRef.current` as real refs. If you’re modeling a custom container object, pick a different name (for example, `box`) or move the mutable value into state. Renaming avoids the lint because the compiler stops inferring it as a ref.

[Previouspurity](https://react.dev/reference/eslint-plugin-react-hooks/lints/purity)[Nextset-state-in-effect](https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect)

---

---


# set-state-in-effect – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# set-state-in-effect

Validates against calling setState synchronously in an effect, which can lead to re-renders that degrade performance.

## Rule Details

Setting state immediately inside an effect forces React to restart the entire render cycle. When you update state in an effect, React must re-render your component, apply changes to the DOM, and then run effects again. This creates an extra render pass that could have been avoided by transforming data directly during render or deriving state from props. Transform data at the top level of your component instead. This code will naturally re-run when props or state change without triggering additional render cycles.

Synchronous `setState` calls in effects trigger immediate re-renders before the browser can paint, causing performance issues and visual jank. React has to render twice: once to apply the state update, then again after effects run. This double rendering is wasteful when the same result could be achieved with a single render.

In many cases, you may also not need an effect at all. Please see [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect) for more information.

## Common Violations

This rule catches several patterns where synchronous setState is used unnecessarily:

* Setting loading state synchronously
* Deriving state from props in effects
* Transforming data in effects instead of render

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Synchronous setState in effect

function Component({data}) {

const [items, setItems] = useState([]);

useEffect(() => {

setItems(data); // Extra render, use initial state instead

}, [data]);

}

// ❌ Setting loading state synchronously

function Component() {

const [loading, setLoading] = useState(false);

useEffect(() => {

setLoading(true); // Synchronous, causes extra render

fetchData().then(() => setLoading(false));

}, []);

}

// ❌ Transforming data in effect

function Component({rawData}) {

const [processed, setProcessed] = useState([]);

useEffect(() => {

setProcessed(rawData.map(transform)); // Should derive in render

}, [rawData]);

}

// ❌ Deriving state from props

function Component({selectedId, items}) {

const [selected, setSelected] = useState(null);

useEffect(() => {

setSelected(items.find(i => i.id === selectedId));

}, [selectedId, items]);

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ setState in an effect is fine if the value comes from a ref

function Tooltip() {

const ref = useRef(null);

const [tooltipHeight, setTooltipHeight] = useState(0);

useLayoutEffect(() => {

const { height } = ref.current.getBoundingClientRect();

setTooltipHeight(height);

}, []);

}

// ✅ Calculate during render

function Component({selectedId, items}) {

const selected = items.find(i => i.id === selectedId);

return <div>{selected?.name}</div>;

}
```

**When something can be calculated from the existing props or state, don’t put it in state.** Instead, calculate it during rendering. This makes your code faster, simpler, and less error-prone. Learn more in [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect).

[Previousrefs](https://react.dev/reference/eslint-plugin-react-hooks/lints/refs)[Nextset-state-in-render](https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render)

---

---


# set-state-in-render – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# set-state-in-render

Validates against unconditionally setting state during render, which can trigger additional renders and potential infinite render loops.

## Rule Details

Calling `setState` during render unconditionally triggers another render before the current one finishes. This creates an infinite loop that crashes your app.

## Common Violations

### Invalid

```
// ❌ Unconditional setState directly in render

function Component({value}) {

const [count, setCount] = useState(0);

setCount(value); // Infinite loop!

return <div>{count}</div>;

}
```

### Valid

```
// ✅ Derive during render

function Component({items}) {

const sorted = [...items].sort(); // Just calculate it in render

return <ul>{sorted.map(/*...*/)}</ul>;

}

// ✅ Set state in event handler

function Component() {

const [count, setCount] = useState(0);

return (

<button onClick={() => setCount(count + 1)}>

{count}

</button>

);

}

// ✅ Derive from props instead of setting state

function Component({user}) {

const name = user?.name || '';

const email = user?.email || '';

return <div>{name}</div>;

}

// ✅ Conditionally derive state from props and state from previous renders

function Component({ items }) {

const [isReverse, setIsReverse] = useState(false);

const [selection, setSelection] = useState(null);

const [prevItems, setPrevItems] = useState(items);

if (items !== prevItems) { // This condition makes it valid

setPrevItems(items);

setSelection(null);

}

// ...

}
```

## Troubleshooting

### I want to sync state to a prop

A common problem is trying to “fix” state after it renders. Suppose you want to keep a counter from exceeding a `max` prop:

```
// ❌ Wrong: clamps during render

function Counter({max}) {

const [count, setCount] = useState(0);

if (count > max) {

setCount(max);

}

return (

<button onClick={() => setCount(count + 1)}>

{count}

</button>

);

}
```

As soon as `count` exceeds `max`, an infinite loop is triggered.

Instead, it’s often better to move this logic to the event (the place where the state is first set). For example, you can enforce the maximum at the moment you update state:

```
// ✅ Clamp when updating

function Counter({max}) {

const [count, setCount] = useState(0);

const increment = () => {

setCount(current => Math.min(current + 1, max));

};

return <button onClick={increment}>{count}</button>;

}
```

Now the setter only runs in response to the click, React finishes the render normally, and `count` never crosses `max`.

In rare cases, you may need to adjust state based on information from previous renders. For those, follow [this pattern](https://react.dev/reference/react/useState#storing-information-from-previous-renders) of setting state conditionally.

[Previousset-state-in-effect](https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-effect)[Nextstatic-components](https://react.dev/reference/eslint-plugin-react-hooks/lints/static-components)

---

---


# static-components – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/static-components

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# static-components

Validates that components are static, not recreated every render. Components that are recreated dynamically can reset state and trigger excessive re-rendering.

## Rule Details

Components defined inside other components are recreated on every render. React sees each as a brand new component type, unmounting the old one and mounting the new one, destroying all state and DOM nodes in the process.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Component defined inside component

function Parent() {

const ChildComponent = () => { // New component every render!

const [count, setCount] = useState(0);

return <button onClick={() => setCount(count + 1)}>{count}</button>;

};

return <ChildComponent />; // State resets every render

}

// ❌ Dynamic component creation

function Parent({type}) {

const Component = type === 'button'

? () => <button>Click</button>

: () => <div>Text</div>;

return <Component />;

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ Components at module level

const ButtonComponent = () => <button>Click</button>;

const TextComponent = () => <div>Text</div>;

function Parent({type}) {

const Component = type === 'button'

? ButtonComponent  // Reference existing component

: TextComponent;

return <Component />;

}
```

## Troubleshooting

### I need to render different components conditionally

You might define components inside to access local state:

```
// ❌ Wrong: Inner component to access parent state

function Parent() {

const [theme, setTheme] = useState('light');

function ThemedButton() { // Recreated every render!

return (

<button className={theme}>

Click me

</button>

);

}

return <ThemedButton />;

}
```

Pass data as props instead:

```
// ✅ Better: Pass props to static component

function ThemedButton({theme}) {

return (

<button className={theme}>

Click me

</button>

);

}

function Parent() {

const [theme, setTheme] = useState('light');

return <ThemedButton theme={theme} />;

}
```

### Note

If you find yourself wanting to define components inside other components to access local variables, that’s a sign you should be passing props instead. This makes components more reusable and testable.

[Previousset-state-in-render](https://react.dev/reference/eslint-plugin-react-hooks/lints/set-state-in-render)[Nextunsupported-syntax](https://react.dev/reference/eslint-plugin-react-hooks/lints/unsupported-syntax)

---

---


# unsupported-syntax – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/unsupported-syntax

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# unsupported-syntax

Validates against syntax that React Compiler does not support. If you need to, you can still use this syntax outside of React, such as in a standalone utility function.

## Rule Details

React Compiler needs to statically analyze your code to apply optimizations. Features like `eval` and `with` make it impossible to statically understand what the code does at compile time, so the compiler can’t optimize components that use them.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ Using eval in component

function Component({ code }) {

const result = eval(code); // Can't be analyzed

return <div>{result}</div>;

}

// ❌ Using with statement

function Component() {

with (Math) { // Changes scope dynamically

return <div>{sin(PI / 2)}</div>;

}

}

// ❌ Dynamic property access with eval

function Component({propName}) {

const value = eval(`props.${propName}`);

return <div>{value}</div>;

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ Use normal property access

function Component({propName, props}) {

const value = props[propName]; // Analyzable

return <div>{value}</div>;

}

// ✅ Use standard Math methods

function Component() {

return <div>{Math.sin(Math.PI / 2)}</div>;

}
```

## Troubleshooting

### I need to evaluate dynamic code

You might need to evaluate user-provided code:

```
// ❌ Wrong: eval in component

function Calculator({expression}) {

const result = eval(expression); // Unsafe and unoptimizable

return <div>Result: {result}</div>;

}
```

Use a safe expression parser instead:

```
// ✅ Better: Use a safe parser

import {evaluate} from 'mathjs'; // or similar library

function Calculator({expression}) {

const [result, setResult] = useState(null);

const calculate = () => {

try {

// Safe mathematical expression evaluation

setResult(evaluate(expression));

} catch (error) {

setResult('Invalid expression');

}

};

return (

<div>

<button onClick={calculate}>Calculate</button>

{result && <div>Result: {result}</div>}

</div>

);

}
```

### Note

Never use `eval` with user input - it’s a security risk. Use dedicated parsing libraries for specific use cases like mathematical expressions, JSON parsing, or template evaluation.

[Previousstatic-components](https://react.dev/reference/eslint-plugin-react-hooks/lints/static-components)[Nextuse-memo](https://react.dev/reference/eslint-plugin-react-hooks/lints/use-memo)

---

---


# use-memo – React

URL: https://react.dev/reference/eslint-plugin-react-hooks/lints/use-memo

[API Reference](https://react.dev/reference/react)

[Lints](https://react.dev/reference/eslint-plugin-react-hooks)

# use-memo

Validates that the `useMemo` hook is used with a return value. See [`useMemo` docs](https://react.dev/reference/react/useMemo) for more information.

## Rule Details

`useMemo` is for computing and caching expensive values, not for side effects. Without a return value, `useMemo` returns `undefined`, which defeats its purpose and likely indicates you’re using the wrong hook.

### Invalid

Examples of incorrect code for this rule:

```
// ❌ No return value

function Component({ data }) {

const processed = useMemo(() => {

data.forEach(item => console.log(item));

// Missing return!

}, [data]);

return <div>{processed}</div>; // Always undefined

}
```

### Valid

Examples of correct code for this rule:

```
// ✅ Returns computed value

function Component({ data }) {

const processed = useMemo(() => {

return data.map(item => item * 2);

}, [data]);

return <div>{processed}</div>;

}
```

## Troubleshooting

### I need to run side effects when dependencies change

You might try to use `useMemo` for side effects:

```
// ❌ Wrong: Side effects in useMemo

function Component({user}) {

// No return value, just side effect

useMemo(() => {

analytics.track('UserViewed', {userId: user.id});

}, [user.id]);

// Not assigned to a variable

useMemo(() => {

return analytics.track('UserViewed', {userId: user.id});

}, [user.id]);

}
```

If the side effect needs to happen in response to user interaction, it’s best to colocate the side effect with the event:

```
// ✅ Good: Side effects in event handlers

function Component({user}) {

const handleClick = () => {

analytics.track('ButtonClicked', {userId: user.id});

// Other click logic...

};

return <button onClick={handleClick}>Click me</button>;

}
```

If the side effect sychronizes React state with some external state (or vice versa), use `useEffect`:

```
// ✅ Good: Synchronization in useEffect

function Component({theme}) {

useEffect(() => {

localStorage.setItem('preferredTheme', theme);

document.body.className = theme;

}, [theme]);

return <div>Current theme: {theme}</div>;

}
```

[Previousunsupported-syntax](https://react.dev/reference/eslint-plugin-react-hooks/lints/unsupported-syntax)

---

---


# Rules of React – React

URL: https://react.dev/reference/rules

[API Reference](https://react.dev/reference/react)

# Rules of React

Just as different programming languages have their own ways of expressing concepts, React has its own idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications.

* [Components and Hooks must be pure](https://react.dev/reference/rules#components-and-hooks-must-be-pure)
* [React calls Components and Hooks](https://react.dev/reference/rules#react-calls-components-and-hooks)
* [Rules of Hooks](https://react.dev/reference/rules#rules-of-hooks)

---

### Note

To learn more about expressing UIs with React, we recommend reading [Thinking in React](https://react.dev/learn/thinking-in-react).

This section describes the rules you need to follow to write idiomatic React code. Writing idiomatic React code can help you write well organized, safe, and composable applications. These properties make your app more resilient to changes and makes it easier to work with other developers, libraries, and tools.

These rules are known as the **Rules of React**. They are rules – and not just guidelines – in the sense that if they are broken, your app likely has bugs. Your code also becomes unidiomatic and harder to understand and reason about.

We strongly recommend using [Strict Mode](https://react.dev/reference/react/StrictMode) alongside React’s [ESLint plugin](https://www.npmjs.com/package/eslint-plugin-react-hooks) to help your codebase follow the Rules of React. By following the Rules of React, you’ll be able to find and address these bugs and keep your application maintainable.

---

## Components and Hooks must be pure

[Purity in Components and Hooks](https://react.dev/reference/rules/components-and-hooks-must-be-pure) is a key rule of React that makes your app predictable, easy to debug, and allows React to automatically optimize your code.

* [Components must be idempotent](https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent) – React components are assumed to always return the same output with respect to their inputs – props, state, and context.
* [Side effects must run outside of render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) – Side effects should not run in render, as React can render components multiple times to create the best possible user experience.
* [Props and state are immutable](https://react.dev/reference/rules/components-and-hooks-must-be-pure#props-and-state-are-immutable) – A component’s props and state are immutable snapshots with respect to a single render. Never mutate them directly.
* [Return values and arguments to Hooks are immutable](https://react.dev/reference/rules/components-and-hooks-must-be-pure#return-values-and-arguments-to-hooks-are-immutable) – Once values are passed to a Hook, you should not modify them. Like props in JSX, values become immutable when passed to a Hook.
* [Values are immutable after being passed to JSX](https://react.dev/reference/rules/components-and-hooks-must-be-pure#values-are-immutable-after-being-passed-to-jsx) – Don’t mutate values after they’ve been used in JSX. Move the mutation before the JSX is created.

---

## React calls Components and Hooks

[React is responsible for rendering components and hooks when necessary to optimize the user experience.](https://react.dev/reference/rules/react-calls-components-and-hooks) It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user.

* [Never call component functions directly](https://react.dev/reference/rules/react-calls-components-and-hooks#never-call-component-functions-directly) – Components should only be used in JSX. Don’t call them as regular functions.
* [Never pass around hooks as regular values](https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values) – Hooks should only be called inside of components. Never pass it around as a regular value.

---

## Rules of Hooks

Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. You need to follow the [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks) when using them.

* [Only call Hooks at the top level](https://react.dev/reference/rules/rules-of-hooks#only-call-hooks-at-the-top-level) – Don’t call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function, before any early returns.
* [Only call Hooks from React functions](https://react.dev/reference/rules/rules-of-hooks#only-call-hooks-from-react-functions) – Don’t call Hooks from regular JavaScript functions.

[NextComponents and Hooks must be pure](https://react.dev/reference/rules/components-and-hooks-must-be-pure)

---

---


# Components and Hooks must be pure – React

URL: https://react.dev/reference/rules/components-and-hooks-must-be-pure

[API Reference](https://react.dev/reference/react)

[Overview](https://react.dev/reference/rules)

# Components and Hooks must be pure

Pure functions only perform a calculation and nothing more. It makes your code easier to understand, debug, and allows React to automatically optimize your components and Hooks correctly.

### Note

This reference page covers advanced topics and requires familiarity with the concepts covered in the [Keeping Components Pure](https://react.dev/learn/keeping-components-pure) page.

* [Why does purity matter?](https://react.dev/reference/rules/components-and-hooks-must-be-pure#why-does-purity-matter)
* [Components and Hooks must be idempotent](https://react.dev/reference/rules/components-and-hooks-must-be-pure#components-and-hooks-must-be-idempotent)
* [Side effects must run outside of render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#side-effects-must-run-outside-of-render) 
  + [When is it okay to have mutation?](https://react.dev/reference/rules/components-and-hooks-must-be-pure#mutation)
* [Props and state are immutable](https://react.dev/reference/rules/components-and-hooks-must-be-pure#props-and-state-are-immutable) 
  + [Don’t mutate Props](https://react.dev/reference/rules/components-and-hooks-must-be-pure#props)
  + [Don’t mutate State](https://react.dev/reference/rules/components-and-hooks-must-be-pure#state)
* [Return values and arguments to Hooks are immutable](https://react.dev/reference/rules/components-and-hooks-must-be-pure#return-values-and-arguments-to-hooks-are-immutable)
* [Values are immutable after being passed to JSX](https://react.dev/reference/rules/components-and-hooks-must-be-pure#values-are-immutable-after-being-passed-to-jsx)

### Why does purity matter?

One of the key concepts that makes React, *React* is *purity*. A pure component or hook is one that is:

* **Idempotent** – You [always get the same result every time](https://react.dev/learn/keeping-components-pure#purity-components-as-formulas) you run it with the same inputs – props, state, context for component inputs; and arguments for hook inputs.
* **Has no side effects in render** – Code with side effects should run [**separately from rendering**](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code). For example as an [event handler](https://react.dev/learn/responding-to-events) – where the user interacts with the UI and causes it to update; or as an [Effect](https://react.dev/reference/react/useEffect) – which runs after render.
* **Does not mutate non-local values**: Components and Hooks should [never modify values that aren’t created locally](https://react.dev/reference/rules/components-and-hooks-must-be-pure#mutation) in render.

When render is kept pure, React can understand how to prioritize which updates are most important for the user to see first. This is made possible because of render purity: since components don’t have side effects [in render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code), React can pause rendering components that aren’t as important to update, and only come back to them later when it’s needed.

Concretely, this means that rendering logic can be run multiple times in a way that allows React to give your user a pleasant user experience. However, if your component has an untracked side effect – like modifying the value of a global variable [during render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code) – when React runs your rendering code again, your side effects will be triggered in a way that won’t match what you want. This often leads to unexpected bugs that can degrade how your users experience your app. You can see an [example of this in the Keeping Components Pure page](https://react.dev/learn/keeping-components-pure#side-effects-unintended-consequences).

#### How does React run your code?

React is declarative: you tell React *what* to render, and React will figure out *how* best to display it to your user. To do this, React has a few phases where it runs your code. You don’t need to know about all of these phases to use React well. But at a high level, you should know about what code runs in *render*, and what runs outside of it.

*Rendering* refers to calculating what the next version of your UI should look like. After rendering, [Effects](https://react.dev/reference/react/useEffect) are *flushed* (meaning they are run until there are no more left) and may update the calculation if the Effects have impacts on layout. React takes this new calculation and compares it to the calculation used to create the previous version of your UI, then *commits* just the minimum changes needed to the [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model) (what your user actually sees) to catch it up to the latest version.

##### Deep Dive

#### How to tell if code runs in render

Show Details

One quick heuristic to tell if code runs during render is to examine where it is: if it’s written at the top level like in the example below, there’s a good chance it runs during render.

```
function Dropdown() {

const selectedItems = new Set(); // created during render

// ...

}
```

Event handlers and Effects don’t run in render:

```
function Dropdown() {

const selectedItems = new Set();

const onSelect = (item) => {

// this code is in an event handler, so it's only run when the user triggers this

selectedItems.add(item);

}

}
```

```
function Dropdown() {

const selectedItems = new Set();

useEffect(() => {

// this code is inside of an Effect, so it only runs after rendering

logForAnalytics(selectedItems);

}, [selectedItems]);

}
```

---

## Components and Hooks must be idempotent

Components must always return the same output with respect to their inputs – props, state, and context. This is known as *idempotency*. [Idempotency](https://en.wikipedia.org/wiki/Idempotence) is a term popularized in functional programming. It refers to the idea that you [always get the same result every time](https://react.dev/learn/keeping-components-pure) you run that piece of code with the same inputs.

This means that *all* code that runs [during render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code) must also be idempotent in order for this rule to hold. For example, this line of code is not idempotent (and therefore, neither is the component):

```
function Clock() {

const time = new Date(); // 🔴 Bad: always returns a different result!

return <span>{time.toLocaleString()}</span>

}
```

`new Date()` is not idempotent as it always returns the current date and changes its result every time it’s called. When you render the above component, the time displayed on the screen will stay stuck on the time that the component was rendered. Similarly, functions like `Math.random()` also aren’t idempotent, because they return different results every time they’re called, even when the inputs are the same.

This doesn’t mean you shouldn’t use non-idempotent functions like `new Date()` *at all* – you should just avoid using them [during render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code). In this case, we can *synchronize* the latest date to this component using an [Effect](https://react.dev/reference/react/useEffect):

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';

function useTime() {
  // 1. Keep track of the current date's state. `useState` receives an initializer function as its
  //    initial state. It only runs once when the hook is called, so only the current date at the
  //    time the hook is called is set first.
  const [time, setTime] = useState(() => new Date());

  useEffect(() => {
    // 2. Update the current date every second using `setInterval`.
    const id = setInterval(() => {
      setTime(new Date()); // ✅ Good: non-idempotent code no longer runs in render
    }, 1000);
    // 3. Return a cleanup function so we don't leak the `setInterval` timer.
    return () => clearInterval(id);
  }, []);

  return time;
}

export default function Clock() {
  const time = useTime();
  return <span>{time.toLocaleString()}</span>;
}
```

Show more

By wrapping the non-idempotent `new Date()` call in an Effect, it moves that calculation [outside of rendering](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code).

If you don’t need to synchronize some external state with React, you can also consider using an [event handler](https://react.dev/learn/responding-to-events) if it only needs to be updated in response to a user interaction.

---

## Side effects must run outside of render

[Side effects](https://react.dev/learn/keeping-components-pure#side-effects-unintended-consequences) should not run [in render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code), as React can render components multiple times to create the best possible user experience.

### Note

Side effects are a broader term than Effects. Effects specifically refer to code that’s wrapped in `useEffect`, while a side effect is a general term for code that has any observable effect other than its primary result of returning a value to the caller.

Side effects are typically written inside of [event handlers](https://react.dev/learn/responding-to-events) or Effects. But never during render.

While render must be kept pure, side effects are necessary at some point in order for your app to do anything interesting, like showing something on the screen! The key point of this rule is that side effects should not run [in render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code), as React can render components multiple times. In most cases, you’ll use [event handlers](https://react.dev/learn/responding-to-events) to handle side effects. Using an event handler explicitly tells React that this code doesn’t need to run during render, keeping render pure. If you’ve exhausted all options – and only as a last resort – you can also handle side effects using `useEffect`.

### When is it okay to have mutation?

#### Local mutation

One common example of a side effect is mutation, which in JavaScript refers to changing the value of a non-[primitive](https://developer.mozilla.org/en-US/docs/Glossary/Primitive) value. In general, while mutation is not idiomatic in React, *local* mutation is absolutely fine:

```
function FriendList({ friends }) {

const items = []; // ✅ Good: locally created

for (let i = 0; i < friends.length; i++) {

const friend = friends[i];

items.push(

<Friend key={friend.id} friend={friend} />

); // ✅ Good: local mutation is okay

}

return <section>{items}</section>;

}
```

There is no need to contort your code to avoid local mutation. [`Array.map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) could also be used here for brevity, but there is nothing wrong with creating a local array and then pushing items into it [during render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code).

Even though it looks like we are mutating `items`, the key point to note is that this code only does so *locally* – the mutation isn’t “remembered” when the component is rendered again. In other words, `items` only stays around as long as the component does. Because `items` is always *recreated* every time `<FriendList />` is rendered, the component will always return the same result.

On the other hand, if `items` was created outside of the component, it holds on to its previous values and remembers changes:

```
const items = []; // 🔴 Bad: created outside of the component

function FriendList({ friends }) {

for (let i = 0; i < friends.length; i++) {

const friend = friends[i];

items.push(

<Friend key={friend.id} friend={friend} />

); // 🔴 Bad: mutates a value created outside of render

}

return <section>{items}</section>;

}
```

When `<FriendList />` runs again, we will continue appending `friends` to `items` every time that component is run, leading to multiple duplicated results. This version of `<FriendList />` has observable side effects [during render](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code) and **breaks the rule**.

#### Lazy initialization

Lazy initialization is also fine despite not being fully “pure”:

```
function ExpenseForm() {

SuperCalculator.initializeIfNotReady(); // ✅ Good: if it doesn't affect other components

// Continue rendering...

}
```

#### Changing the DOM

Side effects that are directly visible to the user are not allowed in the render logic of React components. In other words, merely calling a component function shouldn’t by itself produce a change on the screen.

```
function ProductDetailPage({ product }) {

document.title = product.title; // 🔴 Bad: Changes the DOM

}
```

One way to achieve the desired result of updating `document.title` outside of render is to [synchronize the component with `document`](https://react.dev/learn/synchronizing-with-effects).

As long as calling a component multiple times is safe and doesn’t affect the rendering of other components, React doesn’t care if it’s 100% pure in the strict functional programming sense of the word. It is more important that [components must be idempotent](https://react.dev/reference/rules/components-and-hooks-must-be-pure).

---

## Props and state are immutable

A component’s props and state are immutable [snapshots](https://react.dev/learn/state-as-a-snapshot). Never mutate them directly. Instead, pass new props down, and use the setter function from `useState`.

You can think of the props and state values as snapshots that are updated after rendering. For this reason, you don’t modify the props or state variables directly: instead you pass new props, or use the setter function provided to you to tell React that state needs to update the next time the component is rendered.

### Don’t mutate Props

Props are immutable because if you mutate them, the application will produce inconsistent output, which can be hard to debug as it may or may not work depending on the circumstances.

```
function Post({ item }) {

item.url = new Url(item.url, base); // 🔴 Bad: never mutate props directly

return <Link url={item.url}>{item.title}</Link>;

}
```

```
function Post({ item }) {

const url = new Url(item.url, base); // ✅ Good: make a copy instead

return <Link url={url}>{item.title}</Link>;

}
```

### Don’t mutate State

`useState` returns the state variable and a setter to update that state.

```
const [stateVariable, setter] = useState(0);
```

Rather than updating the state variable in-place, we need to update it using the setter function that is returned by `useState`. Changing values on the state variable doesn’t cause the component to update, leaving your users with an outdated UI. Using the setter function informs React that the state has changed, and that we need to queue a re-render to update the UI.

```
function Counter() {

const [count, setCount] = useState(0);

function handleClick() {

count = count + 1; // 🔴 Bad: never mutate state directly

}

return (

<button onClick={handleClick}>

You pressed me {count} times

</button>

);

}
```

```
function Counter() {

const [count, setCount] = useState(0);

function handleClick() {

setCount(count + 1); // ✅ Good: use the setter function returned by useState

}

return (

<button onClick={handleClick}>

You pressed me {count} times

</button>

);

}
```

---

## Return values and arguments to Hooks are immutable

Once values are passed to a hook, you should not modify them. Like props in JSX, values become immutable when passed to a hook.

```
function useIconStyle(icon) {

const theme = useContext(ThemeContext);

if (icon.enabled) {

icon.className = computeStyle(icon, theme); // 🔴 Bad: never mutate hook arguments directly

}

return icon;

}
```

```
function useIconStyle(icon) {

const theme = useContext(ThemeContext);

const newIcon = { ...icon }; // ✅ Good: make a copy instead

if (icon.enabled) {

newIcon.className = computeStyle(icon, theme);

}

return newIcon;

}
```

One important principle in React is *local reasoning*: the ability to understand what a component or hook does by looking at its code in isolation. Hooks should be treated like “black boxes” when they are called. For example, a custom hook might have used its arguments as dependencies to memoize values inside it:

```
function useIconStyle(icon) {

const theme = useContext(ThemeContext);

return useMemo(() => {

const newIcon = { ...icon };

if (icon.enabled) {

newIcon.className = computeStyle(icon, theme);

}

return newIcon;

}, [icon, theme]);

}
```

If you were to mutate the Hook’s arguments, the custom hook’s memoization will become incorrect, so it’s important to avoid doing that.

```
style = useIconStyle(icon);         // `style` is memoized based on `icon`

icon.enabled = false;               // Bad: 🔴 never mutate hook arguments directly

style = useIconStyle(icon);         // previously memoized result is returned
```

```
style = useIconStyle(icon);         // `style` is memoized based on `icon`

icon = { ...icon, enabled: false }; // Good: ✅ make a copy instead

style = useIconStyle(icon);         // new value of `style` is calculated
```

Similarly, it’s important to not modify the return values of Hooks, as they may have been memoized.

---

## Values are immutable after being passed to JSX

Don’t mutate values after they’ve been used in JSX. Move the mutation to before the JSX is created.

When you use JSX in an expression, React may eagerly evaluate the JSX before the component finishes rendering. This means that mutating values after they’ve been passed to JSX can lead to outdated UIs, as React won’t know to update the component’s output.

```
function Page({ colour }) {

const styles = { colour, size: "large" };

const header = <Header styles={styles} />;

styles.size = "small"; // 🔴 Bad: styles was already used in the JSX above

const footer = <Footer styles={styles} />;

return (

<>

{header}

<Content />

{footer}

</>

);

}
```

```
function Page({ colour }) {

const headerStyles = { colour, size: "large" };

const header = <Header styles={headerStyles} />;

const footerStyles = { colour, size: "small" }; // ✅ Good: we created a new value

const footer = <Footer styles={footerStyles} />;

return (

<>

{header}

<Content />

{footer}

</>

);

}
```

[PreviousOverview](https://react.dev/reference/rules)[NextReact calls Components and Hooks](https://react.dev/reference/rules/react-calls-components-and-hooks)

---

---


# React calls Components and Hooks – React

URL: https://react.dev/reference/rules/react-calls-components-and-hooks

[API Reference](https://react.dev/reference/react)

[Overview](https://react.dev/reference/rules)

# React calls Components and Hooks

React is responsible for rendering components and Hooks when necessary to optimize the user experience. It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user.

* [Never call component functions directly](https://react.dev/reference/rules/react-calls-components-and-hooks#never-call-component-functions-directly)
* [Never pass around Hooks as regular values](https://react.dev/reference/rules/react-calls-components-and-hooks#never-pass-around-hooks-as-regular-values) 
  + [Don’t dynamically mutate a Hook](https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-mutate-a-hook)
  + [Don’t dynamically use Hooks](https://react.dev/reference/rules/react-calls-components-and-hooks#dont-dynamically-use-hooks)

---

## Never call component functions directly

Components should only be used in JSX. Don’t call them as regular functions. React should call it.

React must decide when your component function is called [during rendering](https://react.dev/reference/rules/components-and-hooks-must-be-pure#how-does-react-run-your-code). In React, you do this using JSX.

```
function BlogPost() {

return <Layout><Article /></Layout>; // ✅ Good: Only use components in JSX

}
```

```
function BlogPost() {

return <Layout>{Article()}</Layout>; // 🔴 Bad: Never call them directly

}
```

If a component contains Hooks, it’s easy to violate the [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks) when components are called directly in a loop or conditionally.

Letting React orchestrate rendering also allows a number of benefits:

* **Components become more than functions.** React can augment them with features like *local state* through Hooks that are tied to the component’s identity in the tree.
* **Component types participate in reconciliation.** By letting React call your components, you also tell it more about the conceptual structure of your tree. For example, when you move from rendering `<Feed>` to the `<Profile>` page, React won’t attempt to re-use them.
* **React can enhance your user experience.** For example, it can let the browser do some work between component calls so that re-rendering a large component tree doesn’t block the main thread.
* **A better debugging story.** If components are first-class citizens that the library is aware of, we can build rich developer tools for introspection in development.
* **More efficient reconciliation.** React can decide exactly which components in the tree need re-rendering and skip over the ones that don’t. That makes your app faster and more snappy.

---

## Never pass around Hooks as regular values

Hooks should only be called inside of components or Hooks. Never pass it around as a regular value.

Hooks allow you to augment a component with React features. They should always be called as a function, and never passed around as a regular value. This enables *local reasoning*, or the ability for developers to understand everything a component can do by looking at that component in isolation.

Breaking this rule will cause React to not automatically optimize your component.

### Don’t dynamically mutate a Hook

Hooks should be as “static” as possible. This means you shouldn’t dynamically mutate them. For example, this means you shouldn’t write higher order Hooks:

```
function ChatInput() {

const useDataWithLogging = withLogging(useData); // 🔴 Bad: don't write higher order Hooks

const data = useDataWithLogging();

}
```

Hooks should be immutable and not be mutated. Instead of mutating a Hook dynamically, create a static version of the Hook with the desired functionality.

```
function ChatInput() {

const data = useDataWithLogging(); // ✅ Good: Create a new version of the Hook

}

function useDataWithLogging() {

// ... Create a new version of the Hook and inline the logic here

}
```

### Don’t dynamically use Hooks

Hooks should also not be dynamically used: for example, instead of doing dependency injection in a component by passing a Hook as a value:

```
function ChatInput() {

return <Button useData={useDataWithLogging} /> // 🔴 Bad: don't pass Hooks as props

}
```

You should always inline the call of the Hook into that component and handle any logic in there.

```
function ChatInput() {

return <Button />

}

function Button() {

const data = useDataWithLogging(); // ✅ Good: Use the Hook directly

}

function useDataWithLogging() {

// If there's any conditional logic to change the Hook's behavior, it should be inlined into

// the Hook

}
```

This way, `<Button />` is much easier to understand and debug. When Hooks are used in dynamic ways, it increases the complexity of your app greatly and inhibits local reasoning, making your team less productive in the long term. It also makes it easier to accidentally break the [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks) that Hooks should not be called conditionally. If you find yourself needing to mock components for tests, it’s better to mock the server instead to respond with canned data. If possible, it’s also usually more effective to test your app with end-to-end tests.

[PreviousComponents and Hooks must be pure](https://react.dev/reference/rules/components-and-hooks-must-be-pure)[NextRules of Hooks](https://react.dev/reference/rules/rules-of-hooks)

---

---


# Rules of Hooks – React

URL: https://react.dev/reference/rules/rules-of-hooks

[API Reference](https://react.dev/reference/react)

[Overview](https://react.dev/reference/rules)

# Rules of Hooks

Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.

* [Only call Hooks at the top level](https://react.dev/reference/rules/rules-of-hooks#only-call-hooks-at-the-top-level)
* [Only call Hooks from React functions](https://react.dev/reference/rules/rules-of-hooks#only-call-hooks-from-react-functions)

---

## Only call Hooks at the top level

Functions whose names start with `use` are called [*Hooks*](https://react.dev/reference/react) in React.

**Don’t call Hooks inside loops, conditions, nested functions, or `try`/`catch`/`finally` blocks.** Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component:

* ✅ Call them at the top level in the body of a [function component](https://react.dev/learn/your-first-component).
* ✅ Call them at the top level in the body of a [custom Hook](https://react.dev/learn/reusing-logic-with-custom-hooks).

```
function Counter() {

// ✅ Good: top-level in a function component

const [count, setCount] = useState(0);

// ...

}

function useWindowWidth() {

// ✅ Good: top-level in a custom Hook

const [width, setWidth] = useState(window.innerWidth);

// ...

}
```

It’s **not** supported to call Hooks (functions starting with `use`) in any other cases, for example:

* 🔴 Do not call Hooks inside conditions or loops.
* 🔴 Do not call Hooks after a conditional `return` statement.
* 🔴 Do not call Hooks in event handlers.
* 🔴 Do not call Hooks in class components.
* 🔴 Do not call Hooks inside functions passed to `useMemo`, `useReducer`, or `useEffect`.
* 🔴 Do not call Hooks inside `try`/`catch`/`finally` blocks.

If you break these rules, you might see this error.

```
function Bad({ cond }) {

if (cond) {

// 🔴 Bad: inside a condition (to fix, move it outside!)

const theme = useContext(ThemeContext);

}

// ...

}

function Bad() {

for (let i = 0; i < 10; i++) {

// 🔴 Bad: inside a loop (to fix, move it outside!)

const theme = useContext(ThemeContext);

}

// ...

}

function Bad({ cond }) {

if (cond) {

return;

}

// 🔴 Bad: after a conditional return (to fix, move it before the return!)

const theme = useContext(ThemeContext);

// ...

}

function Bad() {

function handleClick() {

// 🔴 Bad: inside an event handler (to fix, move it outside!)

const theme = useContext(ThemeContext);

}

// ...

}

function Bad() {

const style = useMemo(() => {

// 🔴 Bad: inside useMemo (to fix, move it outside!)

const theme = useContext(ThemeContext);

return createStyle(theme);

});

// ...

}

class Bad extends React.Component {

render() {

// 🔴 Bad: inside a class component (to fix, write a function component instead of a class!)

useEffect(() => {})

// ...

}

}

function Bad() {

try {

// 🔴 Bad: inside try/catch/finally block (to fix, move it outside!)

const [x, setX] = useState(0);

} catch {

const [x, setX] = useState(1);

}

}
```

You can use the [`eslint-plugin-react-hooks` plugin](https://www.npmjs.com/package/eslint-plugin-react-hooks) to catch these mistakes.

### Note

[Custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks) *may* call other Hooks (that’s their whole purpose). This works because custom Hooks are also supposed to only be called while a function component is rendering.

---

## Only call Hooks from React functions

Don’t call Hooks from regular JavaScript functions. Instead, you can:

✅ Call Hooks from React function components.
✅ Call Hooks from [custom Hooks](https://react.dev/learn/reusing-logic-with-custom-hooks#extracting-your-own-custom-hook-from-a-component).

By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.

```
function FriendList() {

const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ✅

}

function setOnlineStatus() { // ❌ Not a component or custom Hook!

const [onlineStatus, setOnlineStatus] = useOnlineStatus();

}
```

[PreviousReact calls Components and Hooks](https://react.dev/reference/rules/react-calls-components-and-hooks)

---

---


# Server Components – React

URL: https://react.dev/reference/rsc/server-components

[API Reference](https://react.dev/reference/react)

# Server Components

Server Components are a new type of Component that renders ahead of time, before bundling, in an environment separate from your client app or SSR server.

This separate environment is the “server” in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server.

* [Server Components without a Server](https://react.dev/reference/rsc/server-components#server-components-without-a-server)
* [Server Components with a Server](https://react.dev/reference/rsc/server-components#server-components-with-a-server)
* [Adding interactivity to Server Components](https://react.dev/reference/rsc/server-components#adding-interactivity-to-server-components)
* [Async components with Server Components](https://react.dev/reference/rsc/server-components#async-components-with-server-components)

### Note

#### How do I build support for Server Components?

While React Server Components in React 19 are stable and will not break between minor versions, the underlying APIs used to implement a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x.

To support React Server Components as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement React Server Components in the future.

### Server Components without a Server

Server components can run at build time to read from the filesystem or fetch static content, so a web server is not required. For example, you may want to read static data from a content management system.

Without Server Components, it’s common to fetch static data on the client with an Effect:

```
// bundle.js

import marked from 'marked'; // 35.9K (11.2K gzipped)

import sanitizeHtml from 'sanitize-html'; // 206K (63.3K gzipped)

function Page({page}) {

const [content, setContent] = useState('');

// NOTE: loads *after* first page render.

useEffect(() => {

fetch(`/api/content/${page}`).then((data) => {

setContent(data.content);

});

}, [page]);

return <div>{sanitizeHtml(marked(content))}</div>;

}
```

```
// api.js

app.get(`/api/content/:page`, async (req, res) => {

const page = req.params.page;

const content = await file.readFile(`${page}.md`);

res.send({content});

});
```

This pattern means users need to download and parse an additional 75K (gzipped) of libraries, and wait for a second request to fetch the data after the page loads, just to render static content that will not change for the lifetime of the page.

With Server Components, you can render these components once at build time:

```
import marked from 'marked'; // Not included in bundle

import sanitizeHtml from 'sanitize-html'; // Not included in bundle

async function Page({page}) {

// NOTE: loads *during* render, when the app is built.

const content = await file.readFile(`${page}.md`);

return <div>{sanitizeHtml(marked(content))}</div>;

}
```

The rendered output can then be server-side rendered (SSR) to HTML and uploaded to a CDN. When the app loads, the client will not see the original `Page` component, or the expensive libraries for rendering the markdown. The client will only see the rendered output:

```
<div><!-- html for markdown --></div>
```

This means the content is visible during first page load, and the bundle does not include the expensive libraries needed to render the static content.

### Note

You may notice that the Server Component above is an async function:

```
async function Page({page}) {

//...

}
```

Async Components are a new feature of Server Components that allow you to `await` in render.

See [Async components with Server Components](https://react.dev/reference/rsc/server-components#async-components-with-server-components) below.

### Server Components with a Server

Server Components can also run on a web server during a request for a page, letting you access your data layer without having to build an API. They are rendered before your application is bundled, and can pass data and JSX as props to Client Components.

Without Server Components, it’s common to fetch dynamic data on the client in an Effect:

```
// bundle.js

function Note({id}) {

const [note, setNote] = useState('');

// NOTE: loads *after* first render.

useEffect(() => {

fetch(`/api/notes/${id}`).then(data => {

setNote(data.note);

});

}, [id]);

return (

<div>

<Author id={note.authorId} />

<p>{note}</p>

</div>

);

}

function Author({id}) {

const [author, setAuthor] = useState('');

// NOTE: loads *after* Note renders.

// Causing an expensive client-server waterfall.

useEffect(() => {

fetch(`/api/authors/${id}`).then(data => {

setAuthor(data.author);

});

}, [id]);

return <span>By: {author.name}</span>;

}
```

```
// api

import db from './database';

app.get(`/api/notes/:id`, async (req, res) => {

const note = await db.notes.get(id);

res.send({note});

});

app.get(`/api/authors/:id`, async (req, res) => {

const author = await db.authors.get(id);

res.send({author});

});
```

With Server Components, you can read the data and render it in the component:

```
import db from './database';

async function Note({id}) {

// NOTE: loads *during* render.

const note = await db.notes.get(id);

return (

<div>

<Author id={note.authorId} />

<p>{note}</p>

</div>

);

}

async function Author({id}) {

// NOTE: loads *after* Note,

// but is fast if data is co-located.

const author = await db.authors.get(id);

return <span>By: {author.name}</span>;

}
```

The bundler then combines the data, rendered Server Components and dynamic Client Components into a bundle. Optionally, that bundle can then be server-side rendered (SSR) to create the initial HTML for the page. When the page loads, the browser does not see the original `Note` and `Author` components; only the rendered output is sent to the client:

```
<div>

<span>By: The React Team</span>

<p>React 19 is...</p>

</div>
```

Server Components can be made dynamic by re-fetching them from a server, where they can access the data and render again. This new application architecture combines the simple “request/response” mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds.

### Adding interactivity to Server Components

Server Components are not sent to the browser, so they cannot use interactive APIs like `useState`. To add interactivity to Server Components, you can compose them with Client Component using the `"use client"` directive.

### Note

#### There is no directive for Server Components.

A common misunderstanding is that Server Components are denoted by `"use server"`, but there is no directive for Server Components. The `"use server"` directive is used for Server Functions.

For more info, see the docs for [Directives](https://react.dev/reference/rsc/directives).

In the following example, the `Notes` Server Component imports an `Expandable` Client Component that uses state to toggle its `expanded` state:

```
// Server Component

import Expandable from './Expandable';

async function Notes() {

const notes = await db.notes.getAll();

return (

<div>

{notes.map(note => (

<Expandable key={note.id}>

<p note={note} />

</Expandable>

))}

</div>

)

}
```

```
// Client Component

"use client"

export default function Expandable({children}) {

const [expanded, setExpanded] = useState(false);

return (

<div>

<button

onClick={() => setExpanded(!expanded)}

>

Toggle

</button>

{expanded && children}

</div>

)

}
```

This works by first rendering `Notes` as a Server Component, and then instructing the bundler to create a bundle for the Client Component `Expandable`. In the browser, the Client Components will see output of the Server Components passed as props:

```
<head>

<!-- the bundle for Client Components -->

<script src="bundle.js" />

</head>

<body>

<div>

<Expandable key={1}>

<p>this is the first note</p>

</Expandable>

<Expandable key={2}>

<p>this is the second note</p>

</Expandable>

<!--...-->

</div>

</body>
```

### Async components with Server Components

Server Components introduce a new way to write Components using async/await. When you `await` in an async component, React will suspend and wait for the promise to resolve before resuming rendering. This works across server/client boundaries with streaming support for Suspense.

You can even create a promise on the server, and await it on the client:

```
// Server Component

import db from './database';

async function Page({id}) {

// Will suspend the Server Component.

const note = await db.notes.get(id);

// NOTE: not awaited, will start here and await on the client.

const commentsPromise = db.comments.get(note.id);

return (

<div>

{note}

<Suspense fallback={<p>Loading Comments...</p>}>

<Comments commentsPromise={commentsPromise} />

</Suspense>

</div>

);

}
```

```
// Client Component

"use client";

import {use} from 'react';

function Comments({commentsPromise}) {

// NOTE: this will resume the promise from the server.

// It will suspend until the data is available.

const comments = use(commentsPromise);

return comments.map(comment => <p>{comment}</p>);

}
```

The `note` content is important data for the page to render, so we `await` it on the server. The comments are below the fold and lower-priority, so we start the promise on the server, and wait for it on the client with the `use` API. This will Suspend on the client, without blocking the `note` content from rendering.

Since async components are not supported on the client, we await the promise with `use`.

[NextServer Functions](https://react.dev/reference/rsc/server-functions)

---

---


# Server Functions – React

URL: https://react.dev/reference/rsc/server-functions

[API Reference](https://react.dev/reference/react)

# Server Functions

### React Server Components

Server Functions are for use in [React Server Components](https://react.dev/reference/rsc/server-components).

**Note:** Until September 2024, we referred to all Server Functions as “Server Actions”. If a Server Function is passed to an action prop or called from inside an action then it is a Server Action, but not all Server Functions are Server Actions. The naming in this documentation has been updated to reflect that Server Functions can be used for multiple purposes.

Server Functions allow Client Components to call async functions executed on the server.

### Note

#### How do I build support for Server Functions?

While Server Functions in React 19 are stable and will not break between minor versions, the underlying APIs used to implement Server Functions in a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x.

To support Server Functions as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement Server Functions in the future.

When a Server Function is defined with the [`"use server"`](https://react.dev/reference/rsc/use-server) directive, your framework will automatically create a reference to the Server Function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.

Server Functions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.

## Usage

### Creating a Server Function from a Server Component

Server Components can define Server Functions with the `"use server"` directive:

```
// Server Component

import Button from './Button';

function EmptyNote () {

async function createNoteAction() {

// Server Function

'use server';

await db.notes.create();

}

return <Button onClick={createNoteAction}/>;

}
```

When React renders the `EmptyNote` Server Component, it will create a reference to the `createNoteAction` function, and pass that reference to the `Button` Client Component. When the button is clicked, React will send a request to the server to execute the `createNoteAction` function with the reference provided:

```
"use client";

export default function Button({onClick}) {

console.log(onClick);

// {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNoteAction'}

return <button onClick={() => onClick()}>Create Empty Note</button>

}
```

For more, see the docs for [`"use server"`](https://react.dev/reference/rsc/use-server).

### Importing Server Functions from Client Components

Client Components can import Server Functions from files that use the `"use server"` directive:

```
"use server";

export async function createNote() {

await db.notes.create();

}
```

When the bundler builds the `EmptyNote` Client Component, it will create a reference to the `createNote` function in the bundle. When the `button` is clicked, React will send a request to the server to execute the `createNote` function using the reference provided:

```
"use client";

import {createNote} from './actions';

function EmptyNote() {

console.log(createNote);

// {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNote'}

<button onClick={() => createNote()} />

}
```

For more, see the docs for [`"use server"`](https://react.dev/reference/rsc/use-server).

### Server Functions with Actions

Server Functions can be called from Actions on the client:

```
"use server";

export async function updateName(name) {

if (!name) {

return {error: 'Name is required'};

}

await db.users.updateName(name);

}
```

```
"use client";

import {updateName} from './actions';

function UpdateName() {

const [name, setName] = useState('');

const [error, setError] = useState(null);

const [isPending, startTransition] = useTransition();

const submitAction = async () => {

startTransition(async () => {

const {error} = await updateName(name);

if (error) {

setError(error);

} else {

setName('');

}

})

}

return (

<form action={submitAction}>

<input type="text" name="name" disabled={isPending}/>

{error && <span>Failed: {error}</span>}

</form>

)

}
```

This allows you to access the `isPending` state of the Server Function by wrapping it in an Action on the client.

For more, see the docs for [Calling a Server Function outside of `<form>`](https://react.dev/reference/rsc/use-server#calling-a-server-function-outside-of-form)

### Server Functions with Form Actions

Server Functions work with the new Form features in React 19.

You can pass a Server Function to a Form to automatically submit the form to the server:

```
"use client";

import {updateName} from './actions';

function UpdateName() {

return (

<form action={updateName}>

<input type="text" name="name" />

</form>

)

}
```

When the Form submission succeeds, React will automatically reset the form. You can add `useActionState` to access the pending state, last response, or to support progressive enhancement.

For more, see the docs for [Server Functions in Forms](https://react.dev/reference/rsc/use-server#server-functions-in-forms).

### Server Functions with `useActionState`

You can call Server Functions with `useActionState` for the common case where you just need access to the action pending state and last returned response:

```
"use client";

import {updateName} from './actions';

function UpdateName() {

const [state, submitAction, isPending] = useActionState(updateName, {error: null});

return (

<form action={submitAction}>

<input type="text" name="name" disabled={isPending}/>

{state.error && <span>Failed: {state.error}</span>}

</form>

);

}
```

When using `useActionState` with Server Functions, React will also automatically replay form submissions entered before hydration finishes. This means users can interact with your app even before the app has hydrated.

For more, see the docs for [`useActionState`](https://react.dev/reference/react/useActionState).

### Progressive enhancement with `useActionState`

Server Functions also support progressive enhancement with the third argument of `useActionState`.

```
"use client";

import {updateName} from './actions';

function UpdateName() {

const [, submitAction] = useActionState(updateName, null, `/name/update`);

return (

<form action={submitAction}>

...

</form>

);

}
```

When the permalink is provided to `useActionState`, React will redirect to the provided URL if the form is submitted before the JavaScript bundle loads.

For more, see the docs for [`useActionState`](https://react.dev/reference/react/useActionState).

[PreviousServer Components](https://react.dev/reference/rsc/server-components)[NextDirectives](https://react.dev/reference/rsc/directives)

---

---


# Directives – React

URL: https://react.dev/reference/rsc/directives

[API Reference](https://react.dev/reference/react)

# Directives

### React Server Components

Directives are for use in [React Server Components](https://react.dev/reference/rsc/server-components).

Directives provide instructions to [bundlers compatible with React Server Components](https://react.dev/learn/creating-a-react-app#full-stack-frameworks).

---

## Source code directives

* [`'use client'`](https://react.dev/reference/rsc/use-client) lets you mark what code runs on the client.
* [`'use server'`](https://react.dev/reference/rsc/use-server) marks server-side functions that can be called from client-side code.

[PreviousServer Functions](https://react.dev/reference/rsc/server-functions)[Next'use client'](https://react.dev/reference/rsc/use-client)

---

---


# 'use client' directive – React

URL: https://react.dev/reference/rsc/use-client

[API Reference](https://react.dev/reference/react)

[Directives](https://react.dev/reference/rsc/directives)

# 'use client'

### React Server Components

`'use client'` is for use with [React Server Components](https://react.dev/reference/rsc/server-components).

`'use client'` lets you mark what code runs on the client.

* [Reference](https://react.dev/reference/rsc/use-client#reference) 
  + [`'use client'`](https://react.dev/reference/rsc/use-client#use-client)
  + [How `'use client'` marks client code](https://react.dev/reference/rsc/use-client#how-use-client-marks-client-code)
  + [When to use `'use client'`](https://react.dev/reference/rsc/use-client#when-to-use-use-client)
  + [Serializable types returned by Server Components](https://react.dev/reference/rsc/use-client#serializable-types)
* [Usage](https://react.dev/reference/rsc/use-client#usage) 
  + [Building with interactivity and state](https://react.dev/reference/rsc/use-client#building-with-interactivity-and-state)
  + [Using client APIs](https://react.dev/reference/rsc/use-client#using-client-apis)
  + [Using third-party libraries](https://react.dev/reference/rsc/use-client#using-third-party-libraries)

---

## Reference

### `'use client'`

Add `'use client'` at the top of a file to mark the module and its transitive dependencies as client code.

```
'use client';

import { useState } from 'react';

import { formatDate } from './formatters';

import Button from './button';

export default function RichTextEditor({ timestamp, text }) {

const date = formatDate(timestamp);

// ...

const editButton = <Button />;

// ...

}
```

When a file marked with `'use client'` is imported from a Server Component, [compatible bundlers](https://react.dev/learn/creating-a-react-app#full-stack-frameworks) will treat the module import as a boundary between server-run and client-run code.

As dependencies of `RichTextEditor`, `formatDate` and `Button` will also be evaluated on the client regardless of whether their modules contain a `'use client'` directive. Note that a single module may be evaluated on the server when imported from server code and on the client when imported from client code.

#### Caveats

* `'use client'` must be at the very beginning of a file, above any imports or other code (comments are OK). They must be written with single or double quotes, but not backticks.
* When a `'use client'` module is imported from another client-rendered module, the directive has no effect.
* When a component module contains a `'use client'` directive, any usage of that component is guaranteed to be a Client Component. However, a component can still be evaluated on the client even if it does not have a `'use client'` directive.
  + A component usage is considered a Client Component if it is defined in module with `'use client'` directive or when it is a transitive dependency of a module that contains a `'use client'` directive. Otherwise, it is a Server Component.
* Code that is marked for client evaluation is not limited to components. All code that is a part of the Client module sub-tree is sent to and run by the client.
* When a server evaluated module imports values from a `'use client'` module, the values must either be a React component or [supported serializable prop values](https://react.dev/reference/rsc/use-client#passing-props-from-server-to-client-components) to be passed to a Client Component. Any other use case will throw an exception.

### How `'use client'` marks client code

In a React app, components are often split into separate files, or [modules](https://react.dev/learn/importing-and-exporting-components#exporting-and-importing-a-component).

For apps that use React Server Components, the app is server-rendered by default. `'use client'` introduces a server-client boundary in the [module dependency tree](https://react.dev/learn/understanding-your-ui-as-a-tree#the-module-dependency-tree), effectively creating a subtree of Client modules.

To better illustrate this, consider the following React Server Components app.

App.jsFancyText.jsInspirationGenerator.jsCopyright.jsinspirations.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import FancyText from './FancyText';
import InspirationGenerator from './InspirationGenerator';
import Copyright from './Copyright';

export default function App() {
  return (
    <>
      <FancyText title text="Get Inspired App" />
      <InspirationGenerator>
        <Copyright year={2004} />
      </InspirationGenerator>
    </>
  );
}
```

In the module dependency tree of this example app, the `'use client'` directive in `InspirationGenerator.js` marks that module and all of its transitive dependencies as Client modules. The subtree starting at `InspirationGenerator.js` is now marked as Client modules.

![A tree graph with the top node representing the module 'App.js'. 'App.js' has three children: 'Copyright.js', 'FancyText.js', and 'InspirationGenerator.js'. 'InspirationGenerator.js' has two children: 'FancyText.js' and 'inspirations.js'. The nodes under and including 'InspirationGenerator.js' have a yellow background color to signify that this sub-graph is client-rendered due to the 'use client' directive in 'InspirationGenerator.js'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fuse_client_module_dependency.dark.png&w=1200&q=75)

![A tree graph with the top node representing the module 'App.js'. 'App.js' has three children: 'Copyright.js', 'FancyText.js', and 'InspirationGenerator.js'. 'InspirationGenerator.js' has two children: 'FancyText.js' and 'inspirations.js'. The nodes under and including 'InspirationGenerator.js' have a yellow background color to signify that this sub-graph is client-rendered due to the 'use client' directive in 'InspirationGenerator.js'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fuse_client_module_dependency.png&w=1200&q=75)

`'use client'` segments the module dependency tree of the React Server Components app, marking `InspirationGenerator.js` and all of its dependencies as client-rendered.

During render, the framework will server-render the root component and continue through the [render tree](https://react.dev/learn/understanding-your-ui-as-a-tree#the-render-tree), opting-out of evaluating any code imported from client-marked code.

The server-rendered portion of the render tree is then sent to the client. The client, with its client code downloaded, then completes rendering the rest of the tree.

![A tree graph where each node represents a component and its children as child components. The top-level node is labelled 'App' and it has two child components 'InspirationGenerator' and 'FancyText'. 'InspirationGenerator' has two child components, 'FancyText' and 'Copyright'. Both 'InspirationGenerator' and its child component 'FancyText' are marked to be client-rendered.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fuse_client_render_tree.dark.png&w=1080&q=75)

![A tree graph where each node represents a component and its children as child components. The top-level node is labelled 'App' and it has two child components 'InspirationGenerator' and 'FancyText'. 'InspirationGenerator' has two child components, 'FancyText' and 'Copyright'. Both 'InspirationGenerator' and its child component 'FancyText' are marked to be client-rendered.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fuse_client_render_tree.png&w=1080&q=75)

The render tree for the React Server Components app. `InspirationGenerator` and its child component `FancyText` are components exported from client-marked code and considered Client Components.

We introduce the following definitions:

* **Client Components** are components in a render tree that are rendered on the client.
* **Server Components** are components in a render tree that are rendered on the server.

Working through the example app, `App`, `FancyText` and `Copyright` are all server-rendered and considered Server Components. As `InspirationGenerator.js` and its transitive dependencies are marked as client code, the component `InspirationGenerator` and its child component `FancyText` are Client Components.

##### Deep Dive

#### How is `FancyText` both a Server and a Client Component?

Show Details

By the above definitions, the component `FancyText` is both a Server and Client Component, how can that be?

First, let’s clarify that the term “component” is not very precise. Here are just two ways “component” can be understood:

1. A “component” can refer to a **component definition**. In most cases this will be a function.

```
// This is a definition of a component

function MyComponent() {

return <p>My Component</p>

}
```

2. A “component” can also refer to a **component usage** of its definition.

```
import MyComponent from './MyComponent';

function App() {

// This is a usage of a component

return <MyComponent />;

}
```

Often, the imprecision is not important when explaining concepts, but in this case it is.

When we talk about Server or Client Components, we are referring to component usages.

* If the component is defined in a module with a `'use client'` directive, or the component is imported and called in a Client Component, then the component usage is a Client Component.
* Otherwise, the component usage is a Server Component.

![A tree graph where each node represents a component and its children as child components. The top-level node is labelled 'App' and it has two child components 'InspirationGenerator' and 'FancyText'. 'InspirationGenerator' has two child components, 'FancyText' and 'Copyright'. Both 'InspirationGenerator' and its child component 'FancyText' are marked to be client-rendered.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fuse_client_render_tree.dark.png&w=1080&q=75)

![A tree graph where each node represents a component and its children as child components. The top-level node is labelled 'App' and it has two child components 'InspirationGenerator' and 'FancyText'. 'InspirationGenerator' has two child components, 'FancyText' and 'Copyright'. Both 'InspirationGenerator' and its child component 'FancyText' are marked to be client-rendered.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fuse_client_render_tree.png&w=1080&q=75)

A render tree illustrates component usages.

Back to the question of `FancyText`, we see that the component definition does *not* have a `'use client'` directive and it has two usages.

The usage of `FancyText` as a child of `App`, marks that usage as a Server Component. When `FancyText` is imported and called under `InspirationGenerator`, that usage of `FancyText` is a Client Component as `InspirationGenerator` contains a `'use client'` directive.

This means that the component definition for `FancyText` will both be evaluated on the server and also downloaded by the client to render its Client Component usage.

##### Deep Dive

#### Why is `Copyright` a Server Component?

Show Details

Because `Copyright` is rendered as a child of the Client Component `InspirationGenerator`, you might be surprised that it is a Server Component.

Recall that `'use client'` defines the boundary between server and client code on the *module dependency tree*, not the render tree.

![A tree graph with the top node representing the module 'App.js'. 'App.js' has three children: 'Copyright.js', 'FancyText.js', and 'InspirationGenerator.js'. 'InspirationGenerator.js' has two children: 'FancyText.js' and 'inspirations.js'. The nodes under and including 'InspirationGenerator.js' have a yellow background color to signify that this sub-graph is client-rendered due to the 'use client' directive in 'InspirationGenerator.js'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fuse_client_module_dependency.dark.png&w=1080&q=75)

![A tree graph with the top node representing the module 'App.js'. 'App.js' has three children: 'Copyright.js', 'FancyText.js', and 'InspirationGenerator.js'. 'InspirationGenerator.js' has two children: 'FancyText.js' and 'inspirations.js'. The nodes under and including 'InspirationGenerator.js' have a yellow background color to signify that this sub-graph is client-rendered due to the 'use client' directive in 'InspirationGenerator.js'.](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fuse_client_module_dependency.png&w=1080&q=75)

`'use client'` defines the boundary between server and client code on the module dependency tree.

In the module dependency tree, we see that `App.js` imports and calls `Copyright` from the `Copyright.js` module. As `Copyright.js` does not contain a `'use client'` directive, the component usage is rendered on the server. `App` is rendered on the server as it is the root component.

Client Components can render Server Components because you can pass JSX as props. In this case, `InspirationGenerator` receives `Copyright` as [children](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children). However, the `InspirationGenerator` module never directly imports the `Copyright` module nor calls the component, all of that is done by `App`. In fact, the `Copyright` component is fully executed before `InspirationGenerator` starts rendering.

The takeaway is that a parent-child render relationship between components does not guarantee the same render environment.

### When to use `'use client'`

With `'use client'`, you can determine when components are Client Components. As Server Components are default, here is a brief overview of the advantages and limitations to Server Components to determine when you need to mark something as client rendered.

For simplicity, we talk about Server Components, but the same principles apply to all code in your app that is server run.

#### Advantages of Server Components

* Server Components can reduce the amount of code sent and run by the client. Only Client modules are bundled and evaluated by the client.
* Server Components benefit from running on the server. They can access the local filesystem and may experience low latency for data fetches and network requests.

#### Limitations of Server Components

* Server Components cannot support interaction as event handlers must be registered and triggered by a client.
  + For example, event handlers like `onClick` can only be defined in Client Components.
* Server Components cannot use most Hooks.
  + When Server Components are rendered, their output is essentially a list of components for the client to render. Server Components do not persist in memory after render and cannot have their own state.

### Serializable types returned by Server Components

As in any React app, parent components pass data to child components. As they are rendered in different environments, passing data from a Server Component to a Client Component requires extra consideration.

Prop values passed from a Server Component to Client Component must be serializable.

Serializable props include:

* Primitives
  + [string](https://developer.mozilla.org/en-US/docs/Glossary/String)
  + [number](https://developer.mozilla.org/en-US/docs/Glossary/Number)
  + [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
  + [boolean](https://developer.mozilla.org/en-US/docs/Glossary/Boolean)
  + [undefined](https://developer.mozilla.org/en-US/docs/Glossary/Undefined)
  + [null](https://developer.mozilla.org/en-US/docs/Glossary/Null)
  + [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol), only symbols registered in the global Symbol registry via [`Symbol.for`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for)
* Iterables containing serializable values
  + [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)
  + [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
  + [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
  + [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)
  + [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) and [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)
* [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)
* Plain [objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object): those created with [object initializers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer), with serializable properties
* Functions that are [Server Functions](https://react.dev/reference/rsc/server-functions)
* Client or Server Component elements (JSX)
* [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Notably, these are not supported:

* [Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) that are not exported from client-marked modules or marked with [`'use server'`](https://react.dev/reference/rsc/use-server)
* [Classes](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Classes_in_JavaScript)
* Objects that are instances of any class (other than the built-ins mentioned) or objects with [a null prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#null-prototype_objects)
* Symbols not registered globally, ex. `Symbol('my new symbol')`

## Usage

### Building with interactivity and state

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
'use client';

import { useState } from 'react';

export default function Counter({initialValue = 0}) {
  const [countValue, setCountValue] = useState(initialValue);
  const increment = () => setCountValue(countValue + 1);
  const decrement = () => setCountValue(countValue - 1);
  return (
    <>
      <h2>Count Value: {countValue}</h2>
      <button onClick={increment}>+1</button>
      <button onClick={decrement}>-1</button>
    </>
  );
}
```

Show more

As `Counter` requires both the `useState` Hook and event handlers to increment or decrement the value, this component must be a Client Component and will require a `'use client'` directive at the top.

In contrast, a component that renders UI without interaction will not need to be a Client Component.

```
import { readFile } from 'node:fs/promises';

import Counter from './Counter';

export default async function CounterContainer() {

const initialValue = await readFile('/path/to/counter_value');

return <Counter initialValue={initialValue} />

}
```

For example, `Counter`’s parent component, `CounterContainer`, does not require `'use client'` as it is not interactive and does not use state. In addition, `CounterContainer` must be a Server Component as it reads from the local file system on the server, which is possible only in a Server Component.

There are also components that don’t use any server or client-only features and can be agnostic to where they render. In our earlier example, `FancyText` is one such component.

```
export default function FancyText({title, text}) {

return title

? <h1 className='fancy title'>{text}</h1>

: <h3 className='fancy cursive'>{text}</h3>

}
```

In this case, we don’t add the `'use client'` directive, resulting in `FancyText`’s *output* (rather than its source code) to be sent to the browser when referenced from a Server Component. As demonstrated in the earlier Inspirations app example, `FancyText` is used as both a Server or Client Component, depending on where it is imported and used.

But if `FancyText`’s HTML output was large relative to its source code (including dependencies), it might be more efficient to force it to always be a Client Component. Components that return a long SVG path string are one case where it may be more efficient to force a component to be a Client Component.

### Using client APIs

Your React app may use client-specific APIs, such as the browser’s APIs for web storage, audio and video manipulation, and device hardware, among [others](https://developer.mozilla.org/en-US/docs/Web/API).

In this example, the component uses [DOM APIs](https://developer.mozilla.org/en-US/docs/Glossary/DOM) to manipulate a [`canvas`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas) element. Since those APIs are only available in the browser, it must be marked as a Client Component.

```
'use client';

import {useRef, useEffect} from 'react';

export default function Circle() {

const ref = useRef(null);

useLayoutEffect(() => {

const canvas = ref.current;

const context = canvas.getContext('2d');

context.reset();

context.beginPath();

context.arc(100, 75, 50, 0, 2 * Math.PI);

context.stroke();

});

return <canvas ref={ref} />;

}
```

### Using third-party libraries

Often in a React app, you’ll leverage third-party libraries to handle common UI patterns or logic.

These libraries may rely on component Hooks or client APIs. Third-party components that use any of the following React APIs must run on the client:

* [createContext](https://react.dev/reference/react/createContext)
* [`react`](https://react.dev/reference/react/hooks) and [`react-dom`](https://react.dev/reference/react-dom/hooks) Hooks, excluding [`use`](https://react.dev/reference/react/use) and [`useId`](https://react.dev/reference/react/useId)
* [forwardRef](https://react.dev/reference/react/forwardRef)
* [memo](https://react.dev/reference/react/memo)
* [startTransition](https://react.dev/reference/react/startTransition)
* If they use client APIs, ex. DOM insertion or native platform views

If these libraries have been updated to be compatible with React Server Components, then they will already include `'use client'` markers of their own, allowing you to use them directly from your Server Components. If a library hasn’t been updated, or if a component needs props like event handlers that can only be specified on the client, you may need to add your own Client Component file in between the third-party Client Component and your Server Component where you’d like to use it.

[PreviousDirectives](https://react.dev/reference/rsc/directives)[Next'use server'](https://react.dev/reference/rsc/use-server)

---

---


# 'use server' directive – React

URL: https://react.dev/reference/rsc/use-server

[API Reference](https://react.dev/reference/react)

[Directives](https://react.dev/reference/rsc/directives)

# 'use server'

### React Server Components

`'use server'` is for use with [using React Server Components](https://react.dev/reference/rsc/server-components).

`'use server'` marks server-side functions that can be called from client-side code.

* [Reference](https://react.dev/reference/rsc/use-server#reference) 
  + [`'use server'`](https://react.dev/reference/rsc/use-server#use-server)
  + [Security considerations](https://react.dev/reference/rsc/use-server#security)
  + [Serializable arguments and return values](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values)
* [Usage](https://react.dev/reference/rsc/use-server#usage) 
  + [Server Functions in forms](https://react.dev/reference/rsc/use-server#server-functions-in-forms)
  + [Calling a Server Function outside of `<form>`](https://react.dev/reference/rsc/use-server#calling-a-server-function-outside-of-form)

---

## Reference

### `'use server'`

Add `'use server'` at the top of an async function body to mark the function as callable by the client. We call these functions [*Server Functions*](https://react.dev/reference/rsc/server-functions).

```
async function addToCart(data) {

'use server';

// ...

}
```

When calling a Server Function on the client, it will make a network request to the server that includes a serialized copy of any arguments passed. If the Server Function returns a value, that value will be serialized and returned to the client.

Instead of individually marking functions with `'use server'`, you can add the directive to the top of a file to mark all exports within that file as Server Functions that can be used anywhere, including imported in client code.

#### Caveats

* `'use server'` must be at the very beginning of their function or module; above any other code including imports (comments above directives are OK). They must be written with single or double quotes, not backticks.
* `'use server'` can only be used in server-side files. The resulting Server Functions can be passed to Client Components through props. See supported [types for serialization](https://react.dev/reference/rsc/use-server#serializable-parameters-and-return-values).
* To import a Server Functions from [client code](https://react.dev/reference/rsc/use-client), the directive must be used on a module level.
* Because the underlying network calls are always asynchronous, `'use server'` can only be used on async functions.
* Always treat arguments to Server Functions as untrusted input and authorize any mutations. See [security considerations](https://react.dev/reference/rsc/use-server#security).
* Server Functions should be called in a [Transition](https://react.dev/reference/react/useTransition). Server Functions passed to [`<form action>`](https://react.dev/reference/react-dom/components/form#props) or [`formAction`](https://react.dev/reference/react-dom/components/input#props) will automatically be called in a transition.
* Server Functions are designed for mutations that update server-side state; they are not recommended for data fetching. Accordingly, frameworks implementing Server Functions typically process one action at a time and do not have a way to cache the return value.

### Security considerations

Arguments to Server Functions are fully client-controlled. For security, always treat them as untrusted input, and make sure to validate and escape arguments as appropriate.

In any Server Function, make sure to validate that the logged-in user is allowed to perform that action.

### Under Construction

To prevent sending sensitive data from a Server Function, there are experimental taint APIs to prevent unique values and objects from being passed to client code.

See [experimental\_taintUniqueValue](https://react.dev/reference/react/experimental_taintUniqueValue) and [experimental\_taintObjectReference](https://react.dev/reference/react/experimental_taintObjectReference).

### Serializable arguments and return values

Since client code calls the Server Function over the network, any arguments passed will need to be serializable.

Here are supported types for Server Function arguments:

* Primitives
  + [string](https://developer.mozilla.org/en-US/docs/Glossary/String)
  + [number](https://developer.mozilla.org/en-US/docs/Glossary/Number)
  + [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
  + [boolean](https://developer.mozilla.org/en-US/docs/Glossary/Boolean)
  + [undefined](https://developer.mozilla.org/en-US/docs/Glossary/Undefined)
  + [null](https://developer.mozilla.org/en-US/docs/Glossary/Null)
  + [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol), only symbols registered in the global Symbol registry via [`Symbol.for`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/for)
* Iterables containing serializable values
  + [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)
  + [Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
  + [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
  + [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)
  + [TypedArray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) and [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)
* [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)
* [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) instances
* Plain [objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object): those created with [object initializers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer), with serializable properties
* Functions that are Server Functions
* [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

Notably, these are not supported:

* React elements, or [JSX](https://react.dev/learn/writing-markup-with-jsx)
* Functions, including component functions or any other function that is not a Server Function
* [Classes](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Classes_in_JavaScript)
* Objects that are instances of any class (other than the built-ins mentioned) or objects with [a null prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#null-prototype_objects)
* Symbols not registered globally, ex. `Symbol('my new symbol')`
* Events from event handlers

Supported serializable return values are the same as [serializable props](https://react.dev/reference/rsc/use-client#serializable-types) for a boundary Client Component.

## Usage

### Server Functions in forms

The most common use case of Server Functions will be calling functions that mutate data. On the browser, the [HTML form element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form) is the traditional approach for a user to submit a mutation. With React Server Components, React introduces first-class support for Server Functions as Actions in [forms](https://react.dev/reference/react-dom/components/form).

Here is a form that allows a user to request a username.

```
// App.js

async function requestUsername(formData) {

'use server';

const username = formData.get('username');

// ...

}

export default function App() {

return (

<form action={requestUsername}>

<input type="text" name="username" />

<button type="submit">Request</button>

</form>

);

}
```

In this example `requestUsername` is a Server Function passed to a `<form>`. When a user submits this form, there is a network request to the server function `requestUsername`. When calling a Server Function in a form, React will supply the form’s [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) as the first argument to the Server Function.

By passing a Server Function to the form `action`, React can [progressively enhance](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement) the form. This means that forms can be submitted before the JavaScript bundle is loaded.

#### Handling return values in forms

In the username request form, there might be the chance that a username is not available. `requestUsername` should tell us if it fails or not.

To update the UI based on the result of a Server Function while supporting progressive enhancement, use [`useActionState`](https://react.dev/reference/react/useActionState).

```
// requestUsername.js

'use server';

export default async function requestUsername(formData) {

const username = formData.get('username');

if (canRequest(username)) {

// ...

return 'successful';

}

return 'failed';

}
```

```
// UsernameForm.js

'use client';

import { useActionState } from 'react';

import requestUsername from './requestUsername';

function UsernameForm() {

const [state, action] = useActionState(requestUsername, null, 'n/a');

return (

<>

<form action={action}>

<input type="text" name="username" />

<button type="submit">Request</button>

</form>

<p>Last submission request returned: {state}</p>

</>

);

}
```

Note that like most Hooks, `useActionState` can only be called in [client code](https://react.dev/reference/rsc/use-client).

### Calling a Server Function outside of `<form>`

Server Functions are exposed server endpoints and can be called anywhere in client code.

When using a Server Function outside a [form](https://react.dev/reference/react-dom/components/form), call the Server Function in a [Transition](https://react.dev/reference/react/useTransition), which allows you to display a loading indicator, show [optimistic state updates](https://react.dev/reference/react/useOptimistic), and handle unexpected errors. Forms will automatically wrap Server Functions in transitions.

```
import incrementLike from './actions';

import { useState, useTransition } from 'react';

function LikeButton() {

const [isPending, startTransition] = useTransition();

const [likeCount, setLikeCount] = useState(0);

const onClick = () => {

startTransition(async () => {

const currentCount = await incrementLike();

setLikeCount(currentCount);

});

};

return (

<>

<p>Total Likes: {likeCount}</p>

<button onClick={onClick} disabled={isPending}>Like</button>;

</>

);

}
```

```
// actions.js

'use server';

let likeCount = 0;

export default async function incrementLike() {

likeCount++;

return likeCount;

}
```

To read a Server Function return value, you’ll need to `await` the promise returned.

[Previous'use client'](https://react.dev/reference/rsc/use-client)

---

---


# Children – React

URL: https://react.dev/reference/react/Children

[API Reference](https://react.dev/reference/react)

[Legacy React APIs](https://react.dev/reference/react/legacy)

# Children

### Pitfall

Using `Children` is uncommon and can lead to fragile code. [See common alternatives.](https://react.dev/reference/react/Children#alternatives)

`Children` lets you manipulate and transform the JSX you received as the [`children` prop.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)

```
const mappedChildren = Children.map(children, child =>

<div className="Row">

{child}

</div>

);
```

* [Reference](https://react.dev/reference/react/Children#reference) 
  + [`Children.count(children)`](https://react.dev/reference/react/Children#children-count)
  + [`Children.forEach(children, fn, thisArg?)`](https://react.dev/reference/react/Children#children-foreach)
  + [`Children.map(children, fn, thisArg?)`](https://react.dev/reference/react/Children#children-map)
  + [`Children.only(children)`](https://react.dev/reference/react/Children#children-only)
  + [`Children.toArray(children)`](https://react.dev/reference/react/Children#children-toarray)
* [Usage](https://react.dev/reference/react/Children#usage) 
  + [Transforming children](https://react.dev/reference/react/Children#transforming-children)
  + [Running some code for each child](https://react.dev/reference/react/Children#running-some-code-for-each-child)
  + [Counting children](https://react.dev/reference/react/Children#counting-children)
  + [Converting children to an array](https://react.dev/reference/react/Children#converting-children-to-an-array)
* [Alternatives](https://react.dev/reference/react/Children#alternatives) 
  + [Exposing multiple components](https://react.dev/reference/react/Children#exposing-multiple-components)
  + [Accepting an array of objects as a prop](https://react.dev/reference/react/Children#accepting-an-array-of-objects-as-a-prop)
  + [Calling a render prop to customize rendering](https://react.dev/reference/react/Children#calling-a-render-prop-to-customize-rendering)
* [Troubleshooting](https://react.dev/reference/react/Children#troubleshooting) 
  + [I pass a custom component, but the `Children` methods don’t show its render result](https://react.dev/reference/react/Children#i-pass-a-custom-component-but-the-children-methods-dont-show-its-render-result)

---

## Reference

### `Children.count(children)`

Call `Children.count(children)` to count the number of children in the `children` data structure.

```
import { Children } from 'react';

function RowList({ children }) {

return (

<>

<h1>Total rows: {Children.count(children)}</h1>

...

</>

);

}
```

[See more examples below.](https://react.dev/reference/react/Children#counting-children)

#### Parameters

* `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.

#### Returns

The number of nodes inside these `children`.

#### Caveats

* Empty nodes (`null`, `undefined`, and Booleans), strings, numbers, and [React elements](https://react.dev/reference/react/createElement) count as individual nodes. Arrays don’t count as individual nodes, but their children do. **The traversal does not go deeper than React elements:** they don’t get rendered, and their children aren’t traversed. [Fragments](https://react.dev/reference/react/Fragment) don’t get traversed.

---

### `Children.forEach(children, fn, thisArg?)`

Call `Children.forEach(children, fn, thisArg?)` to run some code for each child in the `children` data structure.

```
import { Children } from 'react';

function SeparatorList({ children }) {

const result = [];

Children.forEach(children, (child, index) => {

result.push(child);

result.push(<hr key={index} />);

});

// ...
```

[See more examples below.](https://react.dev/reference/react/Children#running-some-code-for-each-child)

#### Parameters

* `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.
* `fn`: The function you want to run for each child, similar to the [array `forEach` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) callback. It will be called with the child as the first argument and its index as the second argument. The index starts at `0` and increments on each call.
* **optional** `thisArg`: The [`this` value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) with which the `fn` function should be called. If omitted, it’s `undefined`.

#### Returns

`Children.forEach` returns `undefined`.

#### Caveats

* Empty nodes (`null`, `undefined`, and Booleans), strings, numbers, and [React elements](https://react.dev/reference/react/createElement) count as individual nodes. Arrays don’t count as individual nodes, but their children do. **The traversal does not go deeper than React elements:** they don’t get rendered, and their children aren’t traversed. [Fragments](https://react.dev/reference/react/Fragment) don’t get traversed.

---

### `Children.map(children, fn, thisArg?)`

Call `Children.map(children, fn, thisArg?)` to map or transform each child in the `children` data structure.

```
import { Children } from 'react';

function RowList({ children }) {

return (

<div className="RowList">

{Children.map(children, child =>

<div className="Row">

{child}

</div>

)}

</div>

);

}
```

[See more examples below.](https://react.dev/reference/react/Children#transforming-children)

#### Parameters

* `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.
* `fn`: The mapping function, similar to the [array `map` method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) callback. It will be called with the child as the first argument and its index as the second argument. The index starts at `0` and increments on each call. You need to return a React node from this function. This may be an empty node (`null`, `undefined`, or a Boolean), a string, a number, a React element, or an array of other React nodes.
* **optional** `thisArg`: The [`this` value](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) with which the `fn` function should be called. If omitted, it’s `undefined`.

#### Returns

If `children` is `null` or `undefined`, returns the same value.

Otherwise, returns a flat array consisting of the nodes you’ve returned from the `fn` function. The returned array will contain all nodes you returned except for `null` and `undefined`.

#### Caveats

* Empty nodes (`null`, `undefined`, and Booleans), strings, numbers, and [React elements](https://react.dev/reference/react/createElement) count as individual nodes. Arrays don’t count as individual nodes, but their children do. **The traversal does not go deeper than React elements:** they don’t get rendered, and their children aren’t traversed. [Fragments](https://react.dev/reference/react/Fragment) don’t get traversed.
* If you return an element or an array of elements with keys from `fn`, **the returned elements’ keys will be automatically combined with the key of the corresponding original item from `children`.** When you return multiple elements from `fn` in an array, their keys only need to be unique locally amongst each other.

---

### `Children.only(children)`

Call `Children.only(children)` to assert that `children` represent a single React element.

```
function Box({ children }) {

const element = Children.only(children);

// ...
```

#### Parameters

* `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.

#### Returns

If `children` [is a valid element,](https://react.dev/reference/react/isValidElement) returns that element.

Otherwise, throws an error.

#### Caveats

* This method always **throws if you pass an array (such as the return value of `Children.map`) as `children`.** In other words, it enforces that `children` is a single React element, not that it’s an array with a single element.

---

### `Children.toArray(children)`

Call `Children.toArray(children)` to create an array out of the `children` data structure.

```
import { Children } from 'react';

export default function ReversedList({ children }) {

const result = Children.toArray(children);

result.reverse();

// ...
```

#### Parameters

* `children`: The value of the [`children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) received by your component.

#### Returns

Returns a flat array of elements in `children`.

#### Caveats

* Empty nodes (`null`, `undefined`, and Booleans) will be omitted in the returned array. **The returned elements’ keys will be calculated from the original elements’ keys and their level of nesting and position.** This ensures that flattening the array does not introduce changes in behavior.

---

## Usage

### Transforming children

To transform the children JSX that your component [receives as the `children` prop,](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) call `Children.map`:

```
import { Children } from 'react';

function RowList({ children }) {

return (

<div className="RowList">

{Children.map(children, child =>

<div className="Row">

{child}

</div>

)}

</div>

);

}
```

In the example above, the `RowList` wraps every child it receives into a `<div className="Row">` container. For example, let’s say the parent component passes three `<p>` tags as the `children` prop to `RowList`:

```
<RowList>

<p>This is the first item.</p>

<p>This is the second item.</p>

<p>This is the third item.</p>

</RowList>
```

Then, with the `RowList` implementation above, the final rendered result will look like this:

```
<div className="RowList">

<div className="Row">

<p>This is the first item.</p>

</div>

<div className="Row">

<p>This is the second item.</p>

</div>

<div className="Row">

<p>This is the third item.</p>

</div>

</div>
```

`Children.map` is similar to [to transforming arrays with `map()`.](https://react.dev/learn/rendering-lists) The difference is that the `children` data structure is considered *opaque.* This means that even if it’s sometimes an array, you should not assume it’s an array or any other particular data type. This is why you should use `Children.map` if you need to transform it.

App.jsRowList.js

RowList.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Children } from 'react';

export default function RowList({ children }) {
  return (
    <div className="RowList">
      {Children.map(children, child =>
        <div className="Row">
          {child}
        </div>
      )}
    </div>
  );
}
```

##### Deep Dive

#### Why is the children prop not always an array?

Show Details

In React, the `children` prop is considered an *opaque* data structure. This means that you shouldn’t rely on how it is structured. To transform, filter, or count children, you should use the `Children` methods.

In practice, the `children` data structure is often represented as an array internally. However, if there is only a single child, then React won’t create an extra array since this would lead to unnecessary memory overhead. As long as you use the `Children` methods instead of directly introspecting the `children` prop, your code will not break even if React changes how the data structure is actually implemented.

Even when `children` is an array, `Children.map` has useful special behavior. For example, `Children.map` combines the [keys](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) on the returned elements with the keys on the `children` you’ve passed to it. This ensures the original JSX children don’t “lose” keys even if they get wrapped like in the example above.

### Pitfall

The `children` data structure **does not include rendered output** of the components you pass as JSX. In the example below, the `children` received by the `RowList` only contains two items rather than three:

1. `<p>This is the first item.</p>`
2. `<MoreRows />`

This is why only two row wrappers are generated in this example:

App.jsRowList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import RowList from './RowList.js';

export default function App() {
  return (
    <RowList>
      <p>This is the first item.</p>
      <MoreRows />
    </RowList>
  );
}

function MoreRows() {
  return (
    <>
      <p>This is the second item.</p>
      <p>This is the third item.</p>
    </>
  );
}
```

Show more

**There is no way to get the rendered output of an inner component** like `<MoreRows />` when manipulating `children`. This is why [it’s usually better to use one of the alternative solutions.](https://react.dev/reference/react/Children#alternatives)

---

### Running some code for each child

Call `Children.forEach` to iterate over each child in the `children` data structure. It does not return any value and is similar to the [array `forEach` method.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach) You can use it to run custom logic like constructing your own array.

App.jsSeparatorList.js

SeparatorList.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Children } from 'react';

export default function SeparatorList({ children }) {
  const result = [];
  Children.forEach(children, (child, index) => {
    result.push(child);
    result.push(<hr key={index} />);
  });
  result.pop(); // Remove the last separator
  return result;
}
```

### Pitfall

As mentioned earlier, there is no way to get the rendered output of an inner component when manipulating `children`. This is why [it’s usually better to use one of the alternative solutions.](https://react.dev/reference/react/Children#alternatives)

---

### Counting children

Call `Children.count(children)` to calculate the number of children.

App.jsRowList.js

RowList.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Children } from 'react';

export default function RowList({ children }) {
  return (
    <div className="RowList">
      <h1 className="RowListHeader">
        Total rows: {Children.count(children)}
      </h1>
      {Children.map(children, child =>
        <div className="Row">
          {child}
        </div>
      )}
    </div>
  );
}
```

Show more

### Pitfall

As mentioned earlier, there is no way to get the rendered output of an inner component when manipulating `children`. This is why [it’s usually better to use one of the alternative solutions.](https://react.dev/reference/react/Children#alternatives)

---

### Converting children to an array

Call `Children.toArray(children)` to turn the `children` data structure into a regular JavaScript array. This lets you manipulate the array with built-in array methods like [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter), [`sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort), or [`reverse`.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)

App.jsReversedList.js

ReversedList.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Children } from 'react';

export default function ReversedList({ children }) {
  const result = Children.toArray(children);
  result.reverse();
  return result;
}
```

### Pitfall

As mentioned earlier, there is no way to get the rendered output of an inner component when manipulating `children`. This is why [it’s usually better to use one of the alternative solutions.](https://react.dev/reference/react/Children#alternatives)

---

## Alternatives

### Note

This section describes alternatives to the `Children` API (with capital `C`) that’s imported like this:

```
import { Children } from 'react';
```

Don’t confuse it with [using the `children` prop](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) (lowercase `c`), which is good and encouraged.

### Exposing multiple components

Manipulating children with the `Children` methods often leads to fragile code. When you pass children to a component in JSX, you don’t usually expect the component to manipulate or transform the individual children.

When you can, try to avoid using the `Children` methods. For example, if you want every child of `RowList` to be wrapped in `<div className="Row">`, export a `Row` component, and manually wrap every row into it like this:

App.jsRowList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { RowList, Row } from './RowList.js';

export default function App() {
  return (
    <RowList>
      <Row>
        <p>This is the first item.</p>
      </Row>
      <Row>
        <p>This is the second item.</p>
      </Row>
      <Row>
        <p>This is the third item.</p>
      </Row>
    </RowList>
  );
}
```

Show more

Unlike using `Children.map`, this approach does not wrap every child automatically. **However, this approach has a significant benefit compared to the [earlier example with `Children.map`](https://react.dev/reference/react/Children#transforming-children) because it works even if you keep extracting more components.** For example, it still works if you extract your own `MoreRows` component:

App.jsRowList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { RowList, Row } from './RowList.js';

export default function App() {
  return (
    <RowList>
      <Row>
        <p>This is the first item.</p>
      </Row>
      <MoreRows />
    </RowList>
  );
}

function MoreRows() {
  return (
    <>
      <Row>
        <p>This is the second item.</p>
      </Row>
      <Row>
        <p>This is the third item.</p>
      </Row>
    </>
  );
}
```

Show more

This wouldn’t work with `Children.map` because it would “see” `<MoreRows />` as a single child (and a single row).

---

### Accepting an array of objects as a prop

You can also explicitly pass an array as a prop. For example, this `RowList` accepts a `rows` array as a prop:

App.jsRowList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { RowList, Row } from './RowList.js';

export default function App() {
  return (
    <RowList rows={[
      { id: 'first', content: <p>This is the first item.</p> },
      { id: 'second', content: <p>This is the second item.</p> },
      { id: 'third', content: <p>This is the third item.</p> }
    ]} />
  );
}
```

Since `rows` is a regular JavaScript array, the `RowList` component can use built-in array methods like [`map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map) on it.

This pattern is especially useful when you want to be able to pass more information as structured data together with children. In the below example, the `TabSwitcher` component receives an array of objects as the `tabs` prop:

App.jsTabSwitcher.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import TabSwitcher from './TabSwitcher.js';

export default function App() {
  return (
    <TabSwitcher tabs={[
      {
        id: 'first',
        header: 'First',
        content: <p>This is the first item.</p>
      },
      {
        id: 'second',
        header: 'Second',
        content: <p>This is the second item.</p>
      },
      {
        id: 'third',
        header: 'Third',
        content: <p>This is the third item.</p>
      }
    ]} />
  );
}
```

Show more

Unlike passing the children as JSX, this approach lets you associate some extra data like `header` with each item. Because you are working with the `tabs` directly, and it is an array, you do not need the `Children` methods.

---

### Calling a render prop to customize rendering

Instead of producing JSX for every single item, you can also pass a function that returns JSX, and call that function when necessary. In this example, the `App` component passes a `renderContent` function to the `TabSwitcher` component. The `TabSwitcher` component calls `renderContent` only for the selected tab:

App.jsTabSwitcher.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import TabSwitcher from './TabSwitcher.js';

export default function App() {
  return (
    <TabSwitcher
      tabIds={['first', 'second', 'third']}
      getHeader={tabId => {
        return tabId[0].toUpperCase() + tabId.slice(1);
      }}
      renderContent={tabId => {
        return <p>This is the {tabId} item.</p>;
      }}
    />
  );
}
```

A prop like `renderContent` is called a *render prop* because it is a prop that specifies how to render a piece of the user interface. However, there is nothing special about it: it is a regular prop which happens to be a function.

Render props are functions, so you can pass information to them. For example, this `RowList` component passes the `id` and the `index` of each row to the `renderRow` render prop, which uses `index` to highlight even rows:

App.jsRowList.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { RowList, Row } from './RowList.js';

export default function App() {
  return (
    <RowList
      rowIds={['first', 'second', 'third']}
      renderRow={(id, index) => {
        return (
          <Row isHighlighted={index % 2 === 0}>
            <p>This is the {id} item.</p>
          </Row> 
        );
      }}
    />
  );
}
```

Show more

This is another example of how parent and child components can cooperate without manipulating the children.

---

## Troubleshooting

### I pass a custom component, but the `Children` methods don’t show its render result

Suppose you pass two children to `RowList` like this:

```
<RowList>

<p>First item</p>

<MoreRows />

</RowList>
```

If you do `Children.count(children)` inside `RowList`, you will get `2`. Even if `MoreRows` renders 10 different items, or if it returns `null`, `Children.count(children)` will still be `2`. From the `RowList`’s perspective, it only “sees” the JSX it has received. It does not “see” the internals of the `MoreRows` component.

The limitation makes it hard to extract a component. This is why [alternatives](https://react.dev/reference/react/Children#alternatives) are preferred to using `Children`.

[PreviousLegacy React APIs](https://react.dev/reference/react/legacy)[NextcloneElement](https://react.dev/reference/react/cloneElement)

---

---


# cloneElement – React

URL: https://react.dev/reference/react/cloneElement

[API Reference](https://react.dev/reference/react)

[Legacy React APIs](https://react.dev/reference/react/legacy)

# cloneElement

### Pitfall

Using `cloneElement` is uncommon and can lead to fragile code. [See common alternatives.](https://react.dev/reference/react/cloneElement#alternatives)

`cloneElement` lets you create a new React element using another element as a starting point.

```
const clonedElement = cloneElement(element, props, ...children)
```

* [Reference](https://react.dev/reference/react/cloneElement#reference) 
  + [`cloneElement(element, props, ...children)`](https://react.dev/reference/react/cloneElement#cloneelement)
* [Usage](https://react.dev/reference/react/cloneElement#usage) 
  + [Overriding props of an element](https://react.dev/reference/react/cloneElement#overriding-props-of-an-element)
* [Alternatives](https://react.dev/reference/react/cloneElement#alternatives) 
  + [Passing data with a render prop](https://react.dev/reference/react/cloneElement#passing-data-with-a-render-prop)
  + [Passing data through context](https://react.dev/reference/react/cloneElement#passing-data-through-context)
  + [Extracting logic into a custom Hook](https://react.dev/reference/react/cloneElement#extracting-logic-into-a-custom-hook)

---

## Reference

### `cloneElement(element, props, ...children)`

Call `cloneElement` to create a React element based on the `element`, but with different `props` and `children`:

```
import { cloneElement } from 'react';

// ...

const clonedElement = cloneElement(

<Row title="Cabbage">

Hello

</Row>,

{ isHighlighted: true },

'Goodbye'

);

console.log(clonedElement); // <Row title="Cabbage" isHighlighted={true}>Goodbye</Row>
```

[See more examples below.](https://react.dev/reference/react/cloneElement#usage)

#### Parameters

* `element`: The `element` argument must be a valid React element. For example, it could be a JSX node like `<Something />`, the result of calling [`createElement`](https://react.dev/reference/react/createElement), or the result of another `cloneElement` call.
* `props`: The `props` argument must either be an object or `null`. If you pass `null`, the cloned element will retain all of the original `element.props`. Otherwise, for every prop in the `props` object, the returned element will “prefer” the value from `props` over the value from `element.props`. The rest of the props will be filled from the original `element.props`. If you pass `props.key` or `props.ref`, they will replace the original ones.
* **optional** `...children`: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, [portals](https://react.dev/reference/react-dom/createPortal), empty nodes (`null`, `undefined`, `true`, and `false`), and arrays of React nodes. If you don’t pass any `...children` arguments, the original `element.props.children` will be preserved.

#### Returns

`cloneElement` returns a React element object with a few properties:

* `type`: Same as `element.type`.
* `props`: The result of shallowly merging `element.props` with the overriding `props` you have passed.
* `ref`: The original `element.ref`, unless it was overridden by `props.ref`.
* `key`: The original `element.key`, unless it was overridden by `props.key`.

Usually, you’ll return the element from your component or make it a child of another element. Although you may read the element’s properties, it’s best to treat every element as opaque after it’s created, and only render it.

#### Caveats

* Cloning an element **does not modify the original element.**
* You should only **pass children as multiple arguments to `cloneElement` if they are all statically known,** like `cloneElement(element, null, child1, child2, child3)`. If your children are dynamic, pass the entire array as the third argument: `cloneElement(element, null, listItems)`. This ensures that React will [warn you about missing `key`s](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) for any dynamic lists. For static lists this is not necessary because they never reorder.
* `cloneElement` makes it harder to trace the data flow, so **try the [alternatives](https://react.dev/reference/react/cloneElement#alternatives) instead.**

---

## Usage

### Overriding props of an element

To override the props of some React element, pass it to `cloneElement` with the props you want to override:

```
import { cloneElement } from 'react';

// ...

const clonedElement = cloneElement(

<Row title="Cabbage" />,

{ isHighlighted: true }

);
```

Here, the resulting cloned element will be `<Row title="Cabbage" isHighlighted={true} />`.

**Let’s walk through an example to see when it’s useful.**

Imagine a `List` component that renders its [`children`](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) as a list of selectable rows with a “Next” button that changes which row is selected. The `List` component needs to render the selected `Row` differently, so it clones every `<Row>` child that it has received, and adds an extra `isHighlighted: true` or `isHighlighted: false` prop:

```
export default function List({ children }) {

const [selectedIndex, setSelectedIndex] = useState(0);

return (

<div className="List">

{Children.map(children, (child, index) =>

cloneElement(child, {

isHighlighted: index === selectedIndex

})

)}
```

Let’s say the original JSX received by `List` looks like this:

```
<List>

<Row title="Cabbage" />

<Row title="Garlic" />

<Row title="Apple" />

</List>
```

By cloning its children, the `List` can pass extra information to every `Row` inside. The result looks like this:

```
<List>

<Row

title="Cabbage"

isHighlighted={true}

/>

<Row

title="Garlic"

isHighlighted={false}

/>

<Row

title="Apple"

isHighlighted={false}

/>

</List>
```

Notice how pressing “Next” updates the state of the `List`, and highlights a different row:

App.jsList.jsRow.jsdata.js

List.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Children, cloneElement, useState } from 'react';

export default function List({ children }) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  return (
    <div className="List">
      {Children.map(children, (child, index) =>
        cloneElement(child, {
          isHighlighted: index === selectedIndex 
        })
      )}
      <hr />
      <button onClick={() => {
        setSelectedIndex(i =>
          (i + 1) % Children.count(children)
        );
      }}>
        Next
      </button>
    </div>
  );
}
```

Show more

To summarize, the `List` cloned the `<Row />` elements it received and added an extra prop to them.

### Pitfall

Cloning children makes it hard to tell how the data flows through your app. Try one of the [alternatives.](https://react.dev/reference/react/cloneElement#alternatives)

---

## Alternatives

### Passing data with a render prop

Instead of using `cloneElement`, consider accepting a *render prop* like `renderItem`. Here, `List` receives `renderItem` as a prop. `List` calls `renderItem` for every item and passes `isHighlighted` as an argument:

```
export default function List({ items, renderItem }) {

const [selectedIndex, setSelectedIndex] = useState(0);

return (

<div className="List">

{items.map((item, index) => {

const isHighlighted = index === selectedIndex;

return renderItem(item, isHighlighted);

})}
```

The `renderItem` prop is called a “render prop” because it’s a prop that specifies how to render something. For example, you can pass a `renderItem` implementation that renders a `<Row>` with the given `isHighlighted` value:

```
<List

items={products}

renderItem={(product, isHighlighted) =>

<Row

key={product.id}

title={product.title}

isHighlighted={isHighlighted}

/>

}

/>
```

The end result is the same as with `cloneElement`:

```
<List>

<Row

title="Cabbage"

isHighlighted={true}

/>

<Row

title="Garlic"

isHighlighted={false}

/>

<Row

title="Apple"

isHighlighted={false}

/>

</List>
```

However, you can clearly trace where the `isHighlighted` value is coming from.

App.jsList.jsRow.jsdata.js

List.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function List({ items, renderItem }) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  return (
    <div className="List">
      {items.map((item, index) => {
        const isHighlighted = index === selectedIndex;
        return renderItem(item, isHighlighted);
      })}
      <hr />
      <button onClick={() => {
        setSelectedIndex(i =>
          (i + 1) % items.length
        );
      }}>
        Next
      </button>
    </div>
  );
}
```

Show more

This pattern is preferred to `cloneElement` because it is more explicit.

---

### Passing data through context

Another alternative to `cloneElement` is to [pass data through context.](https://react.dev/learn/passing-data-deeply-with-context)

For example, you can call [`createContext`](https://react.dev/reference/react/createContext) to define a `HighlightContext`:

```
export const HighlightContext = createContext(false);
```

Your `List` component can wrap every item it renders into a `HighlightContext` provider:

```
export default function List({ items, renderItem }) {

const [selectedIndex, setSelectedIndex] = useState(0);

return (

<div className="List">

{items.map((item, index) => {

const isHighlighted = index === selectedIndex;

return (

<HighlightContext key={item.id} value={isHighlighted}>

{renderItem(item)}

</HighlightContext>

);

})}
```

With this approach, `Row` does not need to receive an `isHighlighted` prop at all. Instead, it reads the context:

```
export default function Row({ title }) {

const isHighlighted = useContext(HighlightContext);

// ...
```

This allows the calling component to not know or worry about passing `isHighlighted` to `<Row>`:

```
<List

items={products}

renderItem={product =>

<Row title={product.title} />

}

/>
```

Instead, `List` and `Row` coordinate the highlighting logic through context.

App.jsList.jsRow.jsHighlightContext.jsdata.js

List.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';
import { HighlightContext } from './HighlightContext.js';

export default function List({ items, renderItem }) {
  const [selectedIndex, setSelectedIndex] = useState(0);
  return (
    <div className="List">
      {items.map((item, index) => {
        const isHighlighted = index === selectedIndex;
        return (
          <HighlightContext
            key={item.id}
            value={isHighlighted}
          >
            {renderItem(item)}
          </HighlightContext>
        );
      })}
      <hr />
      <button onClick={() => {
        setSelectedIndex(i =>
          (i + 1) % items.length
        );
      }}>
        Next
      </button>
    </div>
  );
}
```

Show more

[Learn more about passing data through context.](https://react.dev/reference/react/useContext#passing-data-deeply-into-the-tree)

---

### Extracting logic into a custom Hook

Another approach you can try is to extract the “non-visual” logic into your own Hook, and use the information returned by your Hook to decide what to render. For example, you could write a `useList` custom Hook like this:

```
import { useState } from 'react';

export default function useList(items) {

const [selectedIndex, setSelectedIndex] = useState(0);

function onNext() {

setSelectedIndex(i =>

(i + 1) % items.length

);

}

const selected = items[selectedIndex];

return [selected, onNext];

}
```

Then you could use it like this:

```
export default function App() {

const [selected, onNext] = useList(products);

return (

<div className="List">

{products.map(product =>

<Row

key={product.id}

title={product.title}

isHighlighted={selected === product}

/>

)}

<hr />

<button onClick={onNext}>

Next

</button>

</div>

);

}
```

The data flow is explicit, but the state is inside the `useList` custom Hook that you can use from any component:

App.jsuseList.jsRow.jsdata.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import Row from './Row.js';
import useList from './useList.js';
import { products } from './data.js';

export default function App() {
  const [selected, onNext] = useList(products);
  return (
    <div className="List">
      {products.map(product =>
        <Row
          key={product.id}
          title={product.title}
          isHighlighted={selected === product}
        />
      )}
      <hr />
      <button onClick={onNext}>
        Next
      </button>
    </div>
  );
}
```

Show more

This approach is particularly useful if you want to reuse this logic between different components.

[PreviousChildren](https://react.dev/reference/react/Children)[NextComponent](https://react.dev/reference/react/Component)

---

---


# Component – React

URL: https://react.dev/reference/react/Component

[API Reference](https://react.dev/reference/react)

[Legacy React APIs](https://react.dev/reference/react/legacy)

# Component

### Pitfall

We recommend defining components as functions instead of classes. [See how to migrate.](https://react.dev/reference/react/Component#alternatives)

`Component` is the base class for the React components defined as [JavaScript classes.](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes) Class components are still supported by React, but we don’t recommend using them in new code.

```
class Greeting extends Component {

render() {

return <h1>Hello, {this.props.name}!</h1>;

}

}
```

* [Reference](https://react.dev/reference/react/Component#reference) 
  + [`Component`](https://react.dev/reference/react/Component#component)
  + [`context`](https://react.dev/reference/react/Component#context)
  + [`props`](https://react.dev/reference/react/Component#props)
  + [`state`](https://react.dev/reference/react/Component#state)
  + [`constructor(props)`](https://react.dev/reference/react/Component#constructor)
  + [`componentDidCatch(error, info)`](https://react.dev/reference/react/Component#componentdidcatch)
  + [`componentDidMount()`](https://react.dev/reference/react/Component#componentdidmount)
  + [`componentDidUpdate(prevProps, prevState, snapshot?)`](https://react.dev/reference/react/Component#componentdidupdate)
  + [`componentWillMount()`](https://react.dev/reference/react/Component#componentwillmount)
  + [`componentWillReceiveProps(nextProps)`](https://react.dev/reference/react/Component#componentwillreceiveprops)
  + [`componentWillUpdate(nextProps, nextState)`](https://react.dev/reference/react/Component#componentwillupdate)
  + [`componentWillUnmount()`](https://react.dev/reference/react/Component#componentwillunmount)
  + [`forceUpdate(callback?)`](https://react.dev/reference/react/Component#forceupdate)
  + [`getSnapshotBeforeUpdate(prevProps, prevState)`](https://react.dev/reference/react/Component#getsnapshotbeforeupdate)
  + [`render()`](https://react.dev/reference/react/Component#render)
  + [`setState(nextState, callback?)`](https://react.dev/reference/react/Component#setstate)
  + [`shouldComponentUpdate(nextProps, nextState, nextContext)`](https://react.dev/reference/react/Component#shouldcomponentupdate)
  + [`UNSAFE_componentWillMount()`](https://react.dev/reference/react/Component#unsafe_componentwillmount)
  + [`UNSAFE_componentWillReceiveProps(nextProps, nextContext)`](https://react.dev/reference/react/Component#unsafe_componentwillreceiveprops)
  + [`UNSAFE_componentWillUpdate(nextProps, nextState)`](https://react.dev/reference/react/Component#unsafe_componentwillupdate)
  + [`static contextType`](https://react.dev/reference/react/Component#static-contexttype)
  + [`static defaultProps`](https://react.dev/reference/react/Component#static-defaultprops)
  + [`static getDerivedStateFromError(error)`](https://react.dev/reference/react/Component#static-getderivedstatefromerror)
  + [`static getDerivedStateFromProps(props, state)`](https://react.dev/reference/react/Component#static-getderivedstatefromprops)
* [Usage](https://react.dev/reference/react/Component#usage) 
  + [Defining a class component](https://react.dev/reference/react/Component#defining-a-class-component)
  + [Adding state to a class component](https://react.dev/reference/react/Component#adding-state-to-a-class-component)
  + [Adding lifecycle methods to a class component](https://react.dev/reference/react/Component#adding-lifecycle-methods-to-a-class-component)
  + [Catching rendering errors with an Error Boundary](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
* [Alternatives](https://react.dev/reference/react/Component#alternatives) 
  + [Migrating a simple component from a class to a function](https://react.dev/reference/react/Component#migrating-a-simple-component-from-a-class-to-a-function)
  + [Migrating a component with state from a class to a function](https://react.dev/reference/react/Component#migrating-a-component-with-state-from-a-class-to-a-function)
  + [Migrating a component with lifecycle methods from a class to a function](https://react.dev/reference/react/Component#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)
  + [Migrating a component with context from a class to a function](https://react.dev/reference/react/Component#migrating-a-component-with-context-from-a-class-to-a-function)

---

## Reference

### `Component`

To define a React component as a class, extend the built-in `Component` class and define a [`render` method:](https://react.dev/reference/react/Component#render)

```
import { Component } from 'react';

class Greeting extends Component {

render() {

return <h1>Hello, {this.props.name}!</h1>;

}

}
```

Only the `render` method is required, other methods are optional.

[See more examples below.](https://react.dev/reference/react/Component#usage)

---

### `context`

The [context](https://react.dev/learn/passing-data-deeply-with-context) of a class component is available as `this.context`. It is only available if you specify *which* context you want to receive using [`static contextType`](https://react.dev/reference/react/Component#static-contexttype).

A class component can only read one context at a time.

```
class Button extends Component {

static contextType = ThemeContext;

render() {

const theme = this.context;

const className = 'button-' + theme;

return (

<button className={className}>

{this.props.children}

</button>

);

}

}
```

### Note

Reading `this.context` in class components is equivalent to [`useContext`](https://react.dev/reference/react/useContext) in function components.

[See how to migrate.](https://react.dev/reference/react/Component#migrating-a-component-with-context-from-a-class-to-a-function)

---

### `props`

The props passed to a class component are available as `this.props`.

```
class Greeting extends Component {

render() {

return <h1>Hello, {this.props.name}!</h1>;

}

}

<Greeting name="Taylor" />
```

### Note

Reading `this.props` in class components is equivalent to [declaring props](https://react.dev/learn/passing-props-to-a-component#step-2-read-props-inside-the-child-component) in function components.

[See how to migrate.](https://react.dev/reference/react/Component#migrating-a-simple-component-from-a-class-to-a-function)

---

### `state`

The state of a class component is available as `this.state`. The `state` field must be an object. Do not mutate the state directly. If you wish to change the state, call `setState` with the new state.

```
class Counter extends Component {

state = {

age: 42,

};

handleAgeChange = () => {

this.setState({

age: this.state.age + 1

});

};

render() {

return (

<>

<button onClick={this.handleAgeChange}>

Increment age

</button>

<p>You are {this.state.age}.</p>

</>

);

}

}
```

### Note

Defining `state` in class components is equivalent to calling [`useState`](https://react.dev/reference/react/useState) in function components.

[See how to migrate.](https://react.dev/reference/react/Component#migrating-a-component-with-state-from-a-class-to-a-function)

---

### `constructor(props)`

The [constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor) runs before your class component *mounts* (gets added to the screen). Typically, a constructor is only used for two purposes in React. It lets you declare state and [bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind) your class methods to the class instance:

```
class Counter extends Component {

constructor(props) {

super(props);

this.state = { counter: 0 };

this.handleClick = this.handleClick.bind(this);

}

handleClick() {

// ...

}
```

If you use modern JavaScript syntax, constructors are rarely needed. Instead, you can rewrite this code above using the [public class field syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields) which is supported both by modern browsers and tools like [Babel:](https://babeljs.io/)

```
class Counter extends Component {

state = { counter: 0 };

handleClick = () => {

// ...

}
```

A constructor should not contain any side effects or subscriptions.

#### Parameters

* `props`: The component’s initial props.

#### Returns

`constructor` should not return anything.

#### Caveats

* Do not run any side effects or subscriptions in the constructor. Instead, use [`componentDidMount`](https://react.dev/reference/react/Component#componentdidmount) for that.
* Inside a constructor, you need to call `super(props)` before any other statement. If you don’t do that, `this.props` will be `undefined` while the constructor runs, which can be confusing and cause bugs.
* Constructor is the only place where you can assign [`this.state`](https://react.dev/reference/react/Component#state) directly. In all other methods, you need to use [`this.setState()`](https://react.dev/reference/react/Component#setstate) instead. Do not call `setState` in the constructor.
* When you use [server rendering,](https://react.dev/reference/react-dom/server) the constructor will run on the server too, followed by the [`render`](https://react.dev/reference/react/Component#render) method. However, lifecycle methods like `componentDidMount` or `componentWillUnmount` will not run on the server.
* When [Strict Mode](https://react.dev/reference/react/StrictMode) is on, React will call `constructor` twice in development and then throw away one of the instances. This helps you notice the accidental side effects that need to be moved out of the `constructor`.

### Note

There is no exact equivalent for `constructor` in function components. To declare state in a function component, call [`useState`.](https://react.dev/reference/react/useState) To avoid recalculating the initial state, [pass a function to `useState`.](https://react.dev/reference/react/useState#avoiding-recreating-the-initial-state)

---

### `componentDidCatch(error, info)`

If you define `componentDidCatch`, React will call it when some child component (including distant children) throws an error during rendering. This lets you log that error to an error reporting service in production.

Typically, it is used together with [`static getDerivedStateFromError`](https://react.dev/reference/react/Component#static-getderivedstatefromerror) which lets you update state in response to an error and display an error message to the user. A component with these methods is called an *Error Boundary*.

[See an example.](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)

#### Parameters

* `error`: The error that was thrown. In practice, it will usually be an instance of [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) but this is not guaranteed because JavaScript allows to [`throw`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw) any value, including strings or even `null`.
* `info`: An object containing additional information about the error. Its `componentStack` field contains a stack trace with the component that threw, as well as the names and source locations of all its parent components. In production, the component names will be minified. If you set up production error reporting, you can decode the component stack using sourcemaps the same way as you would do for regular JavaScript error stacks.

#### Returns

`componentDidCatch` should not return anything.

#### Caveats

* In the past, it was common to call `setState` inside `componentDidCatch` in order to update the UI and display the fallback error message. This is deprecated in favor of defining [`static getDerivedStateFromError`.](https://react.dev/reference/react/Component#static-getderivedstatefromerror)
* Production and development builds of React slightly differ in the way `componentDidCatch` handles errors. In development, the errors will bubble up to `window`, which means that any `window.onerror` or `window.addEventListener('error', callback)` will intercept the errors that have been caught by `componentDidCatch`. In production, instead, the errors will not bubble up, which means any ancestor error handler will only receive errors not explicitly caught by `componentDidCatch`.

### Note

There is no direct equivalent for `componentDidCatch` in function components yet. If you’d like to avoid creating class components, write a single `ErrorBoundary` component like above and use it throughout your app. Alternatively, you can use the [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) package which does that for you.

---

### `componentDidMount()`

If you define the `componentDidMount` method, React will call it when your component is added *(mounted)* to the screen. This is a common place to start data fetching, set up subscriptions, or manipulate the DOM nodes.

If you implement `componentDidMount`, you usually need to implement other lifecycle methods to avoid bugs. For example, if `componentDidMount` reads some state or props, you also have to implement [`componentDidUpdate`](https://react.dev/reference/react/Component#componentdidupdate) to handle their changes, and [`componentWillUnmount`](https://react.dev/reference/react/Component#componentwillunmount) to clean up whatever `componentDidMount` was doing.

```
class ChatRoom extends Component {

state = {

serverUrl: 'https://localhost:1234'

};

componentDidMount() {

this.setupConnection();

}

componentDidUpdate(prevProps, prevState) {

if (

this.props.roomId !== prevProps.roomId ||

this.state.serverUrl !== prevState.serverUrl

) {

this.destroyConnection();

this.setupConnection();

}

}

componentWillUnmount() {

this.destroyConnection();

}

// ...

}
```

[See more examples.](https://react.dev/reference/react/Component#adding-lifecycle-methods-to-a-class-component)

#### Parameters

`componentDidMount` does not take any parameters.

#### Returns

`componentDidMount` should not return anything.

#### Caveats

* When [Strict Mode](https://react.dev/reference/react/StrictMode) is on, in development React will call `componentDidMount`, then immediately call [`componentWillUnmount`,](https://react.dev/reference/react/Component#componentwillunmount) and then call `componentDidMount` again. This helps you notice if you forgot to implement `componentWillUnmount` or if its logic doesn’t fully “mirror” what `componentDidMount` does.
* Although you may call [`setState`](https://react.dev/reference/react/Component#setstate) immediately in `componentDidMount`, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the [`render`](https://react.dev/reference/react/Component#render) will be called twice in this case, the user won’t see the intermediate state. Use this pattern with caution because it often causes performance issues. In most cases, you should be able to assign the initial state in the [`constructor`](https://react.dev/reference/react/Component#constructor) instead. It can, however, be necessary for cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.

### Note

For many use cases, defining `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` together in class components is equivalent to calling [`useEffect`](https://react.dev/reference/react/useEffect) in function components. In the rare cases where it’s important for the code to run before browser paint, [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) is a closer match.

[See how to migrate.](https://react.dev/reference/react/Component#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)

---

### `componentDidUpdate(prevProps, prevState, snapshot?)`

If you define the `componentDidUpdate` method, React will call it immediately after your component has been re-rendered with updated props or state. This method is not called for the initial render.

You can use it to manipulate the DOM after an update. This is also a common place to do network requests as long as you compare the current props to previous props (e.g. a network request may not be necessary if the props have not changed). Typically, you’d use it together with [`componentDidMount`](https://react.dev/reference/react/Component#componentdidmount) and [`componentWillUnmount`:](https://react.dev/reference/react/Component#componentwillunmount)

```
class ChatRoom extends Component {

state = {

serverUrl: 'https://localhost:1234'

};

componentDidMount() {

this.setupConnection();

}

componentDidUpdate(prevProps, prevState) {

if (

this.props.roomId !== prevProps.roomId ||

this.state.serverUrl !== prevState.serverUrl

) {

this.destroyConnection();

this.setupConnection();

}

}

componentWillUnmount() {

this.destroyConnection();

}

// ...

}
```

[See more examples.](https://react.dev/reference/react/Component#adding-lifecycle-methods-to-a-class-component)

#### Parameters

* `prevProps`: Props before the update. Compare `prevProps` to [`this.props`](https://react.dev/reference/react/Component#props) to determine what changed.
* `prevState`: State before the update. Compare `prevState` to [`this.state`](https://react.dev/reference/react/Component#state) to determine what changed.
* `snapshot`: If you implemented [`getSnapshotBeforeUpdate`](https://react.dev/reference/react/Component#getsnapshotbeforeupdate), `snapshot` will contain the value you returned from that method. Otherwise, it will be `undefined`.

#### Returns

`componentDidUpdate` should not return anything.

#### Caveats

* `componentDidUpdate` will not get called if [`shouldComponentUpdate`](https://react.dev/reference/react/Component#shouldcomponentupdate) is defined and returns `false`.
* The logic inside `componentDidUpdate` should usually be wrapped in conditions comparing `this.props` with `prevProps`, and `this.state` with `prevState`. Otherwise, there’s a risk of creating infinite loops.
* Although you may call [`setState`](https://react.dev/reference/react/Component#setstate) immediately in `componentDidUpdate`, it’s best to avoid that when you can. It will trigger an extra rendering, but it will happen before the browser updates the screen. This guarantees that even though the [`render`](https://react.dev/reference/react/Component#render) will be called twice in this case, the user won’t see the intermediate state. This pattern often causes performance issues, but it may be necessary for rare cases like modals and tooltips when you need to measure a DOM node before rendering something that depends on its size or position.

### Note

For many use cases, defining `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` together in class components is equivalent to calling [`useEffect`](https://react.dev/reference/react/useEffect) in function components. In the rare cases where it’s important for the code to run before browser paint, [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) is a closer match.

[See how to migrate.](https://react.dev/reference/react/Component#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)

---

### `componentWillMount()`

### Deprecated

This API has been renamed from `componentWillMount` to [`UNSAFE_componentWillMount`.](https://react.dev/reference/react/Component#unsafe_componentwillmount) The old name has been deprecated. In a future major version of React, only the new name will work.

Run the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.

---

### `componentWillReceiveProps(nextProps)`

### Deprecated

This API has been renamed from `componentWillReceiveProps` to [`UNSAFE_componentWillReceiveProps`.](https://react.dev/reference/react/Component#unsafe_componentwillreceiveprops) The old name has been deprecated. In a future major version of React, only the new name will work.

Run the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.

---

### `componentWillUpdate(nextProps, nextState)`

### Deprecated

This API has been renamed from `componentWillUpdate` to [`UNSAFE_componentWillUpdate`.](https://react.dev/reference/react/Component#unsafe_componentwillupdate) The old name has been deprecated. In a future major version of React, only the new name will work.

Run the [`rename-unsafe-lifecycles` codemod](https://github.com/reactjs/react-codemod#rename-unsafe-lifecycles) to automatically update your components.

---

### `componentWillUnmount()`

If you define the `componentWillUnmount` method, React will call it before your component is removed *(unmounted)* from the screen. This is a common place to cancel data fetching or remove subscriptions.

The logic inside `componentWillUnmount` should “mirror” the logic inside [`componentDidMount`.](https://react.dev/reference/react/Component#componentdidmount) For example, if `componentDidMount` sets up a subscription, `componentWillUnmount` should clean up that subscription. If the cleanup logic in your `componentWillUnmount` reads some props or state, you will usually also need to implement [`componentDidUpdate`](https://react.dev/reference/react/Component#componentdidupdate) to clean up resources (such as subscriptions) corresponding to the old props and state.

```
class ChatRoom extends Component {

state = {

serverUrl: 'https://localhost:1234'

};

componentDidMount() {

this.setupConnection();

}

componentDidUpdate(prevProps, prevState) {

if (

this.props.roomId !== prevProps.roomId ||

this.state.serverUrl !== prevState.serverUrl

) {

this.destroyConnection();

this.setupConnection();

}

}

componentWillUnmount() {

this.destroyConnection();

}

// ...

}
```

[See more examples.](https://react.dev/reference/react/Component#adding-lifecycle-methods-to-a-class-component)

#### Parameters

`componentWillUnmount` does not take any parameters.

#### Returns

`componentWillUnmount` should not return anything.

#### Caveats

* When [Strict Mode](https://react.dev/reference/react/StrictMode) is on, in development React will call [`componentDidMount`,](https://react.dev/reference/react/Component#componentdidmount) then immediately call `componentWillUnmount`, and then call `componentDidMount` again. This helps you notice if you forgot to implement `componentWillUnmount` or if its logic doesn’t fully “mirror” what `componentDidMount` does.

### Note

For many use cases, defining `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount` together in class components is equivalent to calling [`useEffect`](https://react.dev/reference/react/useEffect) in function components. In the rare cases where it’s important for the code to run before browser paint, [`useLayoutEffect`](https://react.dev/reference/react/useLayoutEffect) is a closer match.

[See how to migrate.](https://react.dev/reference/react/Component#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)

---

### `forceUpdate(callback?)`

Forces a component to re-render.

Usually, this is not necessary. If your component’s [`render`](https://react.dev/reference/react/Component#render) method only reads from [`this.props`](https://react.dev/reference/react/Component#props), [`this.state`](https://react.dev/reference/react/Component#state), or [`this.context`,](https://react.dev/reference/react/Component#context) it will re-render automatically when you call [`setState`](https://react.dev/reference/react/Component#setstate) inside your component or one of its parents. However, if your component’s `render` method reads directly from an external data source, you have to tell React to update the user interface when that data source changes. That’s what `forceUpdate` lets you do.

Try to avoid all uses of `forceUpdate` and only read from `this.props` and `this.state` in `render`.

#### Parameters

* **optional** `callback` If specified, React will call the `callback` you’ve provided after the update is committed.

#### Returns

`forceUpdate` does not return anything.

#### Caveats

* If you call `forceUpdate`, React will re-render without calling [`shouldComponentUpdate`.](https://react.dev/reference/react/Component#shouldcomponentupdate)

### Note

Reading an external data source and forcing class components to re-render in response to its changes with `forceUpdate` has been superseded by [`useSyncExternalStore`](https://react.dev/reference/react/useSyncExternalStore) in function components.

---

### `getSnapshotBeforeUpdate(prevProps, prevState)`

If you implement `getSnapshotBeforeUpdate`, React will call it immediately before React updates the DOM. It enables your component to capture some information from the DOM (e.g. scroll position) before it is potentially changed. Any value returned by this lifecycle method will be passed as a parameter to [`componentDidUpdate`.](https://react.dev/reference/react/Component#componentdidupdate)

For example, you can use it in a UI like a chat thread that needs to preserve its scroll position during updates:

```
class ScrollingList extends React.Component {

constructor(props) {

super(props);

this.listRef = React.createRef();

}

getSnapshotBeforeUpdate(prevProps, prevState) {

// Are we adding new items to the list?

// Capture the scroll position so we can adjust scroll later.

if (prevProps.list.length < this.props.list.length) {

const list = this.listRef.current;

return list.scrollHeight - list.scrollTop;

}

return null;

}

componentDidUpdate(prevProps, prevState, snapshot) {

// If we have a snapshot value, we've just added new items.

// Adjust scroll so these new items don't push the old ones out of view.

// (snapshot here is the value returned from getSnapshotBeforeUpdate)

if (snapshot !== null) {

const list = this.listRef.current;

list.scrollTop = list.scrollHeight - snapshot;

}

}

render() {

return (

<div ref={this.listRef}>{/* ...contents... */}</div>

);

}

}
```

In the above example, it is important to read the `scrollHeight` property directly in `getSnapshotBeforeUpdate`. It is not safe to read it in [`render`](https://react.dev/reference/react/Component#render), [`UNSAFE_componentWillReceiveProps`](https://react.dev/reference/react/Component#unsafe_componentwillreceiveprops), or [`UNSAFE_componentWillUpdate`](https://react.dev/reference/react/Component#unsafe_componentwillupdate) because there is a potential time gap between these methods getting called and React updating the DOM.

#### Parameters

* `prevProps`: Props before the update. Compare `prevProps` to [`this.props`](https://react.dev/reference/react/Component#props) to determine what changed.
* `prevState`: State before the update. Compare `prevState` to [`this.state`](https://react.dev/reference/react/Component#state) to determine what changed.

#### Returns

You should return a snapshot value of any type that you’d like, or `null`. The value you returned will be passed as the third argument to [`componentDidUpdate`.](https://react.dev/reference/react/Component#componentdidupdate)

#### Caveats

* `getSnapshotBeforeUpdate` will not get called if [`shouldComponentUpdate`](https://react.dev/reference/react/Component#shouldcomponentupdate) is defined and returns `false`.

### Note

At the moment, there is no equivalent to `getSnapshotBeforeUpdate` for function components. This use case is very uncommon, but if you have the need for it, for now you’ll have to write a class component.

---

### `render()`

The `render` method is the only required method in a class component.

The `render` method should specify what you want to appear on the screen, for example:

```
import { Component } from 'react';

class Greeting extends Component {

render() {

return <h1>Hello, {this.props.name}!</h1>;

}

}
```

React may call `render` at any moment, so you shouldn’t assume that it runs at a particular time. Usually, the `render` method should return a piece of [JSX](https://react.dev/learn/writing-markup-with-jsx), but a few [other return types](https://react.dev/reference/react/Component#render-returns) (like strings) are supported. To calculate the returned JSX, the `render` method can read [`this.props`](https://react.dev/reference/react/Component#props), [`this.state`](https://react.dev/reference/react/Component#state), and [`this.context`](https://react.dev/reference/react/Component#context).

You should write the `render` method as a pure function, meaning that it should return the same result if props, state, and context are the same. It also shouldn’t contain side effects (like setting up subscriptions) or interact with the browser APIs. Side effects should happen either in event handlers or methods like [`componentDidMount`.](https://react.dev/reference/react/Component#componentdidmount)

#### Parameters

`render` does not take any parameters.

#### Returns

`render` can return any valid React node. This includes React elements such as `<div />`, strings, numbers, [portals](https://react.dev/reference/react-dom/createPortal), empty nodes (`null`, `undefined`, `true`, and `false`), and arrays of React nodes.

#### Caveats

* `render` should be written as a pure function of props, state, and context. It should not have side effects.
* `render` will not get called if [`shouldComponentUpdate`](https://react.dev/reference/react/Component#shouldcomponentupdate) is defined and returns `false`.
* When [Strict Mode](https://react.dev/reference/react/StrictMode) is on, React will call `render` twice in development and then throw away one of the results. This helps you notice the accidental side effects that need to be moved out of the `render` method.
* There is no one-to-one correspondence between the `render` call and the subsequent `componentDidMount` or `componentDidUpdate` call. Some of the `render` call results may be discarded by React when it’s beneficial.

---

### `setState(nextState, callback?)`

Call `setState` to update the state of your React component.

```
class Form extends Component {

state = {

name: 'Taylor',

};

handleNameChange = (e) => {

const newName = e.target.value;

this.setState({

name: newName

});

}

render() {

return (

<>

<input value={this.state.name} onChange={this.handleNameChange} />

<p>Hello, {this.state.name}.</p>

</>

);

}

}
```

`setState` enqueues changes to the component state. It tells React that this component and its children need to re-render with the new state. This is the main way you’ll update the user interface in response to interactions.

### Pitfall

Calling `setState` **does not** change the current state in the already executing code:

```
function handleClick() {

console.log(this.state.name); // "Taylor"

this.setState({

name: 'Robin'

});

console.log(this.state.name); // Still "Taylor"!

}
```

It only affects what `this.state` will return starting from the *next* render.

You can also pass a function to `setState`. It lets you update state based on the previous state:

```
handleIncreaseAge = () => {

this.setState(prevState => {

return {

age: prevState.age + 1

};

});

}
```

You don’t have to do this, but it’s handy if you want to update state multiple times during the same event.

#### Parameters

* `nextState`: Either an object or a function.

  + If you pass an object as `nextState`, it will be shallowly merged into `this.state`.
  + If you pass a function as `nextState`, it will be treated as an *updater function*. It must be pure, should take the pending state and props as arguments, and should return the object to be shallowly merged into `this.state`. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state.
* **optional** `callback`: If specified, React will call the `callback` you’ve provided after the update is committed.

#### Returns

`setState` does not return anything.

#### Caveats

* Think of `setState` as a *request* rather than an immediate command to update the component. When multiple components update their state in response to an event, React will batch their updates and re-render them together in a single pass at the end of the event. In the rare case that you need to force a particular state update to be applied synchronously, you may wrap it in [`flushSync`,](https://react.dev/reference/react-dom/flushSync) but this may hurt performance.
* `setState` does not update `this.state` immediately. This makes reading `this.state` right after calling `setState` a potential pitfall. Instead, use [`componentDidUpdate`](https://react.dev/reference/react/Component#componentdidupdate) or the setState `callback` argument, either of which are guaranteed to fire after the update has been applied. If you need to set the state based on the previous state, you can pass a function to `nextState` as described above.

### Note

Calling `setState` in class components is similar to calling a [`set` function](https://react.dev/reference/react/useState#setstate) in function components.

[See how to migrate.](https://react.dev/reference/react/Component#migrating-a-component-with-state-from-a-class-to-a-function)

---

### `shouldComponentUpdate(nextProps, nextState, nextContext)`

If you define `shouldComponentUpdate`, React will call it to determine whether a re-render can be skipped.

If you are confident you want to write it by hand, you may compare `this.props` with `nextProps` and `this.state` with `nextState` and return `false` to tell React the update can be skipped.

```
class Rectangle extends Component {

state = {

isHovered: false

};

shouldComponentUpdate(nextProps, nextState) {

if (

nextProps.position.x === this.props.position.x &&

nextProps.position.y === this.props.position.y &&

nextProps.size.width === this.props.size.width &&

nextProps.size.height === this.props.size.height &&

nextState.isHovered === this.state.isHovered

) {

// Nothing has changed, so a re-render is unnecessary

return false;

}

return true;

}

// ...

}
```

React calls `shouldComponentUpdate` before rendering when new props or state are being received. Defaults to `true`. This method is not called for the initial render or when [`forceUpdate`](https://react.dev/reference/react/Component#forceupdate) is used.

#### Parameters

* `nextProps`: The next props that the component is about to render with. Compare `nextProps` to [`this.props`](https://react.dev/reference/react/Component#props) to determine what changed.
* `nextState`: The next state that the component is about to render with. Compare `nextState` to [`this.state`](https://react.dev/reference/react/Component#props) to determine what changed.
* `nextContext`: The next context that the component is about to render with. Compare `nextContext` to [`this.context`](https://react.dev/reference/react/Component#context) to determine what changed. Only available if you specify [`static contextType`](https://react.dev/reference/react/Component#static-contexttype).

#### Returns

Return `true` if you want the component to re-render. That’s the default behavior.

Return `false` to tell React that re-rendering can be skipped.

#### Caveats

* This method *only* exists as a performance optimization. If your component breaks without it, fix that first.
* Consider using [`PureComponent`](https://react.dev/reference/react/PureComponent) instead of writing `shouldComponentUpdate` by hand. `PureComponent` shallowly compares props and state, and reduces the chance that you’ll skip a necessary update.
* We do not recommend doing deep equality checks or using `JSON.stringify` in `shouldComponentUpdate`. It makes performance unpredictable and dependent on the data structure of every prop and state. In the best case, you risk introducing multi-second stalls to your application, and in the worst case you risk crashing it.
* Returning `false` does not prevent child components from re-rendering when *their* state changes.
* Returning `false` does not *guarantee* that the component will not re-render. React will use the return value as a hint but it may still choose to re-render your component if it makes sense to do for other reasons.

### Note

Optimizing class components with `shouldComponentUpdate` is similar to optimizing function components with [`memo`.](https://react.dev/reference/react/memo) Function components also offer more granular optimization with [`useMemo`.](https://react.dev/reference/react/useMemo)

---

### `UNSAFE_componentWillMount()`

If you define `UNSAFE_componentWillMount`, React will call it immediately after the [`constructor`.](https://react.dev/reference/react/Component#constructor) It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:

* To initialize state, declare [`state`](https://react.dev/reference/react/Component#state) as a class field or set `this.state` inside the [`constructor`.](https://react.dev/reference/react/Component#constructor)
* If you need to run a side effect or set up a subscription, move that logic to [`componentDidMount`](https://react.dev/reference/react/Component#componentdidmount) instead.

[See examples of migrating away from unsafe lifecycles.](https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples)

#### Parameters

`UNSAFE_componentWillMount` does not take any parameters.

#### Returns

`UNSAFE_componentWillMount` should not return anything.

#### Caveats

* `UNSAFE_componentWillMount` will not get called if the component implements [`static getDerivedStateFromProps`](https://react.dev/reference/react/Component#static-getderivedstatefromprops) or [`getSnapshotBeforeUpdate`.](https://react.dev/reference/react/Component#getsnapshotbeforeupdate)
* Despite its naming, `UNSAFE_componentWillMount` does not guarantee that the component *will* get mounted if your app uses modern React features like [`Suspense`.](https://react.dev/reference/react/Suspense) If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. This is why this method is “unsafe”. Code that relies on mounting (like adding a subscription) should go into [`componentDidMount`.](https://react.dev/reference/react/Component#componentdidmount)
* `UNSAFE_componentWillMount` is the only lifecycle method that runs during [server rendering.](https://react.dev/reference/react-dom/server) For all practical purposes, it is identical to [`constructor`,](https://react.dev/reference/react/Component#constructor) so you should use the `constructor` for this type of logic instead.

### Note

Calling [`setState`](https://react.dev/reference/react/Component#setstate) inside `UNSAFE_componentWillMount` in a class component to initialize state is equivalent to passing that state as the initial state to [`useState`](https://react.dev/reference/react/useState) in a function component.

---

### `UNSAFE_componentWillReceiveProps(nextProps, nextContext)`

If you define `UNSAFE_componentWillReceiveProps`, React will call it when the component receives new props. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:

* If you need to **run a side effect** (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop changes, move that logic to [`componentDidUpdate`](https://react.dev/reference/react/Component#componentdidupdate) instead.
* If you need to **avoid re-computing some data only when a prop changes,** use a [memoization helper](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization) instead.
* If you need to **“reset” some state when a prop changes,** consider either making a component [fully controlled](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component) or [fully uncontrolled with a key](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key) instead.
* If you need to **“adjust” some state when a prop changes,** check whether you can compute all the necessary information from props alone during rendering. If you can’t, use [`static getDerivedStateFromProps`](https://react.dev/reference/react/Component#static-getderivedstatefromprops) instead.

[See examples of migrating away from unsafe lifecycles.](https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props)

#### Parameters

* `nextProps`: The next props that the component is about to receive from its parent component. Compare `nextProps` to [`this.props`](https://react.dev/reference/react/Component#props) to determine what changed.
* `nextContext`: The next context that the component is about to receive from the closest provider. Compare `nextContext` to [`this.context`](https://react.dev/reference/react/Component#context) to determine what changed. Only available if you specify [`static contextType`](https://react.dev/reference/react/Component#static-contexttype).

#### Returns

`UNSAFE_componentWillReceiveProps` should not return anything.

#### Caveats

* `UNSAFE_componentWillReceiveProps` will not get called if the component implements [`static getDerivedStateFromProps`](https://react.dev/reference/react/Component#static-getderivedstatefromprops) or [`getSnapshotBeforeUpdate`.](https://react.dev/reference/react/Component#getsnapshotbeforeupdate)
* Despite its naming, `UNSAFE_componentWillReceiveProps` does not guarantee that the component *will* receive those props if your app uses modern React features like [`Suspense`.](https://react.dev/reference/react/Suspense) If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into [`componentDidUpdate`.](https://react.dev/reference/react/Component#componentdidupdate)
* `UNSAFE_componentWillReceiveProps` does not mean that the component has received *different* props than the last time. You need to compare `nextProps` and `this.props` yourself to check if something changed.
* React doesn’t call `UNSAFE_componentWillReceiveProps` with initial props during mounting. It only calls this method if some of component’s props are going to be updated. For example, calling [`setState`](https://react.dev/reference/react/Component#setstate) doesn’t generally trigger `UNSAFE_componentWillReceiveProps` inside the same component.

### Note

Calling [`setState`](https://react.dev/reference/react/Component#setstate) inside `UNSAFE_componentWillReceiveProps` in a class component to “adjust” state is equivalent to [calling the `set` function from `useState` during rendering](https://react.dev/reference/react/useState#storing-information-from-previous-renders) in a function component.

---

### `UNSAFE_componentWillUpdate(nextProps, nextState)`

If you define `UNSAFE_componentWillUpdate`, React will call it before rendering with the new props or state. It only exists for historical reasons and should not be used in any new code. Instead, use one of the alternatives:

* If you need to run a side effect (for example, fetch data, run an animation, or reinitialize a subscription) in response to prop or state changes, move that logic to [`componentDidUpdate`](https://react.dev/reference/react/Component#componentdidupdate) instead.
* If you need to read some information from the DOM (for example, to save the current scroll position) so that you can use it in [`componentDidUpdate`](https://react.dev/reference/react/Component#componentdidupdate) later, read it inside [`getSnapshotBeforeUpdate`](https://react.dev/reference/react/Component#getsnapshotbeforeupdate) instead.

[See examples of migrating away from unsafe lifecycles.](https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples)

#### Parameters

* `nextProps`: The next props that the component is about to render with. Compare `nextProps` to [`this.props`](https://react.dev/reference/react/Component#props) to determine what changed.
* `nextState`: The next state that the component is about to render with. Compare `nextState` to [`this.state`](https://react.dev/reference/react/Component#state) to determine what changed.

#### Returns

`UNSAFE_componentWillUpdate` should not return anything.

#### Caveats

* `UNSAFE_componentWillUpdate` will not get called if [`shouldComponentUpdate`](https://react.dev/reference/react/Component#shouldcomponentupdate) is defined and returns `false`.
* `UNSAFE_componentWillUpdate` will not get called if the component implements [`static getDerivedStateFromProps`](https://react.dev/reference/react/Component#static-getderivedstatefromprops) or [`getSnapshotBeforeUpdate`.](https://react.dev/reference/react/Component#getsnapshotbeforeupdate)
* It’s not supported to call [`setState`](https://react.dev/reference/react/Component#setstate) (or any method that leads to `setState` being called, like dispatching a Redux action) during `componentWillUpdate`.
* Despite its naming, `UNSAFE_componentWillUpdate` does not guarantee that the component *will* update if your app uses modern React features like [`Suspense`.](https://react.dev/reference/react/Suspense) If a render attempt is suspended (for example, because the code for some child component has not loaded yet), React will throw the in-progress tree away and attempt to construct the component from scratch during the next attempt. By the time of the next render attempt, the props and state might be different. This is why this method is “unsafe”. Code that should run only for committed updates (like resetting a subscription) should go into [`componentDidUpdate`.](https://react.dev/reference/react/Component#componentdidupdate)
* `UNSAFE_componentWillUpdate` does not mean that the component has received *different* props or state than the last time. You need to compare `nextProps` with `this.props` and `nextState` with `this.state` yourself to check if something changed.
* React doesn’t call `UNSAFE_componentWillUpdate` with initial props and state during mounting.

### Note

There is no direct equivalent to `UNSAFE_componentWillUpdate` in function components.

---

### `static contextType`

If you want to read [`this.context`](https://react.dev/reference/react/Component#context-instance-field) from your class component, you must specify which context it needs to read. The context you specify as the `static contextType` must be a value previously created by [`createContext`.](https://react.dev/reference/react/createContext)

```
class Button extends Component {

static contextType = ThemeContext;

render() {

const theme = this.context;

const className = 'button-' + theme;

return (

<button className={className}>

{this.props.children}

</button>

);

}

}
```

### Note

Reading `this.context` in class components is equivalent to [`useContext`](https://react.dev/reference/react/useContext) in function components.

[See how to migrate.](https://react.dev/reference/react/Component#migrating-a-component-with-context-from-a-class-to-a-function)

---

### `static defaultProps`

You can define `static defaultProps` to set the default props for the class. They will be used for `undefined` and missing props, but not for `null` props.

For example, here is how you define that the `color` prop should default to `'blue'`:

```
class Button extends Component {

static defaultProps = {

color: 'blue'

};

render() {

return <button className={this.props.color}>click me</button>;

}

}
```

If the `color` prop is not provided or is `undefined`, it will be set by default to `'blue'`:

```
<>

{/* this.props.color is "blue" */}

<Button />

{/* this.props.color is "blue" */}

<Button color={undefined} />

{/* this.props.color is null */}

<Button color={null} />

{/* this.props.color is "red" */}

<Button color="red" />

</>
```

### Note

Defining `defaultProps` in class components is similar to using [default values](https://react.dev/learn/passing-props-to-a-component#specifying-a-default-value-for-a-prop) in function components.

---

### `static getDerivedStateFromError(error)`

If you define `static getDerivedStateFromError`, React will call it when a child component (including distant children) throws an error during rendering. This lets you display an error message instead of clearing the UI.

Typically, it is used together with [`componentDidCatch`](https://react.dev/reference/react/Component#componentdidcatch) which lets you send the error report to some analytics service. A component with these methods is called an *Error Boundary*.

[See an example.](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)

#### Parameters

* `error`: The error that was thrown. In practice, it will usually be an instance of [`Error`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) but this is not guaranteed because JavaScript allows to [`throw`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw) any value, including strings or even `null`.

#### Returns

`static getDerivedStateFromError` should return the state telling the component to display the error message.

#### Caveats

* `static getDerivedStateFromError` should be a pure function. If you want to perform a side effect (for example, to call an analytics service), you need to also implement [`componentDidCatch`.](https://react.dev/reference/react/Component#componentdidcatch)

### Note

There is no direct equivalent for `static getDerivedStateFromError` in function components yet. If you’d like to avoid creating class components, write a single `ErrorBoundary` component like above and use it throughout your app. Alternatively, use the [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) package which does that.

---

### `static getDerivedStateFromProps(props, state)`

If you define `static getDerivedStateFromProps`, React will call it right before calling [`render`,](https://react.dev/reference/react/Component#render) both on the initial mount and on subsequent updates. It should return an object to update the state, or `null` to update nothing.

This method exists for [rare use cases](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#when-to-use-derived-state) where the state depends on changes in props over time. For example, this `Form` component resets the `email` state when the `userID` prop changes:

```
class Form extends Component {

state = {

email: this.props.defaultEmail,

prevUserID: this.props.userID

};

static getDerivedStateFromProps(props, state) {

// Any time the current user changes,

// Reset any parts of state that are tied to that user.

// In this simple example, that's just the email.

if (props.userID !== state.prevUserID) {

return {

prevUserID: props.userID,

email: props.defaultEmail

};

}

return null;

}

// ...

}
```

Note that this pattern requires you to keep a previous value of the prop (like `userID`) in state (like `prevUserID`).

### Pitfall

Deriving state leads to verbose code and makes your components difficult to think about. [Make sure you’re familiar with simpler alternatives:](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html)

* If you need to **perform a side effect** (for example, data fetching or an animation) in response to a change in props, use [`componentDidUpdate`](https://react.dev/reference/react/Component#componentdidupdate) method instead.
* If you want to **re-compute some data only when a prop changes,** [use a memoization helper instead.](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization)
* If you want to **“reset” some state when a prop changes,** consider either making a component [fully controlled](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component) or [fully uncontrolled with a key](https://legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key) instead.

#### Parameters

* `props`: The next props that the component is about to render with.
* `state`: The next state that the component is about to render with.

#### Returns

`static getDerivedStateFromProps` return an object to update the state, or `null` to update nothing.

#### Caveats

* This method is fired on *every* render, regardless of the cause. This is different from [`UNSAFE_componentWillReceiveProps`](https://react.dev/reference/react/Component#unsafe_cmoponentwillreceiveprops), which only fires when the parent causes a re-render and not as a result of a local `setState`.
* This method doesn’t have access to the component instance. If you’d like, you can reuse some code between `static getDerivedStateFromProps` and the other class methods by extracting pure functions of the component props and state outside the class definition.

### Note

Implementing `static getDerivedStateFromProps` in a class component is equivalent to [calling the `set` function from `useState` during rendering](https://react.dev/reference/react/useState#storing-information-from-previous-renders) in a function component.

---

## Usage

### Defining a class component

To define a React component as a class, extend the built-in `Component` class and define a [`render` method:](https://react.dev/reference/react/Component#render)

```
import { Component } from 'react';

class Greeting extends Component {

render() {

return <h1>Hello, {this.props.name}!</h1>;

}

}
```

React will call your [`render`](https://react.dev/reference/react/Component#render) method whenever it needs to figure out what to display on the screen. Usually, you will return some [JSX](https://react.dev/learn/writing-markup-with-jsx) from it. Your `render` method should be a [pure function:](https://en.wikipedia.org/wiki/Pure_function) it should only calculate the JSX.

Similarly to [function components,](https://react.dev/learn/your-first-component#defining-a-component) a class component can [receive information by props](https://react.dev/learn/your-first-component#defining-a-component) from its parent component. However, the syntax for reading props is different. For example, if the parent component renders `<Greeting name="Taylor" />`, then you can read the `name` prop from [`this.props`](https://react.dev/reference/react/Component#props), like `this.props.name`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component } from 'react';

class Greeting extends Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

export default function App() {
  return (
    <>
      <Greeting name="Sara" />
      <Greeting name="Cahal" />
      <Greeting name="Edite" />
    </>
  );
}
```

Show more

Note that Hooks (functions starting with `use`, like [`useState`](https://react.dev/reference/react/useState)) are not supported inside class components.

### Pitfall

We recommend defining components as functions instead of classes. [See how to migrate.](https://react.dev/reference/react/Component#migrating-a-simple-component-from-a-class-to-a-function)

---

### Adding state to a class component

To add [state](https://react.dev/learn/state-a-components-memory) to a class, assign an object to a property called [`state`](https://react.dev/reference/react/Component#state). To update state, call [`this.setState`](https://react.dev/reference/react/Component#setstate).

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component } from 'react';

export default class Counter extends Component {
  state = {
    name: 'Taylor',
    age: 42,
  };

  handleNameChange = (e) => {
    this.setState({
      name: e.target.value
    });
  }

  handleAgeChange = () => {
    this.setState({
      age: this.state.age + 1 
    });
  };

  render() {
    return (
      <>
        <input
          value={this.state.name}
          onChange={this.handleNameChange}
        />
        <button onClick={this.handleAgeChange}>
          Increment age
        </button>
        <p>Hello, {this.state.name}. You are {this.state.age}.</p>
      </>
    );
  }
}
```

Show more

### Pitfall

We recommend defining components as functions instead of classes. [See how to migrate.](https://react.dev/reference/react/Component#migrating-a-component-with-state-from-a-class-to-a-function)

---

### Adding lifecycle methods to a class component

There are a few special methods you can define on your class.

If you define the [`componentDidMount`](https://react.dev/reference/react/Component#componentdidmount) method, React will call it when your component is added *(mounted)* to the screen. React will call [`componentDidUpdate`](https://react.dev/reference/react/Component#componentdidupdate) after your component re-renders due to changed props or state. React will call [`componentWillUnmount`](https://react.dev/reference/react/Component#componentwillunmount) after your component has been removed *(unmounted)* from the screen.

If you implement `componentDidMount`, you usually need to implement all three lifecycles to avoid bugs. For example, if `componentDidMount` reads some state or props, you also have to implement `componentDidUpdate` to handle their changes, and `componentWillUnmount` to clean up whatever `componentDidMount` was doing.

For example, this `ChatRoom` component keeps a chat connection synchronized with props and state:

App.jsChatRoom.jschat.js

ChatRoom.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component } from 'react';
import { createConnection } from './chat.js';

export default class ChatRoom extends Component {
  state = {
    serverUrl: 'https://localhost:1234'
  };

  componentDidMount() {
    this.setupConnection();
  }

  componentDidUpdate(prevProps, prevState) {
    if (
      this.props.roomId !== prevProps.roomId ||
      this.state.serverUrl !== prevState.serverUrl
    ) {
      this.destroyConnection();
      this.setupConnection();
    }
  }

  componentWillUnmount() {
    this.destroyConnection();
  }

  setupConnection() {
    this.connection = createConnection(
      this.state.serverUrl,
      this.props.roomId
    );
    this.connection.connect();    
  }

  destroyConnection() {
    this.connection.disconnect();
    this.connection = null;
  }

  render() {
    return (
      <>
        <label>
          Server URL:{' '}
          <input
            value={this.state.serverUrl}
            onChange={e => {
              this.setState({
                serverUrl: e.target.value
              });
            }}
          />
        </label>
        <h1>Welcome to the {this.props.roomId} room!</h1>
      </>
    );
  }
}
```

Show more

Note that in development when [Strict Mode](https://react.dev/reference/react/StrictMode) is on, React will call `componentDidMount`, immediately call `componentWillUnmount`, and then call `componentDidMount` again. This helps you notice if you forgot to implement `componentWillUnmount` or if its logic doesn’t fully “mirror” what `componentDidMount` does.

### Pitfall

We recommend defining components as functions instead of classes. [See how to migrate.](https://react.dev/reference/react/Component#migrating-a-component-with-lifecycle-methods-from-a-class-to-a-function)

---

### Catching rendering errors with an Error Boundary

By default, if your application throws an error during rendering, React will remove its UI from the screen. To prevent this, you can wrap a part of your UI into an *Error Boundary*. An Error Boundary is a special component that lets you display some fallback UI instead of the part that crashed—for example, an error message.

### Note

Error boundaries do not catch errors for:

* Event handlers [(learn more)](https://react.dev/learn/responding-to-events)
* [Server side rendering](https://react.dev/reference/react-dom/server)
* Errors thrown in the error boundary itself (rather than its children)
* Asynchronous code (e.g. `setTimeout` or `requestAnimationFrame` callbacks); an exception is the usage of the [`startTransition`](https://react.dev/reference/react/useTransition#starttransition) function returned by the [`useTransition`](https://react.dev/reference/react/useTransition) Hook. Errors thrown inside the transition function are caught by error boundaries [(learn more)](https://react.dev/reference/react/useTransition#displaying-an-error-to-users-with-error-boundary)

To implement an Error Boundary component, you need to provide [`static getDerivedStateFromError`](https://react.dev/reference/react/Component#static-getderivedstatefromerror) which lets you update state in response to an error and display an error message to the user. You can also optionally implement [`componentDidCatch`](https://react.dev/reference/react/Component#componentdidcatch) to add some extra logic, for example, to log the error to an analytics service.

With [`captureOwnerStack`](https://react.dev/reference/react/captureOwnerStack) you can include the Owner Stack during development.

```
import * as React from 'react';

class ErrorBoundary extends React.Component {

constructor(props) {

super(props);

this.state = { hasError: false };

}

static getDerivedStateFromError(error) {

// Update state so the next render will show the fallback UI.

return { hasError: true };

}

componentDidCatch(error, info) {

logErrorToMyService(

error,

// Example "componentStack":

//   in ComponentThatThrows (created by App)

//   in ErrorBoundary (created by App)

//   in div (created by App)

//   in App

info.componentStack,

// Warning: `captureOwnerStack` is not available in production.

React.captureOwnerStack(),

);

}

render() {

if (this.state.hasError) {

// You can render any custom fallback UI

return this.props.fallback;

}

return this.props.children;

}

}
```

Then you can wrap a part of your component tree with it:

```
<ErrorBoundary fallback={<p>Something went wrong</p>}>

<Profile />

</ErrorBoundary>
```

If `Profile` or its child component throws an error, `ErrorBoundary` will “catch” that error, display a fallback UI with the error message you’ve provided, and send a production error report to your error reporting service.

You don’t need to wrap every component into a separate Error Boundary. When you think about the [granularity of Error Boundaries,](https://www.brandondail.com/posts/fault-tolerance-react) consider where it makes sense to display an error message. For example, in a messaging app, it makes sense to place an Error Boundary around the list of conversations. It also makes sense to place one around every individual message. However, it wouldn’t make sense to place a boundary around every avatar.

### Note

There is currently no way to write an Error Boundary as a function component. However, you don’t have to write the Error Boundary class yourself. For example, you can use [`react-error-boundary`](https://github.com/bvaughn/react-error-boundary) instead.

---

## Alternatives

### Migrating a simple component from a class to a function

Typically, you will [define components as functions](https://react.dev/learn/your-first-component#defining-a-component) instead.

For example, suppose you’re converting this `Greeting` class component to a function:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component } from 'react';

class Greeting extends Component {
  render() {
    return <h1>Hello, {this.props.name}!</h1>;
  }
}

export default function App() {
  return (
    <>
      <Greeting name="Sara" />
      <Greeting name="Cahal" />
      <Greeting name="Edite" />
    </>
  );
}
```

Show more

Define a function called `Greeting`. This is where you will move the body of your `render` function.

```
function Greeting() {

// ... move the code from the render method here ...

}
```

Instead of `this.props.name`, define the `name` prop [using the destructuring syntax](https://react.dev/learn/passing-props-to-a-component) and read it directly:

```
function Greeting({ name }) {

return <h1>Hello, {name}!</h1>;

}
```

Here is a complete example:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Greeting({ name }) {
  return <h1>Hello, {name}!</h1>;
}

export default function App() {
  return (
    <>
      <Greeting name="Sara" />
      <Greeting name="Cahal" />
      <Greeting name="Edite" />
    </>
  );
}
```

---

### Migrating a component with state from a class to a function

Suppose you’re converting this `Counter` class component to a function:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component } from 'react';

export default class Counter extends Component {
  state = {
    name: 'Taylor',
    age: 42,
  };

  handleNameChange = (e) => {
    this.setState({
      name: e.target.value
    });
  }

  handleAgeChange = (e) => {
    this.setState({
      age: this.state.age + 1 
    });
  };

  render() {
    return (
      <>
        <input
          value={this.state.name}
          onChange={this.handleNameChange}
        />
        <button onClick={this.handleAgeChange}>
          Increment age
        </button>
        <p>Hello, {this.state.name}. You are {this.state.age}.</p>
      </>
    );
  }
}
```

Show more

Start by declaring a function with the necessary [state variables:](https://react.dev/reference/react/useState#adding-state-to-a-component)

```
import { useState } from 'react';

function Counter() {

const [name, setName] = useState('Taylor');

const [age, setAge] = useState(42);

// ...
```

Next, convert the event handlers:

```
function Counter() {

const [name, setName] = useState('Taylor');

const [age, setAge] = useState(42);

function handleNameChange(e) {

setName(e.target.value);

}

function handleAgeChange() {

setAge(age + 1);

}

// ...
```

Finally, replace all references starting with `this` with the variables and functions you defined in your component. For example, replace `this.state.age` with `age`, and replace `this.handleNameChange` with `handleNameChange`.

Here is a fully converted component:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState } from 'react';

export default function Counter() {
  const [name, setName] = useState('Taylor');
  const [age, setAge] = useState(42);

  function handleNameChange(e) {
    setName(e.target.value);
  }

  function handleAgeChange() {
    setAge(age + 1);
  }

  return (
    <>
      <input
        value={name}
        onChange={handleNameChange}
      />
      <button onClick={handleAgeChange}>
        Increment age
      </button>
      <p>Hello, {name}. You are {age}.</p>
    </>
  )
}
```

Show more

---

### Migrating a component with lifecycle methods from a class to a function

Suppose you’re converting this `ChatRoom` class component with lifecycle methods to a function:

App.jsChatRoom.jschat.js

ChatRoom.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component } from 'react';
import { createConnection } from './chat.js';

export default class ChatRoom extends Component {
  state = {
    serverUrl: 'https://localhost:1234'
  };

  componentDidMount() {
    this.setupConnection();
  }

  componentDidUpdate(prevProps, prevState) {
    if (
      this.props.roomId !== prevProps.roomId ||
      this.state.serverUrl !== prevState.serverUrl
    ) {
      this.destroyConnection();
      this.setupConnection();
    }
  }

  componentWillUnmount() {
    this.destroyConnection();
  }

  setupConnection() {
    this.connection = createConnection(
      this.state.serverUrl,
      this.props.roomId
    );
    this.connection.connect();    
  }

  destroyConnection() {
    this.connection.disconnect();
    this.connection = null;
  }

  render() {
    return (
      <>
        <label>
          Server URL:{' '}
          <input
            value={this.state.serverUrl}
            onChange={e => {
              this.setState({
                serverUrl: e.target.value
              });
            }}
          />
        </label>
        <h1>Welcome to the {this.props.roomId} room!</h1>
      </>
    );
  }
}
```

Show more

First, verify that your [`componentWillUnmount`](https://react.dev/reference/react/Component#componentwillunmount) does the opposite of [`componentDidMount`.](https://react.dev/reference/react/Component#componentdidmount) In the above example, that’s true: it disconnects the connection that `componentDidMount` sets up. If such logic is missing, add it first.

Next, verify that your [`componentDidUpdate`](https://react.dev/reference/react/Component#componentdidupdate) method handles changes to any props and state you’re using in `componentDidMount`. In the above example, `componentDidMount` calls `setupConnection` which reads `this.state.serverUrl` and `this.props.roomId`. This is why `componentDidUpdate` checks whether `this.state.serverUrl` and `this.props.roomId` have changed, and resets the connection if they did. If your `componentDidUpdate` logic is missing or doesn’t handle changes to all relevant props and state, fix that first.

In the above example, the logic inside the lifecycle methods connects the component to a system outside of React (a chat server). To connect a component to an external system, [describe this logic as a single Effect:](https://react.dev/reference/react/useEffect#connecting-to-an-external-system)

```
import { useState, useEffect } from 'react';

function ChatRoom({ roomId }) {

const [serverUrl, setServerUrl] = useState('https://localhost:1234');

useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}, [serverUrl, roomId]);

// ...

}
```

This [`useEffect`](https://react.dev/reference/react/useEffect) call is equivalent to the logic in the lifecycle methods above. If your lifecycle methods do multiple unrelated things, [split them into multiple independent Effects.](https://react.dev/learn/removing-effect-dependencies#is-your-effect-doing-several-unrelated-things) Here is a complete example you can play with:

App.jsChatRoom.jschat.js

ChatRoom.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from 'react';
import { createConnection } from './chat.js';

export default function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234');

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]);

  return (
    <>
      <label>
        Server URL:{' '}
        <input
          value={serverUrl}
          onChange={e => setServerUrl(e.target.value)}
        />
      </label>
      <h1>Welcome to the {roomId} room!</h1>
    </>
  );
}
```

Show more

### Note

If your component does not synchronize with any external systems, [you might not need an Effect.](https://react.dev/learn/you-might-not-need-an-effect)

---

### Migrating a component with context from a class to a function

In this example, the `Panel` and `Button` class components read [context](https://react.dev/learn/passing-data-deeply-with-context) from [`this.context`:](https://react.dev/reference/react/Component#context)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext, Component } from 'react';

const ThemeContext = createContext(null);

class Panel extends Component {
  static contextType = ThemeContext;

  render() {
    const theme = this.context;
    const className = 'panel-' + theme;
    return (
      <section className={className}>
        <h1>{this.props.title}</h1>
        {this.props.children}
      </section>
    );    
  }
}

class Button extends Component {
  static contextType = ThemeContext;

  render() {
    const theme = this.context;
    const className = 'button-' + theme;
    return (
      <button className={className}>
        {this.props.children}
      </button>
    );
  }
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}
```

Show more

When you convert them to function components, replace `this.context` with [`useContext`](https://react.dev/reference/react/useContext) calls:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createContext, useContext } from 'react';

const ThemeContext = createContext(null);

function Panel({ title, children }) {
  const theme = useContext(ThemeContext);
  const className = 'panel-' + theme;
  return (
    <section className={className}>
      <h1>{title}</h1>
      {children}
    </section>
  )
}

function Button({ children }) {
  const theme = useContext(ThemeContext);
  const className = 'button-' + theme;
  return (
    <button className={className}>
      {children}
    </button>
  );
}

function Form() {
  return (
    <Panel title="Welcome">
      <Button>Sign up</Button>
      <Button>Log in</Button>
    </Panel>
  );
}

export default function MyApp() {
  return (
    <ThemeContext value="dark">
      <Form />
    </ThemeContext>
  )
}
```

Show more

[PreviouscloneElement](https://react.dev/reference/react/cloneElement)[NextcreateElement](https://react.dev/reference/react/createElement)

---

---


# createElement – React

URL: https://react.dev/reference/react/createElement

[API Reference](https://react.dev/reference/react)

[Legacy React APIs](https://react.dev/reference/react/legacy)

# createElement

`createElement` lets you create a React element. It serves as an alternative to writing [JSX.](https://react.dev/learn/writing-markup-with-jsx)

```
const element = createElement(type, props, ...children)
```

* [Reference](https://react.dev/reference/react/createElement#reference) 
  + [`createElement(type, props, ...children)`](https://react.dev/reference/react/createElement#createelement)
* [Usage](https://react.dev/reference/react/createElement#usage) 
  + [Creating an element without JSX](https://react.dev/reference/react/createElement#creating-an-element-without-jsx)

---

## Reference

### `createElement(type, props, ...children)`

Call `createElement` to create a React element with the given `type`, `props`, and `children`.

```
import { createElement } from 'react';

function Greeting({ name }) {

return createElement(

'h1',

{ className: 'greeting' },

'Hello'

);

}
```

[See more examples below.](https://react.dev/reference/react/createElement#usage)

#### Parameters

* `type`: The `type` argument must be a valid React component type. For example, it could be a tag name string (such as `'div'` or `'span'`), or a React component (a function, a class, or a special component like [`Fragment`](https://react.dev/reference/react/Fragment)).
* `props`: The `props` argument must either be an object or `null`. If you pass `null`, it will be treated the same as an empty object. React will create an element with props matching the `props` you have passed. Note that `ref` and `key` from your `props` object are special and will *not* be available as `element.props.ref` and `element.props.key` on the returned `element`. They will be available as `element.ref` and `element.key`.
* **optional** `...children`: Zero or more child nodes. They can be any React nodes, including React elements, strings, numbers, [portals](https://react.dev/reference/react-dom/createPortal), empty nodes (`null`, `undefined`, `true`, and `false`), and arrays of React nodes.

#### Returns

`createElement` returns a React element object with a few properties:

* `type`: The `type` you have passed.
* `props`: The `props` you have passed except for `ref` and `key`.
* `ref`: The `ref` you have passed. If missing, `null`.
* `key`: The `key` you have passed, coerced to a string. If missing, `null`.

Usually, you’ll return the element from your component or make it a child of another element. Although you may read the element’s properties, it’s best to treat every element as opaque after it’s created, and only render it.

#### Caveats

* You must **treat React elements and their props as [immutable](https://en.wikipedia.org/wiki/Immutable_object)** and never change their contents after creation. In development, React will [freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) the returned element and its `props` property shallowly to enforce this.
* When you use JSX, **you must start a tag with a capital letter to render your own custom component.** In other words, `<Something />` is equivalent to `createElement(Something)`, but `<something />` (lowercase) is equivalent to `createElement('something')` (note it’s a string, so it will be treated as a built-in HTML tag).
* You should only **pass children as multiple arguments to `createElement` if they are all statically known,** like `createElement('h1', {}, child1, child2, child3)`. If your children are dynamic, pass the entire array as the third argument: `createElement('ul', {}, listItems)`. This ensures that React will [warn you about missing `key`s](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) for any dynamic lists. For static lists this is not necessary because they never reorder.

---

## Usage

### Creating an element without JSX

If you don’t like [JSX](https://react.dev/learn/writing-markup-with-jsx) or can’t use it in your project, you can use `createElement` as an alternative.

To create an element without JSX, call `createElement` with some type, props, and children:

```
import { createElement } from 'react';

function Greeting({ name }) {

return createElement(

'h1',

{ className: 'greeting' },

'Hello ',

createElement('i', null, name),

'. Welcome!'

);

}
```

The children are optional, and you can pass as many as you need (the example above has three children). This code will display a `<h1>` header with a greeting. For comparison, here is the same example rewritten with JSX:

```
function Greeting({ name }) {

return (

<h1 className="greeting">

Hello <i>{name}</i>. Welcome!

</h1>

);

}
```

To render your own React component, pass a function like `Greeting` as the type instead of a string like `'h1'`:

```
export default function App() {

return createElement(Greeting, { name: 'Taylor' });

}
```

With JSX, it would look like this:

```
export default function App() {

return <Greeting name="Taylor" />;

}
```

Here is a complete example written with `createElement`:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createElement } from 'react';

function Greeting({ name }) {
  return createElement(
    'h1',
    { className: 'greeting' },
    'Hello ',
    createElement('i', null, name),
    '. Welcome!'
  );
}

export default function App() {
  return createElement(
    Greeting,
    { name: 'Taylor' }
  );
}
```

Show more

And here is the same example written using JSX:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
function Greeting({ name }) {
  return (
    <h1 className="greeting">
      Hello <i>{name}</i>. Welcome!
    </h1>
  );
}

export default function App() {
  return <Greeting name="Taylor" />;
}
```

Both coding styles are fine, so you can use whichever one you prefer for your project. The main benefit of using JSX compared to `createElement` is that it’s easy to see which closing tag corresponds to which opening tag.

##### Deep Dive

#### What is a React element, exactly?

Show Details

An element is a lightweight description of a piece of the user interface. For example, both `<Greeting name="Taylor" />` and `createElement(Greeting, { name: 'Taylor' })` produce an object like this:

```
// Slightly simplified

{

type: Greeting,

props: {

name: 'Taylor'

},

key: null,

ref: null,

}
```

**Note that creating this object does not render the `Greeting` component or create any DOM elements.**

A React element is more like a description—an instruction for React to later render the `Greeting` component. By returning this object from your `App` component, you tell React what to do next.

Creating elements is extremely cheap so you don’t need to try to optimize or avoid it.

[PreviousComponent](https://react.dev/reference/react/Component)[NextcreateRef](https://react.dev/reference/react/createRef)

---

---


# createRef – React

URL: https://react.dev/reference/react/createRef

[API Reference](https://react.dev/reference/react)

[Legacy React APIs](https://react.dev/reference/react/legacy)

# createRef

### Pitfall

`createRef` is mostly used for [class components.](https://react.dev/reference/react/Component) Function components typically rely on [`useRef`](https://react.dev/reference/react/useRef) instead.

`createRef` creates a [ref](https://react.dev/learn/referencing-values-with-refs) object which can contain arbitrary value.

```
class MyInput extends Component {

inputRef = createRef();

// ...

}
```

* [Reference](https://react.dev/reference/react/createRef#reference) 
  + [`createRef()`](https://react.dev/reference/react/createRef#createref)
* [Usage](https://react.dev/reference/react/createRef#usage) 
  + [Declaring a ref in a class component](https://react.dev/reference/react/createRef#declaring-a-ref-in-a-class-component)
* [Alternatives](https://react.dev/reference/react/createRef#alternatives) 
  + [Migrating from a class with `createRef` to a function with `useRef`](https://react.dev/reference/react/createRef#migrating-from-a-class-with-createref-to-a-function-with-useref)

---

## Reference

### `createRef()`

Call `createRef` to declare a [ref](https://react.dev/learn/referencing-values-with-refs) inside a [class component.](https://react.dev/reference/react/Component)

```
import { createRef, Component } from 'react';

class MyComponent extends Component {

intervalRef = createRef();

inputRef = createRef();

// ...
```

[See more examples below.](https://react.dev/reference/react/createRef#usage)

#### Parameters

`createRef` takes no parameters.

#### Returns

`createRef` returns an object with a single property:

* `current`: Initially, it’s set to the `null`. You can later set it to something else. If you pass the ref object to React as a `ref` attribute to a JSX node, React will set its `current` property.

#### Caveats

* `createRef` always returns a *different* object. It’s equivalent to writing `{ current: null }` yourself.
* In a function component, you probably want [`useRef`](https://react.dev/reference/react/useRef) instead which always returns the same object.
* `const ref = useRef()` is equivalent to `const [ref, _] = useState(() => createRef(null))`.

---

## Usage

### Declaring a ref in a class component

To declare a ref inside a [class component,](https://react.dev/reference/react/Component) call `createRef` and assign its result to a class field:

```
import { Component, createRef } from 'react';

class Form extends Component {

inputRef = createRef();

// ...

}
```

If you now pass `ref={this.inputRef}` to an `<input>` in your JSX, React will populate `this.inputRef.current` with the input DOM node. For example, here is how you make a button that focuses the input:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component, createRef } from 'react';

export default class Form extends Component {
  inputRef = createRef();

  handleClick = () => {
    this.inputRef.current.focus();
  }

  render() {
    return (
      <>
        <input ref={this.inputRef} />
        <button onClick={this.handleClick}>
          Focus the input
        </button>
      </>
    );
  }
}
```

Show more

### Pitfall

`createRef` is mostly used for [class components.](https://react.dev/reference/react/Component) Function components typically rely on [`useRef`](https://react.dev/reference/react/useRef) instead.

---

## Alternatives

### Migrating from a class with `createRef` to a function with `useRef`

We recommend using function components instead of [class components](https://react.dev/reference/react/Component) in new code. If you have some existing class components using `createRef`, here is how you can convert them. This is the original code:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component, createRef } from 'react';

export default class Form extends Component {
  inputRef = createRef();

  handleClick = () => {
    this.inputRef.current.focus();
  }

  render() {
    return (
      <>
        <input ref={this.inputRef} />
        <button onClick={this.handleClick}>
          Focus the input
        </button>
      </>
    );
  }
}
```

Show more

When you [convert this component from a class to a function,](https://react.dev/reference/react/Component#alternatives) replace calls to `createRef` with calls to [`useRef`:](https://react.dev/reference/react/useRef)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';

export default function Form() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={handleClick}>
        Focus the input
      </button>
    </>
  );
}
```

Show more

[PreviouscreateElement](https://react.dev/reference/react/createElement)[NextforwardRef](https://react.dev/reference/react/forwardRef)

---

---


# forwardRef – React

URL: https://react.dev/reference/react/forwardRef

[API Reference](https://react.dev/reference/react)

[Legacy React APIs](https://react.dev/reference/react/legacy)

# forwardRef

### Deprecated

In React 19, `forwardRef` is no longer necessary. Pass `ref` as a prop instead.

`forwardRef` will be deprecated in a future release. Learn more [here](https://react.dev/blog/2024/04/25/react-19#ref-as-a-prop).

`forwardRef` lets your component expose a DOM node to the parent component with a [ref.](https://react.dev/learn/manipulating-the-dom-with-refs)

```
const SomeComponent = forwardRef(render)
```

* [Reference](https://react.dev/reference/react/forwardRef#reference) 
  + [`forwardRef(render)`](https://react.dev/reference/react/forwardRef#forwardref)
  + [`render` function](https://react.dev/reference/react/forwardRef#render-function)
* [Usage](https://react.dev/reference/react/forwardRef#usage) 
  + [Exposing a DOM node to the parent component](https://react.dev/reference/react/forwardRef#exposing-a-dom-node-to-the-parent-component)
  + [Forwarding a ref through multiple components](https://react.dev/reference/react/forwardRef#forwarding-a-ref-through-multiple-components)
  + [Exposing an imperative handle instead of a DOM node](https://react.dev/reference/react/forwardRef#exposing-an-imperative-handle-instead-of-a-dom-node)
* [Troubleshooting](https://react.dev/reference/react/forwardRef#troubleshooting) 
  + [My component is wrapped in `forwardRef`, but the `ref` to it is always `null`](https://react.dev/reference/react/forwardRef#my-component-is-wrapped-in-forwardref-but-the-ref-to-it-is-always-null)

---

## Reference

### `forwardRef(render)`

Call `forwardRef()` to let your component receive a ref and forward it to a child component:

```
import { forwardRef } from 'react';

const MyInput = forwardRef(function MyInput(props, ref) {

// ...

});
```

[See more examples below.](https://react.dev/reference/react/forwardRef#usage)

#### Parameters

* `render`: The render function for your component. React calls this function with the props and `ref` that your component received from its parent. The JSX you return will be the output of your component.

#### Returns

`forwardRef` returns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned by `forwardRef` is also able to receive a `ref` prop.

#### Caveats

* In Strict Mode, React will **call your render function twice** in order to [help you find accidental impurities.](https://react.dev/reference/react/useState#my-initializer-or-updater-function-runs-twice) This is development-only behavior and does not affect production. If your render function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.

---

### `render` function

`forwardRef` accepts a render function as an argument. React calls this function with `props` and `ref`:

```
const MyInput = forwardRef(function MyInput(props, ref) {

return (

<label>

{props.label}

<input ref={ref} />

</label>

);

});
```

#### Parameters

* `props`: The props passed by the parent component.
* `ref`: The `ref` attribute passed by the parent component. The `ref` can be an object or a function. If the parent component has not passed a ref, it will be `null`. You should either pass the `ref` you receive to another component, or pass it to [`useImperativeHandle`.](https://react.dev/reference/react/useImperativeHandle)

#### Returns

`forwardRef` returns a React component that you can render in JSX. Unlike React components defined as plain functions, the component returned by `forwardRef` is able to take a `ref` prop.

---

## Usage

### Exposing a DOM node to the parent component

By default, each component’s DOM nodes are private. However, sometimes it’s useful to expose a DOM node to the parent—for example, to allow focusing it. To opt in, wrap your component definition into `forwardRef()`:

```
import { forwardRef } from 'react';

const MyInput = forwardRef(function MyInput(props, ref) {

const { label, ...otherProps } = props;

return (

<label>

{label}

<input {...otherProps} />

</label>

);

});
```

You will receive a ref as the second argument after props. Pass it to the DOM node that you want to expose:

```
import { forwardRef } from 'react';

const MyInput = forwardRef(function MyInput(props, ref) {

const { label, ...otherProps } = props;

return (

<label>

{label}

<input {...otherProps} ref={ref} />

</label>

);

});
```

This lets the parent `Form` component access the `<input>` DOM node exposed by `MyInput`:

```
function Form() {

const ref = useRef(null);

function handleClick() {

ref.current.focus();

}

return (

<form>

<MyInput label="Enter your name:" ref={ref} />

<button type="button" onClick={handleClick}>

Edit

</button>

</form>

);

}
```

This `Form` component [passes a ref](https://react.dev/reference/react/useRef#manipulating-the-dom-with-a-ref) to `MyInput`. The `MyInput` component *forwards* that ref to the `<input>` browser tag. As a result, the `Form` component can access that `<input>` DOM node and call [`focus()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus) on it.

Keep in mind that exposing a ref to the DOM node inside your component makes it harder to change your component’s internals later. You will typically expose DOM nodes from reusable low-level components like buttons or text inputs, but you won’t do it for application-level components like an avatar or a comment.

#### Examples of forwarding a ref

1. Focusing a text input 2. Playing and pausing a video

#### Example 1 of 2: Focusing a text input

Clicking the button will focus the input. The `Form` component defines a ref and passes it to the `MyInput` component. The `MyInput` component forwards that ref to the browser `<input>`. This lets the `Form` component focus the `<input>`.

App.jsMyInput.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();
  }

  return (
    <form>
      <MyInput label="Enter your name:" ref={ref} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}
```

Show more

Next Example

---

### Forwarding a ref through multiple components

Instead of forwarding a `ref` to a DOM node, you can forward it to your own component like `MyInput`:

```
const FormField = forwardRef(function FormField(props, ref) {

// ...

return (

<>

<MyInput ref={ref} />

...

</>

);

});
```

If that `MyInput` component forwards a ref to its `<input>`, a ref to `FormField` will give you that `<input>`:

```
function Form() {

const ref = useRef(null);

function handleClick() {

ref.current.focus();

}

return (

<form>

<FormField label="Enter your name:" ref={ref} isRequired={true} />

<button type="button" onClick={handleClick}>

Edit

</button>

</form>

);

}
```

The `Form` component defines a ref and passes it to `FormField`. The `FormField` component forwards that ref to `MyInput`, which forwards it to a browser `<input>` DOM node. This is how `Form` accesses that DOM node.

App.jsFormField.jsMyInput.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';
import FormField from './FormField.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();
  }

  return (
    <form>
      <FormField label="Enter your name:" ref={ref} isRequired={true} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}
```

Show more

---

### Exposing an imperative handle instead of a DOM node

Instead of exposing an entire DOM node, you can expose a custom object, called an *imperative handle,* with a more constrained set of methods. To do this, you’d need to define a separate ref to hold the DOM node:

```
const MyInput = forwardRef(function MyInput(props, ref) {

const inputRef = useRef(null);

// ...

return <input {...props} ref={inputRef} />;

});
```

Pass the `ref` you received to [`useImperativeHandle`](https://react.dev/reference/react/useImperativeHandle) and specify the value you want to expose to the `ref`:

```
import { forwardRef, useRef, useImperativeHandle } from 'react';

const MyInput = forwardRef(function MyInput(props, ref) {

const inputRef = useRef(null);

useImperativeHandle(ref, () => {

return {

focus() {

inputRef.current.focus();

},

scrollIntoView() {

inputRef.current.scrollIntoView();

},

};

}, []);

return <input {...props} ref={inputRef} />;

});
```

If some component gets a ref to `MyInput`, it will only receive your `{ focus, scrollIntoView }` object instead of the DOM node. This lets you limit the information you expose about your DOM node to the minimum.

App.jsMyInput.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();
    // This won't work because the DOM node isn't exposed:
    // ref.current.style.opacity = 0.5;
  }

  return (
    <form>
      <MyInput placeholder="Enter your name" ref={ref} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}
```

Show more

[Read more about using imperative handles.](https://react.dev/reference/react/useImperativeHandle)

### Pitfall

**Do not overuse refs.** You should only use refs for *imperative* behaviors that you can’t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on.

**If you can express something as a prop, you should not use a ref.** For example, instead of exposing an imperative handle like `{ open, close }` from a `Modal` component, it is better to take `isOpen` as a prop like `<Modal isOpen={isOpen} />`. [Effects](https://react.dev/learn/synchronizing-with-effects) can help you expose imperative behaviors via props.

---

## Troubleshooting

### My component is wrapped in `forwardRef`, but the `ref` to it is always `null`

This usually means that you forgot to actually use the `ref` that you received.

For example, this component doesn’t do anything with its `ref`:

```
const MyInput = forwardRef(function MyInput({ label }, ref) {

return (

<label>

{label}

<input />

</label>

);

});
```

To fix it, pass the `ref` down to a DOM node or another component that can accept a ref:

```
const MyInput = forwardRef(function MyInput({ label }, ref) {

return (

<label>

{label}

<input ref={ref} />

</label>

);

});
```

The `ref` to `MyInput` could also be `null` if some of the logic is conditional:

```
const MyInput = forwardRef(function MyInput({ label, showInput }, ref) {

return (

<label>

{label}

{showInput && <input ref={ref} />}

</label>

);

});
```

If `showInput` is `false`, then the ref won’t be forwarded to any node, and a ref to `MyInput` will remain empty. This is particularly easy to miss if the condition is hidden inside another component, like `Panel` in this example:

```
const MyInput = forwardRef(function MyInput({ label, showInput }, ref) {

return (

<label>

{label}

<Panel isExpanded={showInput}>

<input ref={ref} />

</Panel>

</label>

);

});
```

[PreviouscreateRef](https://react.dev/reference/react/createRef)[NextisValidElement](https://react.dev/reference/react/isValidElement)

---

---


# isValidElement – React

URL: https://react.dev/reference/react/isValidElement

[API Reference](https://react.dev/reference/react)

[Legacy React APIs](https://react.dev/reference/react/legacy)

# isValidElement

`isValidElement` checks whether a value is a React element.

```
const isElement = isValidElement(value)
```

* [Reference](https://react.dev/reference/react/isValidElement#reference) 
  + [`isValidElement(value)`](https://react.dev/reference/react/isValidElement#isvalidelement)
* [Usage](https://react.dev/reference/react/isValidElement#usage) 
  + [Checking if something is a React element](https://react.dev/reference/react/isValidElement#checking-if-something-is-a-react-element)

---

## Reference

### `isValidElement(value)`

Call `isValidElement(value)` to check whether `value` is a React element.

```
import { isValidElement, createElement } from 'react';

// ✅ React elements

console.log(isValidElement(<p />)); // true

console.log(isValidElement(createElement('p'))); // true

// ❌ Not React elements

console.log(isValidElement(25)); // false

console.log(isValidElement('Hello')); // false

console.log(isValidElement({ age: 42 })); // false
```

[See more examples below.](https://react.dev/reference/react/isValidElement#usage)

#### Parameters

* `value`: The `value` you want to check. It can be any a value of any type.

#### Returns

`isValidElement` returns `true` if the `value` is a React element. Otherwise, it returns `false`.

#### Caveats

* **Only [JSX tags](https://react.dev/learn/writing-markup-with-jsx) and objects returned by [`createElement`](https://react.dev/reference/react/createElement) are considered to be React elements.** For example, even though a number like `42` is a valid React *node* (and can be returned from a component), it is not a valid React element. Arrays and portals created with [`createPortal`](https://react.dev/reference/react-dom/createPortal) are also *not* considered to be React elements.

---

## Usage

### Checking if something is a React element

Call `isValidElement` to check if some value is a *React element.*

React elements are:

* Values produced by writing a [JSX tag](https://react.dev/learn/writing-markup-with-jsx)
* Values produced by calling [`createElement`](https://react.dev/reference/react/createElement)

For React elements, `isValidElement` returns `true`:

```
import { isValidElement, createElement } from 'react';

// ✅ JSX tags are React elements

console.log(isValidElement(<p />)); // true

console.log(isValidElement(<MyComponent />)); // true

// ✅ Values returned by createElement are React elements

console.log(isValidElement(createElement('p'))); // true

console.log(isValidElement(createElement(MyComponent))); // true
```

Any other values, such as strings, numbers, or arbitrary objects and arrays, are not React elements.

For them, `isValidElement` returns `false`:

```
// ❌ These are *not* React elements

console.log(isValidElement(null)); // false

console.log(isValidElement(25)); // false

console.log(isValidElement('Hello')); // false

console.log(isValidElement({ age: 42 })); // false

console.log(isValidElement([<div />, <div />])); // false

console.log(isValidElement(MyComponent)); // false
```

It is very uncommon to need `isValidElement`. It’s mostly useful if you’re calling another API that *only* accepts elements (like [`cloneElement`](https://react.dev/reference/react/cloneElement) does) and you want to avoid an error when your argument is not a React element.

Unless you have some very specific reason to add an `isValidElement` check, you probably don’t need it.

##### Deep Dive

#### React elements vs React nodes

Show Details

When you write a component, you can return any kind of *React node* from it:

```
function MyComponent() {

// ... you can return any React node ...

}
```

A React node can be:

* A React element created like `<div />` or `createElement('div')`
* A portal created with [`createPortal`](https://react.dev/reference/react-dom/createPortal)
* A string
* A number
* `true`, `false`, `null`, or `undefined` (which are not displayed)
* An array of other React nodes

**Note `isValidElement` checks whether the argument is a *React element,* not whether it’s a React node.** For example, `42` is not a valid React element. However, it is a perfectly valid React node:

```
function MyComponent() {

return 42; // It's ok to return a number from component

}
```

This is why you shouldn’t use `isValidElement` as a way to check whether something can be rendered.

[PreviousforwardRef](https://react.dev/reference/react/forwardRef)[NextPureComponent](https://react.dev/reference/react/PureComponent)

---

---


# PureComponent – React

URL: https://react.dev/reference/react/PureComponent

[API Reference](https://react.dev/reference/react)

[Legacy React APIs](https://react.dev/reference/react/legacy)

# PureComponent

### Pitfall

We recommend defining components as functions instead of classes. [See how to migrate.](https://react.dev/reference/react/PureComponent#alternatives)

`PureComponent` is similar to [`Component`](https://react.dev/reference/react/Component) but it skips re-renders for same props and state. Class components are still supported by React, but we don’t recommend using them in new code.

```
class Greeting extends PureComponent {

render() {

return <h1>Hello, {this.props.name}!</h1>;

}

}
```

* [Reference](https://react.dev/reference/react/PureComponent#reference) 
  + [`PureComponent`](https://react.dev/reference/react/PureComponent#purecomponent)
* [Usage](https://react.dev/reference/react/PureComponent#usage) 
  + [Skipping unnecessary re-renders for class components](https://react.dev/reference/react/PureComponent#skipping-unnecessary-re-renders-for-class-components)
* [Alternatives](https://react.dev/reference/react/PureComponent#alternatives) 
  + [Migrating from a `PureComponent` class component to a function](https://react.dev/reference/react/PureComponent#migrating-from-a-purecomponent-class-component-to-a-function)

---

## Reference

### `PureComponent`

To skip re-rendering a class component for same props and state, extend `PureComponent` instead of [`Component`:](https://react.dev/reference/react/Component)

```
import { PureComponent } from 'react';

class Greeting extends PureComponent {

render() {

return <h1>Hello, {this.props.name}!</h1>;

}

}
```

`PureComponent` is a subclass of `Component` and supports [all the `Component` APIs.](https://react.dev/reference/react/Component#reference) Extending `PureComponent` is equivalent to defining a custom [`shouldComponentUpdate`](https://react.dev/reference/react/Component#shouldcomponentupdate) method that shallowly compares props and state.

[See more examples below.](https://react.dev/reference/react/PureComponent#usage)

---

## Usage

### Skipping unnecessary re-renders for class components

React normally re-renders a component whenever its parent re-renders. As an optimization, you can create a component that React will not re-render when its parent re-renders so long as its new props and state are the same as the old props and state. [Class components](https://react.dev/reference/react/Component) can opt into this behavior by extending `PureComponent`:

```
class Greeting extends PureComponent {

render() {

return <h1>Hello, {this.props.name}!</h1>;

}

}
```

A React component should always have [pure rendering logic.](https://react.dev/learn/keeping-components-pure) This means that it must return the same output if its props, state, and context haven’t changed. By using `PureComponent`, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props and state haven’t changed. However, your component will still re-render if a context that it’s using changes.

In this example, notice that the `Greeting` component re-renders whenever `name` is changed (because that’s one of its props), but not when `address` is changed (because it’s not passed to `Greeting` as a prop):

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { PureComponent, useState } from 'react';

class Greeting extends PureComponent {
  render() {
    console.log("Greeting was rendered at", new Date().toLocaleTimeString());
    return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;
  }
}

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}
```

Show more

### Pitfall

We recommend defining components as functions instead of classes. [See how to migrate.](https://react.dev/reference/react/PureComponent#alternatives)

---

## Alternatives

### Migrating from a `PureComponent` class component to a function

We recommend using function components instead of [class components](https://react.dev/reference/react/Component) in new code. If you have some existing class components using `PureComponent`, here is how you can convert them. This is the original code:

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { PureComponent, useState } from 'react';

class Greeting extends PureComponent {
  render() {
    console.log("Greeting was rendered at", new Date().toLocaleTimeString());
    return <h3>Hello{this.props.name && ', '}{this.props.name}!</h3>;
  }
}

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}
```

Show more

When you [convert this component from a class to a function,](https://react.dev/reference/react/Component#alternatives) wrap it in [`memo`:](https://react.dev/reference/react/memo)

App.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { memo, useState } from 'react';

const Greeting = memo(function Greeting({ name }) {
  console.log("Greeting was rendered at", new Date().toLocaleTimeString());
  return <h3>Hello{name && ', '}{name}!</h3>;
});

export default function MyApp() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  return (
    <>
      <label>
        Name{': '}
        <input value={name} onChange={e => setName(e.target.value)} />
      </label>
      <label>
        Address{': '}
        <input value={address} onChange={e => setAddress(e.target.value)} />
      </label>
      <Greeting name={name} />
    </>
  );
}
```

Show more

### Note

Unlike `PureComponent`, [`memo`](https://react.dev/reference/react/memo) does not compare the new and the old state. In function components, calling the [`set` function](https://react.dev/reference/react/useState#setstate) with the same state [already prevents re-renders by default,](https://react.dev/reference/react/memo#updating-a-memoized-component-using-state) even without `memo`.

[PreviousisValidElement](https://react.dev/reference/react/isValidElement)

---

---


# React Conferences – React

URL: https://react.dev/community/conferences

[Community](https://react.dev/community)

# React Conferences

Do you know of a local React.js conference? Add it here! (Please keep the list chronological)

## Upcoming Conferences

### React Universe Conf 2025

September 2-4, 2025. Wrocław, Poland.

[Website](https://www.reactuniverseconf.com/) - [Twitter](https://twitter.com/react_native_eu) - [LinkedIn](https://www.linkedin.com/events/reactuniverseconf7163919537074118657/)

### React Alicante 2025

October 2-4, 2025. Alicante, Spain.

[Website](https://reactalicante.es/) - [Twitter](https://x.com/ReactAlicante) - [Bluesky](https://bsky.app/profile/reactalicante.es) - [YouTube](https://www.youtube.com/channel/UCaSdUaITU1Cz6PvC97A7e0w)

### RenderCon Kenya 2025

October 04, 2025. Nairobi, Kenya

[Website](https://rendercon.org/) - [Twitter](https://twitter.com/renderconke) - [LinkedIn](https://www.linkedin.com/company/renderconke/) - [YouTube](https://www.youtube.com/channel/UC0bCcG8gHUL4njDOpQGcMIA)

### React Conf 2025

October 7-8, 2025. Henderson, Nevada, USA and free livestream

[Website](https://conf.react.dev/) - [Twitter](https://x.com/reactjs) - [Bluesky](https://bsky.app/profile/react.dev)

### React India 2025

October 31 - November 01, 2025. In-person in Goa, India (hybrid event) + Oct 15 2025 - remote day

[Website](https://www.reactindia.io) - [Twitter](https://twitter.com/react_india) - [Facebook](https://www.facebook.com/ReactJSIndia) - [Youtube](https://www.youtube.com/channel/UCaFbHCBkPvVv1bWs_jwYt3w)

### React Summit US 2025

November 18 - 21, 2025. In-person in New York, USA + remote (hybrid event)

[Website](https://reactsummit.us/) - [Twitter](https://x.com/reactsummit)

### React Advanced London 2025

November 28 & December 1, 2025. In-person in London, UK + online (hybrid event)

[Website](https://reactadvanced.com/) - [Twitter](https://x.com/reactadvanced)

### CityJS Singapore 2026

February 4-6, 2026. In-person in Singapore

[Website](https://india.cityjsconf.org/) - [Twitter](https://x.com/cityjsconf) - [Bluesky](https://bsky.app/profile/cityjsconf.bsky.social)

### CityJS New Delhi 2026

February 12-13, 2026. In-person in New Delhi, India

[Website](https://india.cityjsconf.org/) - [Twitter](https://x.com/cityjsconf) - [Bluesky](https://bsky.app/profile/cityjsconf.bsky.social)

### React Paris 2026

March 26 - 27, 2026. In-person in Paris, France (hybrid event)

[Website](https://react.paris/) - [Twitter](https://x.com/BeJS_)

### CityJS London 2026

April 14-17, 2026. In-person in London

[Website](https://india.cityjsconf.org/) - [Twitter](https://x.com/cityjsconf) - [Bluesky](https://bsky.app/profile/cityjsconf.bsky.social)

## Past Conferences

### React Nexus 2025

July 03 - 05, 2025. In-person in Bangalore, India

[Website](https://reactnexus.com/) - [Twitter](https://x.com/ReactNexus) - [Bluesky](https://bsky.app/profile/reactnexus.com) - [Linkedin](https://www.linkedin.com/company/react-nexus) - [YouTube](https://www.youtube.com/reactify_in)

### React Summit 2025

June 13 - 17, 2025. In-person in Amsterdam, Netherlands + remote (hybrid event)

[Website](https://reactsummit.com/) - [Twitter](https://x.com/reactsummit)

### React Norway 2025

June 13, 2025. In-person in Oslo, Norway + remote (virtual event)

[Website](https://reactnorway.com/) - [Twitter](https://x.com/ReactNorway)

### CityJS Athens 2025

May 27 - 31, 2025. In-person in Athens, Greece

[Website](https://athens.cityjsconf.org/) - [Twitter](https://x.com/cityjsconf) - [Bluesky](https://bsky.app/profile/cityjsconf.bsky.social)

### App.js Conf 2025

May 28 - 30, 2025. In-person in Kraków, Poland + remote

[Website](https://appjs.co) - [Twitter](https://twitter.com/appjsconf)

### CityJS London 2025

April 23 - 25, 2025. In-person in London, UK

[Website](https://london.cityjsconf.org/) - [Twitter](https://x.com/cityjsconf) - [Bluesky](https://bsky.app/profile/cityjsconf.bsky.social)

### React Paris 2025

March 20 - 21, 2025. In-person in Paris, France (hybrid event)

[Website](https://react.paris/) - [Twitter](https://x.com/BeJS_) - [YouTube](https://www.youtube.com/playlist?list=PL53Z0yyYnpWitP8Zv01TSEQmKLvuRh_Dj)

### React Native Connection 2025

April 3 (Reanimated Training) + April 4 (Conference), 2025. Paris, France.

[Website](https://reactnativeconnection.io/) - [X](https://x.com/reactnativeconn) - [Bluesky](https://bsky.app/profile/reactnativeconnect.bsky.social)

### React Day Berlin 2024

December 13 & 16, 2024. In-person in Berlin, Germany + remote (hybrid event)

[Website](https://reactday.berlin/) - [Twitter](https://x.com/reactdayberlin)

### React Africa 2024

November 29, 2024. In-person in Casablanca, Morocco (hybrid event)

[Website](https://react-africa.com/) - [Twitter](https://x.com/BeJS_)

### React Summit US 2024

November 19 & 22, 2024. In-person in New York, USA + online (hybrid event)

[Website](https://reactsummit.us/) - [Twitter](https://twitter.com/reactsummit) - [Videos](https://portal.gitnation.org/)

### React Native London Conf 2024

November 14 & 15, 2024. In-person in London, UK

[Website](https://reactnativelondon.co.uk/) - [Twitter](https://x.com/RNLConf)

### React Advanced London 2024

October 25 & 28, 2024. In-person in London, UK + online (hybrid event)

[Website](https://reactadvanced.com/) - [Twitter](https://x.com/reactadvanced)

### reactjsday 2024

October 25, 2024. In-person in Verona, Italy + online (hybrid event)

[Website](https://2024.reactjsday.it/) - [Twitter](https://x.com/reactjsday) - [Facebook](https://www.facebook.com/GrUSP/) - [YouTube](https://www.youtube.com/c/grusp)

### React Brussels 2024

October 18, 2024. In-person in Brussels, Belgium (hybrid event)

[Website](https://www.react.brussels/) - [Twitter](https://x.com/BrusselsReact) - [YouTube](https://www.youtube.com/playlist?list=PL53Z0yyYnpWimQ0U75woee2zNUIFsiDC3)

### React India 2024

October 17 - 19, 2024. In-person in Goa, India (hybrid event) + Oct 15 2024 - remote day

[Website](https://www.reactindia.io) - [Twitter](https://twitter.com/react_india) - [Facebook](https://www.facebook.com/ReactJSIndia) - [Youtube](https://www.youtube.com/channel/UCaFbHCBkPvVv1bWs_jwYt3w)

### RenderCon Kenya 2024

October 04 - 05, 2024. Nairobi, Kenya

[Website](https://rendercon.org/) - [Twitter](https://twitter.com/renderconke) - [LinkedIn](https://www.linkedin.com/company/renderconke/) - [YouTube](https://www.youtube.com/channel/UC0bCcG8gHUL4njDOpQGcMIA)

### React Alicante 2024

September 19-21, 2024. Alicante, Spain.

[Website](https://reactalicante.es/) - [Twitter](https://twitter.com/ReactAlicante) - [YouTube](https://www.youtube.com/channel/UCaSdUaITU1Cz6PvC97A7e0w)

### React Universe Conf 2024

September 5-6, 2024. Wrocław, Poland.

[Website](https://www.reactuniverseconf.com/) - [Twitter](https://twitter.com/react_native_eu) - [LinkedIn](https://www.linkedin.com/events/reactuniverseconf7163919537074118657/)

### React Rally 2024 🐙

August 12-13, 2024. Park City, UT, USA

[Website](https://reactrally.com) - [Twitter](https://twitter.com/ReactRally) - [YouTube](https://www.youtube.com/channel/UCXBhQ05nu3L1abBUGeQ0ahw)

### The Geek Conf 2024

July 25, 2024. In-person in Berlin, Germany + remote (hybrid event)

[Website](https://thegeekconf.com) - [Twitter](https://twitter.com/thegeekconf)

### Chain React 2024

July 17-19, 2024. In-person in Portland, OR, USA

[Website](https://chainreactconf.com) - [Twitter](https://twitter.com/ChainReactConf)

### React Nexus 2024

July 04 & 05, 2024. Bangalore, India (In-person event)

[Website](https://reactnexus.com/) - [Twitter](https://twitter.com/ReactNexus) - [Linkedin](https://www.linkedin.com/company/react-nexus) - [YouTube](https://www.youtube.com/reactify_in)

### React Summit 2024

June 14 & 18, 2024. In-person in Amsterdam, Netherlands + remote (hybrid event)

[Website](https://reactsummit.com/) - [Twitter](https://twitter.com/reactsummit) - [Videos](https://portal.gitnation.org/)

### React Norway 2024

June 14, 2024. In-person at Farris Bad Hotel in Larvik, Norway and online (hybrid event).

[Website](https://reactnorway.com/) - [Twitter](https://twitter.com/ReactNorway)

### Render(ATL) 2024 🍑

June 12 - June 14, 2024. Atlanta, GA, USA

[Website](https://renderatl.com) - [Discord](https://www.renderatl.com/discord) - [Twitter](https://twitter.com/renderATL) - [Instagram](https://www.instagram.com/renderatl/) - [Facebook](https://www.facebook.com/renderatl/) - [LinkedIn](https://www.linkedin.com/company/renderatl) - [Podcast](https://www.renderatl.com/culture-and-code#/)

### Frontend Nation 2024

June 4 - 7, 2024. Online

[Website](https://frontendnation.com/) - [Twitter](https://twitter.com/frontendnation)

### App.js Conf 2024

May 22 - 24, 2024. In-person in Kraków, Poland + remote

[Website](https://appjs.co) - [Twitter](https://twitter.com/appjsconf)

### React Conf 2024

May 15 - 16, 2024. In-person in Henderson, NV, USA + remote

[Website](https://conf.react.dev) - [Twitter](https://twitter.com/reactjs)

### React Native Connection 2024

April 23, 2024. In-person in Paris, France

[Website](https://reactnativeconnection.io/) - [Twitter](https://twitter.com/ReactNativeConn)

### React Miami 2024

April 19 - 20, 2024. In-person in Miami, FL, USA

[Website](https://reactmiami.com/) - [Twitter](https://twitter.com/ReactMiamiConf)

### Epic Web Conf 2024

April 10 - 11, 2024. In-person in Park City, UT, USA

[Website](https://www.epicweb.dev/conf) - [YouTube](https://www.youtube.com/@EpicWebDev)

### React Paris 2024

March 22, 2024. In-person in Paris, France + Remote (hybrid)

[Website](https://react.paris/) - [Twitter](https://twitter.com/BeJS_) - [LinkedIn](https://www.linkedin.com/events/7150816372074192900/comments/) - [Videos](https://www.youtube.com/playlist?list=PL53Z0yyYnpWhUzgvr2Nys3kZBBLcY0TA7)

### React Day Berlin 2023

December 8 & 12, 2023. In-person in Berlin, Germany + remote first interactivity (hybrid event)

[Website](https://reactday.berlin) - [Twitter](https://twitter.com/reactdayberlin) - [Facebook](https://www.facebook.com/reactdayberlin/) - [Videos](https://portal.gitnation.org/events/react-day-berlin-2023)

### React Summit US 2023

November 13 & 15, 2023. In-person in New York, US + remote first interactivity (hybrid event)

[Website](https://reactsummit.us) - [Twitter](https://twitter.com/reactsummit) - [Facebook](https://www.facebook.com/reactamsterdam) - [Videos](https://portal.gitnation.org/events/react-summit-us-2023)

### reactjsday 2023

October 27th 2023. In-person in Verona, Italy and online (hybrid event)

[Website](https://2023.reactjsday.it/) - [Twitter](https://twitter.com/reactjsday) - [Facebook](https://www.facebook.com/GrUSP/) - [YouTube](https://www.youtube.com/c/grusp)

### React Advanced 2023

October 20 & 23, 2023. In-person in London, UK + remote first interactivity (hybrid event)

[Website](https://www.reactadvanced.com/) - [Twitter](https://twitter.com/ReactAdvanced) - [Facebook](https://www.facebook.com/ReactAdvanced) - [Videos](https://portal.gitnation.org/events/react-advanced-conference-2023)

### React Brussels 2023

October 13th 2023. In-person in Brussels, Belgium + Remote (hybrid)

[Website](https://www.react.brussels/) - [Twitter](https://twitter.com/BrusselsReact) - [Videos](https://www.youtube.com/playlist?list=PL53Z0yyYnpWh85KeMomUoVz8_brrmh_aC)

### React India 2023

October 5 - 7, 2023. In-person in Goa, India (hybrid event) + Oct 3 2023 - remote day

[Website](https://www.reactindia.io) - [Twitter](https://x.com/react_india) - [Facebook](https://www.facebook.com/ReactJSIndia) - [Youtube](https://www.youtube.com/channel/UCaFbHCBkPvVv1bWs_jwYt3w)

### RenderCon Kenya 2023

September 29 - 30, 2023. Nairobi, Kenya

[Website](https://rendercon.org/) - [Twitter](https://twitter.com/renderconke) - [LinkedIn](https://www.linkedin.com/company/renderconke/) - [YouTube](https://www.youtube.com/channel/UC0bCcG8gHUL4njDOpQGcMIA)

### React Live 2023

September 29, 2023. Amsterdam, Netherlands

[Website](https://reactlive.nl/)

### React Alicante 2023

September 28 - 30, 2023. Alicante, Spain

[Website](https://reactalicante.es/) - [Twitter](https://twitter.com/reactalicante)

### RedwoodJS Conference 2023

September 26 - 29, 2023. Grants Pass, Oregon + remote (hybrid event)

[Website](https://www.redwoodjsconf.com/) - [Twitter](https://twitter.com/redwoodjs)

### React Native EU 2023

September 7 & 8, 2023. Wrocław, Poland

[Website](https://react-native.eu) - [Twitter](https://twitter.com/react_native_eu) - [Facebook](https://www.facebook.com/reactnativeeu)

### React Rally 2023 🐙

August 17 & 18, 2023. Salt Lake City, UT, USA

[Website](https://www.reactrally.com/) - [Twitter](https://twitter.com/ReactRally) - [Instagram](https://www.instagram.com/reactrally/)

### React Nexus 2023

July 07 & 08, 2023. Bangalore, India (In-person event)

[Website](https://reactnexus.com/) - [Twitter](https://twitter.com/ReactNexus) - [Linkedin](https://www.linkedin.com/company/react-nexus) - [YouTube](https://www.youtube.com/reactify_in)

### ReactNext 2023

June 27th, 2023. Tel Aviv, Israel

[Website](https://www.react-next.com/) - [Facebook](https://www.facebook.com/ReactNextConf) - [Youtube](https://www.youtube.com/@ReactNext)

### React Norway 2023

June 16th, 2023. Larvik, Norway

[Website](https://reactnorway.com/) - [Twitter](https://twitter.com/ReactNorway/) - [Facebook](https://www.facebook.com/reactdaynorway/)

### React Summit 2023

June 2 & 6, 2023. In-person in Amsterdam, Netherlands + remote first interactivity (hybrid event)

[Website](https://reactsummit.com) - [Twitter](https://twitter.com/reactsummit) - [Facebook](https://www.facebook.com/reactamsterdam) - [Videos](https://portal.gitnation.org/events/react-summit-2023)

### Render(ATL) 2023 🍑

May 31 - June 2, 2023. Atlanta, GA, USA

[Website](https://renderatl.com) - [Discord](https://www.renderatl.com/discord) - [Twitter](https://twitter.com/renderATL) - [Instagram](https://www.instagram.com/renderatl/) - [Facebook](https://www.facebook.com/renderatl/) - [LinkedIn](https://www.linkedin.com/company/renderatl) - [Podcast](https://www.renderatl.com/culture-and-code#/)

### Chain React 2023

May 17 - 19, 2023. Portland, OR, USA

[Website](https://chainreactconf.com/) - [Twitter](https://twitter.com/ChainReactConf) - [Facebook](https://www.facebook.com/ChainReactConf/) - [Youtube](https://www.youtube.com/channel/UCwpSzVt7QpLDbCnPXqR97-g/playlists)

### App.js Conf 2023

May 10 - 12, 2023. In-person in Kraków, Poland + remote

[Website](https://appjs.co) - [Twitter](https://twitter.com/appjsconf)

### RemixConf 2023

May, 2023. Salt Lake City, UT

[Website](https://remix.run/conf/2023) - [Twitter](https://twitter.com/remix_run)

### Reactathon 2023

May 2 - 3, 2023. San Francisco, CA, USA

[Website](https://reactathon.com) - [Twitter](https://twitter.com/reactathon) - [YouTube](https://www.youtube.com/realworldreact)

### React Miami 2023

April 20 - 21, 2023. Miami, FL, USA

[Website](https://www.reactmiami.com/) - [Twitter](https://twitter.com/ReactMiamiConf)

### React Day Berlin 2022

December 2, 2022. In-person in Berlin, Germany + remote (hybrid event)

[Website](https://reactday.berlin) - [Twitter](https://twitter.com/reactdayberlin) - [Facebook](https://www.facebook.com/reactdayberlin/) - [Videos](https://www.youtube.com/c/ReactConferences)

### React Global Online Summit 22.2 by Geekle

November 8 - 9, 2022 - Online Summit

[Website](https://events.geekle.us/react3/) - [LinkedIn](https://www.linkedin.com/posts/geekle-us_event-react-reactjs-activity-6964904611207864320-gpDx?utm_source=share&utm_medium=member_desktop)

### Remix Conf Europe 2022

November 18, 2022, 7am PST / 10am EST / 4pm CET - remote event

[Website](https://remixconf.eu/) - [Twitter](https://twitter.com/remixconfeu) - [Videos](https://portal.gitnation.org/events/remix-conf-europe-2022)

### React Advanced 2022

October 21 & 25, 2022. In-person in London, UK + remote (hybrid event)

[Website](https://www.reactadvanced.com/) - [Twitter](https://twitter.com/ReactAdvanced) - [Facebook](https://www.facebook.com/ReactAdvanced) - [Videos](https://portal.gitnation.org/events/react-advanced-conference-2022)

### ReactJS Day 2022

October 21, 2022 in Verona, Italy

[Website](https://2022.reactjsday.it/) - [Twitter](https://twitter.com/reactjsday) - [LinkedIn](https://www.linkedin.com/company/grusp/) - [Facebook](https://www.facebook.com/reactjsday/) - [Videos](https://www.youtube.com/c/grusp)

### React Brussels 2022

October 14, 2022. In-person in Brussels, Belgium + remote (hybrid event)

[Website](https://www.react.brussels/) - [Twitter](https://twitter.com/BrusselsReact) - [LinkedIn](https://www.linkedin.com/events/6938421827153088512/) - [Facebook](https://www.facebook.com/events/1289080838167252/) - [Videos](https://www.youtube.com/channel/UCvES7lMpnx-t934qGxD4w4g)

### React Alicante 2022

September 29 - October 1, 2022. In-person in Alicante, Spain + remote (hybrid event)

[Website](https://reactalicante.es/) - [Twitter](https://twitter.com/reactalicante) - [Facebook](https://www.facebook.com/ReactAlicante) - [Videos](https://www.youtube.com/channel/UCaSdUaITU1Cz6PvC97A7e0w)

### React India 2022

September 22 - 24, 2022. In-person in Goa, India + remote (hybrid event)

[Website](https://www.reactindia.io) - [Twitter](https://twitter.com/react_india) - [Facebook](https://www.facebook.com/ReactJSIndia) - [Videos](https://www.youtube.com/channel/UCaFbHCBkPvVv1bWs_jwYt3w)

### React Finland 2022

September 12 - 16, 2022. In-person in Helsinki, Finland

[Website](https://react-finland.fi/) - [Twitter](https://twitter.com/ReactFinland) - [Schedule](https://react-finland.fi/schedule/) - [Speakers](https://react-finland.fi/speakers/)

### React Native EU 2022: Powered by callstack

September 1-2, 2022 - Remote event

[Website](https://www.react-native.eu/?utm_campaign=React_Native_EU&utm_source=referral&utm_content=reactjs_community_conferences) -
[Twitter](https://twitter.com/react_native_eu) -
[Linkedin](https://www.linkedin.com/showcase/react-native-eu) -
[Facebook](https://www.facebook.com/reactnativeeu/) -
[Instagram](https://www.instagram.com/reactnative_eu/)

### ReactNext 2022

June 28, 2022. Tel-Aviv, Israel

[Website](https://react-next.com) - [Twitter](https://twitter.com/ReactNext) - [Videos](https://www.youtube.com/c/ReactNext)

### React Norway 2022

June 24, 2022. In-person at Farris Bad Hotel in Larvik, Norway and online (hybrid event).

[Website](https://reactnorway.com/) - [Twitter](https://twitter.com/ReactNorway)

### React Summit 2022

June 17 & 21, 2022. In-person in Amsterdam, Netherlands + remote first interactivity (hybrid event)

[Website](https://reactsummit.com) - [Twitter](https://twitter.com/reactsummit) - [Facebook](https://www.facebook.com/reactamsterdam) - [Videos](https://portal.gitnation.org/events/react-summit-2022)

### App.js Conf 2022

June 8 - 10, 2022. In-person in Kraków, Poland + remote

[Website](https://appjs.co) - [Twitter](https://twitter.com/appjsconf)

### React Day Bangalore 2022

June 8 - 9, 2022. Remote

[Website](https://reactday.in/) - [Twitter](https://twitter.com/ReactDayIn) - [Linkedin](https://www.linkedin.com/company/react-day/) - [YouTube](https://www.youtube.com/reactify_in)

### render(ATL) 2022 🍑

June 1 - 4, 2022. Atlanta, GA, USA

[Website](https://renderatl.com) - [Discord](https://www.renderatl.com/discord) - [Twitter](https://twitter.com/renderATL) - [Instagram](https://www.instagram.com/renderatl/) - [Facebook](https://www.facebook.com/renderatl/) - [LinkedIn](https://www.linkedin.com/company/renderatl) - [Podcast](https://www.renderatl.com/culture-and-code#/)

### RemixConf 2022

May 24 - 25, 2022. Salt Lake City, UT

[Website](https://remix.run/conf/2022) - [Twitter](https://twitter.com/remix_run) - [YouTube](https://www.youtube.com/playlist?list=PLXoynULbYuEC36XutMMWEuTu9uuh171wx)

### Reactathon 2022

May 3 - 5, 2022. Berkeley, CA

[Website](https://reactathon.com) - [Twitter](https://twitter.com/reactathon) -[YouTube](https://www.youtube.com/watch?v=-YG5cljNXIA)

### React Global Online Summit 2022 by Geekle

April 20 - 21, 2022 - Online Summit

[Website](https://events.geekle.us/react2/) - [LinkedIn](https://www.linkedin.com/events/reactglobalonlinesummit-226887417664541614081/)

### React Miami 2022 🌴

April 18 - 19, 2022. Miami, Florida
[Website](https://www.reactmiami.com/)

### React Live 2022

April 1, 2022. Amsterdam, The Netherlands

[Website](https://www.reactlive.nl/) - [Twitter](https://twitter.com/reactlivenl)

### AgentConf 2022

January 27 - 30, 2022. In-person in Dornbirn and Lech Austria

[Website](https://agent.sh/) - [Twitter](https://twitter.com/AgentConf) - [Instagram](https://www.instagram.com/teamagent/)

### React Conf 2021

December 8, 2021 - remote event (replay event on December 9)

[Website](https://conf.reactjs.org/)

### ReactEurope 2021

December 9-10, 2021 - remote event

[Videos](https://www.youtube.com/c/ReacteuropeOrgConf)

### ReactNext 2021

December 15, 2021. Tel-Aviv, Israel

[Website](https://react-next.com) - [Twitter](https://twitter.com/ReactNext) - [Videos](https://www.youtube.com/channel/UC3BT8hh3yTTYxbLQy_wbk2w)

### React India 2021

November 12-13, 2021 - remote event

[Website](https://www.reactindia.io) - [Twitter](https://twitter.com/react_india) - [Facebook](https://www.facebook.com/ReactJSIndia/) - [LinkedIn](https://www.linkedin.com/showcase/14545585) - [YouTube](https://www.youtube.com/channel/UCaFbHCBkPvVv1bWs_jwYt3w/videos)

### React Global by Geekle

November 3-4, 2021 - remote event

[Website](https://geekle.us/react) - [LinkedIn](https://www.linkedin.com/events/javascriptglobalsummit6721691514176720896/) - [YouTube](https://www.youtube.com/watch?v=0HhWIvPhbu0)

### React Advanced 2021

October 22-23, 2021. In-person in London, UK + remote (hybrid event)

[Website](https://reactadvanced.com) - [Twitter](https://twitter.com/reactadvanced) - [Facebook](https://www.facebook.com/ReactAdvanced) - [Videos](https://youtube.com/c/ReactConferences)

### React Conf Brasil 2021

October 16, 2021 - remote event

[Website](http://reactconf.com.br) - [Twitter](https://twitter.com/reactconfbr) - [Slack](https://react.now.sh) - [Facebook](https://facebook.com/reactconf) - [Instagram](https://instagram.com/reactconfbr) - [YouTube](https://www.youtube.com/channel/UCJL5eorStQfC0x1iiWhvqPA/videos)

### React Brussels 2021

October 15, 2021 - remote event

[Website](https://www.react.brussels/) - [Twitter](https://twitter.com/BrusselsReact) - [LinkedIn](https://www.linkedin.com/events/6805708233819336704/)

### render(ATL) 2021

September 13-15, 2021. Atlanta, GA, USA

[Website](https://renderatl.com) - [Twitter](https://twitter.com/renderATL) - [Instagram](https://www.instagram.com/renderatl/) - [Facebook](https://www.facebook.com/renderatl/) - [LinkedIn](https://www.linkedin.com/company/renderatl)

### React Native EU 2021

September 1-2, 2021 - remote event

[Website](https://www.react-native.eu/) - [Twitter](https://twitter.com/react_native_eu) - [Facebook](https://www.facebook.com/reactnativeeu/) - [Instagram](https://www.instagram.com/reactnative_eu/)

### React Finland 2021

August 30 - September 3, 2021 - remote event

[Website](https://react-finland.fi/) - [Twitter](https://twitter.com/ReactFinland) - [LinkedIn](https://www.linkedin.com/company/react-finland/)

### React Case Study Festival 2021

April 27-28, 2021 - remote event

[Website](https://link.geekle.us/react/offsite) - [LinkedIn](https://www.linkedin.com/events/reactcasestudyfestival6721300943411015680/) - [Facebook](https://www.facebook.com/events/255715435820203)

### React Summit - Remote Edition 2021

April 14-16, 2021, 7am PST / 10am EST / 4pm CEST - remote event

[Website](https://remote.reactsummit.com) - [Twitter](https://twitter.com/reactsummit) - [Facebook](https://www.facebook.com/reactamsterdam) - [Videos](https://portal.gitnation.org/events/react-summit-remote-edition-2021)

### React fwdays’21

March 27, 2021 - remote event

[Website](https://fwdays.com/en/event/react-fwdays-2021) - [Twitter](https://twitter.com/fwdays) - [Facebook](https://www.facebook.com/events/1133828147054286) - [LinkedIn](https://www.linkedin.com/events/reactfwdays-21onlineconference6758046347334582273) - [Meetup](https://www.meetup.com/ru-RU/Fwdays/events/275764431/)

### React Next 2020

December 1-2, 2020 - remote event

[Website](https://react-next.com/) - [Twitter](https://twitter.com/reactnext) - [Facebook](https://www.facebook.com/ReactNext2016/)

### React Conf Brasil 2020

November 21, 2020 - remote event

[Website](https://reactconf.com.br/) - [Twitter](https://twitter.com/reactconfbr) - [Slack](https://react.now.sh/)

### React Summit 2020

October 15-16, 2020, 7am PST / 10am EST / 4pm CEST - remote event

[Website](https://reactsummit.com) - [Twitter](https://twitter.com/reactsummit) - [Facebook](https://www.facebook.com/reactamsterdam) - [Videos](https://youtube.com/c/ReactConferences)

### React Native EU 2020

September 3-4, 2020 - remote event

[Website](https://www.react-native.eu/) - [Twitter](https://twitter.com/react_native_eu) - [Facebook](https://www.facebook.com/reactnativeeu/) - [YouTube](https://www.youtube.com/watch?v=m0GfmlGFh3E&list=PLZ3MwD-soTTHy9_88QPLF8DEJkvoB5Tl-) - [Instagram](https://www.instagram.com/reactnative_eu/)

### ReactEurope 2020

May 14-15, 2020 in Paris, France

[Videos](https://www.youtube.com/c/ReacteuropeOrgConf)

### Byteconf React 2020

May 1, 2020. Streamed online on YouTube.

[Website](https://www.bytesized.xyz) - [Twitter](https://twitter.com/bytesizedcode) - [YouTube](https://www.youtube.com/channel/UC046lFvJZhiwSRWsoH8SFjg)

### React Summit - Remote Edition 2020

3pm CEST time, April 17, 2020 - remote event

[Website](https://remote.reactsummit.com) - [Twitter](https://twitter.com/reactsummit) - [Facebook](https://www.facebook.com/reactamsterdam) - [Videos](https://youtube.com/c/ReactConferences)

### Reactathon 2020

March 30 - 31, 2020 in San Francisco, CA

[Website](https://www.reactathon.com) - [Twitter](https://twitter.com/reactathon) - [Facebook](https://www.facebook.com/events/575942819854160/)

### ReactConf AU 2020

February 27 & 28, 2020 in Sydney, Australia

[Website](https://reactconfau.com/) - [Twitter](https://twitter.com/reactconfau) - [Facebook](https://www.facebook.com/reactconfau) - [Instagram](https://www.instagram.com/reactconfau/)

### React Barcamp Cologne 2020

February 1-2, 2020 in Cologne, Germany

[Website](https://react-barcamp.de/) - [Twitter](https://twitter.com/ReactBarcamp) - [Facebook](https://www.facebook.com/reactbarcamp)

### React Day Berlin 2019

December 6, 2019 in Berlin, Germany

[Website](https://reactday.berlin) - [Twitter](https://twitter.com/reactdayberlin) - [Facebook](https://www.facebook.com/reactdayberlin/) - [Videos](https://www.youtube.com/reactdayberlin)

### React Summit 2019

November 30, 2019 in Lagos, Nigeria

[Website](https://reactsummit2019.splashthat.com) -[Twitter](https://twitter.com/react_summit)

### React Conf Brasil 2019

October 19, 2019 in São Paulo, BR

[Website](https://reactconf.com.br/) - [Twitter](https://twitter.com/reactconfbr) - [Facebook](https://www.facebook.com/ReactAdvanced) - [Slack](https://react.now.sh/)

### React Advanced 2019

October 25, 2019 in London, UK

[Website](https://reactadvanced.com) - [Twitter](http://twitter.com/reactadvanced) - [Facebook](https://www.facebook.com/ReactAdvanced) - [Videos](https://youtube.com/c/ReactConferences)

### React Conf 2019

October 24-25, 2019 in Henderson, Nevada USA

[Website](https://conf.reactjs.org/) - [Twitter](https://twitter.com/reactjs)

### React Alicante 2019

September 26-28, 2019 in Alicante, Spain

[Website](http://reactalicante.es/) - [Twitter](https://twitter.com/reactalicante) - [Facebook](https://www.facebook.com/ReactAlicante)

### React India 2019

September 26-28, 2019 in Goa, India

[Website](https://www.reactindia.io/) - [Twitter](https://twitter.com/react_india) - [Facebook](https://www.facebook.com/ReactJSIndia)

### React Boston 2019

September 21-22, 2019 in Boston, Massachusetts USA

[Website](https://www.reactboston.com/) - [Twitter](https://twitter.com/reactboston)

### React Live 2019

September 13th, 2019. Amsterdam, The Netherlands

[Website](https://www.reactlive.nl/) - [Twitter](https://twitter.com/reactlivenl)

### React New York 2019

September 13th, 2019. New York, USA

[Website](https://reactnewyork.com/) - [Twitter](https://twitter.com/reactnewyork)

### ComponentsConf 2019

September 6, 2019 in Melbourne, Australia

[Website](https://www.componentsconf.com.au/) - [Twitter](https://twitter.com/componentsconf)

### React Native EU 2019

September 5-6 in Wrocław, Poland

[Website](https://react-native.eu) - [Twitter](https://twitter.com/react_native_eu) - [Facebook](https://www.facebook.com/reactnativeeu)

### React Conf Iran 2019

August 29, 2019. Tehran, Iran.

[Website](https://reactconf.ir/) - [Videos](https://www.youtube.com/playlist?list=PL-VNqZFI5Nf-Nsj0rD3CWXGPkH-DI_0VY) - [Highlights](https://github.com/ReactConf/react-conf-highlights)

### React Rally 2019

August 22-23, 2019. Salt Lake City, USA.

[Website](https://www.reactrally.com/) - [Twitter](https://twitter.com/ReactRally) - [Instagram](https://www.instagram.com/reactrally/)

### Chain React 2019

July 11-12, 2019. Portland, OR, USA.

[Website](https://infinite.red/ChainReactConf)

### React Loop 2019

June 21, 2019 Chicago, Illinois USA

[Website](https://reactloop.com) - [Twitter](https://twitter.com/ReactLoop)

### React Norway 2019

June 12, 2019. Larvik, Norway

[Website](https://reactnorway.com) - [Twitter](https://twitter.com/ReactNorway)

### ReactNext 2019

June 11, 2019. Tel Aviv, Israel

[Website](https://react-next.com) - [Twitter](https://twitter.com/ReactNext) - [Videos](https://www.youtube.com/channel/UC3BT8hh3yTTYxbLQy_wbk2w)

### React Conf Armenia 2019

May 25, 2019 in Yerevan, Armenia

[Website](https://reactconf.am/) - [Twitter](https://twitter.com/ReactConfAM) - [Facebook](https://www.facebook.com/reactconf.am/) - [YouTube](https://www.youtube.com/c/JavaScriptConferenceArmenia) - [CFP](http://bit.ly/speakReact)

### ReactEurope 2019

May 23-24, 2019 in Paris, France

[Videos](https://www.youtube.com/c/ReacteuropeOrgConf)

### React.NotAConf 2019

May 11 in Sofia, Bulgaria

[Website](http://react-not-a-conf.com/) - [Twitter](https://twitter.com/reactnotaconf) - [Facebook](https://www.facebook.com/events/780891358936156)

### ReactJS Girls Conference

May 3, 2019 in London, UK

[Website](https://reactjsgirls.com/) - [Twitter](https://twitter.com/reactjsgirls)

### React Finland 2019

April 24-26 in Helsinki, Finland

[Website](https://react-finland.fi/) - [Twitter](https://twitter.com/ReactFinland)

### React Amsterdam 2019

April 12, 2019 in Amsterdam, The Netherlands

[Website](https://reactsummit.com) - [Twitter](https://twitter.com/reactsummit) - [Facebook](https://www.facebook.com/reactamsterdam) - [Videos](https://youtube.com/c/ReactConferences)

### App.js Conf 2019

April 4-5, 2019 in Kraków, Poland

[Website](https://appjs.co) - [Twitter](https://twitter.com/appjsconf)

### Reactathon 2019

March 30-31, 2019 in San Francisco, USA

[Website](https://www.reactathon.com/) - [Twitter](https://twitter.com/reactathon)

### React Iran 2019

January 31, 2019 in Tehran, Iran

[Website](http://reactiran.com) - [Instagram](https://www.instagram.com/reactiran/)

### React Day Berlin 2018

November 30, Berlin, Germany

[Website](https://reactday.berlin) - [Twitter](https://twitter.com/reactdayberlin) - [Facebook](https://www.facebook.com/reactdayberlin/) - [Videos](https://www.youtube.com/channel/UC1EYHmQYBUJjkmL6OtK4rlw)

### ReactNext 2018

November 4 in Tel Aviv, Israel

[Website](https://react-next.com) - [Twitter](https://twitter.com/ReactNext) - [Facebook](https://facebook.com/ReactNext2016)

### React Conf 2018

October 25-26 in Henderson, Nevada USA

[Website](https://conf.reactjs.org/)

### React Conf Brasil 2018

October 20 in Sao Paulo, Brazil

[Website](http://reactconfbr.com.br) - [Twitter](https://twitter.com/reactconfbr) - [Facebook](https://www.facebook.com/reactconf)

### ReactJS Day 2018

October 5 in Verona, Italy

[Website](http://2018.reactjsday.it) - [Twitter](https://twitter.com/reactjsday)

### React Boston 2018

September 29-30 in Boston, Massachusetts USA

[Website](http://www.reactboston.com/) - [Twitter](https://twitter.com/ReactBoston)

### React Alicante 2018

September 13-15 in Alicante, Spain

[Website](http://reactalicante.es) - [Twitter](https://twitter.com/ReactAlicante)

### React Native EU 2018

September 5-6 in Wrocław, Poland

[Website](https://react-native.eu) - [Twitter](https://twitter.com/react_native_eu) - [Facebook](https://www.facebook.com/reactnativeeu)

### Byteconf React 2018

August 31 streamed online, via Twitch

[Website](https://byteconf.com) - [Twitch](https://twitch.tv/byteconf) - [Twitter](https://twitter.com/byteconf)

### ReactFoo Delhi

August 18 in Delhi, India

[Website](https://reactfoo.in/2018-delhi/) - [Twitter](https://twitter.com/reactfoo) - [Past talks](https://hasgeek.tv)

### React DEV Conf China

August 18 in Guangzhou, China

[Website](https://react.w3ctech.com)

### React Rally 2018

August 16-17 in Salt Lake City, Utah USA

[Website](http://www.reactrally.com) - [Twitter](https://twitter.com/reactrally)

### Chain React 2018

July 11-13 in Portland, Oregon USA

[Website](https://infinite.red/ChainReactConf) - [Twitter](https://twitter.com/chainreactconf)

### ReactFoo Mumbai

May 26 in Mumbai, India

[Website](https://reactfoo.in/2018-mumbai/) - [Twitter](https://twitter.com/reactfoo) - [Past talks](https://hasgeek.tv)

### ReactEurope 2018

May 17-18 in Paris, France

[Videos](https://www.youtube.com/c/ReacteuropeOrgConf)

### React.NotAConf 2018

April 28 in Sofia, Bulgaria

[Website](http://react-not-a-conf.com/) - [Twitter](https://twitter.com/reactnotaconf) - [Facebook](https://www.facebook.com/groups/1614950305478021/)

### React Finland 2018

April 24-26 in Helsinki, Finland

[Website](https://react-finland.fi/) - [Twitter](https://twitter.com/ReactFinland)

### React Amsterdam 2018

April 13 in Amsterdam, The Netherlands

[Website](https://reactsummit.com) - [Twitter](https://twitter.com/reactsummit) - [Facebook](https://www.facebook.com/reactamsterdam)

### React Native Camp UA 2018

March 31 in Kiev, Ukraine

[Website](http://reactnative.com.ua/) - [Twitter](https://twitter.com/reactnativecamp) - [Facebook](https://www.facebook.com/reactnativecamp/)

### Reactathon 2018

March 20-22 in San Francisco, USA

[Website](https://www.reactathon.com/) - [Twitter](https://twitter.com/reactathon) - [Videos (fundamentals)](https://www.youtube.com/watch?v=knn364bssQU&list=PLRvKvw42Rc7OWK5s-YGGFSmByDzzgC0HP), [Videos (advanced day1)](https://www.youtube.com/watch?v=57hmk4GvJpk&list=PLRvKvw42Rc7N0QpX2Rc5CdrqGuxzwD_0H), [Videos (advanced day2)](https://www.youtube.com/watch?v=1hvQ8p8q0a0&list=PLRvKvw42Rc7Ne46QAjWNWFo1Jf0mQdnIW)

### ReactFest 2018

March 8-9 in London, UK

[Website](https://reactfest.uk/) - [Twitter](https://twitter.com/ReactFest) - [Videos](https://www.youtube.com/watch?v=YOCrJ5vRCnw&list=PLRgweB8YtNRt-Sf-A0y446wTJNUaAAmle)

### AgentConf 2018

January 25-28 in Dornbirn, Austria

[Website](http://agent.sh/)

### ReactFoo Pune

January 19-20, Pune, India

[Website](https://reactfoo.in/2018-pune/) - [Twitter](https://twitter.com/ReactFoo)

### React Day Berlin 2017

December 2, Berlin, Germany

[Website](https://reactday.berlin) - [Twitter](https://twitter.com/reactdayberlin) - [Facebook](https://www.facebook.com/reactdayberlin/) - [Videos](https://www.youtube.com/watch?v=UnNLJvHKfSY&list=PL-3BrJ5CiIx5GoXci54-VsrO6GwLhSHEK)

### React Seoul 2017

November 4 in Seoul, South Korea

[Website](http://seoul.reactjs.kr/en)

### ReactiveConf 2017

October 25–27, Bratislava, Slovakia

[Website](https://reactiveconf.com) - [Videos](https://www.youtube.com/watch?v=BOKxSFB2hOE&list=PLa2ZZ09WYepMB-I7AiDjDYR8TjO8uoNjs)

### React Summit 2017

October 21 in Lagos, Nigeria

[Website](https://reactsummit2017.splashthat.com/) - [Twitter](https://twitter.com/DevCircleLagos/) - [Facebook](https://www.facebook.com/groups/DevCLagos/)

### State.js Conference 2017

October 13 in Stockholm, Sweden

[Website](https://statejs.com/)

### React Conf Brasil 2017

October 7 in Sao Paulo, Brazil

[Website](http://reactconfbr.com.br) - [Twitter](https://twitter.com/reactconfbr) - [Facebook](https://www.facebook.com/reactconf/)

### ReactJS Day 2017

October 6 in Verona, Italy

[Website](http://2017.reactjsday.it) - [Twitter](https://twitter.com/reactjsday) - [Videos](https://www.youtube.com/watch?v=bUqqJPIgjNU&list=PLWK9j6ps_unl293VhhN4RYMCISxye3xH9)

### React Alicante 2017

September 28-30 in Alicante, Spain

[Website](http://reactalicante.es) - [Twitter](https://twitter.com/ReactAlicante) - [Videos](https://www.youtube.com/watch?v=UMZvRCWo6Dw&list=PLd7nkr8mN0sWvBH_s0foCE6eZTX8BmLUM)

### React Boston 2017

September 23-24 in Boston, Massachusetts USA

[Website](http://www.reactboston.com/) - [Twitter](https://twitter.com/ReactBoston) - [Videos](https://www.youtube.com/watch?v=2iPE5l3cl_s&list=PL-fCkV3wv4ub8zJMIhmrrLcQqSR5XPlIT)

### ReactFoo 2017

September 14 in Bangalore, India

[Website](https://reactfoo.in/2017/) - [Videos](https://www.youtube.com/watch?v=3G6tMg29Wnw&list=PL279M8GbNsespKKm1L0NAzYLO6gU5LvfH)

### ReactNext 2017

September 8-10 in Tel Aviv, Israel

[Website](http://react-next.com/) - [Twitter](https://twitter.com/ReactNext) - [Videos (Hall A)](https://www.youtube.com/watch?v=eKXQw5kR86c&list=PLMYVq3z1QxSqq6D7jxVdqttOX7H_Brq8Z), [Videos (Hall B)](https://www.youtube.com/watch?v=1InokWxYGnE&list=PLMYVq3z1QxSqCZmaqgTXLsrcJ8mZmBF7T)

### React Native EU 2017

September 6-7 in Wroclaw, Poland

[Website](http://react-native.eu/) - [Videos](https://www.youtube.com/watch?v=453oKJAqfy0&list=PLzUKC1ci01h_hkn7_KoFA-Au0DXLAQZR7)

### React Rally 2017

August 24-25 in Salt Lake City, Utah USA

[Website](http://www.reactrally.com) - [Twitter](https://twitter.com/reactrally) - [Videos](https://www.youtube.com/watch?v=f4KnHNCZcH4&list=PLUD4kD-wL_zZUhvAIHJjueJDPr6qHvkni)

### Chain React 2017

July 10-11 in Portland, Oregon USA

[Website](https://infinite.red/ChainReactConf) - [Twitter](https://twitter.com/chainreactconf) - [Videos](https://www.youtube.com/watch?v=cz5BzwgATpc&list=PLFHvL21g9bk3RxJ1Ut5nR_uTZFVOxu522)

### ReactEurope 2017

May 18th & 19th in Paris, France

[Videos](https://www.youtube.com/c/ReacteuropeOrgConf)

### React Amsterdam 2017

April 21st in Amsterdam, The Netherlands

[Website](https://reactsummit.com) - [Twitter](https://twitter.com/reactsummit) - [Videos](https://youtube.com/c/ReactConferences)

### React London 2017

March 28th at the [QEII Centre, London](http://qeiicentre.london/)

[Website](http://react.london/) - [Videos](https://www.youtube.com/watch?v=2j9rSur_mnk&list=PLW6ORi0XZU0CFjdoYeC0f5QReBG-NeNKJ)

### React Conf 2017

March 13-14 in Santa Clara, CA

[Website](http://conf.reactjs.org/) - [Videos](https://www.youtube.com/watch?v=7HSd1sk07uU&list=PLb0IAmt7-GS3fZ46IGFirdqKTIxlws7e0)

### Agent Conference 2017

January 20-21 in Dornbirn, Austria

[Website](http://agent.sh/)

### React Remote Conf 2016

October 26-28 online

[Website](https://allremoteconfs.com/react-2016) - [Schedule](https://allremoteconfs.com/react-2016#schedule)

### Reactive 2016

October 26-28 in Bratislava, Slovakia

[Website](https://reactiveconf.com/)

### ReactNL 2016

October 13 in Amsterdam, The Netherlands

[Website](http://reactnl.org/) - [Schedule](http://reactnl.org/#program)

### ReactNext 2016

September 15 in Tel Aviv, Israel

[Website](http://react-next.com/) - [Schedule](http://react-next.com/#schedule) - [Videos](https://www.youtube.com/channel/UC3BT8hh3yTTYxbLQy_wbk2w)

### ReactRally 2016

August 25-26 in Salt Lake City, UT

[Website](http://www.reactrally.com/) - [Schedule](http://www.reactrally.com/#/schedule) - [Videos](https://www.youtube.com/playlist?list=PLUD4kD-wL_zYSfU3tIYsb4WqfFQzO_EjQ)

### ReactEurope 2016

June 2 & 3 in Paris, France

[Videos](https://www.youtube.com/c/ReacteuropeOrgConf)

### React Amsterdam 2016

April 16 in Amsterdam, The Netherlands

[Website](https://reactsummit.com) - [Twitter](https://twitter.com/reactsummit) - [Facebook](https://www.facebook.com/reactamsterdam) - [Videos](https://youtube.com/c/ReactConferences)

### React.js Conf 2016

February 22 & 23 in San Francisco, CA

[Website](http://conf2016.reactjs.org/) - [Schedule](http://conf2016.reactjs.org/schedule.html) - [Videos](https://www.youtube.com/playlist?list=PLb0IAmt7-GS0M8Q95RIc2lOM6nc77q1IY)

### Reactive 2015

November 2-4 in Bratislava, Slovakia

[Website](https://reactive2015.com/) - [Schedule](https://reactive2015.com/schedule_speakers.html#schedule)

### ReactEurope 2015

July 2 & 3 in Paris, France

[Videos](https://www.youtube.com/c/ReacteuropeOrgConf)

### React.js Conf 2015

January 28 & 29 in Facebook HQ, CA

[Website](http://conf2015.reactjs.org/) - [Schedule](http://conf2015.reactjs.org/schedule.html) - [Videos](https://www.youtube.com/playlist?list=PLb0IAmt7-GS1cbw4qonlQztYV1TAW0sCr)

[PreviousCommunity](https://react.dev/community)[NextReact Meetups](https://react.dev/community/meetups)

---

---


# React Meetups – React

URL: https://react.dev/community/meetups

[Community](https://react.dev/community)

# React Meetups

Do you have a local React.js meetup? Add it here! (Please keep the list alphabetical)

## Albania

* [Tirana](https://www.meetup.com/React-User-Group-Albania/)

## Argentina

* [Buenos Aires](https://www.meetup.com/es/React-en-Buenos-Aires)
* [Rosario](https://www.meetup.com/es/reactrosario)

## Australia

* [Brisbane](https://www.meetup.com/reactbris/)
* [Melbourne](https://www.meetup.com/React-Melbourne/)
* [Sydney](https://www.meetup.com/React-Sydney/)

## Austria

* [Vienna](https://www.meetup.com/Vienna-ReactJS-Meetup/)

## Belgium

* [Belgium](https://www.meetup.com/ReactJS-Belgium/)

## Brazil

* [Belo Horizonte](https://www.meetup.com/reactbh/)
* [Curitiba](https://www.meetup.com/pt-br/ReactJS-CWB/)
* [Florianópolis](https://www.meetup.com/pt-br/ReactJS-Floripa/)
* [Joinville](https://www.meetup.com/pt-BR/React-Joinville/)
* [São Paulo](https://www.meetup.com/pt-BR/ReactJS-SP/)

## Bolivia

* [Bolivia](https://www.meetup.com/ReactBolivia/)

## Canada

* [Halifax, NS](https://www.meetup.com/Halifax-ReactJS-Meetup/)
* [Montreal, QC](https://guild.host/react-montreal/)
* [Vancouver, BC](https://www.meetup.com/ReactJS-Vancouver-Meetup/)
* [Ottawa, ON](https://www.meetup.com/Ottawa-ReactJS-Meetup/)
* [Saskatoon, SK](https://www.meetup.com/saskatoon-react-meetup/)
* [Toronto, ON](https://www.meetup.com/Toronto-React-Native/events/)

## Colombia

* [Medellin](https://www.meetup.com/React-Medellin/)

## Czechia

* [Prague](https://guild.host/react-prague/)

## Denmark

* [Aalborg](https://www.meetup.com/Aalborg-React-React-Native-Meetup/)
* [Aarhus](https://www.meetup.com/Aarhus-ReactJS-Meetup/)

## England (UK)

* [Manchester](https://www.meetup.com/Manchester-React-User-Group/)
* [React.JS Girls London](https://www.meetup.com/ReactJS-Girls-London/)
* [React Advanced London](https://guild.host/react-advanced-london)
* [React Native Liverpool](https://www.meetup.com/react-native-liverpool/)
* [React Native London](https://guild.host/RNLDN)

## Finland

* [Helsinki](https://www.meetabit.com/communities/react-helsinki)

## France

* [Lille](https://www.meetup.com/ReactBeerLille/)
* [Paris](https://www.meetup.com/ReactJS-Paris/)

## Germany

* [Cologne](https://www.meetup.com/React-Cologne/)
* [Düsseldorf](https://www.meetup.com/de-DE/ReactJS-Meetup-Dusseldorf/)
* [Hamburg](https://www.meetup.com/Hamburg-React-js-Meetup/)
* [Karlsruhe](https://www.meetup.com/react_ka/)
* [Kiel](https://www.meetup.com/Kiel-React-Native-Meetup/)
* [Munich](https://www.meetup.com/ReactJS-Meetup-Munich/)
* [React Berlin](https://guild.host/react-berlin)

## Greece

* [Athens](https://www.meetup.com/React-To-React-Athens-MeetUp/)
* [Thessaloniki](https://www.meetup.com/Thessaloniki-ReactJS-Meetup/)

## India

* [Ahmedabad](https://reactahmedabad.dev/)
* [Bangalore (React)](https://www.meetup.com/ReactJS-Bangalore/)
* [Bangalore (React Native)](https://www.meetup.com/React-Native-Bangalore-Meetup)
* [Chennai](https://www.linkedin.com/company/chennaireact)
* [Delhi NCR](https://www.meetup.com/React-Delhi-NCR/)
* [Mumbai](https://reactmumbai.dev)
* [Pune](https://www.meetup.com/ReactJS-and-Friends/)
* [Rajasthan](https://reactrajasthan.com)

## Indonesia

* [Indonesia](https://www.meetup.com/reactindonesia/)

## Ireland

* [Dublin](https://guild.host/reactjs-dublin)

## Israel

* [Tel Aviv](https://www.meetup.com/ReactJS-Israel/)

## Italy

* [Milan](https://www.meetup.com/React-JS-Milano/)

## Japan

* [Osaka](https://react-osaka.connpass.com/)

## Kenya

* [Nairobi - Reactdevske](https://kommunity.com/reactjs-developer-community-kenya-reactdevske)

## Malaysia

* [Kuala Lumpur](https://www.kl-react.com/)
* [Penang](https://www.facebook.com/groups/reactpenang/)

## Netherlands

* [Amsterdam](https://guild.host/react-amsterdam)

## New Zealand

* [Wellington](https://www.meetup.com/React-Wellington/)

## Norway

* [Norway](https://reactjs-norway.webflow.io/)
* [Oslo](https://www.meetup.com/ReactJS-Oslo-Meetup/)

## Pakistan

* [Karachi](https://www.facebook.com/groups/902678696597634/)
* [Lahore](https://www.facebook.com/groups/ReactjsLahore/)

## Philippines

* [Manila](https://www.meetup.com/reactjs-developers-manila/)
* [Manila - ReactJS PH](https://www.meetup.com/ReactJS-Philippines/)

## Poland

* [Warsaw](https://www.meetup.com/React-js-Warsaw/)
* [Wrocław](https://www.meetup.com/ReactJS-Wroclaw/)

## Portugal

* [Lisbon](https://www.meetup.com/JavaScript-Lisbon/)

## Scotland (UK)

* [Edinburgh](https://www.meetup.com/react-edinburgh/)

## Spain

* [Barcelona](https://www.meetup.com/ReactJS-Barcelona/)

## Sri Lanka

* [Colombo](https://www.javascriptcolombo.com/)

## Sweden

* [Goteborg](https://www.meetup.com/ReactJS-Goteborg/)
* [Stockholm](https://www.meetup.com/Stockholm-ReactJS-Meetup/)

## Switzerland

* [Zurich](https://www.meetup.com/Zurich-ReactJS-Meetup/)

## Turkey

* [Istanbul](https://kommunity.com/reactjs-istanbul)

## Ukraine

* [Kyiv](https://www.meetup.com/Kyiv-ReactJS-Meetup)

## US

* [Atlanta, GA - ReactJS](https://www.meetup.com/React-ATL/)
* [Austin, TX - ReactJS](https://www.meetup.com/ReactJS-Austin-Meetup/)
* [Boston, MA - ReactJS](https://www.meetup.com/ReactJS-Boston/)
* [Boston, MA - React Native](https://www.meetup.com/Boston-React-Native-Meetup/)
* [Charlotte, NC - ReactJS](https://www.meetup.com/ReactJS-Charlotte/)
* [Charlotte, NC - React Native](https://www.meetup.com/cltreactnative/)
* [Chicago, IL - ReactJS](https://www.meetup.com/React-Chicago/)
* [Cleveland, OH - ReactJS](https://www.meetup.com/Cleveland-React/)
* [Columbus, OH - ReactJS](https://www.meetup.com/ReactJS-Columbus-meetup/)
* [Dallas, TX - ReactJS](https://www.meetup.com/ReactDallas/)
* [Denver, CO - React Denver](https://reactdenver.com/)
* [Detroit, MI - Detroit React User Group](https://www.meetup.com/Detroit-React-User-Group/)
* [Indianapolis, IN - React.Indy](https://www.meetup.com/React-Indy)
* [Irvine, CA - ReactJS](https://www.meetup.com/ReactJS-OC/)
* [Kansas City, MO - ReactJS](https://www.meetup.com/Kansas-City-React-Meetup/)
* [Las Vegas, NV - ReactJS](https://www.meetup.com/ReactVegas/)
* [Leesburg, VA - ReactJS](https://www.meetup.com/React-NOVA/)
* [Los Angeles, CA - ReactJS](https://www.meetup.com/socal-react/)
* [Los Angeles, CA - React Native](https://www.meetup.com/React-Native-Los-Angeles/)
* [Miami, FL - ReactJS](https://www.meetup.com/React-Miami/)
* [New York, NY - ReactJS](https://www.meetup.com/NYC-Javascript-React-Group/)
* [New York, NY - React Ladies](https://www.meetup.com/React-Ladies/)
* [New York, NY - React Native](https://www.meetup.com/React-Native-NYC/)
* [New York, NY - useReactNYC](https://www.meetup.com/useReactNYC/)
* [New York, NY - React.NYC](https://guild.host/react-nyc)
* [Palo Alto, CA - React Native](https://www.meetup.com/React-Native-Silicon-Valley/)
* [Phoenix, AZ - ReactJS](https://www.meetup.com/ReactJS-Phoenix/)
* [Provo, UT - ReactJS](https://www.meetup.com/ReactJS-Utah/)
* [San Diego, CA - San Diego JS](https://www.meetup.com/sandiegojs/)
* [San Francisco - Real World React](https://www.meetup.com/Real-World-React)
* [San Francisco - ReactJS](https://www.meetup.com/ReactJS-San-Francisco/)
* [San Francisco, CA - React Native](https://www.meetup.com/React-Native-San-Francisco/)
* [Santa Monica, CA - ReactJS](https://www.meetup.com/Los-Angeles-ReactJS-User-Group/)
* [Seattle, WA - ReactJS](https://www.meetup.com/seattle-react-js/)
* [Tampa, FL - ReactJS](https://www.meetup.com/ReactJS-Tampa-Bay/)
* [Tucson, AZ - ReactJS](https://www.meetup.com/Tucson-ReactJS-Meetup/)
* [Washington, DC - ReactJS](https://www.meetup.com/React-DC/)

[PreviousReact Conferences](https://react.dev/community/conferences)[NextReact Videos](https://react.dev/community/videos)

---

---


# React Videos – React

URL: https://react.dev/community/videos

[Community](https://react.dev/community)

# React Videos

Videos dedicated to the discussion of React and the React ecosystem.

## React Conf 2024

At React Conf 2024, Meta CTO [Andrew “Boz” Bosworth](https://www.threads.net/@boztank) shared a welcome message to kick off the conference:

### React 19 Keynote

In the Day 1 keynote, we shared vision for React starting with React 19 and the React Compiler. Watch the full keynote from [Joe Savona](https://twitter.com/en_JS), [Lauren Tan](https://twitter.com/potetotes), [Andrew Clark](https://twitter.com/acdlite), [Josh Story](https://twitter.com/joshcstory), [Sathya Gunasekaran](https://twitter.com/_gsathya), and [Mofei Zhang](https://twitter.com/zmofei):

### React Unpacked: A Roadmap to React 19

React 19 introduced new features including Actions, `use()`, `useOptimistic` and more. For a deep dive on using new features in React 19, see [Sam Selikoff’s](https://twitter.com/samselikoff) talk:

### What’s New in React 19

[Lydia Hallie](https://twitter.com/lydiahallie) gave a visual deep dive of React 19’s new features:

### React 19 Deep Dive: Coordinating HTML

[Josh Story](https://twitter.com/joshcstory) provided a deep dive on the document and resource streaming APIs in React 19:

### React for Two Computers

[Dan Abramov](https://bsky.app/profile/danabra.mov) imagined an alternate history where React started server-first:

### Forget About Memo

[Lauren Tan](https://twitter.com/potetotes) gave a talk on using the React Compiler in practice:

### React Compiler Deep Dive

[Sathya Gunasekaran](https://twitter.com/_gsathya) and [Mofei Zhang](https://twitter.com/zmofei) provided a deep dive on how the React Compiler works:

### And more…

**We also heard talks from the community on Server Components:**

* [Enhancing Forms with React Server Components](https://www.youtube.com/embed/0ckOUBiuxVY&t=25280s) by [Aurora Walberg Scharff](https://twitter.com/aurorascharff)
* [And Now You Understand React Server Components](https://www.youtube.com/embed/pOo7x8OiAec) by [Kent C. Dodds](https://twitter.com/kentcdodds)
* [Real-time Server Components](https://www.youtube.com/embed/6sMANTHWtLM) by [Sunil Pai](https://twitter.com/threepointone)

**Talks from React frameworks using new features:**

* [Vanilla React](https://www.youtube.com/embed/ZcwA0xt8FlQ) by [Ryan Florence](https://twitter.com/ryanflorence)
* [React Rhythm & Blues](https://www.youtube.com/embed/rs9X5MjvC4s) by [Lee Robinson](https://twitter.com/leeerob)
* [RedwoodJS, now with React Server Components](https://www.youtube.com/embed/sjyY4MTECUU) by [Amy Dutton](https://twitter.com/selfteachme)
* [Introducing Universal React Server Components in Expo Router](https://www.youtube.com/embed/djhEgxQf3Kw) by [Evan Bacon](https://twitter.com/Baconbrix)

**And Q&As with the React and React Native teams:**

* [React Q&A](https://www.youtube.com/embed/T8TZQ6k4SLE&t=27518s) hosted by [Michael Chan](https://twitter.com/chantastic)
* [React Native Q&A](https://www.youtube.com/embed/0ckOUBiuxVY&t=27935s) hosted by [Jamon Holmgren](https://twitter.com/jamonholmgren)

You can watch all of the talks at React Conf 2024 at [conf2024.react.dev](https://conf2024.react.dev/talks).

## React Conf 2021

### React 18 Keynote

In the keynote, we shared our vision for the future of React starting with React 18.

Watch the full keynote from [Andrew Clark](https://twitter.com/acdlite), [Juan Tejada](https://twitter.com/_jstejada), [Lauren Tan](https://twitter.com/potetotes), and [Rick Hanlon](https://twitter.com/rickhanlonii) here:

### React 18 for Application Developers

For a demo of upgrading to React 18, see [Shruti Kapoor](https://twitter.com/shrutikapoor08)’s talk here:

### Streaming Server Rendering with Suspense

React 18 also includes improvements to server-side rendering performance using Suspense.

Streaming server rendering lets you generate HTML from React components on the server, and stream that HTML to your users. In React 18, you can use `Suspense` to break down your app into smaller independent units which can be streamed independently of each other without blocking the rest of the app. This means users will see your content sooner and be able to start interacting with it much faster.

For a deep dive, see [Shaundai Person](https://twitter.com/shaundai)’s talk here:

### The first React working group

For React 18, we created our first Working Group to collaborate with a panel of experts, developers, library maintainers, and educators. Together we worked to create our gradual adoption strategy and refine new APIs such as `useId`, `useSyncExternalStore`, and `useInsertionEffect`.

For an overview of this work, see [Aakansha’ Doshi](https://twitter.com/aakansha1216)’s talk:

### React Developer Tooling

To support the new features in this release, we also announced the newly formed React DevTools team and a new Timeline Profiler to help developers debug their React apps.

For more information and a demo of new DevTools features, see [Brian Vaughn](https://twitter.com/brian_d_vaughn)’s talk:

### React without memo

Looking further into the future, [Xuan Huang (黄玄)](https://twitter.com/Huxpro) shared an update from our React Labs research into an auto-memoizing compiler. Check out this talk for more information and a demo of the compiler prototype:

### React docs keynote

[Rachel Nabors](https://twitter.com/rachelnabors) kicked off a section of talks about learning and designing with React with a keynote about our investment in React’s new docs ([now shipped as react.dev](https://react.dev/blog/2023/03/16/introducing-react-dev)):

### And more…

**We also heard talks on learning and designing with React:**

* Debbie O’Brien: [Things I learnt from the new React docs](https://youtu.be/-7odLW_hG7s).
* Sarah Rainsberger: [Learning in the Browser](https://youtu.be/5X-WEQflCL0).
* Linton Ye: [The ROI of Designing with React](https://youtu.be/7cPWmID5XAk).
* Delba de Oliveira: [Interactive playgrounds with React](https://youtu.be/zL8cz2W0z34).

**Talks from the Relay, React Native, and PyTorch teams:**

* Robert Balicki: [Re-introducing Relay](https://youtu.be/lhVGdErZuN4).
* Eric Rozell and Steven Moyes: [React Native Desktop](https://youtu.be/9L4FFrvwJwY).
* Roman Rädle: [On-device Machine Learning for React Native](https://youtu.be/NLj73vrc2I8)

**And talks from the community on accessibility, tooling, and Server Components:**

* Daishi Kato: [React 18 for External Store Libraries](https://youtu.be/oPfSC5bQPR8).
* Diego Haz: [Building Accessible Components in React 18](https://youtu.be/dcm8fjBfro8).
* Tafu Nakazaki: [Accessible Japanese Form Components with React](https://youtu.be/S4a0QlsH0pU).
* Lyle Troxell: [UI tools for artists](https://youtu.be/b3l4WxipFsE).
* Helen Lin: [Hydrogen + React 18](https://youtu.be/HS6vIYkSNks).

## Older videos

### React Conf 2019

A playlist of videos from React Conf 2019.

### React Conf 2018

A playlist of videos from React Conf 2018.

### React.js Conf 2017

A playlist of videos from React.js Conf 2017.

### React.js Conf 2016

A playlist of videos from React.js Conf 2016.

### React.js Conf 2015

A playlist of videos from React.js Conf 2015.

### Rethinking Best Practices

Pete Hunt’s talk at JSConf EU 2013 covers three topics: throwing out the notion of templates and building views with JavaScript, “re-rendering” your entire application when your data changes, and a lightweight implementation of the DOM and events - (2013 - 0h30m).

### Introduction to React

Tom Occhino and Jordan Walke introduce React at Facebook Seattle - (2013 - 1h20m).

[PreviousReact Meetups](https://react.dev/community/meetups)[NextMeet the Team](https://react.dev/community/team)

---

---


# Meet the Team – React

URL: https://react.dev/community/team

[Community](https://react.dev/community)

# Meet the Team

React development is led by a dedicated team working full time at Meta. It also receives contributions from people all over the world.

## React Core

The React Core team members work full time on the core component APIs, the engine that powers React DOM and React Native, React DevTools, and the React documentation website.

Current members of the React team are listed in alphabetical order below.

![Andrew Clark](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Andrew Clark](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Facdlite.jpg&w=3840&q=75)

![Andrew Clark](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Andrew Clark](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Facdlite.jpg&w=3840&q=75)

### Andrew Clark

Engineer at Vercel

Andrew got started with web development by making sites with WordPress, and eventually tricked himself into doing JavaScript. His favorite pastime is karaoke. Andrew is either a Disney villain or a Disney princess, depending on the day.

[acdlite](https://twitter.com/acdlite)

[acdlite](https://threads.net/acdlite)

[acdlite](https://github.com/acdlite)

![Dan Abramov](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Dan Abramov](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fgaearon.jpg&w=3840&q=75)

![Dan Abramov](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Dan Abramov](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fgaearon.jpg&w=3840&q=75)

### Dan Abramov

Independent Engineer

Dan got into programming after he accidentally discovered Visual Basic inside Microsoft PowerPoint. He has found his true calling in turning [Sebastian](https://react.dev/community/team#sebastian-markb%C3%A5ge)’s tweets into long-form blog posts. Dan occasionally wins at Fortnite by hiding in a bush until the game ends.

[danabra.mov](https://bsky.app/profile/danabra.mov)

[gaearon](https://github.com/gaearon)

![Eli White](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Eli White](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Feli-white.jpg&w=3840&q=75)

![Eli White](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Eli White](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Feli-white.jpg&w=3840&q=75)

### Eli White

Engineering Manager at Meta

Eli got into programming after he got suspended from middle school for hacking. He has been working on React and React Native since 2017. He enjoys eating treats, especially ice cream and apple pie. You can find Eli trying quirky activities like parkour, indoor skydiving, and aerial silks.

[Eli\_White](https://twitter.com/Eli_White)

[elicwhite](https://threads.net/elicwhite)

[elicwhite](https://github.com/elicwhite)

![Hendrik Liebau](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Hendrik Liebau](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fhendrik.jpg&w=3840&q=75)

![Hendrik Liebau](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Hendrik Liebau](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fhendrik.jpg&w=3840&q=75)

### Hendrik Liebau

Engineer at Vercel

Hendrik’s journey in tech started in the late 90s when he built his first websites with Netscape Communicator. After earning a diploma in computer science and working at digital agencies, he built a React Server Components bundler and library, paving the way to his role on the Next.js team. Outside of work, he enjoys cycling and tinkering in his workshop.

[unstubbable](https://twitter.com/unstubbable)

[unstubbable.bsky.social](https://bsky.app/profile/unstubbable.bsky.social)

[unstubbable](https://github.com/unstubbable)

![Jack Pope](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Jack Pope](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjack-pope.jpg&w=3840&q=75)

![Jack Pope](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Jack Pope](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjack-pope.jpg&w=3840&q=75)

### Jack Pope

Engineer at Meta

Shortly after being introduced to AutoHotkey, Jack had written scripts to automate everything he could think of. When reaching limitations there, he dove headfirst into web app development and hasn’t looked back. Most recently, Jack worked on the web platform at Instagram before moving to React. His favorite programming language is JSX.

[jackpope](https://github.com/jackpope)

 [jackpope.me](https://jackpope.me)

![Jason Bonta](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Jason Bonta](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjasonbonta.jpg&w=3840&q=75)

![Jason Bonta](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Jason Bonta](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjasonbonta.jpg&w=3840&q=75)

### Jason Bonta

Engineering Manager at Meta

Jason abandoned embedded C for a career in front-end engineering and never looked back. Armed with esoteric CSS knowledge and a passion for beautiful UI, Jason joined Facebook in 2010, where he now feels privileged to have seen JavaScript development come of age. Though he may not understand how `for...of` loops work, he loves getting to work with brilliant people on projects that enable amazing UX.

[someextent](https://threads.net/someextent)

![Joe Savona](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Joe Savona](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjoe.jpg&w=3840&q=75)

![Joe Savona](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Joe Savona](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjoe.jpg&w=3840&q=75)

### Joe Savona

Engineer at Meta

Joe was planning to major in math and philosophy but got into computer science after writing physics simulations in Matlab. Prior to React, he worked on Relay, RSocket.js, and the Skip programming language. While he’s not building some sort of reactive system he enjoys running, studying Japanese, and spending time with his family.

[en\_JS](https://twitter.com/en_JS)

[joesavona](https://threads.net/joesavona)

[josephsavona](https://github.com/josephsavona)

![Jordan Brown](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Jordan Brown](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjordan.jpg&w=3840&q=75)

![Jordan Brown](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Jordan Brown](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjordan.jpg&w=3840&q=75)

### Jordan Brown

Engineer at Meta

Jordan started coding by building iPhone apps, where he was pushing and popping view controllers before he knew that for-loops were a thing. He enjoys working on technology that developers love, which naturally drew him to React. Outside of work he enjoys reading, kiteboarding, and playing guitar.

[jbrown215](https://github.com/jbrown215)

![Josh Story](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Josh Story](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjosh.jpg&w=3840&q=75)

![Josh Story](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Josh Story](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fjosh.jpg&w=3840&q=75)

### Josh Story

Engineer at Vercel

Josh majored in Mathematics and discovered programming while in college. His first professional developer job was to program insurance rate calculations in Microsoft Excel, the paragon of Reactive Programming which must be why he now works on React. In between that time Josh has been an IC, Manager, and Executive at a few startups. outside of work he likes to push his limits with cooking.

[storyhb.com](https://bsky.app/profile/storyhb.com)

[gnoff](https://github.com/gnoff)

![Lauren Tan](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Lauren Tan](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Flauren.jpg&w=3840&q=75)

![Lauren Tan](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Lauren Tan](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Flauren.jpg&w=3840&q=75)

### Lauren Tan

Engineer at Meta

Lauren’s programming career peaked when she first discovered the `<marquee>` tag. She’s been chasing that high ever since. She studied Finance instead of CS in college, so she learned to code using Excel. Lauren enjoys dropping cheeky memes in chat, playing video games with her partner, learning Korean, and petting her dog Zelda.

[potetotes](https://twitter.com/potetotes)

[potetotes](https://threads.net/potetotes)

[no.lol](https://bsky.app/profile/no.lol)

[poteto](https://github.com/poteto)

![Matt Carroll](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Matt Carroll](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fmatt-carroll.png&w=3840&q=75)

![Matt Carroll](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Matt Carroll](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fmatt-carroll.png&w=3840&q=75)

### Matt Carroll

Developer Advocate at Meta

Matt stumbled into coding, and since then, has become enamored with creating things in communities that can’t be created alone. Prior to React, he worked on YouTube, the Google Assistant, Fuchsia, and Google Cloud AI and Evernote. When he’s not trying to make better developer tools he enjoys the mountains, jazz, and spending time with his family.

[mattcarrollcode](https://twitter.com/mattcarrollcode)

[mattcarrollcode](https://threads.net/mattcarrollcode)

[mattcarrollcode](https://github.com/mattcarrollcode)

![Mike Vitousek](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Mike Vitousek](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fmike.jpg&w=3840&q=75)

![Mike Vitousek](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Mike Vitousek](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fmike.jpg&w=3840&q=75)

### Mike Vitousek

Engineer at Meta

Mike went to grad school dreaming of becoming a professor but realized that he liked building things a lot more than writing grant applications. Mike joined Meta to work on Javascript infrastructure, which ultimately led him to work on the React Compiler. When not hacking on either Javascript or OCaml, Mike can often be found hiking or skiing in the Pacific Northwest.

[mvitousek](https://github.com/mvitousek)

![Mofei Zhang](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Mofei Zhang](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fmofei-zhang.png&w=3840&q=75)

![Mofei Zhang](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Mofei Zhang](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fmofei-zhang.png&w=3840&q=75)

### Mofei Zhang

Engineer at Meta

Mofei started programming when she realized it can help her cheat in video games. She focused on operating systems in undergrad / grad school, but now finds herself happily tinkering on React. Outside of work, she enjoys debugging bouldering problems and planning her next backpacking trip(s).

[z\_mofei](https://threads.net/z_mofei)

[mofeiZ](https://github.com/mofeiZ)

![Pieter Vanderwerff](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Pieter Vanderwerff](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fpieter.jpg&w=3840&q=75)

![Pieter Vanderwerff](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Pieter Vanderwerff](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fpieter.jpg&w=3840&q=75)

### Pieter Vanderwerff

Engineer at Meta

Pieter studied building science but after failing to get a job he made himself a website and things escalated from there. At Meta, he enjoys working on performance, languages and now React. When he’s not programming you can find him off-road in the mountains.

[pietervanderwerff](https://threads.net/pietervanderwerff)

[pieterv](https://github.com/pieterv)

![Rick Hanlon](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Rick Hanlon](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Frickhanlonii.jpg&w=3840&q=75)

![Rick Hanlon](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Rick Hanlon](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Frickhanlonii.jpg&w=3840&q=75)

### Rick Hanlon

Engineer at Meta

Ricky majored in theoretical math and somehow found himself on the React Native team for a couple years before joining the React team. When he’s not programming you can find him snowboarding, biking, climbing, golfing, or closing GitHub issues that do not match the issue template.

[rickhanlonii](https://twitter.com/rickhanlonii)

[rickhanlonii](https://threads.net/rickhanlonii)

[ricky.fm](https://bsky.app/profile/ricky.fm)

[rickhanlonii](https://github.com/rickhanlonii)

![Ruslan Lesiutin](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Ruslan Lesiutin](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Flesiutin.jpg&w=3840&q=75)

![Ruslan Lesiutin](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Ruslan Lesiutin](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Flesiutin.jpg&w=3840&q=75)

### Ruslan Lesiutin

Engineer at Meta

Ruslan’s introduction to UI programming started when he was a kid by manually editing HTML templates for his custom gaming forums. Somehow, he ended up majoring in Computer Science. He enjoys music, games, and memes. Mostly memes.

[ruslanlesiutin](https://twitter.com/ruslanlesiutin)

[lesiutin](https://threads.net/lesiutin)

[hoxyq](https://github.com/hoxyq)

![Sebastian Markbåge](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Sebastian Markbåge](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fsebmarkbage.jpg&w=3840&q=75)

![Sebastian Markbåge](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Sebastian Markbåge](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fsebmarkbage.jpg&w=3840&q=75)

### Sebastian Markbåge

Engineer at Vercel

Sebastian majored in psychology. He’s usually quiet. Even when he says something, it often doesn’t make sense to the rest of us until a few months later. The correct way to pronounce his surname is “mark-boa-geh” but he settled for “mark-beige” out of pragmatism — and that’s how he approaches React.

[sebmarkbage](https://twitter.com/sebmarkbage)

[sebmarkbage](https://threads.net/sebmarkbage)

[sebmarkbage](https://github.com/sebmarkbage)

![Sebastian Silbermann](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Sebastian Silbermann](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fsebsilbermann.jpg&w=3840&q=75)

![Sebastian Silbermann](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Sebastian Silbermann](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fsebsilbermann.jpg&w=3840&q=75)

### Sebastian Silbermann

Engineer at Vercel

Sebastian learned programming to make the browser games he played during class more enjoyable. Eventually this lead to contributing to as much open source code as possible. Outside of coding he’s busy making sure people don’t confuse him with the other Sebastians and Zilberman of the React community.

[sebsilbermann](https://twitter.com/sebsilbermann)

[sebsilbermann](https://threads.net/sebsilbermann)

[eps1lon](https://github.com/eps1lon)

![Seth Webster](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Seth Webster](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fseth.jpg&w=3840&q=75)

![Seth Webster](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Seth Webster](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fseth.jpg&w=3840&q=75)

### Seth Webster

Engineering Manager at Meta

Seth started programming as a kid growing up in Tucson, AZ. After school, he was bitten by the music bug and was a touring musician for about 10 years before returning to *work*, starting with Intuit. In his spare time, he loves [taking pictures](https://www.sethwebster.com) and flying for animal rescues in the northeastern United States.

[sethwebster](https://twitter.com/sethwebster)

[sethwebster](https://threads.net/sethwebster)

[sethwebster](https://github.com/sethwebster)

 [sethwebster.com](https://sethwebster.com)

![Sophie Alpert](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Sophie Alpert](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fsophiebits.jpg&w=3840&q=75)

![Sophie Alpert](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Sophie Alpert](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fsophiebits.jpg&w=3840&q=75)

### Sophie Alpert

Independent Engineer

Four days after React was released, Sophie rewrote the entirety of her then-current project to use it, which she now realizes was perhaps a bit reckless. After she became the project’s #1 committer, she wondered why she wasn’t getting paid by Facebook like everyone else was and joined the team officially to lead React through its adolescent years. Though she quit that job years ago, somehow she’s still in the team’s group chats and “providing value”.

[sophiebits](https://twitter.com/sophiebits)

[sophiebits](https://threads.net/sophiebits)

[sophiebits](https://github.com/sophiebits)

 [sophiebits.com](https://sophiebits.com)

![Yuzhi Zheng](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Yuzhi Zheng](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fyuzhi.jpg&w=3840&q=75)

![Yuzhi Zheng](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)![Yuzhi Zheng](https://react.dev/_next/image?url=%2Fimages%2Fteam%2Fyuzhi.jpg&w=3840&q=75)

### Yuzhi Zheng

Engineering Manager at Meta

Yuzhi studied Computer Science in school. She liked the instant gratification of seeing code come to life without having to physically be in a laboratory. Now she’s a manager in the React org. Before management, she used to work on the Relay data fetching framework. In her spare time, Yuzhi enjoys optimizing her life via gardening and home improvement projects.

[yuzhiz](https://twitter.com/yuzhiz)

[yuzhiz](https://threads.net/yuzhiz)

[yuzhi](https://github.com/yuzhi)

## Past contributors

You can find the past team members and other people who significantly contributed to React over the years on the [acknowledgements](https://react.dev/community/acknowledgements) page.

[PreviousReact Videos](https://react.dev/community/videos)[NextDocs Contributors](https://react.dev/community/docs-contributors)

---

---


# Docs Contributors – React

URL: https://react.dev/community/docs-contributors

[Community](https://react.dev/community)

# Docs Contributors

React documentation is written and maintained by the [React team](https://react.dev/community/team) and [external contributors.](https://github.com/reactjs/react.dev/graphs/contributors) On this page, we’d like to thank a few people who’ve made significant contributions to this site.

## Content

* [Rachel Nabors](https://twitter.com/RachelNabors): editing, writing, illustrating
* [Dan Abramov](https://bsky.app/profile/danabra.mov): writing, curriculum design
* [Sylwia Vargas](https://twitter.com/SylwiaVargas): example code
* [Rick Hanlon](https://twitter.com/rickhanlonii): writing
* [David McCabe](https://twitter.com/mcc_abe): writing
* [Sophie Alpert](https://twitter.com/sophiebits): writing
* [Pete Hunt](https://twitter.com/floydophone): writing
* [Andrew Clark](https://twitter.com/acdlite): writing
* [Matt Carroll](https://twitter.com/mattcarrollcode): editing, writing
* [Natalia Tepluhina](https://twitter.com/n_tepluhina): reviews, advice
* [Sebastian Markbåge](https://twitter.com/sebmarkbage): feedback

## Design

* [Dan Lebowitz](https://twitter.com/lebo): site design
* [Razvan Gradinar](https://dribbble.com/GradinarRazvan): sandbox design
* [Maggie Appleton](https://maggieappleton.com/): diagram system
* [Sophie Alpert](https://twitter.com/sophiebits): color-coded explanations

## Development

* [Jared Palmer](https://twitter.com/jaredpalmer): site development
* [ThisDotLabs](https://www.thisdot.co/) ([Dane Grant](https://twitter.com/danecando), [Dustin Goodman](https://twitter.com/dustinsgoodman)): site development
* [CodeSandbox](https://codesandbox.io/) ([Ives van Hoorne](https://twitter.com/CompuIves), [Alex Moldovan](https://twitter.com/alexnmoldovan), [Jasper De Moor](https://twitter.com/JasperDeMoor), [Danilo Woznica](https://twitter.com/danilowoz)): sandbox integration
* [Dan Abramov](https://bsky.app/profile/danabra.mov): site development
* [Rick Hanlon](https://twitter.com/rickhanlonii): site development
* [Harish Kumar](https://www.strek.in/): development and maintenance
* [Luna Ruan](https://twitter.com/lunaruan): sandbox improvements

We’d also like to thank countless alpha testers and community members who gave us feedback along the way.

[PreviousMeet the Team](https://react.dev/community/team)[NextTranslations](https://react.dev/community/translations)

---

---


# Acknowledgements – React

URL: https://react.dev/community/acknowledgements

[Community](https://react.dev/community)

# Acknowledgements

React was originally created by [Jordan Walke.](https://github.com/jordwalke) Today, React has a [dedicated full-time team working on it](https://react.dev/community/team), as well as over a thousand [open source contributors.](https://github.com/facebook/react/graphs/contributors)

## Past contributors

We’d like to recognize a few people who have made significant contributions to React and its documentation in the past and have helped maintain them over the years:

* [Almero Steyn](https://github.com/AlmeroSteyn)
* [Andreas Svensson](https://github.com/syranide)
* [Alex Krolick](https://github.com/alexkrolick)
* [Alexey Pyltsyn](https://github.com/lex111)
* [Andrey Lunyov](https://github.com/alunyov)
* [Brandon Dail](https://github.com/aweary)
* [Brian Vaughn](https://github.com/bvaughn)
* [Caleb Meredith](https://github.com/calebmer)
* [Chang Yan](https://github.com/cyan33)
* [Cheng Lou](https://github.com/chenglou)
* [Christoph Nakazawa](https://github.com/cpojer)
* [Christopher Chedeau](https://github.com/vjeux)
* [Clement Hoang](https://github.com/clemmy)
* [Dave McCabe](https://github.com/davidmccabe)
* [Dominic Gannaway](https://github.com/trueadm)
* [Flarnie Marchan](https://github.com/flarnie)
* [Jason Quense](https://github.com/jquense)
* [Jesse Beach](https://github.com/jessebeach)
* [Jessica Franco](https://github.com/Jessidhia)
* [Jim Sproch](https://github.com/jimfb)
* [Josh Duck](https://github.com/joshduck)
* [Joe Critchley](https://github.com/joecritch)
* [Jeff Morrison](https://github.com/jeffmo)
* [Luna Ruan](https://github.com/lunaruan)
* [Luna Wei](https://github.com/lunaleaps)
* [Noah Lemen](https://github.com/noahlemen)
* [Kathryn Middleton](https://github.com/kmiddleton14)
* [Keyan Zhang](https://github.com/keyz)
* [Marco Salazar](https://github.com/salazarm)
* [Mengdi Chen](https://github.com/mondaychen)
* [Nat Alison](https://github.com/tesseralis)
* [Nathan Hunzaker](https://github.com/nhunzaker)
* [Nicolas Gallagher](https://github.com/necolas)
* [Paul O’Shannessy](https://github.com/zpao)
* [Pete Hunt](https://github.com/petehunt)
* [Philipp Spiess](https://github.com/philipp-spiess)
* [Rachel Nabors](https://github.com/rachelnabors)
* [Robert Zhang](https://github.com/robertzhidealx)
* [Samuel Susla](https://github.com/sammy-SC)
* [Sander Spies](https://github.com/sanderspies)
* [Sasha Aickin](https://github.com/aickin)
* [Sathya Gunasekaran](https://github.com/gsathya)
* [Sophia Shoemaker](https://github.com/mrscobbler)
* [Sunil Pai](https://github.com/threepointone)
* [Tianyu Yao](https://github.com/)
* [Tim Yung](https://github.com/yungsters)
* [Xuan Huang](https://github.com/huxpro)

This list is not exhaustive.

We’d like to give special thanks to [Tom Occhino](https://github.com/tomocchino) and [Adam Wolff](https://github.com/wolffiex) for their guidance and support over the years. We are also thankful to all the volunteers who [translated React into other languages.](https://translations.react.dev/)

## Additional Thanks

Additionally, we’re grateful to:

* [Jeff Barczewski](https://github.com/jeffbski) for allowing us to use the `react` package name on npm
* [Christopher Aue](https://christopheraue.net/) for letting us use the reactjs.com domain name and the [@reactjs](https://twitter.com/reactjs) username on Twitter
* [ProjectMoon](https://github.com/ProjectMoon) for letting us use the [flux](https://www.npmjs.com/package/flux) package name on npm
* Shane Anderson for allowing us to use the [react](https://github.com/react) org on GitHub

[PreviousTranslations](https://react.dev/community/translations)[NextVersioning Policy](https://react.dev/community/versioning-policy)

---

---


# Introducing the React Foundation – React

URL: https://react.dev/blog/2025/10/07/introducing-the-react-foundation

[Blog](https://react.dev/blog)

# Introducing the React Foundation

October 7, 2025 by [Seth Webster](https://x.com/sethwebster), [Matt Carroll](https://x.com/mattcarrollcode), [Joe Savona](https://x.com/en_JS), [Sophie Alpert](https://x.com/sophiebits)

---

![](https://react.dev/images/blog/react-foundation/react_foundation_logo.webp)![](https://react.dev/images/blog/react-foundation/react_foundation_logo_dark.webp)

Today, we’re announcing our plans to create the React Foundation and a new technical governance structure.

---

We open sourced React over a decade ago to help developers build great user experiences. From its earliest days, React has received substantial contributions from contributors outside of Meta. Over time, the number of contributors and the scope of their contributions has grown significantly. What started out as a tool developed for Meta has expanded into a project that spans multiple companies with regular contributions from across the ecosystem. React has outgrown the confines of any one company.

To better serve the React community, we are announcing our plans to move React and React Native from Meta to a new React Foundation. As a part of this change, we will also be implementing a new independent technical governance structure. We believe these changes will enable us to give React ecosystem projects more resources.

## The React Foundation

We will make the React Foundation the new home for React, React Native, and some supporting projects like JSX. The React Foundation’s mission will be to support the React community and ecosystem. Once implemented, the React Foundation will

* Maintain React’s infrastructure like GitHub, CI, and trademarks
* Organize React Conf
* Create initiatives to support the React ecosystem like financial support of ecosystem projects, issuing grants, and creating programs

The React Foundation will be governed by a board of directors, with Seth Webster serving as the executive director. This board will direct funds and resources to support React’s development, community, and ecosystem. We believe that this is the best structure to ensure that the React Foundation is vendor-neutral and reflects the best interests of the community.

The founding corporate members of the React Foundation will be Amazon, Callstack, Expo, Meta, Microsoft, Software Mansion, and Vercel. These companies have had a major impact on the React and React Native ecosystems and we are grateful for their support. We are excited to welcome even more members in the future.

![](https://react.dev/images/blog/react-foundation/react_foundation_member_logos.webp)![](https://react.dev/images/blog/react-foundation/react_foundation_member_logos_dark.webp)

## React’s technical governance

We believe that React’s technical direction should be set by the people who contribute to and maintain React. As React moves to a foundation, it is important that no single company or organization is overrepresented. To achieve this, we plan to define a new technical governance structure for React that is independent from the React Foundation.

As a part of creating React’s new technical governance structure we will reach out to the community for feedback. Once finalized, we will share details in a future post.

## Thank you

React’s incredible growth is thanks to the thousands of people, companies, and projects that have shaped React. The creation of the React Foundation is a testament to the strength and vibrancy of the React community. Together, the React Foundation and React’s new technical governance will ensure that React’s future is secure for years to come.

[PreviousReact Compiler v1.0](https://react.dev/blog/2025/10/07/react-compiler-1)[NextReact 19.2](https://react.dev/blog/2025/10/01/react-19-2)

---

---


# React Labs: View Transitions, Activity, and more – React

URL: https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more

[Blog](https://react.dev/blog)

# React Labs: View Transitions, Activity, and more

April 23, 2025 by [Ricky Hanlon](https://twitter.com/rickhanlonii)

---

In React Labs posts, we write about projects in active research and development. In this post, we’re sharing two new experimental features that are ready to try today, and updates on other areas we’re working on now.

Today, we’re excited to release documentation for two new experimental features that are ready for testing:

* [View Transitions](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#view-transitions)
* [Activity](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#activity)

We’re also sharing updates on new features currently in development:

* [React Performance Tracks](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#react-performance-tracks)
* [Compiler IDE Extension](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#compiler-ide-extension)
* [Automatic Effect Dependencies](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#automatic-effect-dependencies)
* [Fragment Refs](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#fragment-refs)
* [Concurrent Stores](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#concurrent-stores)

---

# New Experimental Features

### Note

`<Activity />` has shipped in `react@19.2`.

`<ViewTransition />` and `addTransitionType` are now available in `react@canary`.

View Transitions and Activity are now ready for testing in `react@experimental`. These features have been tested in production and are stable, but the final API may still change as we incorporate feedback.

You can try them by upgrading React packages to the most recent experimental version:

* `react@experimental`
* `react-dom@experimental`

Read on to learn how to use these features in your app, or check out the newly published docs:

* [`<ViewTransition>`](https://react.dev/reference/react/ViewTransition): A component that lets you activate an animation for a Transition.
* [`addTransitionType`](https://react.dev/reference/react/addTransitionType): A function that allows you to specify the cause of a Transition.
* [`<Activity>`](https://react.dev/reference/react/Activity): A component that lets you hide and show parts of the UI.

## View Transitions

React View Transitions are a new experimental feature that makes it easier to add animations to UI transitions in your app. Under-the-hood, these animations use the new [`startViewTransition`](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) API available in most modern browsers.

To opt-in to animating an element, wrap it in the new `<ViewTransition>` component:

```
// "what" to animate.

<ViewTransition>

<div>animate me</div>

</ViewTransition>
```

This new component lets you declaratively define “what” to animate when an animation is activated.

You can define “when” to animate by using one of these three triggers for a View Transition:

```
// "when" to animate.

// Transitions

startTransition(() => setState(...));

// Deferred Values

const deferred = useDeferredValue(value);

// Suspense

<Suspense fallback={<Fallback />}>

<div>Loading...</div>

</Suspense>
```

By default, these animations use the [default CSS animations for View Transitions](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API/Using#customizing_your_animations) applied (typically a smooth cross-fade). You can use [view transition pseudo-selectors](https://developer.mozilla.org/en-US/docs/Web/API/View_Transition_API/Using#the_view_transition_pseudo-element_tree) to define “how” the animation runs. For example, you can use `*` to change the default animation for all transitions:

```
// "how" to animate.

::view-transition-old(*) {

animation: 300ms ease-out fade-out;

}

::view-transition-new(*) {

animation: 300ms ease-in fade-in;

}
```

When the DOM updates due to an animation trigger—like `startTransition`, `useDeferredValue`, or a `Suspense` fallback switching to content—React will use [declarative heuristics](https://react.dev/reference/react/ViewTransition#viewtransition) to automatically determine which `<ViewTransition>` components to activate for the animation. The browser will then run the animation that’s defined in CSS.

If you’re familiar with the browser’s View Transition API and want to know how React supports it, check out [How does `<ViewTransition>` Work](https://react.dev/reference/react/ViewTransition#how-does-viewtransition-work) in the docs.

In this post, let’s take a look at a few examples of how to use View Transitions.

We’ll start with this app, which doesn’t animate any of the following interactions:

* Click a video to view the details.
* Click “back” to go back to the feed.
* Type in the list to filter the videos.

App.jsDetails.jsHome.jsIcons.jsLayout.jsLikeButton.jsVideos.jsrouter.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import TalkDetails from './Details'; import Home from './Home'; import {useRouter} from './router';

export default function App() {
  const {url} = useRouter();

  // 🚩This version doesn't include any animations yet
  return url === '/' ? <Home /> : <TalkDetails />;
}
```

### Note

#### View Transitions do not replace CSS and JS driven animations

View Transitions are meant to be used for UI transitions such as navigation, expanding, opening, or re-ordering. They are not meant to replace all the animations in your app.

In our example app above, notice that there are already animations when you click the “like” button and in the Suspense fallback glimmer. These are good use cases for CSS animations because they are animating a specific element.

### Animating navigations

Our app includes a Suspense-enabled router, with [page transitions already marked as Transitions](https://react.dev/reference/react/useTransition#building-a-suspense-enabled-router), which means navigations are performed with `startTransition`:

```
function navigate(url) {

startTransition(() => {

go(url);

});

}
```

`startTransition` is a View Transition trigger, so we can add `<ViewTransition>` to animate between pages:

```
// "what" to animate

<ViewTransition key={url}>

{url === '/' ? <Home /> : <TalkDetails />}

</ViewTransition>
```

When the `url` changes, the `<ViewTransition>` and new route are rendered. Since the `<ViewTransition>` was updated inside of `startTransition`, the `<ViewTransition>` is activated for an animation.

By default, View Transitions include the browser default cross-fade animation. Adding this to our example, we now have a cross-fade whenever we navigate between pages:

App.jsLayout.jsrouter.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {ViewTransition} from 'react'; import Details from './Details';
import Home from './Home'; import {useRouter} from './router';

export default function App() {
  const {url} = useRouter();

  // Use ViewTransition to animate between pages.
  // No additional CSS needed by default.
  return (
    <ViewTransition>
      {url === '/' ? <Home /> : <Details />}
    </ViewTransition>
  );
}
```

Since our router already updates the route using `startTransition`, this one line change to add `<ViewTransition>` activates with the default cross-fade animation.

If you’re curious how this works, see the docs for [How does `<ViewTransition>` work?](https://react.dev/reference/react/ViewTransition#how-does-viewtransition-work)

### Note

#### Opting out of `<ViewTransition>` animations

In this example, we’re wrapping the root of the app in `<ViewTransition>` for simplicity, but this means that all transitions in the app will be animated, which can lead to unexpected animations.

To fix, we’re wrapping route children with `"none"` so each page can control its own animation:

```
// Layout.js

<ViewTransition default="none">

{children}

</ViewTransition>
```

In practice, navigations should be done via “enter” and “exit” props, or by using Transition Types.

### Customizing animations

By default, `<ViewTransition>` includes the default cross-fade from the browser.

To customize animations, you can provide props to the `<ViewTransition>` component to specify which animations to use, based on [how the `<ViewTransition>` activates](https://react.dev/reference/react/ViewTransition#props).

For example, we can slow down the `default` cross fade animation:

```
<ViewTransition default="slow-fade">

<Home />

</ViewTransition>
```

And define `slow-fade` in CSS using [view transition classes](https://react.dev/reference/react/ViewTransition#view-transition-class):

```
::view-transition-old(.slow-fade) {

animation-duration: 500ms;

}

::view-transition-new(.slow-fade) {

animation-duration: 500ms;

}
```

Now, the cross fade is slower:

App.jsanimations.css

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { ViewTransition } from "react";
import Details from "./Details";
import Home from "./Home";
import { useRouter } from "./router";

export default function App() {
  const { url } = useRouter();

  // Define a default animation of .slow-fade.
  // See animations.css for the animation definition.
  return (
    <ViewTransition default="slow-fade">
      {url === '/' ? <Home /> : <Details />}
    </ViewTransition>
  );
}
```

Show more

See [Styling View Transitions](https://react.dev/reference/react/ViewTransition#styling-view-transitions) for a full guide on styling `<ViewTransition>`.

### Shared Element Transitions

When two pages include the same element, often you want to animate it from one page to the next.

To do this you can add a unique `name` to the `<ViewTransition>`:

```
<ViewTransition name={`video-${video.id}`}>

<Thumbnail video={video} />

</ViewTransition>
```

Now the video thumbnail animates between the two pages:

App.jsVideos.jsanimations.css

Videos.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, ViewTransition } from "react"; import LikeButton from "./LikeButton"; import { useRouter } from "./router"; import { PauseIcon, PlayIcon } from "./Icons"; import { startTransition } from "react";

export function Thumbnail({ video, children }) {
  // Add a name to animate with a shared element transition.
  // This uses the default animation, no additional css needed.
  return (
    <ViewTransition name={`video-${video.id}`}>
      <div
        aria-hidden="true"
        tabIndex={-1}
        className={`thumbnail ${video.image}`}
      >
        {children}
      </div>
    </ViewTransition>
  );
}

export function VideoControls() {
  const [isPlaying, setIsPlaying] = useState(false);

  return (
    <span
      className="controls"
      onClick={() =>
        startTransition(() => {
          setIsPlaying((p) => !p);
        })
      }
    >
      {isPlaying ? <PauseIcon /> : <PlayIcon />}
    </span>
  );
}

export function Video({ video }) {
  const { navigate } = useRouter();

  return (
    <div className="video">
      <div
        className="link"
        onClick={(e) => {
          e.preventDefault();
          navigate(`/video/${video.id}`);
        }}
      >
        <Thumbnail video={video}></Thumbnail>

        <div className="info">
          <div className="video-title">{video.title}</div>
          <div className="video-description">{video.description}</div>
        </div>
      </div>
      <LikeButton video={video} />
    </div>
  );
}
```

Show more

By default, React automatically generates a unique `name` for each element activated for a transition (see [How does `<ViewTransition>` work](https://react.dev/reference/react/ViewTransition#how-does-viewtransition-work)). When React sees a transition where a `<ViewTransition>` with a `name` is removed and a new `<ViewTransition>` with the same `name` is added, it will activate a shared element transition.

For more info, see the docs for [Animating a Shared Element](https://react.dev/reference/react/ViewTransition#animating-a-shared-element).

### Animating based on cause

Sometimes, you may want elements to animate differently based on how it was triggered. For this use case, we’ve added a new API called `addTransitionType` to specify the cause of a transition:

```
function navigate(url) {

startTransition(() => {

// Transition type for the cause "nav forward"

addTransitionType('nav-forward');

go(url);

});

}

function navigateBack(url) {

startTransition(() => {

// Transition type for the cause "nav backward"

addTransitionType('nav-back');

go(url);

});

}
```

With transition types, you can provide custom animations via props to `<ViewTransition>`. Let’s add a shared element transition to the header for “6 Videos” and “Back”:

```
<ViewTransition

name="nav"

share={{

'nav-forward': 'slide-forward',

'nav-back': 'slide-back',

}}>

{heading}

</ViewTransition>
```

Here we pass a `share` prop to define how to animate based on the transition type. When the share transition activates from `nav-forward`, the view transition class `slide-forward` is applied. When it’s from `nav-back`, the `slide-back` animation is activated. Let’s define these animations in CSS:

```
::view-transition-old(.slide-forward) {

/* when sliding forward, the "old" page should slide out to left. */

animation: ...

}

::view-transition-new(.slide-forward) {

/* when sliding forward, the "new" page should slide in from right. */

animation: ...

}

::view-transition-old(.slide-back) {

/* when sliding back, the "old" page should slide out to right. */

animation: ...

}

::view-transition-new(.slide-back) {

/* when sliding back, the "new" page should slide in from left. */

animation: ...

}
```

Now we can animate the header along with thumbnail based on navigation type:

Layout.jsrouter.jsanimations.css

Layout.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {ViewTransition} from 'react'; import { useIsNavPending } from "./router";

export default function Page({ heading, children }) {
  const isPending = useIsNavPending();
  return (
    <div className="page">
      <div className="top">
        <div className="top-nav">
          {/* Custom classes based on transition type. */}
          <ViewTransition
            name="nav"
            share={{
              'nav-forward': 'slide-forward',
              'nav-back': 'slide-back',
            }}>
            {heading}
          </ViewTransition>
          {isPending && <span className="loader"></span>}
        </div>
      </div>
      {/* Opt-out of ViewTransition for the content. */}
      {/* Content can define it's own ViewTransition. */}
      <ViewTransition default="none">
        <div className="bottom">
          <div className="content">{children}</div>
        </div>
      </ViewTransition>
    </div>
  );
}
```

Show more

### Animating Suspense Boundaries

Suspense will also activate View Transitions.

To animate the fallback to content, we can wrap `Suspense` with `<ViewTranstion>`:

```
<ViewTransition>

<Suspense fallback={<VideoInfoFallback />}>

<VideoInfo />

</Suspense>

</ViewTransition>
```

By adding this, the fallback will cross-fade into the content. Click a video and see the video info animate in:

Details.jsanimations.css

Details.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { use, Suspense, ViewTransition } from "react"; import { fetchVideo, fetchVideoDetails } from "./data"; import { Thumbnail, VideoControls } from "./Videos"; import { useRouter } from "./router"; import Layout from "./Layout"; import { ChevronLeft } from "./Icons";

function VideoDetails({ id }) {
  // Cross-fade the fallback to content.
  return (
    <ViewTransition default="slow-fade">
      <Suspense fallback={<VideoInfoFallback />}>
          <VideoInfo id={id} />
      </Suspense>
    </ViewTransition>
  );
}

function VideoInfoFallback() {
  return (
    <div>
      <div className="fit fallback title"></div>
      <div className="fit fallback description"></div>
    </div>
  );
}

export default function Details() {
  const { url, navigateBack } = useRouter();
  const videoId = url.split("/").pop();
  const video = use(fetchVideo(videoId));

  return (
    <Layout
      heading={
        <div
          className="fit back"
          onClick={() => {
            navigateBack("/");
          }}
        >
          <ChevronLeft /> Back
        </div>
      }
    >
      <div className="details">
        <Thumbnail video={video} large>
          <VideoControls />
        </Thumbnail>
        <VideoDetails id={video.id} />
      </div>
    </Layout>
  );
}

function VideoInfo({ id }) {
  const details = use(fetchVideoDetails(id));
  return (
    <div>
      <p className="fit info-title">{details.title}</p>
      <p className="fit info-description">{details.description}</p>
    </div>
  );
}
```

Show more

We can also provide custom animations using an `exit` on the fallback, and `enter` on the content:

```
<Suspense

fallback={

<ViewTransition exit="slide-down">

<VideoInfoFallback />

</ViewTransition>

}

>

<ViewTransition enter="slide-up">

<VideoInfo id={id} />

</ViewTransition>

</Suspense>
```

Here’s how we’ll define `slide-down` and `slide-up` with CSS:

```
::view-transition-old(.slide-down) {

/* Slide the fallback down */

animation: ...;

}

::view-transition-new(.slide-up) {

/* Slide the content up */

animation: ...;

}
```

Now, the Suspense content replaces the fallback with a sliding animation:

Details.jsanimations.css

Details.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { use, Suspense, ViewTransition } from "react"; import { fetchVideo, fetchVideoDetails } from "./data"; import { Thumbnail, VideoControls } from "./Videos"; import { useRouter } from "./router"; import Layout from "./Layout"; import { ChevronLeft } from "./Icons";

function VideoDetails({ id }) {
  return (
    <Suspense
      fallback={
        // Animate the fallback down.
        <ViewTransition exit="slide-down">
          <VideoInfoFallback />
        </ViewTransition>
      }
    >
      {/* Animate the content up */}
      <ViewTransition enter="slide-up">
        <VideoInfo id={id} />
      </ViewTransition>
    </Suspense>
  );
}

function VideoInfoFallback() {
  return (
    <>
      <div className="fallback title"></div>
      <div className="fallback description"></div>
    </>
  );
}

export default function Details() {
  const { url, navigateBack } = useRouter();
  const videoId = url.split("/").pop();
  const video = use(fetchVideo(videoId));

  return (
    <Layout
      heading={
        <div
          className="fit back"
          onClick={() => {
            navigateBack("/");
          }}
        >
          <ChevronLeft /> Back
        </div>
      }
    >
      <div className="details">
        <Thumbnail video={video} large>
          <VideoControls />
        </Thumbnail>
        <VideoDetails id={video.id} />
      </div>
    </Layout>
  );
}

function VideoInfo({ id }) {
  const details = use(fetchVideoDetails(id));
  return (
    <>
      <p className="info-title">{details.title}</p>
      <p className="info-description">{details.description}</p>
    </>
  );
}
```

Show more

### Animating Lists

You can also use `<ViewTransition>` to animate lists of items as they re-order, like in a searchable list of items:

```
<div className="videos">

{filteredVideos.map((video) => (

<ViewTransition key={video.id}>

<Video video={video} />

</ViewTransition>

))}

</div>
```

To activate the ViewTransition, we can use `useDeferredValue`:

```
const [searchText, setSearchText] = useState('');

const deferredSearchText = useDeferredValue(searchText);

const filteredVideos = filterVideos(videos, deferredSearchText);
```

Now the items animate as you type in the search bar:

Home.jsanimations.css

Home.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useId, useState, use, useDeferredValue, ViewTransition } from "react";import { Video } from "./Videos";import Layout from "./Layout";import { fetchVideos } from "./data";import { IconSearch } from "./Icons";

function SearchList({searchText, videos}) {
  // Activate with useDeferredValue ("when")
  const deferredSearchText = useDeferredValue(searchText);
  const filteredVideos = filterVideos(videos, deferredSearchText);
  return (
    <div className="video-list">
      <div className="videos">
        {filteredVideos.map((video) => (
          // Animate each item in list ("what")
          <ViewTransition key={video.id}>
            <Video video={video} />
          </ViewTransition>
        ))}
      </div>
      {filteredVideos.length === 0 && (
        <div className="no-results">No results</div>
      )}
    </div>
  );
}

export default function Home() {
  const videos = use(fetchVideos());
  const count = videos.length;
  const [searchText, setSearchText] = useState('');

  return (
    <Layout heading={<div className="fit">{count} Videos</div>}>
      <SearchInput value={searchText} onChange={setSearchText} />
      <SearchList videos={videos} searchText={searchText} />
    </Layout>
  );
}

function SearchInput({ value, onChange }) {
  const id = useId();
  return (
    <form className="search" onSubmit={(e) => e.preventDefault()}>
      <label htmlFor={id} className="sr-only">
        Search
      </label>
      <div className="search-input">
        <div className="search-icon">
          <IconSearch />
        </div>
        <input
          type="text"
          id={id}
          placeholder="Search"
          value={value}
          onChange={(e) => onChange(e.target.value)}
        />
      </div>
    </form>
  );
}

function filterVideos(videos, query) {
  const keywords = query
    .toLowerCase()
    .split(" ")
    .filter((s) => s !== "");
  if (keywords.length === 0) {
    return videos;
  }
  return videos.filter((video) => {
    const words = (video.title + " " + video.description)
      .toLowerCase()
      .split(" ");
    return keywords.every((kw) => words.some((w) => w.includes(kw)));
  });
}
```

Show more

### Final result

By adding a few `<ViewTransition>` components and a few lines of CSS, we were able to add all the animations above into the final result.

We’re excited about View Transitions and think they will level up the apps you’re able to build. They’re ready to start trying today in the experimental channel of React releases.

Let’s remove the slow fade, and take a look at the final result:

App.jsDetails.jsHome.jsLayout.jsVideos.jsrouter.jsanimations.css

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import {ViewTransition} from 'react'; import Details from './Details'; import Home from './Home'; import {useRouter} from './router';

export default function App() {
  const {url} = useRouter();

  // Animate with a cross fade between pages.
  return (
    <ViewTransition key={url}>
      {url === '/' ? <Home /> : <Details />}
    </ViewTransition>
  );
}
```

If you’re curious to know more about how they work, check out [How Does `<ViewTransition>` Work](https://react.dev/reference/react/ViewTransition#how-does-viewtransition-work) in the docs.

*For more background on how we built View Transitions, see: [#31975](https://github.com/facebook/react/pull/31975), [#32105](https://github.com/facebook/react/pull/32105), [#32041](https://github.com/facebook/react/pull/32041), [#32734](https://github.com/facebook/react/pull/32734), [#32797](https://github.com/facebook/react/pull/32797) [#31999](https://github.com/facebook/react/pull/31999), [#32031](https://github.com/facebook/react/pull/32031), [#32050](https://github.com/facebook/react/pull/32050), [#32820](https://github.com/facebook/react/pull/32820), [#32029](https://github.com/facebook/react/pull/32029), [#32028](https://github.com/facebook/react/pull/32028), and [#32038](https://github.com/facebook/react/pull/32038) by [@sebmarkbage](https://twitter.com/sebmarkbage) (thanks Seb!).*

---

## Activity

### Note

**`<Activity />` is now available in React’s Canary channel.**

[Learn more about React’s release channels here.](https://react.dev/community/versioning-policy#all-release-channels)

In [past](https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022#offscreen) [updates](https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024#offscreen-renamed-to-activity), we shared that we were researching an API to allow components to be visually hidden and deprioritized, preserving UI state with reduced performance costs relative to unmounting or hiding with CSS.

We’re now ready to share the API and how it works, so you can start testing it in experimental React versions.

`<Activity>` is a new component to hide and show parts of the UI:

```
<Activity mode={isVisible ? 'visible' : 'hidden'}>

<Page />

</Activity>
```

When an Activity is visible it’s rendered as normal. When an Activity is hidden it is unmounted, but will save its state and continue to render at a lower priority than anything visible on screen.

You can use `Activity` to save state for parts of the UI the user isn’t using, or pre-render parts that a user is likely to use next.

Let’s look at some examples improving the View Transition examples above.

### Note

**Effects don’t mount when an Activity is hidden.**

When an `<Activity>` is `hidden`, Effects are unmounted. Conceptually, the component is unmounted, but React saves the state for later.

In practice, this works as expected if you have followed the [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect) guide. To eagerly find problematic Effects, we recommend adding [`<StrictMode>`](https://react.dev/reference/react/StrictMode) which will eagerly perform Activity unmounts and mounts to catch any unexpected side effects.

### Restoring state with Activity

When a user navigates away from a page, it’s common to stop rendering the old page:

```
function App() {

const { url } = useRouter();

return (

<>

{url === '/' && <Home />}

{url !== '/' && <Details />}

</>

);

}
```

However, this means if the user goes back to the old page, all of the previous state is lost. For example, if the `<Home />` page has an `<input>` field, when the user leaves the page the `<input>` is unmounted, and all of the text they had typed is lost.

Activity allows you to keep the state around as the user changes pages, so when they come back they can resume where they left off. This is done by wrapping part of the tree in `<Activity>` and toggling the `mode`:

```
function App() {

const { url } = useRouter();

return (

<>

<Activity mode={url === '/' ? 'visible' : 'hidden'}>

<Home />

</Activity>

{url !== '/' && <Details />}

</>

);

}
```

With this change, we can improve on our View Transitions example above. Before, when you searched for a video, selected one, and returned, your search filter was lost. With Activity, your search filter is restored and you can pick up where you left off.

Try searching for a video, selecting it, and clicking “back”:

App.jsanimations.css

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Activity, ViewTransition } from "react"; import Details from "./Details"; import Home from "./Home"; import { useRouter } from "./router";

export default function App() {
  const { url } = useRouter();

  return (
    // View Transitions know about Activity
    <ViewTransition>
      {/* Render Home in Activity so we don't lose state */}
      <Activity mode={url === '/' ? 'visible' : 'hidden'}>
        <Home />
      </Activity>
      {url !== '/' && <Details />}
    </ViewTransition>
  );
}
```

Show more

### Pre-rendering with Activity

Sometimes, you may want to prepare the next part of the UI a user is likely to use ahead of time, so it’s ready by the time they are ready to use it. This is especially useful if the next route needs to suspend on data it needs to render, because you can help ensure the data is already fetched before the user navigates.

For example, our app currently needs to suspend to load the data for each video when you select one. We can improve this by rendering all of the pages in a hidden `<Activity>` until the user navigates:

```
<ViewTransition>

<Activity mode={url === '/' ? 'visible' : 'hidden'}>

<Home />

</Activity>

<Activity mode={url === '/details/1' ? 'visible' : 'hidden'}>

<Details id={id} />

</Activity>

<Activity mode={url === '/details/1' ? 'visible' : 'hidden'}>

<Details id={id} />

</Activity>

<ViewTransition>
```

With this update, if the content on the next page has time to pre-render, it will animate in without the Suspense fallback. Click a video, and notice that the video title and description on the Details page render immediately, without a fallback:

App.jsDetails.jsanimations.css

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Activity, ViewTransition, use } from "react"; import Details from "./Details"; import Home from "./Home"; import { useRouter } from "./router"; import {fetchVideos} from './data';

export default function App() {
  const { url } = useRouter();
  const videoId = url.split("/").pop();
  const videos = use(fetchVideos());

  return (
    <ViewTransition>
      {/* Render videos in Activity to pre-render them */}
      {videos.map(({id}) => (
        <Activity key={id} mode={videoId === id ? 'visible' : 'hidden'}>
          <Details id={id}/>
        </Activity>
      ))}
      <Activity mode={url === '/' ? 'visible' : 'hidden'}>
        <Home />
      </Activity>
    </ViewTransition>
  );
}
```

Show more

### Server-Side Rendering with Activity

When using Activity on a page that uses server-side rendering (SSR), there are additional optimizations.

If part of the page is rendered with `mode="hidden"`, then it will not be included in the SSR response. Instead, React will schedule a client render for the content inside Activity while the rest of the page hydrates, prioritizing the visible content on screen.

For parts of the UI rendered with `mode="visible"`, React will de-prioritize hydration of content within Activity, similar to how Suspense content is hydrated at a lower priority. If the user interacts with the page, we’ll prioritize hydration within the boundary if needed.

These are advanced use cases, but they show the additional benefits considered with Activity.

### Future modes for Activity

In the future, we may add more modes to Activity.

For example, a common use case is rendering a modal, where the previous “inactive” page is visible behind the “active” modal view. The “hidden” mode does not work for this use case because it’s not visible and not included in SSR.

Instead, we’re considering a new mode that would keep the content visible—and included in SSR—but keep it unmounted and de-prioritize updates. This mode may also need to “pause” DOM updates, since it can be distracting to see backgrounded content updating while a modal is open.

Another mode we’re considering for Activity is the ability to automatically destroy state for hidden Activities if there is too much memory being used. Since the component is already unmounted, it may be preferable to destroy state for the least recently used hidden parts of the app rather than consume too many resources.

These are areas we’re still exploring, and we’ll share more as we make progress. For more information on what Activity includes today, [check out the docs](https://react.dev/reference/react/Activity).

---

# Features in development

We’re also developing features to help solve the common problems below.

As we iterate on possible solutions, you may see some potential APIs we’re testing being shared based on the PRs we are landing. Please keep in mind that as we try different ideas, we often change or remove different solutions after trying them out.

When the solutions we’re working on are shared too early, it can create churn and confusion in the community. To balance being transparent and limiting confusion, we’re sharing the problems we’re currently developing solutions for, without sharing a particular solution we have in mind.

As these features progress, we’ll announce them on the blog with docs included so you can try them out.

## React Performance Tracks

We’re working on a new set of custom tracks to performance profilers using browser APIs that [allow adding custom tracks](https://developer.chrome.com/docs/devtools/performance/extension) to provide more information about the performance of your React app.

This feature is still in progress, so we’re not ready to publish docs to fully release it as an experimental feature yet. You can get a sneak preview when using an experimental version of React, which will automatically add the performance tracks to profiles:

![](https://react.dev/images/blog/react-labs-april-2025/perf_tracks.webp)![](https://react.dev/images/blog/react-labs-april-2025/perf_tracks_dark.webp)

There are a few known issues we plan to address such as performance, and the scheduler track not always “connecting” work across Suspended trees, so it’s not quite ready to try. We’re also still collecting feedback from early adopters to improve the design and usability of the tracks.

Once we solve those issues, we’ll publish experimental docs and share that it’s ready to try.

---

## Automatic Effect Dependencies

When we released hooks, we had three motivations:

* **Sharing code between components**: hooks replaced patterns like render props and higher-order components to allow you to reuse stateful logic without changing your component hierarchy.
* **Think in terms of function, not lifecycles**: hooks let you split one component into smaller functions based on what pieces are related (such as setting up a subscription or fetching data), rather than forcing a split based on lifecycle methods.
* **Support ahead-of-time compilation**: hooks were designed to support ahead-of-time compilation with less pitfalls causing unintentional de-optimizations caused by lifecycle methods, and limitations of classes.

Since their release, hooks have been successful at *sharing code between components*. Hooks are now the favored way to share logic between components, and there are less use cases for render props and higher order components. Hooks have also been successful at supporting features like Fast Refresh that were not possible with class components.

### Effects can be hard

Unfortunately, some hooks are still hard to think in terms of function instead of lifecycles. Effects specifically are still hard to understand and are the most common pain point we hear from developers. Last year, we spent a significant amount of time researching how Effects were used, and how those use cases could be simplified and easier to understand.

We found that often, the confusion is from using an Effect when you don’t need to. The [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect) guide covers many cases for when Effects are not the right solution. However, even when an Effect is the right fit for a problem, Effects can still be harder to understand than class component lifecycles.

We believe one of the reasons for confusion is that developers to think of Effects from the *component’s* perspective (like a lifecycle), instead of the *Effects* point of view (what the Effect does).

Let’s look at an example [from the docs](https://react.dev/learn/lifecycle-of-reactive-effects#thinking-from-the-effects-perspective):

```
useEffect(() => {

// Your Effect connected to the room specified with roomId...

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

// ...until it disconnected

connection.disconnect();

};

}, [roomId]);
```

Many users would read this code as “on mount, connect to the roomId. whenever `roomId` changes, disconnect to the old room and re-create the connection”. However, this is thinking from the component’s lifecycle perspective, which means you will need to think of every component lifecycle state to write the Effect correctly. This can be difficult, so it’s understandable that Effects seem harder than class lifecycles when using the component perspective.

### Effects without dependencies

Instead, it’s better to think from the Effect’s perspective. The Effect doesn’t know about the component lifecycles. It only describes how to start synchronization and how to stop it. When users think of Effects in this way, their Effects tend to be easier to write, and more resilient to being started and stopped as many times as is needed.

We spent some time researching why Effects are thought of from the component perspective, and we think one of the reasons is the dependency array. Since you have to write it, it’s right there and in your face reminding you of what you’re “reacting” to and baiting you into the mental model of ‘do this when these values change’.

When we released hooks, we knew we could make them easier to use with ahead-of-time compilation. With the React Compiler, you’re now able to avoid writing `useCallback` and `useMemo` yourself in most cases. For Effects, the compiler can insert the dependencies for you:

```
useEffect(() => {

const connection = createConnection(serverUrl, roomId);

connection.connect();

return () => {

connection.disconnect();

};

}); // compiler inserted dependencies.
```

With this code, the React Compiler can infer the dependencies for you and insert them automatically so you don’t need to see or write them. With features like [the IDE extension](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#compiler-ide-extension) and [`useEffectEvent`](https://react.dev/reference/react/useEffectEvent), we can provide a CodeLens to show you what the Compiler inserted for times you need to debug, or to optimize by removing a dependency. This helps reinforce the correct mental model for writing Effects, which can run at any time to synchronize your component or hook’s state with something else.

Our hope is that automatically inserting dependencies is not only easier to write, but that it also makes them easier to understand by forcing you to think in terms of what the Effect does, and not in component lifecycles.

---

## Compiler IDE Extension

Later in 2025 [we shared](https://react.dev/blog/2025/10/07/react-compiler-1) the first stable release of React Compiler, and we’re continuing to invest in shipping more improvements.

We’ve also begun exploring ways to use the React Compiler to provide information that can improve understanding and debugging your code. One idea we’ve started exploring is a new experimental LSP-based React IDE extension powered by React Compiler, similar to the extension used in [Lauren Tan’s React Conf talk](https://conf2024.react.dev/talks/5).

Our idea is that we can use the compiler’s static analysis to provide more information, suggestions, and optimization opportunities directly in your IDE. For example, we can provide diagnostics for code breaking the Rules of React, hovers to show if components and hooks were optimized by the compiler, or a CodeLens to see [automatically inserted Effect dependencies](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more#automatic-effect-dependencies).

The IDE extension is still an early exploration, but we’ll share our progress in future updates.

---

## Fragment Refs

Many DOM APIs like those for event management, positioning, and focus are difficult to compose when writing with React. This often leads developers to reach for Effects, managing multiple Refs, by using APIs like `findDOMNode` (removed in React 19).

We are exploring adding refs to Fragments that would point to a group of DOM elements, rather than just a single element. Our hope is that this will simplify managing multiple children and make it easier to write composable React code when calling DOM APIs.

Fragment refs are still being researched. We’ll share more when we’re closer to having the final API finished.

---

## Gesture Animations

We’re also researching ways to enhance View Transitions to support gesture animations such as swiping to open a menu, or scroll through a photo carousel.

Gestures present new challenges for a few reasons:

* **Gestures are continuous**: as you swipe the animation is tied to your finger placement time, rather than triggering and running to completion.
* **Gestures don’t complete**: when you release your finger gesture animations can run to completion, or revert to their original state (like when you only partially open a menu) depending on how far you go.
* **Gestures invert old and new**: while you’re animating, you want the page you are animating from to stay “alive” and interactive. This inverts the browser View Transition model where the “old” state is a snapshot and the “new” state is the live DOM.

We believe we’ve found an approach that works well and may introduce a new API for triggering gesture transitions. For now, we’re focused on shipping `<ViewTransition>`, and will revisit gestures afterward.

---

## Concurrent Stores

When we released React 18 with concurrent rendering, we also released `useSyncExternalStore` so external store libraries that did not use React state or context could [support concurrent rendering](https://github.com/reactwg/react-18/discussions/70) by forcing a synchronous render when the store is updated.

Using `useSyncExternalStore` comes at a cost though, since it forces a bail out from concurrent features like transitions, and forces existing content to show Suspense fallbacks.

Now that React 19 has shipped, we’re revisiting this problem space to create a primitive to fully support concurrent external stores with the `use` API:

```
const value = use(store);
```

Our goal is to allow external state to be read during render without tearing, and to work seamlessly with all of the concurrent features React offers.

This research is still early. We’ll share more, and what the new APIs will look like, when we’re further along.

---

*Thanks to [Aurora Scharff](https://bsky.app/profile/aurorascharff.no), [Dan Abramov](https://bsky.app/profile/danabra.mov), [Eli White](https://twitter.com/Eli_White), [Lauren Tan](https://bsky.app/profile/no.lol), [Luna Wei](https://github.com/lunaleaps), [Matt Carroll](https://twitter.com/mattcarrollcode), [Jack Pope](https://jackpope.me), [Jason Bonta](https://threads.net/someextent), [Jordan Brown](https://github.com/jbrown215), [Jordan Eldredge](https://bsky.app/profile/capt.dev), [Mofei Zhang](https://threads.net/z_mofei), [Sebastien Lorber](https://bsky.app/profile/sebastienlorber.com), [Sebastian Markbåge](https://bsky.app/profile/sebmarkbage.calyptus.eu), and [Tim Yung](https://github.com/yungsters) for reviewing this post.*

[PreviousReact 19.2](https://react.dev/blog/2025/10/01/react-19-2)[NextSunsetting Create React App](https://react.dev/blog/2025/02/14/sunsetting-create-react-app)

---

---


# Sunsetting Create React App – React

URL: https://react.dev/blog/2025/02/14/sunsetting-create-react-app

[Blog](https://react.dev/blog)

# Sunsetting Create React App

February 14, 2025 by [Matt Carroll](https://twitter.com/mattcarrollcode) and [Ricky Hanlon](https://bsky.app/profile/ricky.fm)

---

Today, we’re deprecating [Create React App](https://create-react-app.dev/) for new apps, and encouraging existing apps to migrate to a [framework](https://react.dev/blog/2025/02/14/sunsetting-create-react-app#how-to-migrate-to-a-framework), or to [migrate to a build tool](https://react.dev/blog/2025/02/14/sunsetting-create-react-app#how-to-migrate-to-a-build-tool) like Vite, Parcel, or RSBuild.

We’re also providing docs for when a framework isn’t a good fit for your project, you want to build your own framework, or you just want to learn how React works by [building a React app from scratch](https://react.dev/learn/build-a-react-app-from-scratch).

---

When we released Create React App in 2016, there was no clear way to build a new React app.

To create a React app, you had to install a bunch of tools and wire them up together yourself to support basic features like JSX, linting, and hot reloading. This was very tricky to do correctly, so the [community](https://github.com/react-boilerplate/react-boilerplate) [created](https://github.com/kriasoft/react-starter-kit) [boilerplates](https://github.com/petehunt/react-boilerplate) for [common](https://github.com/gaearon/react-hot-boilerplate) [setups](https://github.com/erikras/react-redux-universal-hot-example). However, boilerplates were difficult to update and fragmentation made it difficult for React to release new features.

Create React App solved these problems by combining several tools into a single recommended configuration. This allowed apps a simple way to upgrade to new tooling features, and allowed the React team to deploy non-trivial tooling changes (Fast Refresh support, React Hooks lint rules) to the broadest possible audience.

This model became so popular that there’s an entire category of tools working this way today.

## Deprecating Create React App

Although Create React App makes it easy to get started, [there are several limitations](https://react.dev/blog/2025/02/14/sunsetting-create-react-app#limitations-of-build-tools) that make it difficult to build high performant production apps. In principle, we could solve these problems by essentially evolving it into a [framework](https://react.dev/blog/2025/02/14/sunsetting-create-react-app#why-we-recommend-frameworks).

However, since Create React App currently has no active maintainers, and there are many existing frameworks that solve these problems already, we’ve decided to deprecate Create React App.

Starting today, if you install a new app, you will see a deprecation warning:

Console

create-react-app is deprecated.
You can find a list of up-to-date React frameworks on react.dev
For more info see: react.dev/link/cra
This error message will only be shown once per install.

We’ve also added a deprecation notice to the Create React App [website](https://create-react-app.dev/) and GitHub [repo](https://github.com/facebook/create-react-app). Create React App will continue working in maintenance mode, and we’ve published a new version of Create React App to work with React 19.

## How to Migrate to a Framework

We recommend [creating new React apps](https://react.dev/learn/creating-a-react-app) with a framework. All the frameworks we recommend support client-side rendering ([CSR](https://developer.mozilla.org/en-US/docs/Glossary/CSR)) and single-page apps ([SPA](https://developer.mozilla.org/en-US/docs/Glossary/SPA)), and can be deployed to a CDN or static hosting service without a server.

For existing apps, these guides will help you migrate to a client-only SPA:

* [Next.js’ Create React App migration guide](https://nextjs.org/docs/app/building-your-application/upgrading/from-create-react-app)
* [React Router’s framework adoption guide](https://reactrouter.com/upgrading/component-routes).
* [Expo webpack to Expo Router migration guide](https://docs.expo.dev/router/migrate/from-expo-webpack/)

## How to Migrate to a Build Tool

If your app has unusual constraints, or you prefer to solve these problems by building your own framework, or you just want to learn how react works from scratch, you can roll your own custom setup with React using Vite, Parcel or Rsbuild.

For existing apps, these guides will help you migrate to a build tool:

* [Vite Create React App migration guide](https://www.robinwieruch.de/vite-create-react-app/)
* [Parcel Create React App migration guide](https://parceljs.org/migration/cra/)
* [Rsbuild Create React App migration guide](https://rsbuild.dev/guide/migration/cra)

To help get started with Vite, Parcel or Rsbuild, we’ve added new docs for [Building a React App from Scratch](https://react.dev/learn/build-a-react-app-from-scratch).

##### Deep Dive

#### Do I need a framework?

Show Details

Most apps would benefit from a framework, but there are valid cases to build a React app from scratch. A good rule of thumb is if your app needs routing, you would probably benefit from a framework.

Just like Svelte has Sveltekit, Vue has Nuxt, and Solid has SolidStart, [React recommends using a framework](https://react.dev/blog/2025/02/14/sunsetting-create-react-app#why-we-recommend-frameworks) that fully integrates routing into features like data-fetching and code-splitting out of the box. This avoids the pain of needing to write your own complex configurations and essentially build a framework yourself.

However, you can always [build a React app from scratch](https://react.dev/learn/build-a-react-app-from-scratch) using a build tool like Vite, Parcel, or Rsbuild.

Continue reading to learn more about the [limitations of build tools](https://react.dev/blog/2025/02/14/sunsetting-create-react-app#limitations-of-build-tools) and [why we recommend frameworks](https://react.dev/blog/2025/02/14/sunsetting-create-react-app#why-we-recommend-frameworks).

## Limitations of Build Tools

Create React App and build tools like it make it easy to get started building a React app. After running `npx create-react-app my-app`, you get a fully configured React app with a development server, linting, and a production build.

For example, if you’re building an internal admin tool, you can start with a landing page:

```
export default function App() {

return (

<div>

<h1>Welcome to the Admin Tool!</h1>

</div>

)

}
```

This allows you to immediately start coding in React with features like JSX, default linting rules, and a bundler to run in both development and production. However, this setup is missing the tools you need to build a real production app.

Most production apps need solutions to problems like routing, data fetching, and code splitting.

### Routing

Create React App does not include a specific routing solution. If you’re just getting started, one option is to use `useState` to switch between routes. But doing this means that you can’t share links to your app - every link would go to the same page - and structuring your app becomes difficult over time:

```
import {useState} from 'react';

import Home from './Home';

import Dashboard from './Dashboard';

export default function App() {

// ❌ Routing in state does not create URLs

const [route, setRoute] = useState('home');

return (

<div>

{route === 'home' && <Home />}

{route === 'dashboard' && <Dashboard />}

</div>

)

}
```

This is why most apps that use Create React App solve add routing with a routing library like [React Router](https://reactrouter.com/) or [Tanstack Router](https://tanstack.com/router/latest). With a routing library, you can add additional routes to the app, which provides opinions on the structure of your app, and allows you to start sharing links to routes. For example, with React Router you can define routes:

```
import {RouterProvider, createBrowserRouter} from 'react-router';

import Home from './Home';

import Dashboard from './Dashboard';

// ✅ Each route has it's own URL

const router = createBrowserRouter([

{path: '/', element: <Home />},

{path: '/dashboard', element: <Dashboard />}

]);

export default function App() {

return (

<RouterProvider value={router} />

)

}
```

With this change, you can share a link to `/dashboard` and the app will navigate to the dashboard page . Once you have a routing library, you can add additional features like nested routes, route guards, and route transitions, which are difficult to implement without a routing library.

There’s a tradeoff being made here: the routing library adds complexity to the app, but it also adds features that are difficult to implement without it.

### Data Fetching

Another common problem in Create React App is data fetching. Create React App does not include a specific data fetching solution. If you’re just getting started, a common option is to use `fetch` in an effect to load data.

But doing this means that the data is fetched after the component renders, which can cause network waterfalls. Network waterfalls are caused by fetching data when your app renders instead of in parallel while the code is downloading:

```
export default function Dashboard() {

const [data, setData] = useState(null);

// ❌ Fetching data in a component causes network waterfalls

useEffect(() => {

fetch('/api/data')

.then(response => response.json())

.then(data => setData(data));

}, []);

return (

<div>

{data.map(item => <div key={item.id}>{item.name}</div>)}

</div>

)

}
```

Fetching in an effect means the user has to wait longer to see the content, even though the data could have been fetched earlier. To solve this, you can use a data fetching library like [TanStack Query](https://tanstack.com/query/), [SWR](https://swr.vercel.app/), [Apollo](https://www.apollographql.com/docs/react), or [Relay](https://relay.dev/) which provide options to prefetch data so the request is started before the component renders.

These libraries work best when integrated with your routing “loader” pattern to specify data dependencies at the route level, which allows the router to optimize your data fetches:

```
export async function loader() {

const response = await fetch(`/api/data`);

const data = await response.json();

return data;

}

// ✅ Fetching data in parallel while the code is downloading

export default function Dashboard({loaderData}) {

return (

<div>

{loaderData.map(item => <div key={item.id}>{item.name}</div>)}

</div>

)

}
```

On initial load, the router can fetch the data immediately before the route is rendered. As the user navigates around the app, the router is able to fetch both the data and the route at the same time, parallelizing the fetches. This reduces the time it takes to see the content on the screen, and can improve the user experience.

However, this requires correctly configuring the loaders in your app and trades off complexity for performance.

### Code Splitting

Another common problem in Create React App is [code splitting](https://www.patterns.dev/vanilla/bundle-splitting). Create React App does not include a specific code splitting solution. If you’re just getting started, you might not consider code splitting at all.

This means your app is shipped as a single bundle:

```
- bundle.js    75kb
```

But for ideal performance, you should “split” your code into separate bundles so the user only needs to download what they need. This decreases the time the user needs to wait to load your app, by only downloading the code they need to see the page they are on.

```
- core.js      25kb

- home.js      25kb

- dashboard.js 25kb
```

One way to do code-splitting is with `React.lazy`. However, this means that the code is not fetched until the component renders, which can cause network waterfalls. A more optimal solution is to use a router feature that fetches the code in parallel while the code is downloading. For example, React Router provides a `lazy` option to specify that a route should be code split and optimize when it is loaded:

```
import Home from './Home';

import Dashboard from './Dashboard';

// ✅ Routes are downloaded before rendering

const router = createBrowserRouter([

{path: '/', lazy: () => import('./Home')},

{path: '/dashboard', lazy: () => import('Dashboard')}

]);
```

Optimized code-splitting is tricky to get right, and it’s easy to make mistakes that can cause the user to download more code than they need. It works best when integrated with your router and data loading solutions to maximize caching, parallelize fetches, and support [“import on interaction”](https://www.patterns.dev/vanilla/import-on-interaction) patterns.

### And more…

These are just a few examples of the limitations of Create React App.

Once you’ve integrated routing, data-fetching, and code splitting, you now also need to consider pending states, navigation interruptions, error messages to the user, and revalidation of the data. There are entire categories of problems that users need to solve like:

* Accessibility
* Asset loading
* Authentication
* Caching

* Error handling
* Mutating data
* Navigations
* Optimistic updates

* Progressive enhancement
* Server-side rendering
* Static site generation
* Streaming

All of these work together to create the most optimal [loading sequence](https://www.patterns.dev/vanilla/loading-sequence).

Solving each of these problems individually in Create React App can be difficult as each problem is interconnected with the others and can require deep expertise in problem areas users may not be familiar with. In order to solve these problems, users end up building their own bespoke solutions on top of Create React App, which was the problem Create React App originally tried to solve.

## Why we Recommend Frameworks

Although you could solve all these pieces yourself in a build tool like Create React App, Vite, or Parcel, it is hard to do well. Just like when Create React App itself integrated several build tools together, you need a tool to integrate all of these features together to provide the best experience to users.

This category of tools that integrates build tools, rendering, routing, data fetching, and code splitting are known as “frameworks” — or if you prefer to call React itself a framework, you might call them “metaframeworks”.

Frameworks impose some opinions about structuring your app in order to provide a much better user experience, in the same way build tools impose some opinions to make tooling easier. This is why we started recommending frameworks like [Next.js](https://nextjs.org/), [React Router](https://reactrouter.com/), and [Expo](https://expo.dev/) for new projects.

Frameworks provide the same getting started experience as Create React App, but also provide solutions to problems users need to solve anyway in real production apps.

##### Deep Dive

#### Server rendering is optional

Show Details

The frameworks we recommend all provide the option to create a [client-side rendered (CSR)](https://developer.mozilla.org/en-US/docs/Glossary/CSR) app.

In some cases, CSR is the right choice for a page, but many times it’s not. Even if most of your app is client-side, there are often individual pages that could benefit from server rendering features like [static-site generation (SSG)](https://developer.mozilla.org/en-US/docs/Glossary/SSG) or [server-side rendering (SSR)](https://developer.mozilla.org/en-US/docs/Glossary/SSR), for example a Terms of Service page, or documentation.

Server rendering generally sends less JavaScript to the client, and a full HTML document which produces a faster [First Contentful Paint (FCP)](https://web.dev/articles/fcp) by reducing [Total Blocking Time (TBD)](https://web.dev/articles/tbt), which can also lower [Interaction to Next Paint (INP)](https://web.dev/articles/inp). This is why the [Chrome team has encouraged](https://web.dev/articles/rendering-on-the-web) developers to consider static or server-side render over a full client-side approach to achieve the best possible performance.

There are tradeoffs to using a server, and it is not always the best option for every page. Generating pages on the server incurs additional cost and takes time to generate which can increase [Time to First Byte (TTFB)](https://web.dev/articles/ttfb). The best performing apps are able to pick the right rendering strategy on a per-page basis, based on the tradeoffs of each strategy.

Frameworks provide the option to use a server on any page if you want to, but do not force you to use a server. This allows you to pick the right rendering strategy for each page in your app.

#### What About Server Components

The frameworks we recommend also include support for React Server Components.

Server Components help solve these problems by moving routing and data fetching to the server, and allowing code splitting to be done for client components based on the data you render, instead of just the route rendered, and reducing the amount of JavaScript shipped for the best possible [loading sequence](https://www.patterns.dev/vanilla/loading-sequence).

Server Components do not require a server. They can be run at build time on your CI server to create a static-site generated app (SSG) app, at runtime on a web server for a server-side rendered (SSR) app.

See [Introducing zero-bundle size React Server Components](https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components) and [the docs](https://react.dev/reference/rsc/server-components) for more info.

### Note

#### Server Rendering is not just for SEO

A common misunderstanding is that server rendering is only for [SEO](https://developer.mozilla.org/en-US/docs/Glossary/SEO).

While server rendering can improve SEO, it also improves performance by reducing the amount of JavaScript the user needs to download and parse before they can see the content on the screen.

This is why the Chrome team [has encouraged](https://web.dev/articles/rendering-on-the-web) developers to consider static or server-side render over a full client-side approach to achieve the best possible performance.

---

*Thank you to [Dan Abramov](https://bsky.app/profile/danabra.mov) for creating Create React App, and [Joe Haddad](https://github.com/Timer), [Ian Schmitz](https://github.com/ianschmitz), [Brody McKee](https://github.com/mrmckeb), and [many others](https://github.com/facebook/create-react-app/graphs/contributors) for maintaining Create React App over the years. Thank you to [Brooks Lybrand](https://bsky.app/profile/brookslybrand.bsky.social), [Dan Abramov](https://bsky.app/profile/danabra.mov), [Devon Govett](https://bsky.app/profile/devongovett.bsky.social), [Eli White](https://x.com/Eli_White), [Jack Herrington](https://bsky.app/profile/jherr.dev), [Joe Savona](https://x.com/en_JS), [Lauren Tan](https://bsky.app/profile/no.lol), [Lee Robinson](https://x.com/leeerob), [Mark Erikson](https://bsky.app/profile/acemarke.dev), [Ryan Florence](https://x.com/ryanflorence), [Sophie Alpert](https://bsky.app/profile/sophiebits.com), [Tanner Linsley](https://bsky.app/profile/tannerlinsley.com), and [Theo Browne](https://x.com/theo) for reviewing and providing feedback on this post.*

[PreviousReact Labs: View Transitions, Activity, and more](https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more)[NextReact 19](https://react.dev/blog/2024/12/05/react-19)

---

---


# React Conf 2024 Recap – React

URL: https://react.dev/blog/2024/05/22/react-conf-2024-recap

[Blog](https://react.dev/blog)

# React Conf 2024 Recap

May 22, 2024 by [Ricky Hanlon](https://twitter.com/rickhanlonii).

---

Last week we hosted React Conf 2024, a two-day conference in Henderson, Nevada where 700+ attendees gathered in-person to discuss the latest in UI engineering. This was our first in-person conference since 2019, and we were thrilled to be able to bring the community together again.

---

At React Conf 2024, we announced the [React 19 RC](https://react.dev/blog/2024/12/05/react-19), the [React Native New Architecture Beta](https://github.com/reactwg/react-native-new-architecture/discussions/189), and an experimental release of the [React Compiler](https://react.dev/learn/react-compiler). The community also took the stage to announce [React Router v7](https://remix.run/blog/merging-remix-and-react-router), [Universal Server Components](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=20765s) in Expo Router, React Server Components in [RedwoodJS](https://redwoodjs.com/blog/rsc-now-in-redwoodjs), and much more.

The entire [day 1](https://www.youtube.com/watch?v=T8TZQ6k4SLE) and [day 2](https://www.youtube.com/watch?v=0ckOUBiuxVY) streams are available online. In this post, we’ll summarize the talks and announcements from the event.

## Day 1

*[Watch the full day 1 stream here.](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=973s)*

To kick off day 1, Meta CTO [Andrew “Boz” Bosworth](https://www.threads.net/@boztank) shared a welcome message followed by an introduction by [Seth Webster](https://twitter.com/sethwebster), who manages the React Org at Meta, and our MC [Ashley Narcisse](https://twitter.com/_darkfadr).

In the day 1 keynote, [Joe Savona](https://twitter.com/en_JS) shared our goals and vision for React to make it easy for anyone to build great user experiences. [Lauren Tan](https://twitter.com/potetotes) followed with a State of React, where she shared that React was downloaded over 1 billion times in 2023, and that 37% of new developers learn to program with React. Finally, she highlighted the work of the React community to make React, React.

For more, check out these talks from the community later in the conference:

* [Vanilla React](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=5542s) by [Ryan Florence](https://twitter.com/ryanflorence)
* [React Rhythm & Blues](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=12728s) by [Lee Robinson](https://twitter.com/leeerob)
* [RedwoodJS, now with React Server Components](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=26815s) by [Amy Dutton](https://twitter.com/selfteachme)
* [Introducing Universal React Server Components in Expo Router](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=20765s) by [Evan Bacon](https://twitter.com/Baconbrix)

Next in the keynote, [Josh Story](https://twitter.com/joshcstory) and [Andrew Clark](https://twitter.com/acdlite) shared new features coming in React 19, and announced the React 19 RC which is ready for testing in production. Check out all the features in the [React 19 release post](https://react.dev/blog/2024/12/05/react-19), and see these talks for deep dives on the new features:

* [What’s new in React 19](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=8880s) by [Lydia Hallie](https://twitter.com/lydiahallie)
* [React Unpacked: A Roadmap to React 19](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=10112s) by [Sam Selikoff](https://twitter.com/samselikoff)
* [React 19 Deep Dive: Coordinating HTML](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=24916s) by [Josh Story](https://twitter.com/joshcstory)
* [Enhancing Forms with React Server Components](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=25280s) by [Aurora Walberg Scharff](https://twitter.com/aurorascharff)
* [React for Two Computers](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=18825s) by [Dan Abramov](https://bsky.app/profile/danabra.mov)
* [And Now You Understand React Server Components](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=11256s) by [Kent C. Dodds](https://twitter.com/kentcdodds)

Finally, we ended the keynote with [Joe Savona](https://twitter.com/en_JS), [Sathya Gunasekaran](https://twitter.com/_gsathya), and [Mofei Zhang](https://twitter.com/zmofei) announcing that the React Compiler is now [Open Source](https://github.com/facebook/react/pull/29061), and sharing an experimental version of the React Compiler to try out.

For more information on using the Compiler and how it works, check out [the docs](https://react.dev/learn/react-compiler) and these talks:

* [Forget About Memo](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=12020s) by [Lauren Tan](https://twitter.com/potetotes)
* [React Compiler Deep Dive](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=9313s) by [Sathya Gunasekaran](https://twitter.com/_gsathya) and [Mofei Zhang](https://twitter.com/zmofei)

Watch the full day 1 keynote here:

## Day 2

*[Watch the full day 2 stream here.](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=1720s)*

To kick off day 2, [Seth Webster](https://twitter.com/sethwebster) shared a welcome message, followed by a Thank You from [Eli White](https://x.com/Eli_White) and an introduction by our Chief Vibes Officer [Ashley Narcisse](https://twitter.com/_darkfadr).

In the day 2 keynote, [Nicola Corti](https://twitter.com/cortinico) shared the State of React Native, including 78 million downloads in 2023. He also highlighted apps using React Native including 2000+ screens used inside of Meta; the product details page in Facebook Marketplace, which is visited more than 2 billion times per day; and part of the Microsoft Windows Start Menu and some features in almost every Microsoft Office product across mobile and desktop.

Nicola also highlighted all the work the community does to support React Native including libraries, frameworks, and multiple platforms. For more, check out these talks from the community:

* [Extending React Native beyond Mobile and Desktop Apps](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=5798s) by [Chris Traganos](https://twitter.com/chris_trag) and [Anisha Malde](https://twitter.com/anisha_malde)
* [Spatial computing with React](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=22525s) by [Michał Pierzchała](https://twitter.com/thymikee)

[Riccardo Cipolleschi](https://twitter.com/cipolleschir) continued the day 2 keynote by announcing that the React Native New Architecture is now in Beta and ready for apps to adopt in production. He shared new features and improvements in the new architecture, and shared the roadmap for the future of React Native. For more check out:

* [Cross Platform React](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=26569s) by [Olga Zinoveva](https://github.com/SlyCaptainFlint) and [Naman Goel](https://twitter.com/naman34)

Next in the keynote, Nicola announced that we are now recommending starting with a framework like Expo for all new apps created with React Native. With the change, he also announced a new React Native homepage and new Getting Started docs. You can view the new Getting Started guide in the [React Native docs](https://reactnative.dev/docs/next/environment-setup).

Finally, to end the keynote, [Kadi Kraman](https://twitter.com/kadikraman) shared the latest features and improvements in Expo, and how to get started developing with React Native using Expo.

Watch the full day 2 keynote here:

## Q&A

The React and React Native teams also ended each day with a Q&A session:

* [React Q&A](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=27518s) hosted by [Michael Chan](https://twitter.com/chantastic)
* [React Native Q&A](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=27935s) hosted by [Jamon Holmgren](https://twitter.com/jamonholmgren)

## And more…

We also heard talks on accessibility, error reporting, css, and more:

* [Demystifying accessibility in React apps](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=20655s) by [Kateryna Porshnieva](https://twitter.com/krambertech)
* [Pigment CSS, CSS in the server component age](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=21696s) by [Olivier Tassinari](https://twitter.com/olivtassinari)
* [Real-time React Server Components](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=24070s) by [Sunil Pai](https://twitter.com/threepointone)
* [Let’s break React Rules](https://www.youtube.com/watch?v=T8TZQ6k4SLE&t=25862s) by [Charlotte Isambert](https://twitter.com/c_isambert)
* [Solve 100% of your errors](https://www.youtube.com/watch?v=0ckOUBiuxVY&t=19881s) by [Ryan Albrecht](https://github.com/ryan953)

## Thank you

Thank you to all the staff, speakers, and participants who made React Conf 2024 possible. There are too many to list, but we want to thank a few in particular.

Thank you to [Barbara Markiewicz](https://twitter.com/barbara_markie), the team at [Callstack](https://www.callstack.com/), and our React Team Developer Advocate [Matt Carroll](https://twitter.com/mattcarrollcode) for helping to plan the entire event; and to [Sunny Leggett](https://zeroslopeevents.com/about) and everyone from [Zero Slope](https://zeroslopeevents.com) for helping to organize the event.

Thank you [Ashley Narcisse](https://twitter.com/_darkfadr) for being our MC and Chief Vibes Officer; and to [Michael Chan](https://twitter.com/chantastic) and [Jamon Holmgren](https://twitter.com/jamonholmgren) for hosting the Q&A sessions.

Thank you [Seth Webster](https://twitter.com/sethwebster) and [Eli White](https://x.com/Eli_White) for welcoming us each day and providing direction on structure and content; and to [Tom Occhino](https://twitter.com/tomocchino) for joining us with a special message during the after-party.

Thank you [Ricky Hanlon](https://www.youtube.com/watch?v=FxTZL2U-uKg&t=1263s) for providing detailed feedback on talks, working on slide designs, and generally filling in the gaps to sweat the details.

Thank you [Callstack](https://www.callstack.com/) for building the conference website; and to [Kadi Kraman](https://twitter.com/kadikraman) and the [Expo](https://expo.dev/) team for building the conference mobile app.

Thank you to all the sponsors who made the event possible: [Remix](https://remix.run/), [Amazon](https://developer.amazon.com/apps-and-games?cmp=US_2024_05_3P_React-Conf-2024&ch=prtnr&chlast=prtnr&pub=ref&publast=ref&type=org&typelast=org), [MUI](https://mui.com/), [Sentry](https://sentry.io/for/react/?utm_source=sponsored-conf&utm_medium=sponsored-event&utm_campaign=frontend-fy25q2-evergreen&utm_content=logo-reactconf2024-learnmore), [Abbott](https://www.jobs.abbott/software), [Expo](https://expo.dev/), [RedwoodJS](https://rwsdk.com/), and [Vercel](https://vercel.com).

Thank you to the AV Team for the visuals, stage, and sound; and to the Westin Hotel for hosting us.

Thank you to all the speakers who shared their knowledge and experiences with the community.

Finally, thank you to everyone who attended in person and online to show what makes React, React. React is more than a library, it is a community, and it was inspiring to see everyone come together to share and learn together.

See you next time!

[PreviousReact Compiler Beta Release and Roadmap](https://react.dev/blog/2024/10/21/react-compiler-beta-release)[NextReact 19 RC](https://react.dev/blog/2024/04/25/react-19)

---

---


# React Labs: What We've Been Working On – February 2024 – React

URL: https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024

[Blog](https://react.dev/blog)

# React Labs: What We've Been Working On – February 2024

February 15, 2024 by [Joseph Savona](https://twitter.com/en_JS), [Ricky Hanlon](https://twitter.com/rickhanlonii), [Andrew Clark](https://twitter.com/acdlite), [Matt Carroll](https://twitter.com/mattcarrollcode), and [Dan Abramov](https://bsky.app/profile/danabra.mov).

---

In React Labs posts, we write about projects in active research and development. We’ve made significant progress since our [last update](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023), and we’d like to share our progress.

---

## React Compiler

React Compiler is no longer a research project: the compiler now powers instagram.com in production, and we are working to ship the compiler across additional surfaces at Meta and to prepare the first open source release.

As discussed in our [previous post](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-optimizing-compiler), React can *sometimes* re-render too much when state changes. Since the early days of React our solution for such cases has been manual memoization. In our current APIs, this means applying the [`useMemo`](https://react.dev/reference/react/useMemo), [`useCallback`](https://react.dev/reference/react/useCallback), and [`memo`](https://react.dev/reference/react/memo) APIs to manually tune how much React re-renders on state changes. But manual memoization is a compromise. It clutters up our code, is easy to get wrong, and requires extra work to keep up to date.

Manual memoization is a reasonable compromise, but we weren’t satisfied. Our vision is for React to *automatically* re-render just the right parts of the UI when state changes, *without compromising on React’s core mental model*. We believe that React’s approach — UI as a simple function of state, with standard JavaScript values and idioms — is a key part of why React has been approachable for so many developers. That’s why we’ve invested in building an optimizing compiler for React.

JavaScript is a notoriously challenging language to optimize, thanks to its loose rules and dynamic nature. React Compiler is able to compile code safely by modeling both the rules of JavaScript *and* the “rules of React”. For example, React components must be idempotent — returning the same value given the same inputs — and can’t mutate props or state values. These rules limit what developers can do and help to carve out a safe space for the compiler to optimize.

Of course, we understand that developers sometimes bend the rules a bit, and our goal is to make React Compiler work out of the box on as much code as possible. The compiler attempts to detect when code doesn’t strictly follow React’s rules and will either compile the code where safe or skip compilation if it isn’t safe. We’re testing against Meta’s large and varied codebase in order to help validate this approach.

For developers who are curious about making sure their code follows React’s rules, we recommend [enabling Strict Mode](https://react.dev/reference/react/StrictMode) and [configuring React’s ESLint plugin](https://react.dev/learn/editor-setup#linting). These tools can help to catch subtle bugs in your React code, improving the quality of your applications today, and future-proofs your applications for upcoming features such as React Compiler. We are also working on consolidated documentation of the rules of React and updates to our ESLint plugin to help teams understand and apply these rules to create more robust apps.

To see the compiler in action, you can check out our [talk from last fall](https://www.youtube.com/watch?v=qOQClO3g8-Y). At the time of the talk, we had early experimental data from trying React Compiler on one page of instagram.com. Since then, we shipped the compiler to production across instagram.com. We’ve also expanded our team to accelerate the rollout to additional surfaces at Meta and to open source. We’re excited about the path ahead and will have more to share in the coming months.

## Actions

We [previously shared](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components) that we were exploring solutions for sending data from the client to the server with Server Actions, so that you can execute database mutations and implement forms. During development of Server Actions, we extended these APIs to support data handling in client-only applications as well.

We refer to this broader collection of features as simply “Actions”. Actions allow you to pass a function to DOM elements such as [`<form/>`](https://react.dev/reference/react-dom/components/form):

```
<form action={search}>

<input name="query" />

<button type="submit">Search</button>

</form>
```

The `action` function can operate synchronously or asynchronously. You can define them on the client side using standard JavaScript or on the server with the [`'use server'`](https://react.dev/reference/rsc/use-server) directive. When using an action, React will manage the life cycle of the data submission for you, providing hooks like [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus), and [`useActionState`](https://react.dev/reference/react/useActionState) to access the current state and response of the form action.

By default, Actions are submitted within a [transition](https://react.dev/reference/react/useTransition), keeping the current page interactive while the action is processing. Since Actions support async functions, we’ve also added the ability to use `async/await` in transitions. This allows you to show pending UI with the `isPending` state of a transition when an async request like `fetch` starts, and show the pending UI all the way through the update being applied.

Alongside Actions, we’re introducing a feature named [`useOptimistic`](https://react.dev/reference/react/useOptimistic) for managing optimistic state updates. With this hook, you can apply temporary updates that are automatically reverted once the final state commits. For Actions, this allows you to optimistically set the final state of the data on the client, assuming the submission is successful, and revert to the value for data received from the server. It works using regular `async`/`await`, so it works the same whether you’re using `fetch` on the client, or a Server Action from the server.

Library authors can implement custom `action={fn}` props in their own components with `useTransition`. Our intent is for libraries to adopt the Actions pattern when designing their component APIs, to provide a consistent experience for React developers. For example, if your library provides a `<Calendar onSelect={eventHandler}>` component, consider also exposing a `<Calendar selectAction={action}>` API, too.

While we initially focused on Server Actions for client-server data transfer, our philosophy for React is to provide the same programming model across all platforms and environments. When possible, if we introduce a feature on the client, we aim to make it also work on the server, and vice versa. This philosophy allows us to create a single set of APIs that work no matter where your app runs, making it easier to upgrade to different environments later.

Actions are now available in the Canary channel and will ship in the next release of React.

## New Features in React Canary

We introduced [React Canaries](https://react.dev/blog/2023/05/03/react-canaries) as an option to adopt individual new stable features as soon as their design is close to final, before they’re released in a stable semver version.

Canaries are a change to the way we develop React. Previously, features would be researched and built privately inside of Meta, so users would only see the final polished product when released to Stable. With Canaries, we’re building in public with the help of the community to finalize features we share in the React Labs blog series. This means you hear about new features sooner, as they’re being finalized instead of after they’re complete.

React Server Components, Asset Loading, Document Metadata, and Actions have all landed in the React Canary, and we’ve added docs for these features on react.dev:

* **Directives**: [`"use client"`](https://react.dev/reference/rsc/use-client) and [`"use server"`](https://react.dev/reference/rsc/use-server) are bundler features designed for full-stack React frameworks. They mark the “split points” between the two environments: `"use client"` instructs the bundler to generate a `<script>` tag (like [Astro Islands](https://docs.astro.build/en/concepts/islands/#creating-an-island)), while `"use server"` tells the bundler to generate a POST endpoint (like [tRPC Mutations](https://trpc.io/docs/concepts)). Together, they let you write reusable components that compose client-side interactivity with the related server-side logic.
* **Document Metadata**: we added built-in support for rendering [`<title>`](https://react.dev/reference/react-dom/components/title), [`<meta>`](https://react.dev/reference/react-dom/components/meta), and metadata [`<link>`](https://react.dev/reference/react-dom/components/link) tags anywhere in your component tree. These work the same way in all environments, including fully client-side code, SSR, and RSC. This provides built-in support for features pioneered by libraries like [React Helmet](https://github.com/nfl/react-helmet).
* **Asset Loading**: we integrated Suspense with the loading lifecycle of resources such as stylesheets, fonts, and scripts so that React takes them into account to determine whether the content in elements like [`<style>`](https://react.dev/reference/react-dom/components/style), [`<link>`](https://react.dev/reference/react-dom/components/link), and [`<script>`](https://react.dev/reference/react-dom/components/script) are ready to be displayed. We’ve also added new [Resource Loading APIs](https://react.dev/reference/react-dom#resource-preloading-apis) like `preload` and `preinit` to provide greater control for when a resource should load and initialize.
* **Actions**: As shared above, we’ve added Actions to manage sending data from the client to the server. You can add `action` to elements like [`<form/>`](https://react.dev/reference/react-dom/components/form), access the status with [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus), handle the result with [`useActionState`](https://react.dev/reference/react/useActionState), and optimistically update the UI with [`useOptimistic`](https://react.dev/reference/react/useOptimistic).

Since all of these features work together, it’s difficult to release them in the Stable channel individually. Releasing Actions without the complementary hooks for accessing form states would limit the practical usability of Actions. Introducing React Server Components without integrating Server Actions would complicate modifying data on the server.

Before we can release a set of features to the Stable channel, we need to ensure they work cohesively and developers have everything they need to use them in production. React Canaries allow us to develop these features individually, and release the stable APIs incrementally until the entire feature set is complete.

The current set of features in React Canary are complete and ready to release.

## The Next Major Version of React

After a couple of years of iteration, `react@canary` is now ready to ship to `react@latest`. The new features mentioned above are compatible with any environment your app runs in, providing everything needed for production use. Since Asset Loading and Document Metadata may be a breaking change for some apps, the next version of React will be a major version: **React 19**.

There’s still more to be done to prepare for release. In React 19, we’re also adding long-requested improvements which require breaking changes like support for Web Components. Our focus now is to land these changes, prepare for release, finalize docs for new features, and publish announcements for what’s included.

We’ll share more information about everything React 19 includes, how to adopt the new client features, and how to build support for React Server Components in the coming months.

## Offscreen (renamed to Activity).

Since our last update, we’ve renamed a capability we’re researching from “Offscreen” to “Activity”. The name “Offscreen” implied that it only applied to parts of the app that were not visible, but while researching the feature we realized that it’s possible for parts of the app to be visible and inactive, such as content behind a modal. The new name more closely reflects the behavior of marking certain parts of the app “active” or “inactive”.

Activity is still under research and our remaining work is to finalize the primitives that are exposed to library developers. We’ve deprioritized this area while we focus on shipping features that are more complete.

---

In addition to this update, our team has presented at conferences and made appearances on podcasts to speak more on our work and answer questions.

* [Sathya Gunasekaran](https://github.com/gsathya) spoke about the React Compiler at the [React India](https://www.youtube.com/watch?v=kjOacmVsLSE) conference
* [Dan Abramov](https://react.dev/community/team#dan-abramov) gave a talk at [RemixConf](https://www.youtube.com/watch?v=zMf_xeGPn6s) titled “React from Another Dimension” which explores an alternative history of how React Server Components and Actions could have been created
* [Dan Abramov](https://react.dev/community/team#dan-abramov) was interviewed on [the Changelog’s JS Party podcast](https://changelog.com/jsparty/311) about React Server Components
* [Matt Carroll](https://react.dev/community/team#matt-carroll) was interviewed on the [Front-End Fire podcast](https://www.buzzsprout.com/2226499/14462424-interview-the-two-reacts-with-rachel-nabors-evan-bacon-and-matt-carroll) where he discussed [The Two Reacts](https://overreacted.io/the-two-reacts/)

Thanks [Lauren Tan](https://twitter.com/potetotes), [Sophie Alpert](https://twitter.com/sophiebits), [Jason Bonta](https://threads.net/someextent), [Eli White](https://twitter.com/Eli_White), and [Sathya Gunasekaran](https://twitter.com/_gsathya) for reviewing this post.

Thanks for reading, and [see you at React Conf](https://conf.react.dev/)!

[PreviousReact 19 RC Upgrade Guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide)[NextReact Canaries: Enabling Incremental Feature Rollout Outside Meta](https://react.dev/blog/2023/05/03/react-canaries)

---

---


# React Canaries: Enabling Incremental Feature Rollout Outside Meta – React

URL: https://react.dev/blog/2023/05/03/react-canaries

[Blog](https://react.dev/blog)

# React Canaries: Enabling Incremental Feature Rollout Outside Meta

May 3, 2023 by [Dan Abramov](https://bsky.app/profile/danabra.mov), [Sophie Alpert](https://twitter.com/sophiebits), [Rick Hanlon](https://twitter.com/rickhanlonii), [Sebastian Markbåge](https://twitter.com/sebmarkbage), and [Andrew Clark](https://twitter.com/acdlite)

---

We’d like to offer the React community an option to adopt individual new features as soon as their design is close to final, before they’re released in a stable version—similar to how Meta has long used bleeding-edge versions of React internally. We are introducing a new officially supported [Canary release channel](https://react.dev/community/versioning-policy#canary-channel). It lets curated setups like frameworks decouple adoption of individual React features from the React release schedule.

---

## tl;dr

* We’re introducing an officially supported [Canary release channel](https://react.dev/community/versioning-policy#canary-channel) for React. Since it’s officially supported, if any regressions land, we’ll treat them with a similar urgency to bugs in stable releases.
* Canaries let you start using individual new React features before they land in the semver-stable releases.
* Unlike the [Experimental](https://react.dev/community/versioning-policy#experimental-channel) channel, React Canaries only include features that we reasonably believe to be ready for adoption. We encourage frameworks to consider bundling pinned Canary React releases.
* We will announce breaking changes and new features on our blog as they land in Canary releases.
* **As always, React continues to follow semver for every Stable release.**

## How React features are usually developed

Typically, every React feature has gone through the same stages:

1. We develop an initial version and prefix it with `experimental_` or `unstable_`. The feature is only available in the `experimental` release channel. At this point, the feature is expected to change significantly.
2. We find a team at Meta willing to help us test this feature and provide feedback on it. This leads to a round of changes. As the feature becomes more stable, we work with more teams at Meta to try it out.
3. Eventually, we feel confident in the design. We remove the prefix from the API name, and make the feature available on the `main` branch by default, which most Meta products use. At this point, any team at Meta can use this feature.
4. As we build confidence in the direction, we also post an RFC for the new feature. At this point we know the design works for a broad set of cases, but we might make some last minute adjustments.
5. When we are close to cutting an open source release, we write documentation for the feature and finally release the feature in a stable React release.

This playbook works well for most features we’ve released so far. However, there can be a significant gap between when the feature is generally ready to use (step 3) and when it is released in open source (step 5).

**We’d like to offer the React community an option to follow the same approach as Meta, and adopt individual new features earlier (as they become available) without having to wait for the next release cycle of React.**

As always, all React features will eventually make it into a Stable release.

## Can we just do more minor releases?

Generally, we *do* use minor releases for introducing new features.

However, this isn’t always possible. Sometimes, new features are interconnected with *other* new features which have not yet been fully completed and that we’re still actively iterating on. We can’t release them separately because their implementations are related. We can’t version them separately because they affect the same packages (for example, `react` and `react-dom`). And we need to keep the ability to iterate on the pieces that aren’t ready without a flurry of major version releases, which semver would require us to do.

At Meta, we’ve solved this problem by building React from the `main` branch, and manually updating it to a specific pinned commit every week. This is also the approach that React Native releases have been following for the last several years. Every *stable* release of React Native is pinned to a specific commit from the `main` branch of the React repository. This lets React Native include important bugfixes and incrementally adopt new React features at the framework level without getting coupled to the global React release schedule.

We would like to make this workflow available to other frameworks and curated setups. For example, it lets a framework *on top of* React include a React-related breaking change *before* this breaking change gets included into a stable React release. This is particularly useful because some breaking changes only affect framework integrations. This lets a framework release such a change in its own minor version without breaking semver.

Rolling releases with the Canaries channel will allow us to have a tighter feedback loop and ensure that new features get comprehensive testing in the community. This workflow is closer to how TC39, the JavaScript standards committee, [handles changes in numbered stages](https://tc39.es/process-document/). New React features may be available in frameworks built on React before they are in a React stable release, just as new JavaScript features ship in browsers before they are officially ratified as part of the specification.

## Why not use experimental releases instead?

Although you *can* technically use [Experimental releases](https://react.dev/community/versioning-policy#canary-channel), we recommend against using them in production because experimental APIs can undergo significant breaking changes on their way to stabilization (or can even be removed entirely). While Canaries can also contain mistakes (as with any release), going forward we plan to announce any significant breaking changes in Canaries on our blog. Canaries are the closest to the code Meta runs internally, so you can generally expect them to be relatively stable. However, you *do* need to keep the version pinned and manually scan the GitHub commit log when updating between the pinned commits.

**We expect that most people using React outside a curated setup (like a framework) will want to continue using the Stable releases.** However, if you’re building a framework, you might want to consider bundling a Canary version of React pinned to a particular commit, and update it at your own pace. The benefit of that is that it lets you ship individual completed React features and bugfixes earlier for your users and at your own release schedule, similar to how React Native has been doing it for the last few years. The downside is that you would take on additional responsibility to review which React commits are being pulled in and communicate to your users which React changes are included with your releases.

If you’re a framework author and want to try this approach, please get in touch with us.

## Announcing breaking changes and new features early

Canary releases represent our best guess of what will go into the next stable React release at any given time.

Traditionally, we’ve only announced breaking changes at the *end* of the release cycle (when doing a major release). Now that Canary releases are an officially supported way to consume React, we plan to shift towards announcing breaking changes and significant new features *as they land* in Canaries. For example, if we merge a breaking change that will go out in a Canary, we will write a post about it on the React blog, including codemods and migration instructions if necessary. Then, if you’re a framework author cutting a major release that updates the pinned React canary to include that change, you can link to our blog post from your release notes. Finally, when a stable major version of React is ready, we will link to those already published blog posts, which we hope will help our team make progress faster.

We plan to document APIs as they land in Canaries—even if these APIs are not yet available outside of them. APIs that are only available in Canaries will be marked with a special note on the corresponding pages. This will include APIs like [`use`](https://github.com/reactjs/rfcs/pull/229), and some others (like `cache` and `createServerContext`) which we’ll send RFCs for.

## Canaries must be pinned

If you decide to adopt the Canary workflow for your app or framework, make sure you always pin the *exact* version of the Canary you’re using. Since Canaries are pre-releases, they may still include breaking changes.

## Example: React Server Components

As we [announced in March](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#react-server-components), the React Server Components conventions have been finalized, and we do not expect significant breaking changes related to their user-facing API contract. However, we can’t release support for React Server Components in a stable version of React yet because we are still working on several intertwined framework-only features (such as [asset loading](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023#asset-loading)) and expect more breaking changes there.

This means that React Server Components are ready to be adopted by frameworks. However, until the next major React release, the only way for a framework to adopt them is to ship a pinned Canary version of React. (To avoid bundling two copies of React, frameworks that wish to do this would need to enforce resolution of `react` and `react-dom` to the pinned Canary they ship with their framework, and explain that to their users. As an example, this is what Next.js App Router does.)

## Testing libraries against both Stable and Canary versions

We do not expect library authors to test every single Canary release since it would be prohibitively difficult. However, just as when we [originally introduced the different React pre-release channels three years ago](https://legacy.reactjs.org/blog/2019/10/22/react-release-channels.html), we encourage libraries to run tests against *both* the latest Stable and latest Canary versions. If you see a change in behavior that wasn’t announced, please file a bug in the React repository so that we can help diagnose it. We expect that as this practice becomes widely adopted, it will reduce the amount of effort necessary to upgrade libraries to new major versions of React, since accidental regressions would be found as they land.

### Note

Strictly speaking, Canary is not a *new* release channel—it used to be called Next. However, we’ve decided to rename it to avoid confusion with Next.js. We’re announcing it as a *new* release channel to communicate the new expectations, such as Canaries being an officially supported way to use React.

## Stable releases work like before

We are not introducing any changes to stable React releases.

[PreviousReact Labs: What We've Been Working On – February 2024](https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024)[NextReact Labs: What We've Been Working On – March 2023](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023)

---

---


# React Labs: What We've Been Working On – March 2023 – React

URL: https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023

[Blog](https://react.dev/blog)

# React Labs: What We've Been Working On – March 2023

March 22, 2023 by [Joseph Savona](https://twitter.com/en_JS), [Josh Story](https://twitter.com/joshcstory), [Lauren Tan](https://twitter.com/potetotes), [Mengdi Chen](https://twitter.com/mengdi_en), [Samuel Susla](https://twitter.com/SamuelSusla), [Sathya Gunasekaran](https://twitter.com/_gsathya), [Sebastian Markbåge](https://twitter.com/sebmarkbage), and [Andrew Clark](https://twitter.com/acdlite)

---

In React Labs posts, we write about projects in active research and development. We’ve made significant progress on them since our [last update](https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022), and we’d like to share what we learned.

---

## React Server Components

React Server Components (or RSC) is a new application architecture designed by the React team.

We’ve first shared our research on RSC in an [introductory talk](https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components) and an [RFC](https://github.com/reactjs/rfcs/pull/188). To recap them, we are introducing a new kind of component—Server Components—that run ahead of time and are excluded from your JavaScript bundle. Server Components can run during the build, letting you read from the filesystem or fetch static content. They can also run on the server, letting you access your data layer without having to build an API. You can pass data by props from Server Components to the interactive Client Components in the browser.

RSC combines the simple “request/response” mental model of server-centric Multi-Page Apps with the seamless interactivity of client-centric Single-Page Apps, giving you the best of both worlds.

Since our last update, we have merged the [React Server Components RFC](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md) to ratify the proposal. We resolved outstanding issues with the [React Server Module Conventions](https://github.com/reactjs/rfcs/blob/main/text/0227-server-module-conventions.md) proposal, and reached consensus with our partners to go with the `"use client"` convention. These documents also act as specification for what an RSC-compatible implementation should support.

The biggest change is that we introduced [`async` / `await`](https://github.com/reactjs/rfcs/pull/229) as the primary way to do data fetching from Server Components. We also plan to support data loading from the client by introducing a new Hook called `use` that unwraps Promises. Although we can’t support `async / await` in arbitrary components in client-only apps, we plan to add support for it when you structure your client-only app similar to how RSC apps are structured.

Now that we have data fetching pretty well sorted, we’re exploring the other direction: sending data from the client to the server, so that you can execute database mutations and implement forms. We’re doing this by letting you pass Server Action functions across the server/client boundary, which the client can then call, providing seamless RPC. Server Actions also give you progressively enhanced forms before JavaScript loads.

React Server Components has shipped in [Next.js App Router](https://react.dev/learn/creating-a-react-app#nextjs-app-router). This showcases a deep integration of a router that really buys into RSC as a primitive, but it’s not the only way to build a RSC-compatible router and framework. There’s a clear separation for features provided by the RSC spec and implementation. React Server Components is meant as a spec for components that work across compatible React frameworks.

We generally recommend using an existing framework, but if you need to build your own custom framework, it is possible. Building your own RSC-compatible framework is not as easy as we’d like it to be, mainly due to the deep bundler integration needed. The current generation of bundlers are great for use on the client, but they weren’t designed with first-class support for splitting a single module graph between the server and the client. This is why we’re now partnering directly with bundler developers to get the primitives for RSC built-in.

## Asset Loading

[Suspense](https://react.dev/reference/react/Suspense) lets you specify what to display on the screen while the data or code for your components is still being loaded. This lets your users progressively see more content while the page is loading as well as during the router navigations that load more data and code. However, from the user’s perspective, data loading and rendering do not tell the whole story when considering whether new content is ready. By default, browsers load stylesheets, fonts, and images independently, which can lead to UI jumps and consecutive layout shifts.

We’re working to fully integrate Suspense with the loading lifecycle of stylesheets, fonts, and images, so that React takes them into account to determine whether the content is ready to be displayed. Without any change to the way you author your React components, updates will behave in a more coherent and pleasing manner. As an optimization, we will also provide a manual way to preload assets like fonts directly from components.

We are currently implementing these features and will have more to share soon.

## Document Metadata

Different pages and screens in your app may have different metadata like the `<title>` tag, description, and other `<meta>` tags specific to this screen. From the maintenance perspective, it’s more scalable to keep this information close to the React component for that page or screen. However, the HTML tags for this metadata need to be in the document `<head>` which is typically rendered in a component at the very root of your app.

Today, people solve this problem with one of the two techniques.

One technique is to render a special third-party component that moves `<title>`, `<meta>`, and other tags inside it into the document `<head>`. This works for major browsers but there are many clients which do not run client-side JavaScript, such as Open Graph parsers, and so this technique is not universally suitable.

Another technique is to server-render the page in two parts. First, the main content is rendered and all such tags are collected. Then, the `<head>` is rendered with these tags. Finally, the `<head>` and the main content are sent to the browser. This approach works, but it prevents you from taking advantage of the [React 18’s Streaming Server Renderer](https://react.dev/reference/react-dom/server/renderToReadableStream) because you’d have to wait for all content to render before sending the `<head>`.

This is why we’re adding built-in support for rendering `<title>`, `<meta>`, and metadata `<link>` tags anywhere in your component tree out of the box. It would work the same way in all environments, including fully client-side code, SSR, and in the future, RSC. We will share more details about this soon.

## React Optimizing Compiler

Since our previous update we’ve been actively iterating on the design of [React Forget](https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022#react-compiler), an optimizing compiler for React. We’ve previously talked about it as an “auto-memoizing compiler”, and that is true in some sense. But building the compiler has helped us understand React’s programming model even more deeply. A better way to understand React Forget is as an automatic *reactivity* compiler.

The core idea of React is that developers define their UI as a function of the current state. You work with plain JavaScript values — numbers, strings, arrays, objects — and use standard JavaScript idioms — if/else, for, etc — to describe your component logic. The mental model is that React will re-render whenever the application state changes. We believe this simple mental model and keeping close to JavaScript semantics is an important principle in React’s programming model.

The catch is that React can sometimes be *too* reactive: it can re-render too much. For example, in JavaScript we don’t have cheap ways to compare if two objects or arrays are equivalent (having the same keys and values), so creating a new object or array on each render may cause React to do more work than it strictly needs to. This means developers have to explicitly memoize components so as to not over-react to changes.

Our goal with React Forget is to ensure that React apps have just the right amount of reactivity by default: that apps re-render only when state values *meaningfully* change. From an implementation perspective this means automatically memoizing, but we believe that the reactivity framing is a better way to understand React and Forget. One way to think about this is that React currently re-renders when object identity changes. With Forget, React re-renders when the semantic value changes — but without incurring the runtime cost of deep comparisons.

In terms of concrete progress, since our last update we have substantially iterated on the design of the compiler to align with this automatic reactivity approach and to incorporate feedback from using the compiler internally. After some significant refactors to the compiler starting late last year, we’ve now begun using the compiler in production in limited areas at Meta. We plan to open-source it once we’ve proved it in production.

Finally, a lot of people have expressed interest in how the compiler works. We’re looking forward to sharing a lot more details when we prove the compiler and open-source it. But there are a few bits we can share now:

The core of the compiler is almost completely decoupled from Babel, and the core compiler API is (roughly) old AST in, new AST out (while retaining source location data). Under the hood we use a custom code representation and transformation pipeline in order to do low-level semantic analysis. However, the primary public interface to the compiler will be via Babel and other build system plugins. For ease of testing we currently have a Babel plugin which is a very thin wrapper that calls the compiler to generate a new version of each function and swap it in.

As we refactored the compiler over the last few months, we wanted to focus on refining the core compilation model to ensure we could handle complexities such as conditionals, loops, reassignment, and mutation. However, JavaScript has a lot of ways to express each of those features: if/else, ternaries, for, for-in, for-of, etc. Trying to support the full language up-front would have delayed the point where we could validate the core model. Instead, we started with a small but representative subset of the language: let/const, if/else, for loops, objects, arrays, primitives, function calls, and a few other features. As we gained confidence in the core model and refined our internal abstractions, we expanded the supported language subset. We’re also explicit about syntax we don’t yet support, logging diagnostics and skipping compilation for unsupported input. We have utilities to try the compiler on Meta’s codebases and see what unsupported features are most common so we can prioritize those next. We’ll continue incrementally expanding towards supporting the whole language.

Making plain JavaScript in React components reactive requires a compiler with a deep understanding of semantics so that it can understand exactly what the code is doing. By taking this approach, we’re creating a system for reactivity within JavaScript that lets you write product code of any complexity with the full expressivity of the language, instead of being limited to a domain specific language.

## Offscreen Rendering

Offscreen rendering is an upcoming capability in React for rendering screens in the background without additional performance overhead. You can think of it as a version of the [`content-visibility` CSS property](https://developer.mozilla.org/en-US/docs/Web/CSS/content-visibility) that works not only for DOM elements but React components, too. During our research, we’ve discovered a variety of use cases:

* A router can prerender screens in the background so that when a user navigates to them, they’re instantly available.
* A tab switching component can preserve the state of hidden tabs, so the user can switch between them without losing their progress.
* A virtualized list component can prerender additional rows above and below the visible window.
* When opening a modal or popup, the rest of the app can be put into “background” mode so that events and updates are disabled for everything except the modal.

Most React developers will not interact with React’s offscreen APIs directly. Instead, offscreen rendering will be integrated into things like routers and UI libraries, and then developers who use those libraries will automatically benefit without additional work.

The idea is that you should be able to render any React tree offscreen without changing the way you write your components. When a component is rendered offscreen, it does not actually *mount* until the component becomes visible — its effects are not fired. For example, if a component uses `useEffect` to log analytics when it appears for the first time, prerendering won’t mess up the accuracy of those analytics. Similarly, when a component goes offscreen, its effects are unmounted, too. A key feature of offscreen rendering is that you can toggle the visibility of a component without losing its state.

Since our last update, we’ve tested an experimental version of prerendering internally at Meta in our React Native apps on Android and iOS, with positive performance results. We’ve also improved how offscreen rendering works with Suspense — suspending inside an offscreen tree will not trigger Suspense fallbacks. Our remaining work involves finalizing the primitives that are exposed to library developers. We expect to publish an RFC later this year, alongside an experimental API for testing and feedback.

## Transition Tracing

The Transition Tracing API lets you detect when [React Transitions](https://react.dev/reference/react/useTransition) become slower and investigate why they may be slow. Following our last update, we have completed the initial design of the API and published an [RFC](https://github.com/reactjs/rfcs/pull/238). The basic capabilities have also been implemented. The project is currently on hold. We welcome feedback on the RFC and look forward to resuming its development to provide a better performance measurement tool for React. This will be particularly useful with routers built on top of React Transitions, like the [Next.js App Router](https://react.dev/learn/creating-a-react-app#nextjs-app-router).

---

In addition to this update, our team has made recent guest appearances on community podcasts and livestreams to speak more on our work and answer questions.

* [Dan Abramov](https://bsky.app/profile/danabra.mov) and [Joe Savona](https://twitter.com/en_JS) were interviewed by [Kent C. Dodds on his YouTube channel](https://www.youtube.com/watch?v=h7tur48JSaw), where they discussed concerns around React Server Components.
* [Dan Abramov](https://bsky.app/profile/danabra.mov) and [Joe Savona](https://twitter.com/en_JS) were guests on the [JSParty podcast](https://jsparty.fm/267) and shared their thoughts about the future of React.

Thanks to [Andrew Clark](https://twitter.com/acdlite), [Dan Abramov](https://bsky.app/profile/danabra.mov), [Dave McCabe](https://twitter.com/mcc_abe), [Luna Wei](https://twitter.com/lunaleaps), [Matt Carroll](https://twitter.com/mattcarrollcode), [Sean Keegan](https://twitter.com/DevRelSean), [Sebastian Silbermann](https://twitter.com/sebsilbermann), [Seth Webster](https://twitter.com/sethwebster), and [Sophie Alpert](https://twitter.com/sophiebits) for reviewing this post.

Thanks for reading, and see you in the next update!

[PreviousReact Canaries: Enabling Incremental Feature Rollout Outside Meta](https://react.dev/blog/2023/05/03/react-canaries)[NextIntroducing react.dev](https://react.dev/blog/2023/03/16/introducing-react-dev)

---

---


# React Labs: What We've Been Working On – June 2022 – React

URL: https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022

[Blog](https://react.dev/blog)

# React Labs: What We've Been Working On – June 2022

June 15, 2022 by [Andrew Clark](https://twitter.com/acdlite), [Dan Abramov](https://bsky.app/profile/danabra.mov), [Jan Kassens](https://twitter.com/kassens), [Joseph Savona](https://twitter.com/en_JS), [Josh Story](https://twitter.com/joshcstory), [Lauren Tan](https://twitter.com/potetotes), [Luna Ruan](https://twitter.com/lunaruan), [Mengdi Chen](https://twitter.com/mengdi_en), [Rick Hanlon](https://twitter.com/rickhanlonii), [Robert Zhang](https://twitter.com/jiaxuanzhang01), [Sathya Gunasekaran](https://twitter.com/_gsathya), [Sebastian Markbåge](https://twitter.com/sebmarkbage), and [Xuan Huang](https://twitter.com/Huxpro)

---

[React 18](https://react.dev/blog/2022/03/29/react-v18) was years in the making, and with it brought valuable lessons for the React team. Its release was the result of many years of research and exploring many paths. Some of those paths were successful; many more were dead-ends that led to new insights. One lesson we’ve learned is that it’s frustrating for the community to wait for new features without having insight into these paths that we’re exploring.

---

We typically have a number of projects being worked on at any time, ranging from the more experimental to the clearly defined. Looking ahead, we’d like to start regularly sharing more about what we’ve been working on with the community across these projects.

To set expectations, this is not a roadmap with clear timelines. Many of these projects are under active research and are difficult to put concrete ship dates on. They may possibly never even ship in their current iteration depending on what we learn. Instead, we want to share with you the problem spaces we’re actively thinking about, and what we’ve learned so far.

## Server Components

We announced an [experimental demo of React Server Components](https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html) (RSC) in December 2020. Since then we’ve been finishing up its dependencies in React 18, and working on changes inspired by experimental feedback.

In particular, we’re abandoning the idea of having forked I/O libraries (eg react-fetch), and instead adopting an async/await model for better compatibility. This doesn’t technically block RSC’s release because you can also use routers for data fetching. Another change is that we’re also moving away from the file extension approach in favor of [annotating boundaries](https://github.com/reactjs/rfcs/pull/189#issuecomment-1116482278).

We’re working together with Vercel and Shopify to unify bundler support for shared semantics in both webpack and Vite. Before launch, we want to make sure that the semantics of RSCs are the same across the whole React ecosystem. This is the major blocker for reaching stable.

## Asset Loading

Currently, assets like scripts, external styles, fonts, and images are typically preloaded and loaded using external systems. This can make it tricky to coordinate across new environments like streaming, Server Components, and more.
We’re looking at adding APIs to preload and load deduplicated external assets through React APIs that work in all React environments.

We’re also looking at having these support Suspense so you can have images, CSS, and fonts that block display until they’re loaded but don’t block streaming and concurrent rendering. This can help avoid [“popcorning“](https://twitter.com/sebmarkbage/status/1516852731251724293) as the visuals pop and layout shifts.

## Static Server Rendering Optimizations

Static Site Generation (SSG) and Incremental Static Regeneration (ISR) are great ways to get performance for cacheable pages, but we think we can add features to improve performance of dynamic Server Side Rendering (SSR) – especially when most but not all of the content is cacheable. We’re exploring ways to optimize server rendering utilizing compilation and static passes.

## React Optimizing Compiler

We gave an [early preview](https://www.youtube.com/watch?v=lGEMwh32soc) of React Forget at React Conf 2021. It’s a compiler that automatically generates the equivalent of `useMemo` and `useCallback` calls to minimize the cost of re-rendering, while retaining React’s programming model.

Recently, we finished a rewrite of the compiler to make it more reliable and capable. This new architecture allows us to analyze and memoize more complex patterns such as the use of [local mutations](https://react.dev/learn/keeping-components-pure#local-mutation-your-components-little-secret), and opens up many new compile-time optimization opportunities beyond just being on par with memoization Hooks.

We’re also working on a playground for exploring many aspects of the compiler. While the goal of the playground is to make development of the compiler easier, we think that it will make it easier to try it out and build intuition for what the compiler does. It reveals various insights into how it works under the hood, and live renders the compiler’s outputs as you type. This will be shipped together with the compiler when it’s released.

## Offscreen

Today, if you want to hide and show a component, you have two options. One is to add or remove it from the tree completely. The problem with this approach is that the state of your UI is lost each time you unmount, including state stored in the DOM, like scroll position.

The other option is to keep the component mounted and toggle the appearance visually using CSS. This preserves the state of your UI, but it comes at a performance cost, because React must keep rendering the hidden component and all of its children whenever it receives new updates.

Offscreen introduces a third option: hide the UI visually, but deprioritize its content. The idea is similar in spirit to the `content-visibility` CSS property: when content is hidden, it doesn’t need to stay in sync with the rest of the UI. React can defer the rendering work until the rest of the app is idle, or until the content becomes visible again.

Offscreen is a low level capability that unlocks high level features. Similar to React’s other concurrent features like `startTransition`, in most cases you won’t interact with the Offscreen API directly, but instead via an opinionated framework to implement patterns like:

* **Instant transitions.** Some routing frameworks already prefetch data to speed up subsequent navigations, like when hovering over a link. With Offscreen, they’ll also be able to prerender the next screen in the background.
* **Reusable state.** Similarly, when navigating between routes or tabs, you can use Offscreen to preserve the state of the previous screen so you can switch back and pick up where you left off.
* **Virtualized list rendering.** When displaying large lists of items, virtualized list frameworks will prerender more rows than are currently visible. You can use Offscreen to prerender the hidden rows at a lower priority than the visible items in the list.
* **Backgrounded content.** We’re also exploring a related feature for deprioritizing content in the background without hiding it, like when displaying a modal overlay.

## Transition Tracing

Currently, React has two profiling tools. The [original Profiler](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) shows an overview of all the commits in a profiling session. For each commit, it also shows all components that rendered and the amount of time it took for them to render. We also have a beta version of a [Timeline Profiler](https://github.com/reactwg/react-18/discussions/76) introduced in React 18 that shows when components schedule updates and when React works on these updates. Both of these profilers help developers identify performance problems in their code.

We’ve realized that developers don’t find knowing about individual slow commits or components out of context that useful. It’s more useful to know about what actually causes the slow commits. And that developers want to be able to track specific interactions (eg a button click, an initial load, or a page navigation) to watch for performance regressions and to understand why an interaction was slow and how to fix it.

We previously tried to solve this issue by creating an [Interaction Tracing API](https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16), but it had some fundamental design flaws that reduced the accuracy of tracking why an interaction was slow and sometimes resulted in interactions never ending. We ended up [removing this API](https://github.com/facebook/react/pull/20037) because of these issues.

We are working on a new version for the Interaction Tracing API (tentatively called Transition Tracing because it is initiated via `startTransition`) that solves these problems.

## New React Docs

Last year, we announced the beta version of the new React documentation website ([later shipped as react.dev](https://react.dev/blog/2023/03/16/introducing-react-dev)) of the new React documentation website. The new learning materials teach Hooks first and has new diagrams, illustrations, as well as many interactive examples and challenges. We took a break from that work to focus on the React 18 release, but now that React 18 is out, we’re actively working to finish and ship the new documentation.

We are currently writing a detailed section about effects, as we’ve heard that is one of the more challenging topics for both new and experienced React users. [Synchronizing with Effects](https://react.dev/learn/synchronizing-with-effects) is the first published page in the series, and there are more to come in the following weeks. When we first started writing a detailed section about effects, we’ve realized that many common effect patterns can be simplified by adding a new primitive to React. We’ve shared some initial thoughts on that in the [useEvent RFC](https://github.com/reactjs/rfcs/pull/220). It is currently in early research, and we are still iterating on the idea. We appreciate the community’s comments on the RFC so far, as well as the [feedback](https://github.com/reactjs/react.dev/issues/3308) and contributions to the ongoing documentation rewrite. We’d specifically like to thank [Harish Kumar](https://github.com/harish-sethuraman) for submitting and reviewing many improvements to the new website implementation.

*Thanks to [Sophie Alpert](https://twitter.com/sophiebits) for reviewing this blog post!*

[PreviousIntroducing react.dev](https://react.dev/blog/2023/03/16/introducing-react-dev)[NextReact v18.0](https://react.dev/blog/2022/03/29/react-v18)

---

---


# React Conf 2021 Recap – React

URL: https://react.dev/blog/2021/12/17/react-conf-2021-recap

[Blog](https://react.dev/blog)

# React Conf 2021 Recap

December 17, 2021 by [Jesslyn Tannady](https://twitter.com/jtannady) and [Rick Hanlon](https://twitter.com/rickhanlonii)

---

Last week we hosted our 6th React Conf. In previous years, we’ve used the React Conf stage to deliver industry changing announcements such as [*React Native*](https://engineering.fb.com/2015/03/26/android/react-native-bringing-modern-web-techniques-to-mobile/) and [*React Hooks*](https://reactjs.org/docs/hooks-intro.html). This year, we shared our multi-platform vision for React, starting with the release of React 18 and gradual adoption of concurrent features.

---

This was the first time React Conf was hosted online, and it was streamed for free, translated to 8 different languages. Participants from all over the world joined our conference Discord and the replay event for accessibility in all timezones. Over 50,000 people registered, with over 60,000 views of 19 talks, and 5,000 participants in Discord across both events.

All the talks are [available to stream online](https://www.youtube.com/watch?v=FZ0cG47msEk&list=PLNG_1j3cPCaZZ7etkzWA7JfdmKWT0pMsa).

Here’s a summary of what was shared on stage:

## React 18 and concurrent features

In the keynote, we shared our vision for the future of React starting with React 18.

React 18 adds the long-awaited concurrent renderer and updates to Suspense without any major breaking changes. Apps can upgrade to React 18 and begin gradually adopting concurrent features with the amount of effort on par with any other major release.

**This means there is no concurrent mode, only concurrent features.**

In the keynote, we also shared our vision for Suspense, Server Components, new React working groups, and our long-term many-platform vision for React Native.

Watch the full keynote from [Andrew Clark](https://twitter.com/acdlite), [Juan Tejada](https://twitter.com/_jstejada), [Lauren Tan](https://twitter.com/potetotes), and [Rick Hanlon](https://twitter.com/rickhanlonii) here:

## React 18 for Application Developers

In the keynote, we also announced that the React 18 RC is available to try now. Pending further feedback, this is the exact version of React that we will publish to stable early next year.

To try the React 18 RC, upgrade your dependencies:

```
npm install react@rc react-dom@rc
```

and switch to the new `createRoot` API:

```
// before

const container = document.getElementById('root');

ReactDOM.render(<App />, container);

// after

const container = document.getElementById('root');

const root = ReactDOM.createRoot(container);

root.render(<App/>);
```

For a demo of upgrading to React 18, see [Shruti Kapoor](https://twitter.com/shrutikapoor08)’s talk here:

## Streaming Server Rendering with Suspense

React 18 also includes improvements to server-side rendering performance using Suspense.

Streaming server rendering lets you generate HTML from React components on the server, and stream that HTML to your users. In React 18, you can use `Suspense` to break down your app into smaller independent units which can be streamed independently of each other without blocking the rest of the app. This means users will see your content sooner and be able to start interacting with it much faster.

For a deep dive, see [Shaundai Person](https://twitter.com/shaundai)’s talk here:

## The first React working group

For React 18, we created our first Working Group to collaborate with a panel of experts, developers, library maintainers, and educators. Together we worked to create our gradual adoption strategy and refine new APIs such as `useId`, `useSyncExternalStore`, and `useInsertionEffect`.

For an overview of this work, see [Aakansha’ Doshi](https://twitter.com/aakansha1216)’s talk:

## React Developer Tooling

To support the new features in this release, we also announced the newly formed React DevTools team and a new Timeline Profiler to help developers debug their React apps.

For more information and a demo of new DevTools features, see [Brian Vaughn](https://twitter.com/brian_d_vaughn)’s talk:

## React without memo

Looking further into the future, [Xuan Huang (黄玄)](https://twitter.com/Huxpro) shared an update from our React Labs research into an auto-memoizing compiler. Check out this talk for more information and a demo of the compiler prototype:

## React docs keynote

[Rachel Nabors](https://twitter.com/rachelnabors) kicked off a section of talks about learning and designing with React with a keynote about our investment in React’s new docs ([now shipped as react.dev](https://react.dev/blog/2023/03/16/introducing-react-dev)):

## And more…

**We also heard talks on learning and designing with React:**

* Debbie O’Brien: [Things I learnt from the new React docs](https://youtu.be/-7odLW_hG7s).
* Sarah Rainsberger: [Learning in the Browser](https://youtu.be/5X-WEQflCL0).
* Linton Ye: [The ROI of Designing with React](https://youtu.be/7cPWmID5XAk).
* Delba de Oliveira: [Interactive playgrounds with React](https://youtu.be/zL8cz2W0z34).

**Talks from the Relay, React Native, and PyTorch teams:**

* Robert Balicki: [Re-introducing Relay](https://youtu.be/lhVGdErZuN4).
* Eric Rozell and Steven Moyes: [React Native Desktop](https://youtu.be/9L4FFrvwJwY).
* Roman Rädle: [On-device Machine Learning for React Native](https://youtu.be/NLj73vrc2I8)

**And talks from the community on accessibility, tooling, and Server Components:**

* Daishi Kato: [React 18 for External Store Libraries](https://youtu.be/oPfSC5bQPR8).
* Diego Haz: [Building Accessible Components in React 18](https://youtu.be/dcm8fjBfro8).
* Tafu Nakazaki: [Accessible Japanese Form Components with React](https://youtu.be/S4a0QlsH0pU).
* Lyle Troxell: [UI tools for artists](https://youtu.be/b3l4WxipFsE).
* Helen Lin: [Hydrogen + React 18](https://youtu.be/HS6vIYkSNks).

## Thank you

This was our first year planning a conference ourselves, and we have a lot of people to thank.

First, thanks to all of our speakers [Aakansha Doshi](https://twitter.com/aakansha1216), [Andrew Clark](https://twitter.com/acdlite), [Brian Vaughn](https://twitter.com/brian_d_vaughn), [Daishi Kato](https://twitter.com/dai_shi), [Debbie O’Brien](https://twitter.com/debs_obrien), [Delba de Oliveira](https://twitter.com/delba_oliveira), [Diego Haz](https://twitter.com/diegohaz), [Eric Rozell](https://twitter.com/EricRozell), [Helen Lin](https://twitter.com/wizardlyhel), [Juan Tejada](https://twitter.com/_jstejada), [Lauren Tan](https://twitter.com/potetotes), [Linton Ye](https://twitter.com/lintonye), [Lyle Troxell](https://twitter.com/lyle), [Rachel Nabors](https://twitter.com/rachelnabors), [Rick Hanlon](https://twitter.com/rickhanlonii), [Robert Balicki](https://twitter.com/StatisticsFTW), [Roman Rädle](https://twitter.com/raedle), [Sarah Rainsberger](https://twitter.com/sarah11918), [Shaundai Person](https://twitter.com/shaundai), [Shruti Kapoor](https://twitter.com/shrutikapoor08), [Steven Moyes](https://twitter.com/moyessa), [Tafu Nakazaki](https://twitter.com/hawaiiman0), and [Xuan Huang (黄玄)](https://twitter.com/Huxpro).

Thanks to everyone who helped provide feedback on talks including [Andrew Clark](https://twitter.com/acdlite), [Dan Abramov](https://bsky.app/profile/danabra.mov), [Dave McCabe](https://twitter.com/mcc_abe), [Eli White](https://twitter.com/Eli_White), [Joe Savona](https://twitter.com/en_JS), [Lauren Tan](https://twitter.com/potetotes), [Rachel Nabors](https://twitter.com/rachelnabors), and [Tim Yung](https://twitter.com/yungsters).

Thanks to [Lauren Tan](https://twitter.com/potetotes) for setting up the conference Discord and serving as our Discord admin.

Thanks to [Seth Webster](https://twitter.com/sethwebster) for feedback on overall direction and making sure we were focused on diversity and inclusion.

Thanks to [Rachel Nabors](https://twitter.com/rachelnabors) for spearheading our moderation effort, and [Aisha Blake](https://twitter.com/AishaBlake) for creating our moderation guide, leading our moderation team, training the translators and moderators, and helping to moderate both events.

Thanks to our moderators [Jesslyn Tannady](https://twitter.com/jtannady), [Suzie Grange](https://twitter.com/missuze), [Becca Bailey](https://twitter.com/beccaliz), [Luna Wei](https://twitter.com/lunaleaps), [Joe Previte](https://twitter.com/jsjoeio), [Nicola Corti](https://twitter.com/Cortinico), [Gijs Weterings](https://twitter.com/gweterings), [Claudio Procida](https://twitter.com/claudiopro), Julia Neumann, Mengdi Chen, Jean Zhang, Ricky Li, and [Xuan Huang (黄玄)](https://twitter.com/Huxpro).

Thanks to [Manjula Dube](https://twitter.com/manjula_dube), [Sahil Mhapsekar](https://twitter.com/apheri0), and Vihang Patel from [React India](https://www.reactindia.io/), and [Jasmine Xie](https://twitter.com/jasmine_xby), [QiChang Li](https://twitter.com/QCL15), and [YanLun Li](https://twitter.com/anneincoding) from [React China](https://twitter.com/ReactChina) for helping moderate our replay event and keep it engaging for the community.

Thanks to Vercel for publishing their [Virtual Event Starter Kit](https://vercel.com/virtual-event-starter-kit), which the conference website was built on, and to [Lee Robinson](https://twitter.com/leeerob) and [Delba de Oliveira](https://twitter.com/delba_oliveira) for sharing their experience running Next.js Conf.

Thanks to [Leah Silber](https://twitter.com/wifelette) for sharing her experience running conferences, learnings from running [RustConf](https://rustconf.com/), and for her book [Event Driven](https://leanpub.com/eventdriven/) and the advice it contains for running conferences.

Thanks to [Kevin Lewis](https://twitter.com/_phzn) and [Rachel Nabors](https://twitter.com/rachelnabors) for sharing their experience running Women of React Conf.

Thanks to [Aakansha Doshi](https://twitter.com/aakansha1216), [Laurie Barth](https://twitter.com/laurieontech), [Michael Chan](https://twitter.com/chantastic), and [Shaundai Person](https://twitter.com/shaundai) for their advice and ideas throughout planning.

Thanks to [Dan Lebowitz](https://twitter.com/lebo) for help designing and building the conference website and tickets.

Thanks to Laura Podolak Waddell, Desmond Osei-Acheampong, Mark Rossi, Josh Toberman and others on the Facebook Video Productions team for recording the videos for the Keynote and Meta employee talks.

Thanks to our partner HitPlay for helping to organize the conference, editing all the videos in the stream, translating all the talks, and moderating the Discord in multiple languages.

Finally, thanks to all of our participants for making this a great React Conf!

[PreviousHow to Upgrade to React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide)[NextThe Plan for React 18](https://react.dev/blog/2021/06/08/the-plan-for-react-18)

---

---


# Introducing Zero-Bundle-Size React Server Components – React

URL: https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components

[Blog](https://react.dev/blog)

# Introducing Zero-Bundle-Size React Server Components

December 21, 2020 by [Dan Abramov](https://bsky.app/profile/danabra.mov), [Lauren Tan](https://twitter.com/potetotes), [Joseph Savona](https://twitter.com/en_JS), and [Sebastian Markbåge](https://twitter.com/sebmarkbage)

---

2020 has been a long year. As it comes to an end we wanted to share a special Holiday Update on our research into zero-bundle-size **React Server Components**.

---

To introduce React Server Components, we have prepared a talk and a demo. If you want, you can check them out during the holidays, or later when work picks back up in the new year.

**React Server Components are still in research and development.** We are sharing this work in the spirit of transparency and to get initial feedback from the React community. There will be plenty of time for that, so **don’t feel like you have to catch up right now!**

If you want to check them out, we recommend going in the following order:

1. **Watch the talk** to learn about React Server Components and see the demo.
2. **[Clone the demo](http://github.com/reactjs/server-components-demo)** to play with React Server Components on your computer.
3. **[Read the RFC (with FAQ at the end)](https://github.com/reactjs/rfcs/pull/188)** for a deeper technical breakdown and to provide feedback.

We are excited to hear from you on the RFC or in replies to the [@reactjs](https://twitter.com/reactjs) Twitter handle. Happy holidays, stay safe, and see you next year!

[PreviousThe Plan for React 18](https://react.dev/blog/2021/06/08/the-plan-for-react-18)[NextOlder posts](https://reactjs.org/blog/all.html)

---

---


# unmountComponentAtNode – React

URL: https://react.dev/reference/react-dom/unmountComponentAtNode

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# unmountComponentAtNode

### Deprecated

This API will be removed in a future major version of React.

In React 18, `unmountComponentAtNode` was replaced by [`root.unmount()`](https://react.dev/reference/react-dom/client/createRoot#root-unmount).

`unmountComponentAtNode` removes a mounted React component from the DOM.

```
unmountComponentAtNode(domNode)
```

* [Reference](https://react.dev/reference/react-dom/unmountComponentAtNode#reference) 
  + [`unmountComponentAtNode(domNode)`](https://react.dev/reference/react-dom/unmountComponentAtNode#unmountcomponentatnode)
* [Usage](https://react.dev/reference/react-dom/unmountComponentAtNode#usage) 
  + [Removing a React app from a DOM element](https://react.dev/reference/react-dom/unmountComponentAtNode#removing-a-react-app-from-a-dom-element)

---

## Reference

### `unmountComponentAtNode(domNode)`

Call `unmountComponentAtNode` to remove a mounted React component from the DOM and clean up its event handlers and state.

```
import { unmountComponentAtNode } from 'react-dom';

const domNode = document.getElementById('root');

render(<App />, domNode);

unmountComponentAtNode(domNode);
```

[See more examples below.](https://react.dev/reference/react-dom/unmountComponentAtNode#usage)

#### Parameters

* `domNode`: A [DOM element.](https://developer.mozilla.org/en-US/docs/Web/API/Element) React will remove a mounted React component from this element.

#### Returns

`unmountComponentAtNode` returns `true` if a component was unmounted and `false` otherwise.

---

## Usage

Call `unmountComponentAtNode` to remove a mounted React component from a browser DOM node and clean up its event handlers and state.

```
import { render, unmountComponentAtNode } from 'react-dom';

import App from './App.js';

const rootNode = document.getElementById('root');

render(<App />, rootNode);

// ...

unmountComponentAtNode(rootNode);
```

### Removing a React app from a DOM element

Occasionally, you may want to “sprinkle” React on an existing page, or a page that is not fully written in React. In those cases, you may need to “stop” the React app, by removing all of the UI, state, and listeners from the DOM node it was rendered to.

In this example, clicking “Render React App” will render a React app. Click “Unmount React App” to destroy it:

index.jsindex.htmlApp.js

index.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import './styles.css';
import { render, unmountComponentAtNode } from 'react-dom';
import App from './App.js';

const domNode = document.getElementById('root');

document.getElementById('render').addEventListener('click', () => {
  render(<App />, domNode);
});

document.getElementById('unmount').addEventListener('click', () => {
  unmountComponentAtNode(domNode);
});
```

[Previousrender](https://react.dev/reference/react-dom/render)[NextClient APIs](https://react.dev/reference/react-dom/client)

---

---


# React Reference Overview – React

URL: https://react.dev/reference

[API Reference](https://react.dev/reference/react)

# React Reference Overview

This section provides detailed reference documentation for working with React. For an introduction to React, please visit the [Learn](https://react.dev/learn) section.

The React reference documentation is broken down into functional subsections:

## React

Programmatic React features:

* [Hooks](https://react.dev/reference/react/hooks) - Use different React features from your components.
* [Components](https://react.dev/reference/react/components) - Built-in components that you can use in your JSX.
* [APIs](https://react.dev/reference/react/apis) - APIs that are useful for defining components.
* [Directives](https://react.dev/reference/rsc/directives) - Provide instructions to bundlers compatible with React Server Components.

## React DOM

React DOM contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following:

* [Hooks](https://react.dev/reference/react-dom/hooks) - Hooks for web applications which run in the browser DOM environment.
* [Components](https://react.dev/reference/react-dom/components) - React supports all of the browser built-in HTML and SVG components.
* [APIs](https://react.dev/reference/react-dom) - The `react-dom` package contains methods supported only in web applications.
* [Client APIs](https://react.dev/reference/react-dom/client) - The `react-dom/client` APIs let you render React components on the client (in the browser).
* [Server APIs](https://react.dev/reference/react-dom/server) - The `react-dom/server` APIs let you render React components to HTML on the server.
* [Static APIs](https://react.dev/reference/react-dom/static) - The `react-dom/static` APIs let you generate static HTML for React components.

## React Compiler

The React Compiler is a build-time optimization tool that automatically memoizes your React components and values:

* [Configuration](https://react.dev/reference/react-compiler/configuration) - Configuration options for React Compiler.
* [Directives](https://react.dev/reference/react-compiler/directives) - Function-level directives to control compilation.
* [Compiling Libraries](https://react.dev/reference/react-compiler/compiling-libraries) - Guide for shipping pre-compiled library code.

## ESLint Plugin React Hooks

The [ESLint plugin for React Hooks](https://react.dev/reference/eslint-plugin-react-hooks) helps enforce the Rules of React:

* [Lints](https://react.dev/reference/eslint-plugin-react-hooks) - Detailed documentation for each lint with examples.

## Rules of React

React has idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications:

* [Components and Hooks must be pure](https://react.dev/reference/rules/components-and-hooks-must-be-pure) – Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly.
* [React calls Components and Hooks](https://react.dev/reference/rules/react-calls-components-and-hooks) – React is responsible for rendering components and hooks when necessary to optimize the user experience.
* [Rules of Hooks](https://react.dev/reference/rules/rules-of-hooks) – Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called.

## Legacy APIs

* [Legacy APIs](https://react.dev/reference/react/legacy) - Exported from the `react` package, but not recommended for use in newly written code.

[NextHooks](https://react.dev/reference/react/hooks)

---

---


# findDOMNode – React

URL: https://react.dev/reference/react-dom/findDOMNode#alternatives

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# findDOMNode

### Deprecated

This API will be removed in a future major version of React. [See the alternatives.](https://react.dev/reference/react-dom/findDOMNode#alternatives)

`findDOMNode` finds the browser DOM node for a React [class component](https://react.dev/reference/react/Component) instance.

```
const domNode = findDOMNode(componentInstance)
```

* [Reference](https://react.dev/reference/react-dom/findDOMNode#reference) 
  + [`findDOMNode(componentInstance)`](https://react.dev/reference/react-dom/findDOMNode#finddomnode)
* [Usage](https://react.dev/reference/react-dom/findDOMNode#usage) 
  + [Finding the root DOM node of a class component](https://react.dev/reference/react-dom/findDOMNode#finding-the-root-dom-node-of-a-class-component)
* [Alternatives](https://react.dev/reference/react-dom/findDOMNode#alternatives) 
  + [Reading component’s own DOM node from a ref](https://react.dev/reference/react-dom/findDOMNode#reading-components-own-dom-node-from-a-ref)
  + [Reading a child component’s DOM node from a forwarded ref](https://react.dev/reference/react-dom/findDOMNode#reading-a-child-components-dom-node-from-a-forwarded-ref)
  + [Adding a wrapper `<div>` element](https://react.dev/reference/react-dom/findDOMNode#adding-a-wrapper-div-element)

---

## Reference

### `findDOMNode(componentInstance)`

Call `findDOMNode` to find the browser DOM node for a given React [class component](https://react.dev/reference/react/Component) instance.

```
import { findDOMNode } from 'react-dom';

const domNode = findDOMNode(componentInstance);
```

[See more examples below.](https://react.dev/reference/react-dom/findDOMNode#usage)

#### Parameters

* `componentInstance`: An instance of the [`Component`](https://react.dev/reference/react/Component) subclass. For example, `this` inside a class component.

#### Returns

`findDOMNode` returns the first closest browser DOM node within the given `componentInstance`. When a component renders to `null`, or renders `false`, `findDOMNode` returns `null`. When a component renders to a string, `findDOMNode` returns a text DOM node containing that value.

#### Caveats

* A component may return an array or a [Fragment](https://react.dev/reference/react/Fragment) with multiple children. In that case `findDOMNode`, will return the DOM node corresponding to the first non-empty child.
* `findDOMNode` only works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like calling `findDOMNode()` in `render()` on a component that has yet to be created), an exception will be thrown.
* `findDOMNode` only returns the result at the time of your call. If a child component renders a different node later, there is no way for you to be notified of this change.
* `findDOMNode` accepts a class component instance, so it can’t be used with function components.

---

## Usage

### Finding the root DOM node of a class component

Call `findDOMNode` with a [class component](https://react.dev/reference/react/Component) instance (usually, `this`) to find the DOM node it has rendered.

```
class AutoselectingInput extends Component {

componentDidMount() {

const input = findDOMNode(this);

input.select()

}

render() {

return <input defaultValue="Hello" />

}

}
```

Here, the `input` variable will be set to the `<input>` DOM element. This lets you do something with it. For example, when clicking “Show example” below mounts the input, [`input.select()`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select) selects all text in the input:

App.jsAutoselectingInput.js

AutoselectingInput.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component } from 'react';
import { findDOMNode } from 'react-dom';

class AutoselectingInput extends Component {
  componentDidMount() {
    const input = findDOMNode(this);
    input.select()
  }

  render() {
    return <input defaultValue="Hello" />
  }
}

export default AutoselectingInput;
```

---

## Alternatives

### Reading component’s own DOM node from a ref

Code using `findDOMNode` is fragile because the connection between the JSX node and the code manipulating the corresponding DOM node is not explicit. For example, try wrapping this `<input />` into a `<div>`:

App.jsAutoselectingInput.js

AutoselectingInput.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component } from 'react';
import { findDOMNode } from 'react-dom';

class AutoselectingInput extends Component {
  componentDidMount() {
    const input = findDOMNode(this);
    input.select()
  }
  render() {
    return <input defaultValue="Hello" />
  }
}

export default AutoselectingInput;
```

This will break the code because now, `findDOMNode(this)` finds the `<div>` DOM node, but the code expects an `<input>` DOM node. To avoid these kinds of problems, use [`createRef`](https://react.dev/reference/react/createRef) to manage a specific DOM node.

In this example, `findDOMNode` is no longer used. Instead, `inputRef = createRef(null)` is defined as an instance field on the class. To read the DOM node from it, you can use `this.inputRef.current`. To attach it to the JSX, you render `<input ref={this.inputRef} />`. This connects the code using the DOM node to its JSX:

App.jsAutoselectingInput.js

AutoselectingInput.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRef, Component } from 'react';

class AutoselectingInput extends Component {
  inputRef = createRef(null);

  componentDidMount() {
    const input = this.inputRef.current;
    input.select()
  }

  render() {
    return (
      <input ref={this.inputRef} defaultValue="Hello" />
    );
  }
}

export default AutoselectingInput;
```

Show more

In modern React without class components, the equivalent code would call [`useRef`](https://react.dev/reference/react/useRef) instead:

App.jsAutoselectingInput.js

AutoselectingInput.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useEffect } from 'react';

export default function AutoselectingInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    const input = inputRef.current;
    input.select();
  }, []);

  return <input ref={inputRef} defaultValue="Hello" />
}
```

[Read more about manipulating the DOM with refs.](https://react.dev/learn/manipulating-the-dom-with-refs)

---

### Reading a child component’s DOM node from a forwarded ref

In this example, `findDOMNode(this)` finds a DOM node that belongs to another component. The `AutoselectingInput` renders `MyInput`, which is your own component that renders a browser `<input>`.

App.jsAutoselectingInput.jsMyInput.js

AutoselectingInput.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { Component } from 'react';
import { findDOMNode } from 'react-dom';
import MyInput from './MyInput.js';

class AutoselectingInput extends Component {
  componentDidMount() {
    const input = findDOMNode(this);
    input.select()
  }
  render() {
    return <MyInput />;
  }
}

export default AutoselectingInput;
```

Notice that calling `findDOMNode(this)` inside `AutoselectingInput` still gives you the DOM `<input>`—even though the JSX for this `<input>` is hidden inside the `MyInput` component. This seems convenient for the above example, but it leads to fragile code. Imagine that you wanted to edit `MyInput` later and add a wrapper `<div>` around it. This would break the code of `AutoselectingInput` (which expects to find an `<input>`).

To replace `findDOMNode` in this example, the two components need to coordinate:

1. `AutoSelectingInput` should declare a ref, like [in the earlier example](https://react.dev/reference/react-dom/findDOMNode#reading-components-own-dom-node-from-a-ref), and pass it to `<MyInput>`.
2. `MyInput` should be declared with [`forwardRef`](https://react.dev/reference/react/forwardRef) to take that ref and forward it down to the `<input>` node.

This version does that, so it no longer needs `findDOMNode`:

App.jsAutoselectingInput.jsMyInput.js

AutoselectingInput.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createRef, Component } from 'react';
import MyInput from './MyInput.js';

class AutoselectingInput extends Component {
  inputRef = createRef(null);

  componentDidMount() {
    const input = this.inputRef.current;
    input.select()
  }

  render() {
    return (
      <MyInput ref={this.inputRef} />
    );
  }
}

export default AutoselectingInput;
```

Show more

Here is how this code would look like with function components instead of classes:

App.jsAutoselectingInput.jsMyInput.js

AutoselectingInput.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useRef, useEffect } from 'react';
import MyInput from './MyInput.js';

export default function AutoselectingInput() {
  const inputRef = useRef(null);

  useEffect(() => {
    const input = inputRef.current;
    input.select();
  }, []);

  return <MyInput ref={inputRef} defaultValue="Hello" />
}
```

---

### Adding a wrapper `<div>` element

Sometimes a component needs to know the position and size of its children. This makes it tempting to find the children with `findDOMNode(this)`, and then use DOM methods like [`getBoundingClientRect`](https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect) for measurements.

There is currently no direct equivalent for this use case, which is why `findDOMNode` is deprecated but is not yet removed completely from React. In the meantime, you can try rendering a wrapper `<div>` node around the content as a workaround, and getting a ref to that node. However, extra wrappers can break styling.

```
<div ref={someRef}>

{children}

</div>
```

This also applies to focusing and scrolling to arbitrary children.

[PreviousflushSync](https://react.dev/reference/react-dom/flushSync)[Nexthydrate](https://react.dev/reference/react-dom/hydrate)

---

---


# Server Functions – React

URL: https://react.dev/reference/rsc/server-actions

[API Reference](https://react.dev/reference/react)

# Server Functions

### React Server Components

Server Functions are for use in [React Server Components](https://react.dev/reference/rsc/server-components).

**Note:** Until September 2024, we referred to all Server Functions as “Server Actions”. If a Server Function is passed to an action prop or called from inside an action then it is a Server Action, but not all Server Functions are Server Actions. The naming in this documentation has been updated to reflect that Server Functions can be used for multiple purposes.

Server Functions allow Client Components to call async functions executed on the server.

### Note

#### How do I build support for Server Functions?

While Server Functions in React 19 are stable and will not break between minor versions, the underlying APIs used to implement Server Functions in a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x.

To support Server Functions as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement Server Functions in the future.

When a Server Function is defined with the [`"use server"`](https://react.dev/reference/rsc/use-server) directive, your framework will automatically create a reference to the Server Function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.

Server Functions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.

## Usage

### Creating a Server Function from a Server Component

Server Components can define Server Functions with the `"use server"` directive:

```
// Server Component

import Button from './Button';

function EmptyNote () {

async function createNoteAction() {

// Server Function

'use server';

await db.notes.create();

}

return <Button onClick={createNoteAction}/>;

}
```

When React renders the `EmptyNote` Server Component, it will create a reference to the `createNoteAction` function, and pass that reference to the `Button` Client Component. When the button is clicked, React will send a request to the server to execute the `createNoteAction` function with the reference provided:

```
"use client";

export default function Button({onClick}) {

console.log(onClick);

// {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNoteAction'}

return <button onClick={() => onClick()}>Create Empty Note</button>

}
```

For more, see the docs for [`"use server"`](https://react.dev/reference/rsc/use-server).

### Importing Server Functions from Client Components

Client Components can import Server Functions from files that use the `"use server"` directive:

```
"use server";

export async function createNote() {

await db.notes.create();

}
```

When the bundler builds the `EmptyNote` Client Component, it will create a reference to the `createNote` function in the bundle. When the `button` is clicked, React will send a request to the server to execute the `createNote` function using the reference provided:

```
"use client";

import {createNote} from './actions';

function EmptyNote() {

console.log(createNote);

// {$$typeof: Symbol.for("react.server.reference"), $$id: 'createNote'}

<button onClick={() => createNote()} />

}
```

For more, see the docs for [`"use server"`](https://react.dev/reference/rsc/use-server).

### Server Functions with Actions

Server Functions can be called from Actions on the client:

```
"use server";

export async function updateName(name) {

if (!name) {

return {error: 'Name is required'};

}

await db.users.updateName(name);

}
```

```
"use client";

import {updateName} from './actions';

function UpdateName() {

const [name, setName] = useState('');

const [error, setError] = useState(null);

const [isPending, startTransition] = useTransition();

const submitAction = async () => {

startTransition(async () => {

const {error} = await updateName(name);

if (error) {

setError(error);

} else {

setName('');

}

})

}

return (

<form action={submitAction}>

<input type="text" name="name" disabled={isPending}/>

{error && <span>Failed: {error}</span>}

</form>

)

}
```

This allows you to access the `isPending` state of the Server Function by wrapping it in an Action on the client.

For more, see the docs for [Calling a Server Function outside of `<form>`](https://react.dev/reference/rsc/use-server#calling-a-server-function-outside-of-form)

### Server Functions with Form Actions

Server Functions work with the new Form features in React 19.

You can pass a Server Function to a Form to automatically submit the form to the server:

```
"use client";

import {updateName} from './actions';

function UpdateName() {

return (

<form action={updateName}>

<input type="text" name="name" />

</form>

)

}
```

When the Form submission succeeds, React will automatically reset the form. You can add `useActionState` to access the pending state, last response, or to support progressive enhancement.

For more, see the docs for [Server Functions in Forms](https://react.dev/reference/rsc/use-server#server-functions-in-forms).

### Server Functions with `useActionState`

You can call Server Functions with `useActionState` for the common case where you just need access to the action pending state and last returned response:

```
"use client";

import {updateName} from './actions';

function UpdateName() {

const [state, submitAction, isPending] = useActionState(updateName, {error: null});

return (

<form action={submitAction}>

<input type="text" name="name" disabled={isPending}/>

{state.error && <span>Failed: {state.error}</span>}

</form>

);

}
```

When using `useActionState` with Server Functions, React will also automatically replay form submissions entered before hydration finishes. This means users can interact with your app even before the app has hydrated.

For more, see the docs for [`useActionState`](https://react.dev/reference/react/useActionState).

### Progressive enhancement with `useActionState`

Server Functions also support progressive enhancement with the third argument of `useActionState`.

```
"use client";

import {updateName} from './actions';

function UpdateName() {

const [, submitAction] = useActionState(updateName, null, `/name/update`);

return (

<form action={submitAction}>

...

</form>

);

}
```

When the permalink is provided to `useActionState`, React will redirect to the provided URL if the form is submitted before the JavaScript bundle loads.

For more, see the docs for [`useActionState`](https://react.dev/reference/react/useActionState).

[PreviousServer Components](https://react.dev/reference/rsc/server-components)[NextDirectives](https://react.dev/reference/rsc/directives)

---

---


# hydrateRoot – React

URL: https://react.dev/link/hydration-mismatch

[API Reference](https://react.dev/reference/react)

[Client APIs](https://react.dev/reference/react-dom/client)

# hydrateRoot

`hydrateRoot` lets you display React components inside a browser DOM node whose HTML content was previously generated by [`react-dom/server`.](https://react.dev/reference/react-dom/server)

```
const root = hydrateRoot(domNode, reactNode, options?)
```

* [Reference](https://react.dev/link/hydration-mismatch#reference) 
  + [`hydrateRoot(domNode, reactNode, options?)`](https://react.dev/link/hydration-mismatch#hydrateroot)
  + [`root.render(reactNode)`](https://react.dev/link/hydration-mismatch#root-render)
  + [`root.unmount()`](https://react.dev/link/hydration-mismatch#root-unmount)
* [Usage](https://react.dev/link/hydration-mismatch#usage) 
  + [Hydrating server-rendered HTML](https://react.dev/link/hydration-mismatch#hydrating-server-rendered-html)
  + [Hydrating an entire document](https://react.dev/link/hydration-mismatch#hydrating-an-entire-document)
  + [Suppressing unavoidable hydration mismatch errors](https://react.dev/link/hydration-mismatch#suppressing-unavoidable-hydration-mismatch-errors)
  + [Handling different client and server content](https://react.dev/link/hydration-mismatch#handling-different-client-and-server-content)
  + [Updating a hydrated root component](https://react.dev/link/hydration-mismatch#updating-a-hydrated-root-component)
  + [Error logging in production](https://react.dev/link/hydration-mismatch#error-logging-in-production)
* [Troubleshooting](https://react.dev/link/hydration-mismatch#troubleshooting) 
  + [I’m getting an error: “You passed a second argument to root.render”](https://react.dev/link/hydration-mismatch#im-getting-an-error-you-passed-a-second-argument-to-root-render)

---

## Reference

### `hydrateRoot(domNode, reactNode, options?)`

Call `hydrateRoot` to “attach” React to existing HTML that was already rendered by React in a server environment.

```
import { hydrateRoot } from 'react-dom/client';

const domNode = document.getElementById('root');

const root = hydrateRoot(domNode, reactNode);
```

React will attach to the HTML that exists inside the `domNode`, and take over managing the DOM inside it. An app fully built with React will usually only have one `hydrateRoot` call with its root component.

[See more examples below.](https://react.dev/link/hydration-mismatch#usage)

#### Parameters

* `domNode`: A [DOM element](https://developer.mozilla.org/en-US/docs/Web/API/Element) that was rendered as the root element on the server.
* `reactNode`: The “React node” used to render the existing HTML. This will usually be a piece of JSX like `<App />` which was rendered with a `ReactDOM Server` method such as `renderToPipeableStream(<App />)`.
* **optional** `options`: An object with options for this React root.

  + **optional** `onCaughtError`: Callback called when React catches an error in an Error Boundary. Called with the `error` caught by the Error Boundary, and an `errorInfo` object containing the `componentStack`.
  + **optional** `onUncaughtError`: Callback called when an error is thrown and not caught by an Error Boundary. Called with the `error` that was thrown and an `errorInfo` object containing the `componentStack`.
  + **optional** `onRecoverableError`: Callback called when React automatically recovers from errors. Called with the `error` React throws, and an `errorInfo` object containing the `componentStack`. Some recoverable errors may include the original error cause as `error.cause`.
  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server.

#### Returns

`hydrateRoot` returns an object with two methods: [`render`](https://react.dev/link/hydration-mismatch#root-render) and [`unmount`.](https://react.dev/link/hydration-mismatch#root-unmount)

#### Caveats

* `hydrateRoot()` expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them.
* In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.
* You’ll likely have only one `hydrateRoot` call in your app. If you use a framework, it might do this call for you.
* If your app is client-rendered with no HTML rendered already, using `hydrateRoot()` is not supported. Use [`createRoot()`](https://react.dev/reference/react-dom/client/createRoot) instead.

---

### `root.render(reactNode)`

Call `root.render` to update a React component inside a hydrated React root for a browser DOM element.

```
root.render(<App />);
```

React will update `<App />` in the hydrated `root`.

[See more examples below.](https://react.dev/link/hydration-mismatch#usage)

#### Parameters

* `reactNode`: A “React node” that you want to update. This will usually be a piece of JSX like `<App />`, but you can also pass a React element constructed with [`createElement()`](https://react.dev/reference/react/createElement), a string, a number, `null`, or `undefined`.

#### Returns

`root.render` returns `undefined`.

#### Caveats

* If you call `root.render` before the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering.

---

### `root.unmount()`

Call `root.unmount` to destroy a rendered tree inside a React root.

```
root.unmount();
```

An app fully built with React will usually not have any calls to `root.unmount`.

This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to “stop” managing the removed root’s content by calling `root.unmount`. Otherwise, the components inside the removed root won’t clean up and free up resources like subscriptions.

Calling `root.unmount` will unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree.

#### Parameters

`root.unmount` does not accept any parameters.

#### Returns

`root.unmount` returns `undefined`.

#### Caveats

* Calling `root.unmount` will unmount all the components in the tree and “detach” React from the root DOM node.
* Once you call `root.unmount` you cannot call `root.render` again on the root. Attempting to call `root.render` on an unmounted root will throw a “Cannot update an unmounted root” error.

---

## Usage

### Hydrating server-rendered HTML

If your app’s HTML was generated by [`react-dom/server`](https://react.dev/reference/react-dom/client/createRoot), you need to *hydrate* it on the client.

```
import { hydrateRoot } from 'react-dom/client';

hydrateRoot(document.getElementById('root'), <App />);
```

This will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you.

To hydrate your app, React will “attach” your components’ logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser.

index.jsindex.htmlApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import './styles.css';
import { hydrateRoot } from 'react-dom/client';
import App from './App.js';

hydrateRoot(
  document.getElementById('root'),
  <App />
);
```

You shouldn’t need to call `hydrateRoot` again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will [use state](https://react.dev/reference/react/useState) instead.

### Pitfall

The React tree you pass to `hydrateRoot` needs to produce **the same output** as it did on the server.

This is important for the user experience. The user will spend some time looking at the server-generated HTML before your JavaScript code loads. Server rendering creates an illusion that the app loads faster by showing the HTML snapshot of its output. Suddenly showing different content breaks that illusion. This is why the server render output must match the initial render output on the client.

The most common causes leading to hydration errors include:

* Extra whitespace (like newlines) around the React-generated HTML inside the root node.
* Using checks like `typeof window !== 'undefined'` in your rendering logic.
* Using browser-only APIs like [`window.matchMedia`](https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia) in your rendering logic.
* Rendering different data on the server and the client.

React recovers from some hydration errors, but **you must fix them like other bugs.** In the best case, they’ll lead to a slowdown; in the worst case, event handlers can get attached to the wrong elements.

---

### Hydrating an entire document

Apps fully built with React can render the entire document as JSX, including the [`<html>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/html) tag:

```
function App() {

return (

<html>

<head>

<meta charSet="utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="stylesheet" href="/styles.css"></link>

<title>My app</title>

</head>

<body>

<Router />

</body>

</html>

);

}
```

To hydrate the entire document, pass the [`document`](https://developer.mozilla.org/en-US/docs/Web/API/Window/document) global as the first argument to `hydrateRoot`:

```
import { hydrateRoot } from 'react-dom/client';

import App from './App.js';

hydrateRoot(document, <App />);
```

---

### Suppressing unavoidable hydration mismatch errors

If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.

To silence hydration warnings on an element, add `suppressHydrationWarning={true}`:

index.jsindex.htmlApp.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function App() {
  return (
    <h1 suppressHydrationWarning={true}>
      Current Date: {new Date().toLocaleDateString()}
    </h1>
  );
}
```

This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. React will **not** attempt to patch mismatched text content.

---

### Handling different client and server content

If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a [state variable](https://react.dev/reference/react/useState) like `isClient`, which you can set to `true` in an [Effect](https://react.dev/reference/react/useEffect):

index.jsindex.htmlApp.js

App.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from "react";

export default function App() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return (
    <h1>
      {isClient ? 'Is Client' : 'Is Server'}
    </h1>
  );
}
```

This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.

### Pitfall

This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may also feel jarring to the user.

---

### Updating a hydrated root component

After the root has finished hydrating, you can call [`root.render`](https://react.dev/link/hydration-mismatch#root-render) to update the root React component. **Unlike with [`createRoot`](https://react.dev/reference/react-dom/client/createRoot), you don’t usually need to do this because the initial content was already rendered as HTML.**

If you call `root.render` at some point after hydration, and the component tree structure matches up with what was previously rendered, React will [preserve the state.](https://react.dev/learn/preserving-and-resetting-state) Notice how you can type in the input, which means that the updates from repeated `render` calls every second in this example are not destructive:

index.jsindex.htmlApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { hydrateRoot } from 'react-dom/client';
import './styles.css';
import App from './App.js';

const root = hydrateRoot(
  document.getElementById('root'),
  <App counter={0} />
);

let i = 0;
setInterval(() => {
  root.render(<App counter={i} />);
  i++;
}, 1000);
```

It is uncommon to call [`root.render`](https://react.dev/link/hydration-mismatch#root-render) on a hydrated root. Usually, you’ll [update state](https://react.dev/reference/react/useState) inside one of the components instead.

### Error logging in production

By default, React will log all errors to the console. To implement your own error reporting, you can provide the optional error handler root options `onUncaughtError`, `onCaughtError` and `onRecoverableError`:

```
import { hydrateRoot } from "react-dom/client";

import App from "./App.js";

import { reportCaughtError } from "./reportError";

const container = document.getElementById("root");

const root = hydrateRoot(container, <App />, {

onCaughtError: (error, errorInfo) => {

if (error.message !== "Known error") {

reportCaughtError({

error,

componentStack: errorInfo.componentStack,

});

}

},

});
```

The onCaughtError option is a function called with two arguments:

1. The error that was thrown.
2. An errorInfo object that contains the componentStack of the error.

Together with `onUncaughtError` and `onRecoverableError`, you can implement your own error reporting system:

index.jsreportError.jsApp.js

index.js

ReloadClear[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { hydrateRoot } from "react-dom/client";
import App from "./App.js";
import {
  onCaughtErrorProd,
  onRecoverableErrorProd,
  onUncaughtErrorProd,
} from "./reportError";

const container = document.getElementById("root");
hydrateRoot(container, <App />, {
  // Keep in mind to remove these options in development to leverage
  // React's default handlers or implement your own overlay for development.
  // The handlers are only specfied unconditionally here for demonstration purposes.
  onCaughtError: onCaughtErrorProd,
  onRecoverableError: onRecoverableErrorProd,
  onUncaughtError: onUncaughtErrorProd,
});
```

Show more

## Troubleshooting

### I’m getting an error: “You passed a second argument to root.render”

A common mistake is to pass the options for `hydrateRoot` to `root.render(...)`:

Console

Warning: You passed a second argument to root.render(…) but it only accepts one argument.

To fix, pass the root options to `hydrateRoot(...)`, not `root.render(...)`:

```
// 🚩 Wrong: root.render only takes one argument.

root.render(App, {onUncaughtError});

// ✅ Correct: pass options to createRoot.

const root = hydrateRoot(container, <App />, {onUncaughtError});
```

[PreviouscreateRoot](https://react.dev/reference/react-dom/client/createRoot)[NextServer APIs](https://react.dev/reference/react-dom/server)

---

---


# Introducing the New JSX Transform – React Blog

URL: https://react.dev/link/new-jsx-transform

# Introducing the New JSX Transform

September 22, 2020 by [Luna Ruan](https://twitter.com/lunaruan)

> This blog site has been archived. Go to [react.dev/blog](https://react.dev/blog) to see the recent posts.

Although React 17 [doesn’t contain new features](https://react.dev/blog/2020/08/10/react-v17-rc.html), it will provide support for a new version of the JSX transform. In this post, we will describe what it is and how to try it.

## What’s a JSX Transform?

Browsers don’t understand JSX out of the box, so most React users rely on a compiler like Babel or TypeScript to **transform JSX code into regular JavaScript**. Many preconfigured toolkits like Create React App or Next.js also include a JSX transform under the hood.

Together with the React 17 release, we’ve wanted to make a few improvements to the JSX transform, but we didn’t want to break existing setups. This is why we [worked with Babel](https://babeljs.io/blog/2020/03/16/7.9.0#a-new-jsx-transform-11154httpsgithubcombabelbabelpull11154) to **offer a new, rewritten version of the JSX transform** for people who would like to upgrade.

Upgrading to the new transform is completely optional, but it has a few benefits:

* With the new transform, you can **use JSX without importing React**.
* Depending on your setup, its compiled output may **slightly improve the bundle size**.
* It will enable future improvements that **reduce the number of concepts** you need to learn React.

**This upgrade will not change the JSX syntax and is not required.** The old JSX transform will keep working as usual, and there are no plans to remove the support for it.

[React 17 RC](https://react.dev/blog/2020/08/10/react-v17-rc.html) already includes support for the new transform, so go give it a try! To make it easier to adopt, **we’ve also backported its support** to React 16.14.0, React 15.7.0, and React 0.14.10. You can find the upgrade instructions for different tools [below](https://react.dev/link/new-jsx-transform#how-to-upgrade-to-the-new-jsx-transform).

Now let’s take a closer look at the differences between the old and the new transform.

## What’s Different in the New Transform?

When you use JSX, the compiler transforms it into React function calls that the browser can understand. **The old JSX transform** turned JSX into `React.createElement(...)` calls.

For example, let’s say your source code looks like this:

```
import React from 'react';

function App() {
  return <h1>Hello World</h1>;
}
```

Under the hood, the old JSX transform turns it into regular JavaScript:

```
import React from 'react';

function App() {
  return React.createElement('h1', null, 'Hello world');
}
```

> Note
>
> **Your source code doesn’t need to change in any way.** We’re describing how the JSX transform turns your JSX source code into the JavaScript code a browser can understand.

However, this is not perfect:

* Because JSX was compiled into `React.createElement`, `React` needed to be in scope if you used JSX.
* There are some [performance improvements and simplifications](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#motivation) that `React.createElement` does not allow.

To solve these issues, React 17 introduces two new entry points to the React package that are intended to only be used by compilers like Babel and TypeScript. Instead of transforming JSX to `React.createElement`, **the new JSX transform** automatically imports special functions from those new entry points in the React package and calls them.

Let’s say that your source code looks like this:

```
function App() {
  return <h1>Hello World</h1>;
}
```

This is what the new JSX transform compiles it to:

```
// Inserted by a compiler (don't import it yourself!)
import {jsx as _jsx} from 'react/jsx-runtime';

function App() {
  return _jsx('h1', { children: 'Hello world' });
}
```

Note how our original code **did not need to import React** to use JSX anymore! (But we would still need to import React in order to use Hooks or other exports that React provides.)

**This change is fully compatible with all of the existing JSX code**, so you won’t have to change your components. If you’re curious, you can check out the [technical RFC](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#detailed-design) for more details about how the new transform works.

> Note
>
> The functions inside `react/jsx-runtime` and `react/jsx-dev-runtime` must only be used by the compiler transform. If you need to manually create elements in your code, you should keep using `React.createElement`. It will continue to work and is not going away.

## How to Upgrade to the New JSX Transform

If you aren’t ready to upgrade to the new JSX transform or if you are using JSX for another library, don’t worry. The old transform will not be removed and will continue to be supported.

If you want to upgrade, you will need two things:

* **A version of React that supports the new transform** ([React 17 RC](https://react.dev/blog/2020/08/10/react-v17-rc.html) and higher supports it, but we’ve also released React 16.14.0, React 15.7.0, and React 0.14.10 for people who are still on the older major versions).
* **A compatible compiler** (see instructions for different tools below).

Since the new JSX transform doesn’t require React to be in scope, [we’ve also prepared an automated script](https://react.dev/link/new-jsx-transform#removing-unused-react-imports) that will remove the unnecessary imports from your codebase.

### Create React App

Create React App [4.0.0](https://github.com/facebook/create-react-app/releases/tag/v4.0.0)+ uses the new transform for compatible React versions.

### Next.js

Next.js [v9.5.3](https://github.com/vercel/next.js/releases/tag/v9.5.3)+ uses the new transform for compatible React versions.

### Gatsby

Gatsby [v2.24.5](https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/CHANGELOG.md#22452-2020-08-28)+ uses the new transform for compatible React versions.

> Note
>
> If you get [this Gatsby error](https://github.com/gatsbyjs/gatsby/issues/26979) after upgrading to React 17 RC, run `npm update` to fix it.

### Manual Babel Setup

Support for the new JSX transform is available in Babel [v7.9.0](https://babeljs.io/blog/2020/03/16/7.9.0) and above.

First, you’ll need to update to the latest Babel and plugin transform.

If you are using `@babel/plugin-transform-react-jsx`:

```
# for npm users
npm update @babel/core @babel/plugin-transform-react-jsx
```

```
# for yarn users
yarn upgrade @babel/core @babel/plugin-transform-react-jsx
```

If you are using `@babel/preset-react`:

```
# for npm users
npm update @babel/core @babel/preset-react
```

```
# for yarn users
yarn upgrade @babel/core @babel/preset-react
```

Currently, the old transform `{"runtime": "classic"}` is the default option. To enable the new transform, you can pass `{"runtime": "automatic"}` as an option to `@babel/plugin-transform-react-jsx` or `@babel/preset-react`:

```
// If you are using @babel/preset-react
{
  "presets": [
    ["@babel/preset-react", {
      "runtime": "automatic"
    }]
  ]
}
```

```
// If you're using @babel/plugin-transform-react-jsx
{
  "plugins": [
    ["@babel/plugin-transform-react-jsx", {
      "runtime": "automatic"
    }]
  ]
}
```

Starting from Babel 8, `"automatic"` will be the default runtime for both plugins. For more information, check out the Babel documentation for [@babel/plugin-transform-react-jsx](https://babeljs.io/docs/en/babel-plugin-transform-react-jsx) and [@babel/preset-react](https://babeljs.io/docs/en/babel-preset-react).

> Note
>
> If you use JSX with a library other than React, you can use [the `importSource` option](https://babeljs.io/docs/en/babel-preset-react#importsource) to import from that library instead — as long as it provides the necessary entry points. Alternatively, you can keep using the classic transform which will continue to be supported.
>
> If you’re a library author and you are implementing the `/jsx-runtime` entry point for your library, keep in mind that [there is a case](https://github.com/facebook/react/issues/20031#issuecomment-710346866) in which even the new transform has to fall back to `createElement` for backwards compatibility. In that case, it will auto-import `createElement` directly from the *root* entry point specified by `importSource`.

### ESLint

If you are using [eslint-plugin-react](https://github.com/yannickcr/eslint-plugin-react), the `react/jsx-uses-react` and `react/react-in-jsx-scope` rules are no longer necessary and can be turned off or removed.

```
{
  // ...
  "rules": {
    // ...
    "react/jsx-uses-react": "off",
    "react/react-in-jsx-scope": "off"
  }
}
```

### TypeScript

TypeScript supports the new JSX transform in [v4.1](https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#jsx-factories) and up.

### Flow

Flow supports the new JSX transform in [v0.126.0](https://github.com/facebook/flow/releases/tag/v0.126.0) and up, by adding `react.runtime=automatic` to your Flow configuration options.

## Removing Unused React Imports

Because the new JSX transform will automatically import the necessary `react/jsx-runtime` functions, React will no longer need to be in scope when you use JSX. This might lead to unused React imports in your code. It doesn’t hurt to keep them, but if you’d like to remove them, we recommend running a [“codemod”](https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb) script to remove them automatically:

```
cd your_project
npx react-codemod update-react-imports
```

> Note
>
> If you’re getting errors when running the codemod, try specifying a different JavaScript dialect when `npx react-codemod update-react-imports` asks you to choose one. In particular, at this moment the “JavaScript with Flow” setting supports newer syntax than the “JavaScript” setting even if you don’t use Flow. [File an issue](https://github.com/reactjs/react-codemod/issues) if you run into problems.
>
> Keep in mind that the codemod output will not always match your project’s coding style, so you might want to run [Prettier](https://prettier.io/) after the codemod finishes for consistent formatting.

Running this codemod will:

* Remove all unused React imports as a result of upgrading to the new JSX transform.
* Change all default React imports (i.e. `import React from "react"`) to destructured named imports (ex. `import { useState } from "react"`) which is the preferred style going into the future. This codemod **will not** affect the existing namespace imports (i.e. `import * as React from "react"`) which is also a valid style. The default imports will keep working in React 17, but in the longer term we encourage moving away from them.

For example,

```
import React from 'react';

function App() {
  return <h1>Hello World</h1>;
}
```

will be replaced with

```
function App() {
  return <h1>Hello World</h1>;
}
```

If you use some other import from React — for example, a Hook — then the codemod will convert it to a named import.

For example,

```
import React from 'react';

function App() {
  const [text, setText] = React.useState('Hello World');
  return <h1>{text}</h1>;
}
```

will be replaced with

```
import { useState } from 'react';

function App() {
  const [text, setText] = useState('Hello World');
  return <h1>{text}</h1>;
}
```

In addition to cleaning up unused imports, this will also help you prepare for a future major version of React (not React 17) which will support ES Modules and not have a default export.

## Thanks

We’d like to thank Babel, TypeScript, Create React App, Next.js, Gatsby, ESLint, and Flow maintainers for their help implementing and integrating the new JSX transform. We also want to thank the React community for their feedback and discussion on the related [technical RFC](https://github.com/reactjs/rfcs/pull/107).

Is this page useful?[Edit this page](https://github.com/reactjs/reactjs.org/tree/main/content/blog/2020-09-22-introducing-the-new-jsx-transform.md)

---


# React v19 – React

URL: https://react.dev/blog/2024/04/25/react-19#error-handling

[Blog](https://react.dev/blog)

# React v19

December 05, 2024 by [The React Team](https://react.dev/community/team)

---

### Note

### React 19 is now stable!

Additions since this post was originally shared with the React 19 RC in April:

* **Pre-warming for suspended trees**: see [Improvements to Suspense](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#improvements-to-suspense).
* **React DOM static APIs**: see [New React DOM Static APIs](https://react.dev/blog/2024/04/25/react-19#new-react-dom-static-apis).

*The date for this post has been updated to reflect the stable release date.*

React v19 is now available on npm!

In our [React 19 Upgrade Guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide), we shared step-by-step instructions for upgrading your app to React 19. In this post, we’ll give an overview of the new features in React 19, and how you can adopt them.

* [What’s new in React 19](https://react.dev/blog/2024/04/25/react-19#whats-new-in-react-19)
* [Improvements in React 19](https://react.dev/blog/2024/04/25/react-19#improvements-in-react-19)
* [How to upgrade](https://react.dev/blog/2024/04/25/react-19#how-to-upgrade)

For a list of breaking changes, see the [Upgrade Guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide).

---

## What’s new in React 19

### Actions

A common use case in React apps is to perform a data mutation and then update state in response. For example, when a user submits a form to change their name, you will make an API request, and then handle the response. In the past, you would need to handle pending states, errors, optimistic updates, and sequential requests manually.

For example, you could handle the pending and error state in `useState`:

```
// Before Actions

function UpdateName({}) {

const [name, setName] = useState("");

const [error, setError] = useState(null);

const [isPending, setIsPending] = useState(false);

const handleSubmit = async () => {

setIsPending(true);

const error = await updateName(name);

setIsPending(false);

if (error) {

setError(error);

return;

}

redirect("/path");

};

return (

<div>

<input value={name} onChange={(event) => setName(event.target.value)} />

<button onClick={handleSubmit} disabled={isPending}>

Update

</button>

{error && <p>{error}</p>}

</div>

);

}
```

In React 19, we’re adding support for using async functions in transitions to handle pending states, errors, forms, and optimistic updates automatically.

For example, you can use `useTransition` to handle the pending state for you:

```
// Using pending state from Actions

function UpdateName({}) {

const [name, setName] = useState("");

const [error, setError] = useState(null);

const [isPending, startTransition] = useTransition();

const handleSubmit = () => {

startTransition(async () => {

const error = await updateName(name);

if (error) {

setError(error);

return;

}

redirect("/path");

})

};

return (

<div>

<input value={name} onChange={(event) => setName(event.target.value)} />

<button onClick={handleSubmit} disabled={isPending}>

Update

</button>

{error && <p>{error}</p>}

</div>

);

}
```

The async transition will immediately set the `isPending` state to true, make the async request(s), and switch `isPending` to false after any transitions. This allows you to keep the current UI responsive and interactive while the data is changing.

### Note

#### By convention, functions that use async transitions are called “Actions”.

Actions automatically manage submitting data for you:

* **Pending state**: Actions provide a pending state that starts at the beginning of a request and automatically resets when the final state update is committed.
* **Optimistic updates**: Actions support the new [`useOptimistic`](https://react.dev/blog/2024/04/25/react-19#new-hook-optimistic-updates) hook so you can show users instant feedback while the requests are submitting.
* **Error handling**: Actions provide error handling so you can display Error Boundaries when a request fails, and revert optimistic updates to their original value automatically.
* **Forms**: `<form>` elements now support passing functions to the `action` and `formAction` props. Passing functions to the `action` props use Actions by default and reset the form automatically after submission.

Building on top of Actions, React 19 introduces [`useOptimistic`](https://react.dev/blog/2024/04/25/react-19#new-hook-optimistic-updates) to manage optimistic updates, and a new hook [`React.useActionState`](https://react.dev/blog/2024/04/25/react-19#new-hook-useactionstate) to handle common cases for Actions. In `react-dom` we’re adding [`<form>` Actions](https://react.dev/blog/2024/04/25/react-19#form-actions) to manage forms automatically and [`useFormStatus`](https://react.dev/blog/2024/04/25/react-19#new-hook-useformstatus) to support the common cases for Actions in forms.

In React 19, the above example can be simplified to:

```
// Using <form> Actions and useActionState

function ChangeName({ name, setName }) {

const [error, submitAction, isPending] = useActionState(

async (previousState, formData) => {

const error = await updateName(formData.get("name"));

if (error) {

return error;

}

redirect("/path");

return null;

},

null,

);

return (

<form action={submitAction}>

<input type="text" name="name" />

<button type="submit" disabled={isPending}>Update</button>

{error && <p>{error}</p>}

</form>

);

}
```

In the next section, we’ll break down each of the new Action features in React 19.

### New hook: `useActionState`

To make the common cases easier for Actions, we’ve added a new hook called `useActionState`:

```
const [error, submitAction, isPending] = useActionState(

async (previousState, newName) => {

const error = await updateName(newName);

if (error) {

// You can return any result of the action.

// Here, we return only the error.

return error;

}

// handle success

return null;

},

null,

);
```

`useActionState` accepts a function (the “Action”), and returns a wrapped Action to call. This works because Actions compose. When the wrapped Action is called, `useActionState` will return the last result of the Action as `data`, and the pending state of the Action as `pending`.

### Note

`React.useActionState` was previously called `ReactDOM.useFormState` in the Canary releases, but we’ve renamed it and deprecated `useFormState`.

See [#28491](https://github.com/facebook/react/pull/28491) for more info.

For more information, see the docs for [`useActionState`](https://react.dev/reference/react/useActionState).

### React DOM: `<form>` Actions

Actions are also integrated with React 19’s new `<form>` features for `react-dom`. We’ve added support for passing functions as the `action` and `formAction` props of `<form>`, `<input>`, and `<button>` elements to automatically submit forms with Actions:

```
<form action={actionFunction}>
```

When a `<form>` Action succeeds, React will automatically reset the form for uncontrolled components. If you need to reset the `<form>` manually, you can call the new `requestFormReset` React DOM API.

For more information, see the `react-dom` docs for [`<form>`](https://react.dev/reference/react-dom/components/form), [`<input>`](https://react.dev/reference/react-dom/components/input), and `<button>`.

### React DOM: New hook: `useFormStatus`

In design systems, it’s common to write design components that need access to information about the `<form>` they’re in, without drilling props down to the component. This can be done via Context, but to make the common case easier, we’ve added a new hook `useFormStatus`:

```
import {useFormStatus} from 'react-dom';

function DesignButton() {

const {pending} = useFormStatus();

return <button type="submit" disabled={pending} />

}
```

`useFormStatus` reads the status of the parent `<form>` as if the form was a Context provider.

For more information, see the `react-dom` docs for [`useFormStatus`](https://react.dev/reference/react-dom/hooks/useFormStatus).

### New hook: `useOptimistic`

Another common UI pattern when performing a data mutation is to show the final state optimistically while the async request is underway. In React 19, we’re adding a new hook called `useOptimistic` to make this easier:

```
function ChangeName({currentName, onUpdateName}) {

const [optimisticName, setOptimisticName] = useOptimistic(currentName);

const submitAction = async formData => {

const newName = formData.get("name");

setOptimisticName(newName);

const updatedName = await updateName(newName);

onUpdateName(updatedName);

};

return (

<form action={submitAction}>

<p>Your name is: {optimisticName}</p>

<p>

<label>Change Name:</label>

<input

type="text"

name="name"

disabled={currentName !== optimisticName}

/>

</p>

</form>

);

}
```

The `useOptimistic` hook will immediately render the `optimisticName` while the `updateName` request is in progress. When the update finishes or errors, React will automatically switch back to the `currentName` value.

For more information, see the docs for [`useOptimistic`](https://react.dev/reference/react/useOptimistic).

### New API: `use`

In React 19 we’re introducing a new API to read resources in render: `use`.

For example, you can read a promise with `use`, and React will Suspend until the promise resolves:

```
import {use} from 'react';

function Comments({commentsPromise}) {

// `use` will suspend until the promise resolves.

const comments = use(commentsPromise);

return comments.map(comment => <p key={comment.id}>{comment}</p>);

}

function Page({commentsPromise}) {

// When `use` suspends in Comments,

// this Suspense boundary will be shown.

return (

<Suspense fallback={<div>Loading...</div>}>

<Comments commentsPromise={commentsPromise} />

</Suspense>

)

}
```

### Note

#### `use` does not support promises created in render.

If you try to pass a promise created in render to `use`, React will warn:

Console

A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.

To fix, you need to pass a promise from a Suspense powered library or framework that supports caching for promises. In the future we plan to ship features to make it easier to cache promises in render.

You can also read context with `use`, allowing you to read Context conditionally such as after early returns:

```
import {use} from 'react';

import ThemeContext from './ThemeContext'

function Heading({children}) {

if (children == null) {

return null;

}

// This would not work with useContext

// because of the early return.

const theme = use(ThemeContext);

return (

<h1 style={{color: theme.color}}>

{children}

</h1>

);

}
```

The `use` API can only be called in render, similar to hooks. Unlike hooks, `use` can be called conditionally. In the future we plan to support more ways to consume resources in render with `use`.

For more information, see the docs for [`use`](https://react.dev/reference/react/use).

## New React DOM Static APIs

We’ve added two new APIs to `react-dom/static` for static site generation:

* [`prerender`](https://react.dev/reference/react-dom/static/prerender)
* [`prerenderToNodeStream`](https://react.dev/reference/react-dom/static/prerenderToNodeStream)

These new APIs improve on `renderToString` by waiting for data to load for static HTML generation. They are designed to work with streaming environments like Node.js Streams and Web Streams. For example, in a Web Stream environment, you can prerender a React tree to static HTML with `prerender`:

```
import { prerender } from 'react-dom/static';

async function handler(request) {

const {prelude} = await prerender(<App />, {

bootstrapScripts: ['/main.js']

});

return new Response(prelude, {

headers: { 'content-type': 'text/html' },

});

}
```

Prerender APIs will wait for all data to load before returning the static HTML stream. Streams can be converted to strings, or sent with a streaming response. They do not support streaming content as it loads, which is supported by the existing [React DOM server rendering APIs](https://react.dev/reference/react-dom/server).

For more information, see [React DOM Static APIs](https://react.dev/reference/react-dom/static).

## React Server Components

### Server Components

Server Components are a new option that allows rendering components ahead of time, before bundling, in an environment separate from your client application or SSR server. This separate environment is the “server” in React Server Components. Server Components can run once at build time on your CI server, or they can be run for each request using a web server.

React 19 includes all of the React Server Components features included from the Canary channel. This means libraries that ship with Server Components can now target React 19 as a peer dependency with a `react-server` [export condition](https://github.com/reactjs/rfcs/blob/main/text/0227-server-module-conventions.md#react-server-conditional-exports) for use in frameworks that support the [Full-stack React Architecture](https://react.dev/learn/creating-a-react-app#which-features-make-up-the-react-teams-full-stack-architecture-vision).

### Note

#### How do I build support for Server Components?

While React Server Components in React 19 are stable and will not break between minor versions, the underlying APIs used to implement a React Server Components bundler or framework do not follow semver and may break between minors in React 19.x.

To support React Server Components as a bundler or framework, we recommend pinning to a specific React version, or using the Canary release. We will continue working with bundlers and frameworks to stabilize the APIs used to implement React Server Components in the future.

For more, see the docs for [React Server Components](https://react.dev/reference/rsc/server-components).

### Server Actions

Server Actions allow Client Components to call async functions executed on the server.

When a Server Action is defined with the `"use server"` directive, your framework will automatically create a reference to the server function, and pass that reference to the Client Component. When that function is called on the client, React will send a request to the server to execute the function, and return the result.

### Note

#### There is no directive for Server Components.

A common misunderstanding is that Server Components are denoted by `"use server"`, but there is no directive for Server Components. The `"use server"` directive is used for Server Actions.

For more info, see the docs for [Directives](https://react.dev/reference/rsc/directives).

Server Actions can be created in Server Components and passed as props to Client Components, or they can be imported and used in Client Components.

For more, see the docs for [React Server Actions](https://react.dev/reference/rsc/server-actions).

## Improvements in React 19

### `ref` as a prop

Starting in React 19, you can now access `ref` as a prop for function components:

```
function MyInput({placeholder, ref}) {

return <input placeholder={placeholder} ref={ref} />

}

//...

<MyInput ref={ref} />
```

New function components will no longer need `forwardRef`, and we will be publishing a codemod to automatically update your components to use the new `ref` prop. In future versions we will deprecate and remove `forwardRef`.

### Note

`ref`s passed to classes are not passed as props since they reference the component instance.

### Diffs for hydration errors

We also improved error reporting for hydration errors in `react-dom`. For example, instead of logging multiple errors in DEV without any information about the mismatch:

Console

Warning: Text content did not match. Server: “Server” Client: “Client”
 at span
 at App

Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.

Warning: Text content did not match. Server: “Server” Client: “Client”
 at span
 at App

Warning: An error occurred during hydration. The server HTML was replaced with client content in <div>.

Uncaught Error: Text content does not match server-rendered HTML.
 at checkForUnmatchedText
 …

We now log a single message with a diff of the mismatch:

Console

Uncaught Error: Hydration failed because the server rendered HTML didn’t match the client. As a result this tree will be regenerated on the client. This can happen if an SSR-ed Client Component used:

- A server/client branch `if (typeof window !== 'undefined')`.
- Variable input such as `Date.now()` or `Math.random()` which changes each time it’s called.
- Date formatting in a user’s locale which doesn’t match the server.
- External changing data without sending a snapshot of it along with the HTML.
- Invalid HTML tag nesting.

It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.

<https://react.dev/link/hydration-mismatch> 

 <App>
 <span>
+ Client
- Server

 at throwOnHydrationMismatch
 …

### `<Context>` as a provider

In React 19, you can render `<Context>` as a provider instead of `<Context.Provider>`:

```
const ThemeContext = createContext('');

function App({children}) {

return (

<ThemeContext value="dark">

{children}

</ThemeContext>

);

}
```

New Context providers can use `<Context>` and we will be publishing a codemod to convert existing providers. In future versions we will deprecate `<Context.Provider>`.

### Cleanup functions for refs

We now support returning a cleanup function from `ref` callbacks:

```
<input

ref={(ref) => {

// ref created

// NEW: return a cleanup function to reset

// the ref when element is removed from DOM.

return () => {

// ref cleanup

};

}}

/>
```

When the component unmounts, React will call the cleanup function returned from the `ref` callback. This works for DOM refs, refs to class components, and `useImperativeHandle`.

### Note

Previously, React would call `ref` functions with `null` when unmounting the component. If your `ref` returns a cleanup function, React will now skip this step.

In future versions, we will deprecate calling refs with `null` when unmounting components.

Due to the introduction of ref cleanup functions, returning anything else from a `ref` callback will now be rejected by TypeScript. The fix is usually to stop using implicit returns, for example:

```
- <div ref={current => (instance = current)} />

+ <div ref={current => {instance = current}} />
```

The original code returned the instance of the `HTMLDivElement` and TypeScript wouldn’t know if this was *supposed* to be a cleanup function or if you didn’t want to return a cleanup function.

You can codemod this pattern with [`no-implicit-ref-callback-return`](https://github.com/eps1lon/types-react-codemod/#no-implicit-ref-callback-return).

### `useDeferredValue` initial value

We’ve added an `initialValue` option to `useDeferredValue`:

```
function Search({deferredValue}) {

// On initial render the value is ''.

// Then a re-render is scheduled with the deferredValue.

const value = useDeferredValue(deferredValue, '');

return (

<Results query={value} />

);

}
```

When initialValue is provided, `useDeferredValue` will return it as `value` for the initial render of the component, and schedules a re-render in the background with the deferredValue returned.

For more, see [`useDeferredValue`](https://react.dev/reference/react/useDeferredValue).

### Support for Document Metadata

In HTML, document metadata tags like `<title>`, `<link>`, and `<meta>` are reserved for placement in the `<head>` section of the document. In React, the component that decides what metadata is appropriate for the app may be very far from the place where you render the `<head>` or React does not render the `<head>` at all. In the past, these elements would need to be inserted manually in an effect, or by libraries like [`react-helmet`](https://github.com/nfl/react-helmet), and required careful handling when server rendering a React application.

In React 19, we’re adding support for rendering document metadata tags in components natively:

```
function BlogPost({post}) {

return (

<article>

<h1>{post.title}</h1>

<title>{post.title}</title>

<meta name="author" content="Josh" />

<link rel="author" href="https://twitter.com/joshcstory/" />

<meta name="keywords" content={post.keywords} />

<p>

Eee equals em-see-squared...

</p>

</article>

);

}
```

When React renders this component, it will see the `<title>` `<link>` and `<meta>` tags, and automatically hoist them to the `<head>` section of document. By supporting these metadata tags natively, we’re able to ensure they work with client-only apps, streaming SSR, and Server Components.

### Note

#### You may still want a Metadata library

For simple use cases, rendering Document Metadata as tags may be suitable, but libraries can offer more powerful features like overriding generic metadata with specific metadata based on the current route. These features make it easier for frameworks and libraries like [`react-helmet`](https://github.com/nfl/react-helmet) to support metadata tags, rather than replace them.

For more info, see the docs for [`<title>`](https://react.dev/reference/react-dom/components/title), [`<link>`](https://react.dev/reference/react-dom/components/link), and [`<meta>`](https://react.dev/reference/react-dom/components/meta).

### Support for stylesheets

Stylesheets, both externally linked (`<link rel="stylesheet" href="...">`) and inline (`<style>...</style>`), require careful positioning in the DOM due to style precedence rules. Building a stylesheet capability that allows for composability within components is hard, so users often end up either loading all of their styles far from the components that may depend on them, or they use a style library which encapsulates this complexity.

In React 19, we’re addressing this complexity and providing even deeper integration into Concurrent Rendering on the Client and Streaming Rendering on the Server with built in support for stylesheets. If you tell React the `precedence` of your stylesheet it will manage the insertion order of the stylesheet in the DOM and ensure that the stylesheet (if external) is loaded before revealing content that depends on those style rules.

```
function ComponentOne() {

return (

<Suspense fallback="loading...">

<link rel="stylesheet" href="foo" precedence="default" />

<link rel="stylesheet" href="bar" precedence="high" />

<article class="foo-class bar-class">

{...}

</article>

</Suspense>

)

}

function ComponentTwo() {

return (

<div>

<p>{...}</p>

<link rel="stylesheet" href="baz" precedence="default" />  <-- will be inserted between foo & bar

</div>

)

}
```

During Server Side Rendering React will include the stylesheet in the `<head>`, which ensures that the browser will not paint until it has loaded. If the stylesheet is discovered late after we’ve already started streaming, React will ensure that the stylesheet is inserted into the `<head>` on the client before revealing the content of a Suspense boundary that depends on that stylesheet.

During Client Side Rendering React will wait for newly rendered stylesheets to load before committing the render. If you render this component from multiple places within your application React will only include the stylesheet once in the document:

```
function App() {

return <>

<ComponentOne />

...

<ComponentOne /> // won't lead to a duplicate stylesheet link in the DOM

</>

}
```

For users accustomed to loading stylesheets manually this is an opportunity to locate those stylesheets alongside the components that depend on them allowing for better local reasoning and an easier time ensuring you only load the stylesheets that you actually depend on.

Style libraries and style integrations with bundlers can also adopt this new capability so even if you don’t directly render your own stylesheets, you can still benefit as your tools are upgraded to use this feature.

For more details, read the docs for [`<link>`](https://react.dev/reference/react-dom/components/link) and [`<style>`](https://react.dev/reference/react-dom/components/style).

### Support for async scripts

In HTML normal scripts (`<script src="...">`) and deferred scripts (`<script defer="" src="...">`) load in document order which makes rendering these kinds of scripts deep within your component tree challenging. Async scripts (`<script async="" src="...">`) however will load in arbitrary order.

In React 19 we’ve included better support for async scripts by allowing you to render them anywhere in your component tree, inside the components that actually depend on the script, without having to manage relocating and deduplicating script instances.

```
function MyComponent() {

return (

<div>

<script async={true} src="..." />

Hello World

</div>

)

}

function App() {

<html>

<body>

<MyComponent>

...

<MyComponent> // won't lead to duplicate script in the DOM

</body>

</html>

}
```

In all rendering environments, async scripts will be deduplicated so that React will only load and execute the script once even if it is rendered by multiple different components.

In Server Side Rendering, async scripts will be included in the `<head>` and prioritized behind more critical resources that block paint such as stylesheets, fonts, and image preloads.

For more details, read the docs for [`<script>`](https://react.dev/reference/react-dom/components/script).

### Support for preloading resources

During initial document load and on client side updates, telling the Browser about resources that it will likely need to load as early as possible can have a dramatic effect on page performance.

React 19 includes a number of new APIs for loading and preloading Browser resources to make it as easy as possible to build great experiences that aren’t held back by inefficient resource loading.

```
import { prefetchDNS, preconnect, preload, preinit } from 'react-dom'

function MyComponent() {

preinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly

preload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font

preload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet

prefetchDNS('https://...') // when you may not actually request anything from this host

preconnect('https://...') // when you will request something but aren't sure what

}
```

```
<!-- the above would result in the following DOM/HTML -->

<html>

<head>

<!-- links/scripts are prioritized by their utility to early loading, not call order -->

<link rel="prefetch-dns" href="https://...">

<link rel="preconnect" href="https://...">

<link rel="preload" as="font" href="https://.../path/to/font.woff">

<link rel="preload" as="style" href="https://.../path/to/stylesheet.css">

<script async="" src="https://.../path/to/some/script.js"></script>

</head>

<body>

...

</body>

</html>
```

These APIs can be used to optimize initial page loads by moving discovery of additional resources like fonts out of stylesheet loading. They can also make client updates faster by prefetching a list of resources used by an anticipated navigation and then eagerly preloading those resources on click or even on hover.

For more details see [Resource Preloading APIs](https://react.dev/reference/react-dom#resource-preloading-apis).

### Compatibility with third-party scripts and extensions

We’ve improved hydration to account for third-party scripts and browser extensions.

When hydrating, if an element that renders on the client doesn’t match the element found in the HTML from the server, React will force a client re-render to fix up the content. Previously, if an element was inserted by third-party scripts or browser extensions, it would trigger a mismatch error and client render.

In React 19, unexpected tags in the `<head>` and `<body>` will be skipped over, avoiding the mismatch errors. If React needs to re-render the entire document due to an unrelated hydration mismatch, it will leave in place stylesheets inserted by third-party scripts and browser extensions.

### Better error reporting

We improved error handling in React 19 to remove duplication and provide options for handling caught and uncaught errors. For example, when there’s an error in render caught by an Error Boundary, previously React would throw the error twice (once for the original error, then again after failing to automatically recover), and then call `console.error` with info about where the error occurred.

This resulted in three errors for every caught error:

Console

Uncaught Error: hit
 at Throws
 at renderWithHooks
 …

Uncaught Error: hit <-- Duplicate
 at Throws
 at renderWithHooks
 …

The above error occurred in the Throws component:
 at Throws
 at ErrorBoundary
 at App

React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.

In React 19, we log a single error with all the error information included:

Console

Error: hit
 at Throws
 at renderWithHooks
 …

The above error occurred in the Throws component:
 at Throws
 at ErrorBoundary
 at App

React will try to recreate this component tree from scratch using the error boundary you provided, ErrorBoundary.
 at ErrorBoundary
 at App

Additionally, we’ve added two new root options to complement `onRecoverableError`:

* `onCaughtError`: called when React catches an error in an Error Boundary.
* `onUncaughtError`: called when an error is thrown and not caught by an Error Boundary.
* `onRecoverableError`: called when an error is thrown and automatically recovered.

For more info and examples, see the docs for [`createRoot`](https://react.dev/reference/react-dom/client/createRoot) and [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot).

### Support for Custom Elements

React 19 adds full support for custom elements and passes all tests on [Custom Elements Everywhere](https://custom-elements-everywhere.com/).

In past versions, using Custom Elements in React has been difficult because React treated unrecognized props as attributes rather than properties. In React 19, we’ve added support for properties that works on the client and during SSR with the following strategy:

* **Server Side Rendering**: props passed to a custom element will render as attributes if their type is a primitive value like `string`, `number`, or the value is `true`. Props with non-primitive types like `object`, `symbol`, `function`, or value `false` will be omitted.
* **Client Side Rendering**: props that match a property on the Custom Element instance will be assigned as properties, otherwise they will be assigned as attributes.

Thanks to [Joey Arhar](https://github.com/josepharhar) for driving the design and implementation of Custom Element support in React.

#### How to upgrade

See the [React 19 Upgrade Guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide) for step-by-step instructions and a full list of breaking and notable changes.

*Note: this post was originally published 04/25/2024 and has been updated to 12/05/2024 with the stable release.*

[PreviousSunsetting Create React App](https://react.dev/blog/2025/02/14/sunsetting-create-react-app)[NextReact Compiler Beta Release and Roadmap](https://react.dev/blog/2024/10/21/react-compiler-beta-release)

---

---


# react-dom/test-utils Deprecation Warnings – React

URL: https://react.dev/warnings/react-dom-test-utils

[React Docs](https://react.dev/)

# react-dom/test-utils Deprecation Warnings

## ReactDOMTestUtils.act() warning

`act` from `react-dom/test-utils` has been deprecated in favor of `act` from `react`.

Before:

```
import {act} from 'react-dom/test-utils';
```

After:

```
import {act} from 'react';
```

## Rest of ReactDOMTestUtils APIS

All APIs except `act` have been removed.

The React Team recommends migrating your tests to [@testing-library/react](https://testing-library.com/docs/react-testing-library/intro/) for a modern and well supported testing experience.

### ReactDOMTestUtils.renderIntoDocument

`renderIntoDocument` can be replaced with `render` from `@testing-library/react`.

Before:

```
import {renderIntoDocument} from 'react-dom/test-utils';

renderIntoDocument(<Component />);
```

After:

```
import {render} from '@testing-library/react';

render(<Component />);
```

### ReactDOMTestUtils.Simulate

`Simulate` can be replaced with `fireEvent` from `@testing-library/react`.

Before:

```
import {Simulate} from 'react-dom/test-utils';

const element = document.querySelector('button');

Simulate.click(element);
```

After:

```
import {fireEvent} from '@testing-library/react';

const element = document.querySelector('button');

fireEvent.click(element);
```

Be aware that `fireEvent` dispatches an actual event on the element and doesn’t just synthetically call the event handler.

### List of all removed APIs

* `mockComponent()`
* `isElement()`
* `isElementOfType()`
* `isDOMComponent()`
* `isCompositeComponent()`
* `isCompositeComponentWithType()`
* `findAllInRenderedTree()`
* `scryRenderedDOMComponentsWithClass()`
* `findRenderedDOMComponentWithClass()`
* `scryRenderedDOMComponentsWithTag()`
* `findRenderedDOMComponentWithTag()`
* `scryRenderedComponentsWithType()`
* `findRenderedComponentWithType()`
* `renderIntoDocument`
* `Simulate`

---

---


# Not Found – React

URL: https://react.dev/reference/react-dom/static/index

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# hydrate – React

URL: https://react.dev/reference/react-dom/hydrate

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# hydrate

### Deprecated

This API will be removed in a future major version of React.

In React 18, `hydrate` was replaced by [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot) Using `hydrate` in React 18 will warn that your app will behave as if it’s running React 17. Learn more [here.](https://react.dev/blog/2022/03/08/react-18-upgrade-guide#updates-to-client-rendering-apis)

`hydrate` lets you display React components inside a browser DOM node whose HTML content was previously generated by [`react-dom/server`](https://react.dev/reference/react-dom/server) in React 17 and below.

```
hydrate(reactNode, domNode, callback?)
```

* [Reference](https://react.dev/reference/react-dom/hydrate#reference) 
  + [`hydrate(reactNode, domNode, callback?)`](https://react.dev/reference/react-dom/hydrate#hydrate)
* [Usage](https://react.dev/reference/react-dom/hydrate#usage) 
  + [Hydrating server-rendered HTML](https://react.dev/reference/react-dom/hydrate#hydrating-server-rendered-html)
  + [Suppressing unavoidable hydration mismatch errors](https://react.dev/reference/react-dom/hydrate#suppressing-unavoidable-hydration-mismatch-errors)
  + [Handling different client and server content](https://react.dev/reference/react-dom/hydrate#handling-different-client-and-server-content)

---

## Reference

### `hydrate(reactNode, domNode, callback?)`

Call `hydrate` in React 17 and below to “attach” React to existing HTML that was already rendered by React in a server environment.

```
import { hydrate } from 'react-dom';

hydrate(reactNode, domNode);
```

React will attach to the HTML that exists inside the `domNode`, and take over managing the DOM inside it. An app fully built with React will usually only have one `hydrate` call with its root component.

[See more examples below.](https://react.dev/reference/react-dom/hydrate#usage)

#### Parameters

* `reactNode`: The “React node” used to render the existing HTML. This will usually be a piece of JSX like `<App />` which was rendered with a `ReactDOM Server` method such as `renderToString(<App />)` in React 17.
* `domNode`: A [DOM element](https://developer.mozilla.org/en-US/docs/Web/API/Element) that was rendered as the root element on the server.
* **optional**: `callback`: A function. If passed, React will call it after your component is hydrated.

#### Returns

`hydrate` returns null.

#### Caveats

* `hydrate` expects the rendered content to be identical with the server-rendered content. React can patch up differences in text content, but you should treat mismatches as bugs and fix them.
* In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive.
* You’ll likely have only one `hydrate` call in your app. If you use a framework, it might do this call for you.
* If your app is client-rendered with no HTML rendered already, using `hydrate()` is not supported. Use [render()](https://react.dev/reference/react-dom/render) (for React 17 and below) or [createRoot()](https://react.dev/reference/react-dom/client/createRoot) (for React 18+) instead.

---

## Usage

Call `hydrate` to attach a React component into a server-rendered browser DOM node.

```
import { hydrate } from 'react-dom';

hydrate(<App />, document.getElementById('root'));
```

Using `hydrate()` to render a client-only app (an app without server-rendered HTML) is not supported. Use [`render()`](https://react.dev/reference/react-dom/render) (in React 17 and below) or [`createRoot()`](https://react.dev/reference/react-dom/client/createRoot) (in React 18+) instead.

### Hydrating server-rendered HTML

In React, “hydration” is how React “attaches” to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the client.

In apps fully built with React, **you will usually only hydrate one “root”, once at startup for your entire app**.

index.jsindex.htmlApp.js

index.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import './styles.css';
import { hydrate } from 'react-dom';
import App from './App.js';

hydrate(<App />, document.getElementById('root'));
```

Usually you shouldn’t need to call `hydrate` again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will [use state.](https://react.dev/reference/react/useState)

For more information on hydration, see the docs for [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot)

---

### Suppressing unavoidable hydration mismatch errors

If a single element’s attribute or text content is unavoidably different between the server and the client (for example, a timestamp), you may silence the hydration mismatch warning.

To silence hydration warnings on an element, add `suppressHydrationWarning={true}`:

index.jsindex.htmlApp.js

App.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function App() {
  return (
    <h1 suppressHydrationWarning={true}>
      Current Date: {new Date().toLocaleDateString()}
    </h1>
  );
}
```

This only works one level deep, and is intended to be an escape hatch. Don’t overuse it. Unless it’s text content, React still won’t attempt to patch it up, so it may remain inconsistent until future updates.

---

### Handling different client and server content

If you intentionally need to render something different on the server and the client, you can do a two-pass rendering. Components that render something different on the client can read a [state variable](https://react.dev/reference/react/useState) like `isClient`, which you can set to `true` in an [Effect](https://react.dev/reference/react/useEffect):

index.jsindex.htmlApp.js

App.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { useState, useEffect } from "react";

export default function App() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  return (
    <h1>
      {isClient ? 'Is Client' : 'Is Server'}
    </h1>
  );
}
```

This way the initial render pass will render the same content as the server, avoiding mismatches, but an additional pass will happen synchronously right after hydration.

### Pitfall

This approach makes hydration slower because your components have to render twice. Be mindful of the user experience on slow connections. The JavaScript code may load significantly later than the initial HTML render, so rendering a different UI immediately after hydration may feel jarring to the user.

[PreviousfindDOMNode](https://react.dev/reference/react-dom/findDOMNode)[Nextpreconnect](https://react.dev/reference/react-dom/preconnect)

---

---


# render – React

URL: https://react.dev/reference/react-dom/render

[API Reference](https://react.dev/reference/react)

[APIs](https://react.dev/reference/react-dom)

# render

### Deprecated

This API will be removed in a future major version of React.

In React 18, `render` was replaced by [`createRoot`.](https://react.dev/reference/react-dom/client/createRoot) Using `render` in React 18 will warn that your app will behave as if it’s running React 17. Learn more [here.](https://react.dev/blog/2022/03/08/react-18-upgrade-guide#updates-to-client-rendering-apis)

`render` renders a piece of [JSX](https://react.dev/learn/writing-markup-with-jsx) (“React node”) into a browser DOM node.

```
render(reactNode, domNode, callback?)
```

* [Reference](https://react.dev/reference/react-dom/render#reference) 
  + [`render(reactNode, domNode, callback?)`](https://react.dev/reference/react-dom/render#render)
* [Usage](https://react.dev/reference/react-dom/render#usage) 
  + [Rendering the root component](https://react.dev/reference/react-dom/render#rendering-the-root-component)
  + [Rendering multiple roots](https://react.dev/reference/react-dom/render#rendering-multiple-roots)
  + [Updating the rendered tree](https://react.dev/reference/react-dom/render#updating-the-rendered-tree)

---

## Reference

### `render(reactNode, domNode, callback?)`

Call `render` to display a React component inside a browser DOM element.

```
import { render } from 'react-dom';

const domNode = document.getElementById('root');

render(<App />, domNode);
```

React will display `<App />` in the `domNode`, and take over managing the DOM inside it.

An app fully built with React will usually only have one `render` call with its root component. A page that uses “sprinkles” of React for parts of the page may have as many `render` calls as needed.

[See more examples below.](https://react.dev/reference/react-dom/render#usage)

#### Parameters

* `reactNode`: A *React node* that you want to display. This will usually be a piece of JSX like `<App />`, but you can also pass a React element constructed with [`createElement()`](https://react.dev/reference/react/createElement), a string, a number, `null`, or `undefined`.
* `domNode`: A [DOM element.](https://developer.mozilla.org/en-US/docs/Web/API/Element) React will display the `reactNode` you pass inside this DOM element. From this moment, React will manage the DOM inside the `domNode` and update it when your React tree changes.
* **optional** `callback`: A function. If passed, React will call it after your component is placed into the DOM.

#### Returns

`render` usually returns `null`. However, if the `reactNode` you pass is a *class component*, then it will return an instance of that component.

#### Caveats

* In React 18, `render` was replaced by [`createRoot`.](https://react.dev/reference/react-dom/client/createRoot) Please use `createRoot` for React 18 and beyond.
* The first time you call `render`, React will clear all the existing HTML content inside the `domNode` before rendering the React component into it. If your `domNode` contains HTML generated by React on the server or during the build, use [`hydrate()`](https://react.dev/reference/react-dom/hydrate) instead, which attaches the event handlers to the existing HTML.
* If you call `render` on the same `domNode` more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by [“matching it up”](https://react.dev/learn/preserving-and-resetting-state) with the previously rendered tree. Calling `render` on the same `domNode` again is similar to calling the [`set` function](https://react.dev/reference/react/useState#setstate) on the root component: React avoids unnecessary DOM updates.
* If your app is fully built with React, you’ll likely have only one `render` call in your app. (If you use a framework, it might do this call for you.) When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), use [`createPortal`](https://react.dev/reference/react-dom/createPortal) instead of `render`.

---

## Usage

Call `render` to display a React component inside a browser DOM node.

```
import { render } from 'react-dom';

import App from './App.js';

render(<App />, document.getElementById('root'));
```

### Rendering the root component

In apps fully built with React, **you will usually only do this once at startup**—to render the “root” component.

index.jsApp.js

index.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import './styles.css';
import { render } from 'react-dom';
import App from './App.js';

render(<App />, document.getElementById('root'));
```

Usually you shouldn’t need to call `render` again or to call it in more places. From this point on, React will be managing the DOM of your application. To update the UI, your components will [use state.](https://react.dev/reference/react/useState)

---

### Rendering multiple roots

If your page [isn’t fully built with React](https://react.dev/learn/add-react-to-an-existing-project#using-react-for-a-part-of-your-existing-page), call `render` for each top-level piece of UI managed by React.

index.jsindex.htmlComponents.js

index.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import './styles.css';
import { render } from 'react-dom';
import { Comments, Navigation } from './Components.js';

render(
  <Navigation />,
  document.getElementById('navigation')
);

render(
  <Comments />,
  document.getElementById('comments')
);
```

You can destroy the rendered trees with [`unmountComponentAtNode()`.](https://react.dev/reference/react-dom/unmountComponentAtNode)

---

### Updating the rendered tree

You can call `render` more than once on the same DOM node. As long as the component tree structure matches up with what was previously rendered, React will [preserve the state.](https://react.dev/learn/preserving-and-resetting-state) Notice how you can type in the input, which means that the updates from repeated `render` calls every second are not destructive:

index.jsApp.js

index.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { render } from 'react-dom';
import './styles.css';
import App from './App.js';

let i = 0;
setInterval(() => {
  render(
    <App counter={i} />,
    document.getElementById('root')
  );
  i++;
}, 1000);
```

It is uncommon to call `render` multiple times. Usually, you’ll [update state](https://react.dev/reference/react/useState) inside your components instead.

[PreviouspreloadModule](https://react.dev/reference/react-dom/preloadModule)[NextunmountComponentAtNode](https://react.dev/reference/react-dom/unmountComponentAtNode)

---

---


# renderToNodeStream – React

URL: https://react.dev/reference/react-dom/server/renderToNodeStream

[API Reference](https://react.dev/reference/react)

[Server APIs](https://react.dev/reference/react-dom/server)

# renderToNodeStream

### Deprecated

This API will be removed in a future major version of React. Use [`renderToPipeableStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream) instead.

`renderToNodeStream` renders a React tree to a [Node.js Readable Stream.](https://nodejs.org/api/stream.html#readable-streams)

```
const stream = renderToNodeStream(reactNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/server/renderToNodeStream#reference) 
  + [`renderToNodeStream(reactNode, options?)`](https://react.dev/reference/react-dom/server/renderToNodeStream#rendertonodestream)
* [Usage](https://react.dev/reference/react-dom/server/renderToNodeStream#usage) 
  + [Rendering a React tree as HTML to a Node.js Readable Stream](https://react.dev/reference/react-dom/server/renderToNodeStream#rendering-a-react-tree-as-html-to-a-nodejs-readable-stream)

---

## Reference

### `renderToNodeStream(reactNode, options?)`

On the server, call `renderToNodeStream` to get a [Node.js Readable Stream](https://nodejs.org/api/stream.html#readable-streams) which you can pipe into the response.

```
import { renderToNodeStream } from 'react-dom/server';

const stream = renderToNodeStream(<App />);

stream.pipe(response);
```

On the client, call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to make the server-generated HTML interactive.

[See more examples below.](https://react.dev/reference/react-dom/server/renderToNodeStream#usage)

#### Parameters

* `reactNode`: A React node you want to render to HTML. For example, a JSX element like `<App />`.
* **optional** `options`: An object for server render.

  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to [`hydrateRoot`.](https://react.dev/reference/react-dom/client/hydrateRoot#parameters)

#### Returns

A [Node.js Readable Stream](https://nodejs.org/api/stream.html#readable-streams) that outputs an HTML string.

#### Caveats

* This method will wait for all [Suspense boundaries](https://react.dev/reference/react/Suspense) to complete before returning any output.
* As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits. This is why it’s recommended that you migrate to [`renderToPipeableStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream) instead.
* The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like [iconv-lite](https://www.npmjs.com/package/iconv-lite), which provides transform streams for transcoding text.

---

## Usage

### Rendering a React tree as HTML to a Node.js Readable Stream

Call `renderToNodeStream` to get a [Node.js Readable Stream](https://nodejs.org/api/stream.html#readable-streams) which you can pipe to your server response:

```
import { renderToNodeStream } from 'react-dom/server';

// The route handler syntax depends on your backend framework

app.use('/', (request, response) => {

const stream = renderToNodeStream(<App />);

stream.pipe(response);

});
```

The stream will produce the initial non-interactive HTML output of your React components. On the client, you will need to call [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) to *hydrate* that server-generated HTML and make it interactive.

[PreviousServer APIs](https://react.dev/reference/react-dom/server)[NextrenderToPipeableStream](https://react.dev/reference/react-dom/server/renderToPipeableStream)

---

---


# renderToStaticNodeStream – React

URL: https://react.dev/reference/react-dom/server/renderToStaticNodeStream

[API Reference](https://react.dev/reference/react)

[Server APIs](https://react.dev/reference/react-dom/server)

# renderToStaticNodeStream

`renderToStaticNodeStream` renders a non-interactive React tree to a [Node.js Readable Stream.](https://nodejs.org/api/stream.html#readable-streams)

```
const stream = renderToStaticNodeStream(reactNode, options?)
```

* [Reference](https://react.dev/reference/react-dom/server/renderToStaticNodeStream#reference) 
  + [`renderToStaticNodeStream(reactNode, options?)`](https://react.dev/reference/react-dom/server/renderToStaticNodeStream#rendertostaticnodestream)
* [Usage](https://react.dev/reference/react-dom/server/renderToStaticNodeStream#usage) 
  + [Rendering a React tree as static HTML to a Node.js Readable Stream](https://react.dev/reference/react-dom/server/renderToStaticNodeStream#rendering-a-react-tree-as-static-html-to-a-nodejs-readable-stream)

---

## Reference

### `renderToStaticNodeStream(reactNode, options?)`

On the server, call `renderToStaticNodeStream` to get a [Node.js Readable Stream](https://nodejs.org/api/stream.html#readable-streams).

```
import { renderToStaticNodeStream } from 'react-dom/server';

const stream = renderToStaticNodeStream(<Page />);

stream.pipe(response);
```

[See more examples below.](https://react.dev/reference/react-dom/server/renderToStaticNodeStream#usage)

The stream will produce non-interactive HTML output of your React components.

#### Parameters

* `reactNode`: A React node you want to render to HTML. For example, a JSX element like `<Page />`.
* **optional** `options`: An object for server render.

  + **optional** `identifierPrefix`: A string prefix React uses for IDs generated by [`useId`.](https://react.dev/reference/react/useId) Useful to avoid conflicts when using multiple roots on the same page.

#### Returns

A [Node.js Readable Stream](https://nodejs.org/api/stream.html#readable-streams) that outputs an HTML string. The resulting HTML can’t be hydrated on the client.

#### Caveats

* `renderToStaticNodeStream` output cannot be hydrated.
* This method will wait for all [Suspense boundaries](https://react.dev/reference/react/Suspense) to complete before returning any output.
* As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits.
* The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like [iconv-lite](https://www.npmjs.com/package/iconv-lite), which provides transform streams for transcoding text.

---

## Usage

### Rendering a React tree as static HTML to a Node.js Readable Stream

Call `renderToStaticNodeStream` to get a [Node.js Readable Stream](https://nodejs.org/api/stream.html#readable-streams) which you can pipe to your server response:

```
import { renderToStaticNodeStream } from 'react-dom/server';

// The route handler syntax depends on your backend framework

app.use('/', (request, response) => {

const stream = renderToStaticNodeStream(<Page />);

stream.pipe(response);

});
```

The stream will produce the initial non-interactive HTML output of your React components.

### Pitfall

This method renders **non-interactive HTML that cannot be hydrated.** This is useful if you want to use React as a simple static page generator, or if you’re rendering completely static content like emails.

Interactive apps should use [`renderToPipeableStream`](https://react.dev/reference/react-dom/server/renderToPipeableStream) on the server and [`hydrateRoot`](https://react.dev/reference/react-dom/client/hydrateRoot) on the client.

[PreviousrenderToStaticMarkup](https://react.dev/reference/react-dom/server/renderToStaticMarkup)[NextrenderToString](https://react.dev/reference/react-dom/server/renderToString)

---

---


# createFactory – React

URL: https://react.dev/reference/react/createFactory

[API Reference](https://react.dev/reference/react)

[Legacy React APIs](https://react.dev/reference/react/legacy)

# createFactory

### Deprecated

This API will be removed in a future major version of React. [See the alternatives.](https://react.dev/reference/react/createFactory#alternatives)

`createFactory` lets you create a function that produces React elements of a given type.

```
const factory = createFactory(type)
```

* [Reference](https://react.dev/reference/react/createFactory#reference) 
  + [`createFactory(type)`](https://react.dev/reference/react/createFactory#createfactory)
* [Usage](https://react.dev/reference/react/createFactory#usage) 
  + [Creating React elements with a factory](https://react.dev/reference/react/createFactory#creating-react-elements-with-a-factory)
* [Alternatives](https://react.dev/reference/react/createFactory#alternatives) 
  + [Copying `createFactory` into your project](https://react.dev/reference/react/createFactory#copying-createfactory-into-your-project)
  + [Replacing `createFactory` with `createElement`](https://react.dev/reference/react/createFactory#replacing-createfactory-with-createelement)
  + [Replacing `createFactory` with JSX](https://react.dev/reference/react/createFactory#replacing-createfactory-with-jsx)

---

## Reference

### `createFactory(type)`

Call `createFactory(type)` to create a factory function which produces React elements of a given `type`.

```
import { createFactory } from 'react';

const button = createFactory('button');
```

Then you can use it to create React elements without JSX:

```
export default function App() {

return button({

onClick: () => {

alert('Clicked!')

}

}, 'Click me');

}
```

[See more examples below.](https://react.dev/reference/react/createFactory#usage)

#### Parameters

* `type`: The `type` argument must be a valid React component type. For example, it could be a tag name string (such as `'div'` or `'span'`), or a React component (a function, a class, or a special component like [`Fragment`](https://react.dev/reference/react/Fragment)).

#### Returns

Returns a factory function. That factory function receives a `props` object as the first argument, followed by a list of `...children` arguments, and returns a React element with the given `type`, `props` and `children`.

---

## Usage

### Creating React elements with a factory

Although most React projects use [JSX](https://react.dev/learn/writing-markup-with-jsx) to describe the user interface, JSX is not required. In the past, `createFactory` used to be one of the ways you could describe the user interface without JSX.

Call `createFactory` to create a *factory function* for a specific element type like `'button'`:

```
import { createFactory } from 'react';

const button = createFactory('button');
```

Calling that factory function will produce React elements with the props and children you have provided:

App.js

App.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createFactory } from 'react';

const button = createFactory('button');

export default function App() {
  return button({
    onClick: () => {
      alert('Clicked!')
    }
  }, 'Click me');
}
```

This is how `createFactory` was used as an alternative to JSX. However, `createFactory` is deprecated, and you should not call `createFactory` in any new code. See how to migrate away from `createFactory` below.

---

## Alternatives

### Copying `createFactory` into your project

If your project has many `createFactory` calls, copy this `createFactory.js` implementation into your project:

App.jscreateFactory.js

App.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createFactory } from './createFactory.js';

const button = createFactory('button');

export default function App() {
  return button({
    onClick: () => {
      alert('Clicked!')
    }
  }, 'Click me');
}
```

This lets you keep all of your code unchanged except the imports.

---

### Replacing `createFactory` with `createElement`

If you have a few `createFactory` calls that you don’t mind porting manually, and you don’t want to use JSX, you can replace every call a factory function with a [`createElement`](https://react.dev/reference/react/createElement) call. For example, you can replace this code:

```
import { createFactory } from 'react';

const button = createFactory('button');

export default function App() {

return button({

onClick: () => {

alert('Clicked!')

}

}, 'Click me');

}
```

with this code:

```
import { createElement } from 'react';

export default function App() {

return createElement('button', {

onClick: () => {

alert('Clicked!')

}

}, 'Click me');

}
```

Here is a complete example of using React without JSX:

App.js

App.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
import { createElement } from 'react';

export default function App() {
  return createElement('button', {
    onClick: () => {
      alert('Clicked!')
    }
  }, 'Click me');
}
```

---

### Replacing `createFactory` with JSX

Finally, you can use JSX instead of `createFactory`. This is the most common way to use React:

App.js

App.js

Reset[Fork](https://codesandbox.io/api/v1/sandboxes/define?undefined&environment=create-react-app "Open in CodeSandbox")

```
export default function App() {
  return (
    <button onClick={() => {
      alert('Clicked!');
    }}>
      Click me
    </button>
  );
};
```

### Pitfall

Sometimes, your existing code might pass some variable as a `type` instead of a constant like `'button'`:

```
function Heading({ isSubheading, ...props }) {

const type = isSubheading ? 'h2' : 'h1';

const factory = createFactory(type);

return factory(props);

}
```

To do the same in JSX, you need to rename your variable to start with an uppercase letter like `Type`:

```
function Heading({ isSubheading, ...props }) {

const Type = isSubheading ? 'h2' : 'h1';

return <Type {...props} />;

}
```

Otherwise React will interpret `<type>` as a built-in HTML tag because it is lowercase.

[PreviouscreateElement](https://react.dev/reference/react/createElement)[NextcreateRef](https://react.dev/reference/react/createRef)

---

---


# Not Found – React

URL: https://react.dev/docs/getting-started.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/tutorial/tutorial.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/community/support.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/languages

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2020/08/10/react-v17-rc.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2022/03/29/react-v18.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2022/03/08/react-18-upgrade-guide.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2021/12/17/react-conf-2021-recap.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2021/06/08/the-plan-for-react-18.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2020/10/20/react-v17.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2020/09/22/introducing-the-new-jsx-transform.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/2020/02/26/react-v16.13.0.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/blog/all.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/docs/hello-world.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/docs/accessibility.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/docs/react-api.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/docs/hooks-intro.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/docs/testing.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/docs/how-to-contribute.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/docs/faq-ajax.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---


# Not Found – React

URL: https://react.dev/acknowledgements.html

[Learn React](https://react.dev/learn)

# Not Found

This page doesn’t exist.

If this is a mistake, [let us know](https://github.com/reactjs/react.dev/issues/new), and we will try to fix it!

---

---

